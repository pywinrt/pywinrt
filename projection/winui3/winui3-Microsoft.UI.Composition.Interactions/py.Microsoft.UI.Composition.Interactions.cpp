// WARNING: Please don't edit this file. It was generated by Python/WinRT v3.1.0

#include "py.Microsoft.UI.Composition.Interactions.h"

namespace py::cpp::Microsoft::UI::Composition::Interactions
{
    // ----- CompositionConditionalValue class --------------------

    static PyObject* _new_CompositionConditionalValue(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Microsoft::UI::Composition::Interactions::CompositionConditionalValue>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Microsoft::UI::Composition::Interactions::CompositionConditionalValue>::type_name);
        return nullptr;
    }

    static void _dealloc_CompositionConditionalValue(py::wrapper::Microsoft::UI::Composition::Interactions::CompositionConditionalValue* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* CompositionConditionalValue_Create(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Composition.Interactions.CompositionConditionalValue", L"Create", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Microsoft::UI::Composition::Compositor>(args, 0);

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return winrt::Microsoft::UI::Composition::Interactions::CompositionConditionalValue::Create(param0);
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* CompositionConditionalValue_get_Value(py::wrapper::Microsoft::UI::Composition::Interactions::CompositionConditionalValue* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Composition.Interactions.CompositionConditionalValue", L"Value");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Value();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int CompositionConditionalValue_put_Value(py::wrapper::Microsoft::UI::Composition::Interactions::CompositionConditionalValue* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Composition.Interactions.CompositionConditionalValue", L"Value");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Microsoft::UI::Composition::ExpressionAnimation>(arg);

            {
                auto _gil = release_gil();
                self->obj.Value(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* CompositionConditionalValue_get_Condition(py::wrapper::Microsoft::UI::Composition::Interactions::CompositionConditionalValue* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Composition.Interactions.CompositionConditionalValue", L"Condition");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Condition();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int CompositionConditionalValue_put_Condition(py::wrapper::Microsoft::UI::Composition::Interactions::CompositionConditionalValue* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Composition.Interactions.CompositionConditionalValue", L"Condition");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Microsoft::UI::Composition::ExpressionAnimation>(arg);

            {
                auto _gil = release_gil();
                self->obj.Condition(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* _assign_array_CompositionConditionalValue(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Microsoft::UI::Composition::Interactions::CompositionConditionalValue>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_CompositionConditionalValue(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Microsoft::UI::Composition::Interactions::CompositionConditionalValue>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_CompositionConditionalValue[] = {
        { "_assign_array_", _assign_array_CompositionConditionalValue, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_CompositionConditionalValue), METH_O | METH_STATIC, nullptr },
        { }};

    static PyGetSetDef _getset_CompositionConditionalValue[] = {
        { "value", reinterpret_cast<getter>(CompositionConditionalValue_get_Value), reinterpret_cast<setter>(CompositionConditionalValue_put_Value), nullptr, nullptr },
        { "condition", reinterpret_cast<getter>(CompositionConditionalValue_get_Condition), reinterpret_cast<setter>(CompositionConditionalValue_put_Condition), nullptr, nullptr },
        { }};

    static PyType_Slot _type_slots_CompositionConditionalValue[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_CompositionConditionalValue) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_CompositionConditionalValue) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_CompositionConditionalValue) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_CompositionConditionalValue) },
        { }};

    static PyType_Spec type_spec_CompositionConditionalValue = {
        "winui3._winui3_microsoft_ui_composition_interactions.CompositionConditionalValue",
        sizeof(py::wrapper::Microsoft::UI::Composition::Interactions::CompositionConditionalValue),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_CompositionConditionalValue};

    static PyGetSetDef getset_CompositionConditionalValue_Static[] = {
        { }};

    static PyMethodDef methods_CompositionConditionalValue_Static[] = {
        { "create", reinterpret_cast<PyCFunction>(CompositionConditionalValue_Create), METH_VARARGS, nullptr },
        { }};

    static PyType_Slot type_slots_CompositionConditionalValue_Static[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_CompositionConditionalValue_Static) },
        { Py_tp_methods, reinterpret_cast<void*>(methods_CompositionConditionalValue_Static) },
        { }
    };

    static PyType_Spec type_spec_CompositionConditionalValue_Static = {
        "winui3._winui3_microsoft_ui_composition_interactions.CompositionConditionalValue_Static",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT,
        type_slots_CompositionConditionalValue_Static};

    // ----- CompositionInteractionSourceCollection class --------------------

    static PyObject* _new_CompositionInteractionSourceCollection(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Microsoft::UI::Composition::Interactions::CompositionInteractionSourceCollection>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Microsoft::UI::Composition::Interactions::CompositionInteractionSourceCollection>::type_name);
        return nullptr;
    }

    static void _dealloc_CompositionInteractionSourceCollection(py::wrapper::Microsoft::UI::Composition::Interactions::CompositionInteractionSourceCollection* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* CompositionInteractionSourceCollection_Add(py::wrapper::Microsoft::UI::Composition::Interactions::CompositionInteractionSourceCollection* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Composition.Interactions.CompositionInteractionSourceCollection", L"Add", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Microsoft::UI::Composition::Interactions::ICompositionInteractionSource>(args, 0);

                {
                    auto _gil = release_gil();
                    self->obj.Add(param0);
                }

                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* CompositionInteractionSourceCollection_First(py::wrapper::Microsoft::UI::Composition::Interactions::CompositionInteractionSourceCollection* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Composition.Interactions.CompositionInteractionSourceCollection", L"First", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return self->obj.First();
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* CompositionInteractionSourceCollection_Remove(py::wrapper::Microsoft::UI::Composition::Interactions::CompositionInteractionSourceCollection* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Composition.Interactions.CompositionInteractionSourceCollection", L"Remove", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Microsoft::UI::Composition::Interactions::ICompositionInteractionSource>(args, 0);

                {
                    auto _gil = release_gil();
                    self->obj.Remove(param0);
                }

                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* CompositionInteractionSourceCollection_RemoveAll(py::wrapper::Microsoft::UI::Composition::Interactions::CompositionInteractionSourceCollection* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Composition.Interactions.CompositionInteractionSourceCollection", L"RemoveAll", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                {
                    auto _gil = release_gil();
                    self->obj.RemoveAll();
                }

                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* CompositionInteractionSourceCollection_get_Count(py::wrapper::Microsoft::UI::Composition::Interactions::CompositionInteractionSourceCollection* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Composition.Interactions.CompositionInteractionSourceCollection", L"Count");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Count();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_CompositionInteractionSourceCollection(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Microsoft::UI::Composition::Interactions::CompositionInteractionSourceCollection>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_CompositionInteractionSourceCollection(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Microsoft::UI::Composition::Interactions::CompositionInteractionSourceCollection>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _iterator_CompositionInteractionSourceCollection(py::wrapper::Microsoft::UI::Composition::Interactions::CompositionInteractionSourceCollection* self) noexcept
    {
        try
        {
            return py::convert([&]()
            {
                auto _gil = py::release_gil();
                return self->obj.First();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_CompositionInteractionSourceCollection[] = {
        { "add", reinterpret_cast<PyCFunction>(CompositionInteractionSourceCollection_Add), METH_VARARGS, nullptr },
        { "first", reinterpret_cast<PyCFunction>(CompositionInteractionSourceCollection_First), METH_VARARGS, nullptr },
        { "remove", reinterpret_cast<PyCFunction>(CompositionInteractionSourceCollection_Remove), METH_VARARGS, nullptr },
        { "remove_all", reinterpret_cast<PyCFunction>(CompositionInteractionSourceCollection_RemoveAll), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_CompositionInteractionSourceCollection, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_CompositionInteractionSourceCollection), METH_O | METH_STATIC, nullptr },
        { }};

    static PyGetSetDef _getset_CompositionInteractionSourceCollection[] = {
        { "count", reinterpret_cast<getter>(CompositionInteractionSourceCollection_get_Count), nullptr, nullptr, nullptr },
        { }};

    static PyType_Slot _type_slots_CompositionInteractionSourceCollection[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_CompositionInteractionSourceCollection) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_CompositionInteractionSourceCollection) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_CompositionInteractionSourceCollection) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_CompositionInteractionSourceCollection) },
        { Py_tp_iter, reinterpret_cast<void*>(_iterator_CompositionInteractionSourceCollection) },
        { }};

    static PyType_Spec type_spec_CompositionInteractionSourceCollection = {
        "winui3._winui3_microsoft_ui_composition_interactions.CompositionInteractionSourceCollection",
        sizeof(py::wrapper::Microsoft::UI::Composition::Interactions::CompositionInteractionSourceCollection),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_CompositionInteractionSourceCollection};

    // ----- InteractionSourceConfiguration class --------------------

    static PyObject* _new_InteractionSourceConfiguration(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Microsoft::UI::Composition::Interactions::InteractionSourceConfiguration>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Microsoft::UI::Composition::Interactions::InteractionSourceConfiguration>::type_name);
        return nullptr;
    }

    static void _dealloc_InteractionSourceConfiguration(py::wrapper::Microsoft::UI::Composition::Interactions::InteractionSourceConfiguration* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* InteractionSourceConfiguration_get_ScaleSourceMode(py::wrapper::Microsoft::UI::Composition::Interactions::InteractionSourceConfiguration* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Composition.Interactions.InteractionSourceConfiguration", L"ScaleSourceMode");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.ScaleSourceMode();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int InteractionSourceConfiguration_put_ScaleSourceMode(py::wrapper::Microsoft::UI::Composition::Interactions::InteractionSourceConfiguration* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Composition.Interactions.InteractionSourceConfiguration", L"ScaleSourceMode");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Microsoft::UI::Composition::Interactions::InteractionSourceRedirectionMode>(arg);

            {
                auto _gil = release_gil();
                self->obj.ScaleSourceMode(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* InteractionSourceConfiguration_get_PositionYSourceMode(py::wrapper::Microsoft::UI::Composition::Interactions::InteractionSourceConfiguration* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Composition.Interactions.InteractionSourceConfiguration", L"PositionYSourceMode");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.PositionYSourceMode();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int InteractionSourceConfiguration_put_PositionYSourceMode(py::wrapper::Microsoft::UI::Composition::Interactions::InteractionSourceConfiguration* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Composition.Interactions.InteractionSourceConfiguration", L"PositionYSourceMode");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Microsoft::UI::Composition::Interactions::InteractionSourceRedirectionMode>(arg);

            {
                auto _gil = release_gil();
                self->obj.PositionYSourceMode(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* InteractionSourceConfiguration_get_PositionXSourceMode(py::wrapper::Microsoft::UI::Composition::Interactions::InteractionSourceConfiguration* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Composition.Interactions.InteractionSourceConfiguration", L"PositionXSourceMode");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.PositionXSourceMode();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int InteractionSourceConfiguration_put_PositionXSourceMode(py::wrapper::Microsoft::UI::Composition::Interactions::InteractionSourceConfiguration* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Composition.Interactions.InteractionSourceConfiguration", L"PositionXSourceMode");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Microsoft::UI::Composition::Interactions::InteractionSourceRedirectionMode>(arg);

            {
                auto _gil = release_gil();
                self->obj.PositionXSourceMode(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* _assign_array_InteractionSourceConfiguration(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Microsoft::UI::Composition::Interactions::InteractionSourceConfiguration>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_InteractionSourceConfiguration(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Microsoft::UI::Composition::Interactions::InteractionSourceConfiguration>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_InteractionSourceConfiguration[] = {
        { "_assign_array_", _assign_array_InteractionSourceConfiguration, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_InteractionSourceConfiguration), METH_O | METH_STATIC, nullptr },
        { }};

    static PyGetSetDef _getset_InteractionSourceConfiguration[] = {
        { "scale_source_mode", reinterpret_cast<getter>(InteractionSourceConfiguration_get_ScaleSourceMode), reinterpret_cast<setter>(InteractionSourceConfiguration_put_ScaleSourceMode), nullptr, nullptr },
        { "position_y_source_mode", reinterpret_cast<getter>(InteractionSourceConfiguration_get_PositionYSourceMode), reinterpret_cast<setter>(InteractionSourceConfiguration_put_PositionYSourceMode), nullptr, nullptr },
        { "position_x_source_mode", reinterpret_cast<getter>(InteractionSourceConfiguration_get_PositionXSourceMode), reinterpret_cast<setter>(InteractionSourceConfiguration_put_PositionXSourceMode), nullptr, nullptr },
        { }};

    static PyType_Slot _type_slots_InteractionSourceConfiguration[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_InteractionSourceConfiguration) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_InteractionSourceConfiguration) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_InteractionSourceConfiguration) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_InteractionSourceConfiguration) },
        { }};

    static PyType_Spec type_spec_InteractionSourceConfiguration = {
        "winui3._winui3_microsoft_ui_composition_interactions.InteractionSourceConfiguration",
        sizeof(py::wrapper::Microsoft::UI::Composition::Interactions::InteractionSourceConfiguration),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_InteractionSourceConfiguration};

    // ----- InteractionTracker class --------------------

    static PyObject* _new_InteractionTracker(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Microsoft::UI::Composition::Interactions::InteractionTracker>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Microsoft::UI::Composition::Interactions::InteractionTracker>::type_name);
        return nullptr;
    }

    static void _dealloc_InteractionTracker(py::wrapper::Microsoft::UI::Composition::Interactions::InteractionTracker* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* InteractionTracker_AdjustPositionXIfGreaterThanThreshold(py::wrapper::Microsoft::UI::Composition::Interactions::InteractionTracker* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 2)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Composition.Interactions.InteractionTracker", L"AdjustPositionXIfGreaterThanThreshold", 2);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(2);
                    return nullptr;
                }

                auto param0 = py::convert_to<float>(args, 0);
                auto param1 = py::convert_to<float>(args, 1);

                {
                    auto _gil = release_gil();
                    self->obj.AdjustPositionXIfGreaterThanThreshold(param0, param1);
                }

                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* InteractionTracker_AdjustPositionYIfGreaterThanThreshold(py::wrapper::Microsoft::UI::Composition::Interactions::InteractionTracker* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 2)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Composition.Interactions.InteractionTracker", L"AdjustPositionYIfGreaterThanThreshold", 2);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(2);
                    return nullptr;
                }

                auto param0 = py::convert_to<float>(args, 0);
                auto param1 = py::convert_to<float>(args, 1);

                {
                    auto _gil = release_gil();
                    self->obj.AdjustPositionYIfGreaterThanThreshold(param0, param1);
                }

                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* InteractionTracker_ConfigureCenterPointXInertiaModifiers(py::wrapper::Microsoft::UI::Composition::Interactions::InteractionTracker* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Composition.Interactions.InteractionTracker", L"ConfigureCenterPointXInertiaModifiers", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Foundation::Collections::IIterable<winrt::Microsoft::UI::Composition::Interactions::CompositionConditionalValue>>(args, 0);

                {
                    auto _gil = release_gil();
                    self->obj.ConfigureCenterPointXInertiaModifiers(param0);
                }

                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* InteractionTracker_ConfigureCenterPointYInertiaModifiers(py::wrapper::Microsoft::UI::Composition::Interactions::InteractionTracker* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Composition.Interactions.InteractionTracker", L"ConfigureCenterPointYInertiaModifiers", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Foundation::Collections::IIterable<winrt::Microsoft::UI::Composition::Interactions::CompositionConditionalValue>>(args, 0);

                {
                    auto _gil = release_gil();
                    self->obj.ConfigureCenterPointYInertiaModifiers(param0);
                }

                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* InteractionTracker_ConfigurePositionXInertiaModifiers(py::wrapper::Microsoft::UI::Composition::Interactions::InteractionTracker* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Composition.Interactions.InteractionTracker", L"ConfigurePositionXInertiaModifiers", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Foundation::Collections::IIterable<winrt::Microsoft::UI::Composition::Interactions::InteractionTrackerInertiaModifier>>(args, 0);

                {
                    auto _gil = release_gil();
                    self->obj.ConfigurePositionXInertiaModifiers(param0);
                }

                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* InteractionTracker_ConfigurePositionYInertiaModifiers(py::wrapper::Microsoft::UI::Composition::Interactions::InteractionTracker* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Composition.Interactions.InteractionTracker", L"ConfigurePositionYInertiaModifiers", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Foundation::Collections::IIterable<winrt::Microsoft::UI::Composition::Interactions::InteractionTrackerInertiaModifier>>(args, 0);

                {
                    auto _gil = release_gil();
                    self->obj.ConfigurePositionYInertiaModifiers(param0);
                }

                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* InteractionTracker_ConfigureScaleInertiaModifiers(py::wrapper::Microsoft::UI::Composition::Interactions::InteractionTracker* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Composition.Interactions.InteractionTracker", L"ConfigureScaleInertiaModifiers", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Foundation::Collections::IIterable<winrt::Microsoft::UI::Composition::Interactions::InteractionTrackerInertiaModifier>>(args, 0);

                {
                    auto _gil = release_gil();
                    self->obj.ConfigureScaleInertiaModifiers(param0);
                }

                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* InteractionTracker_ConfigureVector2PositionInertiaModifiers(py::wrapper::Microsoft::UI::Composition::Interactions::InteractionTracker* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Composition.Interactions.InteractionTracker", L"ConfigureVector2PositionInertiaModifiers", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Foundation::Collections::IIterable<winrt::Microsoft::UI::Composition::Interactions::InteractionTrackerVector2InertiaModifier>>(args, 0);

                {
                    auto _gil = release_gil();
                    self->obj.ConfigureVector2PositionInertiaModifiers(param0);
                }

                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* InteractionTracker_Create(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Composition.Interactions.InteractionTracker", L"Create", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Microsoft::UI::Composition::Compositor>(args, 0);

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return winrt::Microsoft::UI::Composition::Interactions::InteractionTracker::Create(param0);
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* InteractionTracker_CreateWithOwner(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 2)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Composition.Interactions.InteractionTracker", L"CreateWithOwner", 2);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(2);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Microsoft::UI::Composition::Compositor>(args, 0);
                auto param1 = py::convert_to<winrt::Microsoft::UI::Composition::Interactions::IInteractionTrackerOwner>(args, 1);

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return winrt::Microsoft::UI::Composition::Interactions::InteractionTracker::CreateWithOwner(param0, param1);
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* InteractionTracker_GetBindingMode(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 2)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Composition.Interactions.InteractionTracker", L"GetBindingMode", 2);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(2);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Microsoft::UI::Composition::Interactions::InteractionTracker>(args, 0);
                auto param1 = py::convert_to<winrt::Microsoft::UI::Composition::Interactions::InteractionTracker>(args, 1);

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return winrt::Microsoft::UI::Composition::Interactions::InteractionTracker::GetBindingMode(param0, param1);
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* InteractionTracker_SetBindingMode(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 3)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Composition.Interactions.InteractionTracker", L"SetBindingMode", 3);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(3);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Microsoft::UI::Composition::Interactions::InteractionTracker>(args, 0);
                auto param1 = py::convert_to<winrt::Microsoft::UI::Composition::Interactions::InteractionTracker>(args, 1);
                auto param2 = py::convert_to<winrt::Microsoft::UI::Composition::Interactions::InteractionBindingAxisModes>(args, 2);

                {
                    auto _gil = release_gil();
                    winrt::Microsoft::UI::Composition::Interactions::InteractionTracker::SetBindingMode(param0, param1, param2);
                }

                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* InteractionTracker_TryUpdatePosition(py::wrapper::Microsoft::UI::Composition::Interactions::InteractionTracker* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Composition.Interactions.InteractionTracker", L"TryUpdatePosition", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Foundation::Numerics::float3>(args, 0);

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return self->obj.TryUpdatePosition(param0);
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* InteractionTracker_TryUpdatePositionBy(py::wrapper::Microsoft::UI::Composition::Interactions::InteractionTracker* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Composition.Interactions.InteractionTracker", L"TryUpdatePositionBy", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Foundation::Numerics::float3>(args, 0);

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return self->obj.TryUpdatePositionBy(param0);
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* InteractionTracker_TryUpdatePositionByWithOption(py::wrapper::Microsoft::UI::Composition::Interactions::InteractionTracker* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 2)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Composition.Interactions.InteractionTracker", L"TryUpdatePositionBy", 2);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(2);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Foundation::Numerics::float3>(args, 0);
                auto param1 = py::convert_to<winrt::Microsoft::UI::Composition::Interactions::InteractionTrackerClampingOption>(args, 1);

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return self->obj.TryUpdatePositionBy(param0, param1);
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* InteractionTracker_TryUpdatePositionWithAdditionalVelocity(py::wrapper::Microsoft::UI::Composition::Interactions::InteractionTracker* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Composition.Interactions.InteractionTracker", L"TryUpdatePositionWithAdditionalVelocity", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Foundation::Numerics::float3>(args, 0);

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return self->obj.TryUpdatePositionWithAdditionalVelocity(param0);
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* InteractionTracker_TryUpdatePositionWithAnimation(py::wrapper::Microsoft::UI::Composition::Interactions::InteractionTracker* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Composition.Interactions.InteractionTracker", L"TryUpdatePositionWithAnimation", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Microsoft::UI::Composition::CompositionAnimation>(args, 0);

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return self->obj.TryUpdatePositionWithAnimation(param0);
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* InteractionTracker_TryUpdatePositionWithOption(py::wrapper::Microsoft::UI::Composition::Interactions::InteractionTracker* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 2)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Composition.Interactions.InteractionTracker", L"TryUpdatePosition", 2);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(2);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Foundation::Numerics::float3>(args, 0);
                auto param1 = py::convert_to<winrt::Microsoft::UI::Composition::Interactions::InteractionTrackerClampingOption>(args, 1);

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return self->obj.TryUpdatePosition(param0, param1);
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 3)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Composition.Interactions.InteractionTracker", L"TryUpdatePosition", 3);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(3);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Foundation::Numerics::float3>(args, 0);
                auto param1 = py::convert_to<winrt::Microsoft::UI::Composition::Interactions::InteractionTrackerClampingOption>(args, 1);
                auto param2 = py::convert_to<winrt::Microsoft::UI::Composition::Interactions::InteractionTrackerPositionUpdateOption>(args, 2);

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return self->obj.TryUpdatePosition(param0, param1, param2);
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* InteractionTracker_TryUpdateScale(py::wrapper::Microsoft::UI::Composition::Interactions::InteractionTracker* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 2)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Composition.Interactions.InteractionTracker", L"TryUpdateScale", 2);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(2);
                    return nullptr;
                }

                auto param0 = py::convert_to<float>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Foundation::Numerics::float3>(args, 1);

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return self->obj.TryUpdateScale(param0, param1);
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* InteractionTracker_TryUpdateScaleWithAdditionalVelocity(py::wrapper::Microsoft::UI::Composition::Interactions::InteractionTracker* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 2)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Composition.Interactions.InteractionTracker", L"TryUpdateScaleWithAdditionalVelocity", 2);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(2);
                    return nullptr;
                }

                auto param0 = py::convert_to<float>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Foundation::Numerics::float3>(args, 1);

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return self->obj.TryUpdateScaleWithAdditionalVelocity(param0, param1);
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* InteractionTracker_TryUpdateScaleWithAnimation(py::wrapper::Microsoft::UI::Composition::Interactions::InteractionTracker* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 2)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Composition.Interactions.InteractionTracker", L"TryUpdateScaleWithAnimation", 2);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(2);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Microsoft::UI::Composition::CompositionAnimation>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Foundation::Numerics::float3>(args, 1);

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return self->obj.TryUpdateScaleWithAnimation(param0, param1);
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* InteractionTracker_get_ScaleInertiaDecayRate(py::wrapper::Microsoft::UI::Composition::Interactions::InteractionTracker* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Composition.Interactions.InteractionTracker", L"ScaleInertiaDecayRate");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.ScaleInertiaDecayRate();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int InteractionTracker_put_ScaleInertiaDecayRate(py::wrapper::Microsoft::UI::Composition::Interactions::InteractionTracker* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Composition.Interactions.InteractionTracker", L"ScaleInertiaDecayRate");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::IReference<float>>(arg);

            {
                auto _gil = release_gil();
                self->obj.ScaleInertiaDecayRate(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* InteractionTracker_get_PositionInertiaDecayRate(py::wrapper::Microsoft::UI::Composition::Interactions::InteractionTracker* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Composition.Interactions.InteractionTracker", L"PositionInertiaDecayRate");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.PositionInertiaDecayRate();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int InteractionTracker_put_PositionInertiaDecayRate(py::wrapper::Microsoft::UI::Composition::Interactions::InteractionTracker* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Composition.Interactions.InteractionTracker", L"PositionInertiaDecayRate");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::IReference<winrt::Windows::Foundation::Numerics::float3>>(arg);

            {
                auto _gil = release_gil();
                self->obj.PositionInertiaDecayRate(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* InteractionTracker_get_MinScale(py::wrapper::Microsoft::UI::Composition::Interactions::InteractionTracker* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Composition.Interactions.InteractionTracker", L"MinScale");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.MinScale();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int InteractionTracker_put_MinScale(py::wrapper::Microsoft::UI::Composition::Interactions::InteractionTracker* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Composition.Interactions.InteractionTracker", L"MinScale");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<float>(arg);

            {
                auto _gil = release_gil();
                self->obj.MinScale(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* InteractionTracker_get_MinPosition(py::wrapper::Microsoft::UI::Composition::Interactions::InteractionTracker* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Composition.Interactions.InteractionTracker", L"MinPosition");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.MinPosition();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int InteractionTracker_put_MinPosition(py::wrapper::Microsoft::UI::Composition::Interactions::InteractionTracker* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Composition.Interactions.InteractionTracker", L"MinPosition");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::Numerics::float3>(arg);

            {
                auto _gil = release_gil();
                self->obj.MinPosition(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* InteractionTracker_get_MaxScale(py::wrapper::Microsoft::UI::Composition::Interactions::InteractionTracker* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Composition.Interactions.InteractionTracker", L"MaxScale");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.MaxScale();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int InteractionTracker_put_MaxScale(py::wrapper::Microsoft::UI::Composition::Interactions::InteractionTracker* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Composition.Interactions.InteractionTracker", L"MaxScale");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<float>(arg);

            {
                auto _gil = release_gil();
                self->obj.MaxScale(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* InteractionTracker_get_MaxPosition(py::wrapper::Microsoft::UI::Composition::Interactions::InteractionTracker* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Composition.Interactions.InteractionTracker", L"MaxPosition");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.MaxPosition();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int InteractionTracker_put_MaxPosition(py::wrapper::Microsoft::UI::Composition::Interactions::InteractionTracker* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Composition.Interactions.InteractionTracker", L"MaxPosition");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::Numerics::float3>(arg);

            {
                auto _gil = release_gil();
                self->obj.MaxPosition(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* InteractionTracker_get_InteractionSources(py::wrapper::Microsoft::UI::Composition::Interactions::InteractionTracker* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Composition.Interactions.InteractionTracker", L"InteractionSources");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.InteractionSources();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* InteractionTracker_get_IsPositionRoundingSuggested(py::wrapper::Microsoft::UI::Composition::Interactions::InteractionTracker* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Composition.Interactions.InteractionTracker", L"IsPositionRoundingSuggested");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.IsPositionRoundingSuggested();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* InteractionTracker_get_NaturalRestingPosition(py::wrapper::Microsoft::UI::Composition::Interactions::InteractionTracker* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Composition.Interactions.InteractionTracker", L"NaturalRestingPosition");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.NaturalRestingPosition();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* InteractionTracker_get_NaturalRestingScale(py::wrapper::Microsoft::UI::Composition::Interactions::InteractionTracker* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Composition.Interactions.InteractionTracker", L"NaturalRestingScale");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.NaturalRestingScale();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* InteractionTracker_get_Owner(py::wrapper::Microsoft::UI::Composition::Interactions::InteractionTracker* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Composition.Interactions.InteractionTracker", L"Owner");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Owner();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* InteractionTracker_get_Position(py::wrapper::Microsoft::UI::Composition::Interactions::InteractionTracker* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Composition.Interactions.InteractionTracker", L"Position");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Position();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* InteractionTracker_get_PositionVelocityInPixelsPerSecond(py::wrapper::Microsoft::UI::Composition::Interactions::InteractionTracker* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Composition.Interactions.InteractionTracker", L"PositionVelocityInPixelsPerSecond");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.PositionVelocityInPixelsPerSecond();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* InteractionTracker_get_Scale(py::wrapper::Microsoft::UI::Composition::Interactions::InteractionTracker* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Composition.Interactions.InteractionTracker", L"Scale");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Scale();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* InteractionTracker_get_ScaleVelocityInPercentPerSecond(py::wrapper::Microsoft::UI::Composition::Interactions::InteractionTracker* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Composition.Interactions.InteractionTracker", L"ScaleVelocityInPercentPerSecond");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.ScaleVelocityInPercentPerSecond();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* InteractionTracker_get_IsInertiaFromImpulse(py::wrapper::Microsoft::UI::Composition::Interactions::InteractionTracker* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Composition.Interactions.InteractionTracker", L"IsInertiaFromImpulse");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.IsInertiaFromImpulse();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_InteractionTracker(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Microsoft::UI::Composition::Interactions::InteractionTracker>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_InteractionTracker(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Microsoft::UI::Composition::Interactions::InteractionTracker>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_InteractionTracker[] = {
        { "adjust_position_x_if_greater_than_threshold", reinterpret_cast<PyCFunction>(InteractionTracker_AdjustPositionXIfGreaterThanThreshold), METH_VARARGS, nullptr },
        { "adjust_position_y_if_greater_than_threshold", reinterpret_cast<PyCFunction>(InteractionTracker_AdjustPositionYIfGreaterThanThreshold), METH_VARARGS, nullptr },
        { "configure_center_point_x_inertia_modifiers", reinterpret_cast<PyCFunction>(InteractionTracker_ConfigureCenterPointXInertiaModifiers), METH_VARARGS, nullptr },
        { "configure_center_point_y_inertia_modifiers", reinterpret_cast<PyCFunction>(InteractionTracker_ConfigureCenterPointYInertiaModifiers), METH_VARARGS, nullptr },
        { "configure_position_x_inertia_modifiers", reinterpret_cast<PyCFunction>(InteractionTracker_ConfigurePositionXInertiaModifiers), METH_VARARGS, nullptr },
        { "configure_position_y_inertia_modifiers", reinterpret_cast<PyCFunction>(InteractionTracker_ConfigurePositionYInertiaModifiers), METH_VARARGS, nullptr },
        { "configure_scale_inertia_modifiers", reinterpret_cast<PyCFunction>(InteractionTracker_ConfigureScaleInertiaModifiers), METH_VARARGS, nullptr },
        { "configure_vector2_position_inertia_modifiers", reinterpret_cast<PyCFunction>(InteractionTracker_ConfigureVector2PositionInertiaModifiers), METH_VARARGS, nullptr },
        { "try_update_position", reinterpret_cast<PyCFunction>(InteractionTracker_TryUpdatePosition), METH_VARARGS, nullptr },
        { "try_update_position_by", reinterpret_cast<PyCFunction>(InteractionTracker_TryUpdatePositionBy), METH_VARARGS, nullptr },
        { "try_update_position_by_with_option", reinterpret_cast<PyCFunction>(InteractionTracker_TryUpdatePositionByWithOption), METH_VARARGS, nullptr },
        { "try_update_position_with_additional_velocity", reinterpret_cast<PyCFunction>(InteractionTracker_TryUpdatePositionWithAdditionalVelocity), METH_VARARGS, nullptr },
        { "try_update_position_with_animation", reinterpret_cast<PyCFunction>(InteractionTracker_TryUpdatePositionWithAnimation), METH_VARARGS, nullptr },
        { "try_update_position_with_option", reinterpret_cast<PyCFunction>(InteractionTracker_TryUpdatePositionWithOption), METH_VARARGS, nullptr },
        { "try_update_scale", reinterpret_cast<PyCFunction>(InteractionTracker_TryUpdateScale), METH_VARARGS, nullptr },
        { "try_update_scale_with_additional_velocity", reinterpret_cast<PyCFunction>(InteractionTracker_TryUpdateScaleWithAdditionalVelocity), METH_VARARGS, nullptr },
        { "try_update_scale_with_animation", reinterpret_cast<PyCFunction>(InteractionTracker_TryUpdateScaleWithAnimation), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_InteractionTracker, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_InteractionTracker), METH_O | METH_STATIC, nullptr },
        { }};

    static PyGetSetDef _getset_InteractionTracker[] = {
        { "scale_inertia_decay_rate", reinterpret_cast<getter>(InteractionTracker_get_ScaleInertiaDecayRate), reinterpret_cast<setter>(InteractionTracker_put_ScaleInertiaDecayRate), nullptr, nullptr },
        { "position_inertia_decay_rate", reinterpret_cast<getter>(InteractionTracker_get_PositionInertiaDecayRate), reinterpret_cast<setter>(InteractionTracker_put_PositionInertiaDecayRate), nullptr, nullptr },
        { "min_scale", reinterpret_cast<getter>(InteractionTracker_get_MinScale), reinterpret_cast<setter>(InteractionTracker_put_MinScale), nullptr, nullptr },
        { "min_position", reinterpret_cast<getter>(InteractionTracker_get_MinPosition), reinterpret_cast<setter>(InteractionTracker_put_MinPosition), nullptr, nullptr },
        { "max_scale", reinterpret_cast<getter>(InteractionTracker_get_MaxScale), reinterpret_cast<setter>(InteractionTracker_put_MaxScale), nullptr, nullptr },
        { "max_position", reinterpret_cast<getter>(InteractionTracker_get_MaxPosition), reinterpret_cast<setter>(InteractionTracker_put_MaxPosition), nullptr, nullptr },
        { "interaction_sources", reinterpret_cast<getter>(InteractionTracker_get_InteractionSources), nullptr, nullptr, nullptr },
        { "is_position_rounding_suggested", reinterpret_cast<getter>(InteractionTracker_get_IsPositionRoundingSuggested), nullptr, nullptr, nullptr },
        { "natural_resting_position", reinterpret_cast<getter>(InteractionTracker_get_NaturalRestingPosition), nullptr, nullptr, nullptr },
        { "natural_resting_scale", reinterpret_cast<getter>(InteractionTracker_get_NaturalRestingScale), nullptr, nullptr, nullptr },
        { "owner", reinterpret_cast<getter>(InteractionTracker_get_Owner), nullptr, nullptr, nullptr },
        { "position", reinterpret_cast<getter>(InteractionTracker_get_Position), nullptr, nullptr, nullptr },
        { "position_velocity_in_pixels_per_second", reinterpret_cast<getter>(InteractionTracker_get_PositionVelocityInPixelsPerSecond), nullptr, nullptr, nullptr },
        { "scale", reinterpret_cast<getter>(InteractionTracker_get_Scale), nullptr, nullptr, nullptr },
        { "scale_velocity_in_percent_per_second", reinterpret_cast<getter>(InteractionTracker_get_ScaleVelocityInPercentPerSecond), nullptr, nullptr, nullptr },
        { "is_inertia_from_impulse", reinterpret_cast<getter>(InteractionTracker_get_IsInertiaFromImpulse), nullptr, nullptr, nullptr },
        { }};

    static PyType_Slot _type_slots_InteractionTracker[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_InteractionTracker) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_InteractionTracker) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_InteractionTracker) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_InteractionTracker) },
        { }};

    static PyType_Spec type_spec_InteractionTracker = {
        "winui3._winui3_microsoft_ui_composition_interactions.InteractionTracker",
        sizeof(py::wrapper::Microsoft::UI::Composition::Interactions::InteractionTracker),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_InteractionTracker};

    static PyGetSetDef getset_InteractionTracker_Static[] = {
        { }};

    static PyMethodDef methods_InteractionTracker_Static[] = {
        { "create", reinterpret_cast<PyCFunction>(InteractionTracker_Create), METH_VARARGS, nullptr },
        { "create_with_owner", reinterpret_cast<PyCFunction>(InteractionTracker_CreateWithOwner), METH_VARARGS, nullptr },
        { "get_binding_mode", reinterpret_cast<PyCFunction>(InteractionTracker_GetBindingMode), METH_VARARGS, nullptr },
        { "set_binding_mode", reinterpret_cast<PyCFunction>(InteractionTracker_SetBindingMode), METH_VARARGS, nullptr },
        { }};

    static PyType_Slot type_slots_InteractionTracker_Static[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_InteractionTracker_Static) },
        { Py_tp_methods, reinterpret_cast<void*>(methods_InteractionTracker_Static) },
        { }
    };

    static PyType_Spec type_spec_InteractionTracker_Static = {
        "winui3._winui3_microsoft_ui_composition_interactions.InteractionTracker_Static",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT,
        type_slots_InteractionTracker_Static};

    // ----- InteractionTrackerCustomAnimationStateEnteredArgs class --------------------

    static PyObject* _new_InteractionTrackerCustomAnimationStateEnteredArgs(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Microsoft::UI::Composition::Interactions::InteractionTrackerCustomAnimationStateEnteredArgs>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Microsoft::UI::Composition::Interactions::InteractionTrackerCustomAnimationStateEnteredArgs>::type_name);
        return nullptr;
    }

    static void _dealloc_InteractionTrackerCustomAnimationStateEnteredArgs(py::wrapper::Microsoft::UI::Composition::Interactions::InteractionTrackerCustomAnimationStateEnteredArgs* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* InteractionTrackerCustomAnimationStateEnteredArgs_get_RequestId(py::wrapper::Microsoft::UI::Composition::Interactions::InteractionTrackerCustomAnimationStateEnteredArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Composition.Interactions.InteractionTrackerCustomAnimationStateEnteredArgs", L"RequestId");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.RequestId();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* InteractionTrackerCustomAnimationStateEnteredArgs_get_IsFromBinding(py::wrapper::Microsoft::UI::Composition::Interactions::InteractionTrackerCustomAnimationStateEnteredArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Composition.Interactions.InteractionTrackerCustomAnimationStateEnteredArgs", L"IsFromBinding");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.IsFromBinding();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_InteractionTrackerCustomAnimationStateEnteredArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Microsoft::UI::Composition::Interactions::InteractionTrackerCustomAnimationStateEnteredArgs>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_InteractionTrackerCustomAnimationStateEnteredArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Microsoft::UI::Composition::Interactions::InteractionTrackerCustomAnimationStateEnteredArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_InteractionTrackerCustomAnimationStateEnteredArgs[] = {
        { "_assign_array_", _assign_array_InteractionTrackerCustomAnimationStateEnteredArgs, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_InteractionTrackerCustomAnimationStateEnteredArgs), METH_O | METH_STATIC, nullptr },
        { }};

    static PyGetSetDef _getset_InteractionTrackerCustomAnimationStateEnteredArgs[] = {
        { "request_id", reinterpret_cast<getter>(InteractionTrackerCustomAnimationStateEnteredArgs_get_RequestId), nullptr, nullptr, nullptr },
        { "is_from_binding", reinterpret_cast<getter>(InteractionTrackerCustomAnimationStateEnteredArgs_get_IsFromBinding), nullptr, nullptr, nullptr },
        { }};

    static PyType_Slot _type_slots_InteractionTrackerCustomAnimationStateEnteredArgs[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_InteractionTrackerCustomAnimationStateEnteredArgs) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_InteractionTrackerCustomAnimationStateEnteredArgs) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_InteractionTrackerCustomAnimationStateEnteredArgs) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_InteractionTrackerCustomAnimationStateEnteredArgs) },
        { }};

    static PyType_Spec type_spec_InteractionTrackerCustomAnimationStateEnteredArgs = {
        "winui3._winui3_microsoft_ui_composition_interactions.InteractionTrackerCustomAnimationStateEnteredArgs",
        sizeof(py::wrapper::Microsoft::UI::Composition::Interactions::InteractionTrackerCustomAnimationStateEnteredArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_InteractionTrackerCustomAnimationStateEnteredArgs};

    // ----- InteractionTrackerIdleStateEnteredArgs class --------------------

    static PyObject* _new_InteractionTrackerIdleStateEnteredArgs(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Microsoft::UI::Composition::Interactions::InteractionTrackerIdleStateEnteredArgs>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Microsoft::UI::Composition::Interactions::InteractionTrackerIdleStateEnteredArgs>::type_name);
        return nullptr;
    }

    static void _dealloc_InteractionTrackerIdleStateEnteredArgs(py::wrapper::Microsoft::UI::Composition::Interactions::InteractionTrackerIdleStateEnteredArgs* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* InteractionTrackerIdleStateEnteredArgs_get_RequestId(py::wrapper::Microsoft::UI::Composition::Interactions::InteractionTrackerIdleStateEnteredArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Composition.Interactions.InteractionTrackerIdleStateEnteredArgs", L"RequestId");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.RequestId();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* InteractionTrackerIdleStateEnteredArgs_get_IsFromBinding(py::wrapper::Microsoft::UI::Composition::Interactions::InteractionTrackerIdleStateEnteredArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Composition.Interactions.InteractionTrackerIdleStateEnteredArgs", L"IsFromBinding");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.IsFromBinding();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_InteractionTrackerIdleStateEnteredArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Microsoft::UI::Composition::Interactions::InteractionTrackerIdleStateEnteredArgs>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_InteractionTrackerIdleStateEnteredArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Microsoft::UI::Composition::Interactions::InteractionTrackerIdleStateEnteredArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_InteractionTrackerIdleStateEnteredArgs[] = {
        { "_assign_array_", _assign_array_InteractionTrackerIdleStateEnteredArgs, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_InteractionTrackerIdleStateEnteredArgs), METH_O | METH_STATIC, nullptr },
        { }};

    static PyGetSetDef _getset_InteractionTrackerIdleStateEnteredArgs[] = {
        { "request_id", reinterpret_cast<getter>(InteractionTrackerIdleStateEnteredArgs_get_RequestId), nullptr, nullptr, nullptr },
        { "is_from_binding", reinterpret_cast<getter>(InteractionTrackerIdleStateEnteredArgs_get_IsFromBinding), nullptr, nullptr, nullptr },
        { }};

    static PyType_Slot _type_slots_InteractionTrackerIdleStateEnteredArgs[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_InteractionTrackerIdleStateEnteredArgs) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_InteractionTrackerIdleStateEnteredArgs) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_InteractionTrackerIdleStateEnteredArgs) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_InteractionTrackerIdleStateEnteredArgs) },
        { }};

    static PyType_Spec type_spec_InteractionTrackerIdleStateEnteredArgs = {
        "winui3._winui3_microsoft_ui_composition_interactions.InteractionTrackerIdleStateEnteredArgs",
        sizeof(py::wrapper::Microsoft::UI::Composition::Interactions::InteractionTrackerIdleStateEnteredArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_InteractionTrackerIdleStateEnteredArgs};

    // ----- InteractionTrackerInertiaModifier class --------------------

    static PyObject* _new_InteractionTrackerInertiaModifier(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Microsoft::UI::Composition::Interactions::InteractionTrackerInertiaModifier>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Microsoft::UI::Composition::Interactions::InteractionTrackerInertiaModifier>::type_name);
        return nullptr;
    }

    static void _dealloc_InteractionTrackerInertiaModifier(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* _assign_array_InteractionTrackerInertiaModifier(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Microsoft::UI::Composition::Interactions::InteractionTrackerInertiaModifier>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_InteractionTrackerInertiaModifier(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Microsoft::UI::Composition::Interactions::InteractionTrackerInertiaModifier>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_InteractionTrackerInertiaModifier[] = {
        { "_assign_array_", _assign_array_InteractionTrackerInertiaModifier, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_InteractionTrackerInertiaModifier), METH_O | METH_STATIC, nullptr },
        { }};

    static PyGetSetDef _getset_InteractionTrackerInertiaModifier[] = {
        { }};

    static PyType_Slot _type_slots_InteractionTrackerInertiaModifier[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_InteractionTrackerInertiaModifier) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_InteractionTrackerInertiaModifier) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_InteractionTrackerInertiaModifier) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_InteractionTrackerInertiaModifier) },
        { }};

    static PyType_Spec type_spec_InteractionTrackerInertiaModifier = {
        "winui3._winui3_microsoft_ui_composition_interactions.InteractionTrackerInertiaModifier",
        sizeof(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>),
        0,
        Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,
        _type_slots_InteractionTrackerInertiaModifier};

    static PyGetSetDef getset_InteractionTrackerInertiaModifier_Static[] = {
        { }};

    static PyMethodDef methods_InteractionTrackerInertiaModifier_Static[] = {
        { }};

    static PyType_Slot type_slots_InteractionTrackerInertiaModifier_Static[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_InteractionTrackerInertiaModifier_Static) },
        { Py_tp_methods, reinterpret_cast<void*>(methods_InteractionTrackerInertiaModifier_Static) },
        { }
    };

    static PyType_Spec type_spec_InteractionTrackerInertiaModifier_Static = {
        "winui3._winui3_microsoft_ui_composition_interactions.InteractionTrackerInertiaModifier_Static",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,
        type_slots_InteractionTrackerInertiaModifier_Static};

    // ----- InteractionTrackerInertiaMotion class --------------------

    static PyObject* _new_InteractionTrackerInertiaMotion(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Microsoft::UI::Composition::Interactions::InteractionTrackerInertiaMotion>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Microsoft::UI::Composition::Interactions::InteractionTrackerInertiaMotion>::type_name);
        return nullptr;
    }

    static void _dealloc_InteractionTrackerInertiaMotion(py::wrapper::Microsoft::UI::Composition::Interactions::InteractionTrackerInertiaMotion* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* InteractionTrackerInertiaMotion_Create(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Composition.Interactions.InteractionTrackerInertiaMotion", L"Create", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Microsoft::UI::Composition::Compositor>(args, 0);

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return winrt::Microsoft::UI::Composition::Interactions::InteractionTrackerInertiaMotion::Create(param0);
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* InteractionTrackerInertiaMotion_get_Motion(py::wrapper::Microsoft::UI::Composition::Interactions::InteractionTrackerInertiaMotion* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Composition.Interactions.InteractionTrackerInertiaMotion", L"Motion");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Motion();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int InteractionTrackerInertiaMotion_put_Motion(py::wrapper::Microsoft::UI::Composition::Interactions::InteractionTrackerInertiaMotion* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Composition.Interactions.InteractionTrackerInertiaMotion", L"Motion");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Microsoft::UI::Composition::ExpressionAnimation>(arg);

            {
                auto _gil = release_gil();
                self->obj.Motion(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* InteractionTrackerInertiaMotion_get_Condition(py::wrapper::Microsoft::UI::Composition::Interactions::InteractionTrackerInertiaMotion* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Composition.Interactions.InteractionTrackerInertiaMotion", L"Condition");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Condition();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int InteractionTrackerInertiaMotion_put_Condition(py::wrapper::Microsoft::UI::Composition::Interactions::InteractionTrackerInertiaMotion* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Composition.Interactions.InteractionTrackerInertiaMotion", L"Condition");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Microsoft::UI::Composition::ExpressionAnimation>(arg);

            {
                auto _gil = release_gil();
                self->obj.Condition(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* _assign_array_InteractionTrackerInertiaMotion(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Microsoft::UI::Composition::Interactions::InteractionTrackerInertiaMotion>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_InteractionTrackerInertiaMotion(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Microsoft::UI::Composition::Interactions::InteractionTrackerInertiaMotion>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_InteractionTrackerInertiaMotion[] = {
        { "_assign_array_", _assign_array_InteractionTrackerInertiaMotion, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_InteractionTrackerInertiaMotion), METH_O | METH_STATIC, nullptr },
        { }};

    static PyGetSetDef _getset_InteractionTrackerInertiaMotion[] = {
        { "motion", reinterpret_cast<getter>(InteractionTrackerInertiaMotion_get_Motion), reinterpret_cast<setter>(InteractionTrackerInertiaMotion_put_Motion), nullptr, nullptr },
        { "condition", reinterpret_cast<getter>(InteractionTrackerInertiaMotion_get_Condition), reinterpret_cast<setter>(InteractionTrackerInertiaMotion_put_Condition), nullptr, nullptr },
        { }};

    static PyType_Slot _type_slots_InteractionTrackerInertiaMotion[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_InteractionTrackerInertiaMotion) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_InteractionTrackerInertiaMotion) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_InteractionTrackerInertiaMotion) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_InteractionTrackerInertiaMotion) },
        { }};

    static PyType_Spec type_spec_InteractionTrackerInertiaMotion = {
        "winui3._winui3_microsoft_ui_composition_interactions.InteractionTrackerInertiaMotion",
        sizeof(py::wrapper::Microsoft::UI::Composition::Interactions::InteractionTrackerInertiaMotion),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_InteractionTrackerInertiaMotion};

    static PyGetSetDef getset_InteractionTrackerInertiaMotion_Static[] = {
        { }};

    static PyMethodDef methods_InteractionTrackerInertiaMotion_Static[] = {
        { "create", reinterpret_cast<PyCFunction>(InteractionTrackerInertiaMotion_Create), METH_VARARGS, nullptr },
        { }};

    static PyType_Slot type_slots_InteractionTrackerInertiaMotion_Static[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_InteractionTrackerInertiaMotion_Static) },
        { Py_tp_methods, reinterpret_cast<void*>(methods_InteractionTrackerInertiaMotion_Static) },
        { }
    };

    static PyType_Spec type_spec_InteractionTrackerInertiaMotion_Static = {
        "winui3._winui3_microsoft_ui_composition_interactions.InteractionTrackerInertiaMotion_Static",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT,
        type_slots_InteractionTrackerInertiaMotion_Static};

    // ----- InteractionTrackerInertiaNaturalMotion class --------------------

    static PyObject* _new_InteractionTrackerInertiaNaturalMotion(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Microsoft::UI::Composition::Interactions::InteractionTrackerInertiaNaturalMotion>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Microsoft::UI::Composition::Interactions::InteractionTrackerInertiaNaturalMotion>::type_name);
        return nullptr;
    }

    static void _dealloc_InteractionTrackerInertiaNaturalMotion(py::wrapper::Microsoft::UI::Composition::Interactions::InteractionTrackerInertiaNaturalMotion* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* InteractionTrackerInertiaNaturalMotion_Create(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Composition.Interactions.InteractionTrackerInertiaNaturalMotion", L"Create", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Microsoft::UI::Composition::Compositor>(args, 0);

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return winrt::Microsoft::UI::Composition::Interactions::InteractionTrackerInertiaNaturalMotion::Create(param0);
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* InteractionTrackerInertiaNaturalMotion_get_NaturalMotion(py::wrapper::Microsoft::UI::Composition::Interactions::InteractionTrackerInertiaNaturalMotion* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Composition.Interactions.InteractionTrackerInertiaNaturalMotion", L"NaturalMotion");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.NaturalMotion();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int InteractionTrackerInertiaNaturalMotion_put_NaturalMotion(py::wrapper::Microsoft::UI::Composition::Interactions::InteractionTrackerInertiaNaturalMotion* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Composition.Interactions.InteractionTrackerInertiaNaturalMotion", L"NaturalMotion");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Microsoft::UI::Composition::ScalarNaturalMotionAnimation>(arg);

            {
                auto _gil = release_gil();
                self->obj.NaturalMotion(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* InteractionTrackerInertiaNaturalMotion_get_Condition(py::wrapper::Microsoft::UI::Composition::Interactions::InteractionTrackerInertiaNaturalMotion* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Composition.Interactions.InteractionTrackerInertiaNaturalMotion", L"Condition");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Condition();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int InteractionTrackerInertiaNaturalMotion_put_Condition(py::wrapper::Microsoft::UI::Composition::Interactions::InteractionTrackerInertiaNaturalMotion* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Composition.Interactions.InteractionTrackerInertiaNaturalMotion", L"Condition");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Microsoft::UI::Composition::ExpressionAnimation>(arg);

            {
                auto _gil = release_gil();
                self->obj.Condition(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* _assign_array_InteractionTrackerInertiaNaturalMotion(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Microsoft::UI::Composition::Interactions::InteractionTrackerInertiaNaturalMotion>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_InteractionTrackerInertiaNaturalMotion(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Microsoft::UI::Composition::Interactions::InteractionTrackerInertiaNaturalMotion>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_InteractionTrackerInertiaNaturalMotion[] = {
        { "_assign_array_", _assign_array_InteractionTrackerInertiaNaturalMotion, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_InteractionTrackerInertiaNaturalMotion), METH_O | METH_STATIC, nullptr },
        { }};

    static PyGetSetDef _getset_InteractionTrackerInertiaNaturalMotion[] = {
        { "natural_motion", reinterpret_cast<getter>(InteractionTrackerInertiaNaturalMotion_get_NaturalMotion), reinterpret_cast<setter>(InteractionTrackerInertiaNaturalMotion_put_NaturalMotion), nullptr, nullptr },
        { "condition", reinterpret_cast<getter>(InteractionTrackerInertiaNaturalMotion_get_Condition), reinterpret_cast<setter>(InteractionTrackerInertiaNaturalMotion_put_Condition), nullptr, nullptr },
        { }};

    static PyType_Slot _type_slots_InteractionTrackerInertiaNaturalMotion[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_InteractionTrackerInertiaNaturalMotion) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_InteractionTrackerInertiaNaturalMotion) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_InteractionTrackerInertiaNaturalMotion) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_InteractionTrackerInertiaNaturalMotion) },
        { }};

    static PyType_Spec type_spec_InteractionTrackerInertiaNaturalMotion = {
        "winui3._winui3_microsoft_ui_composition_interactions.InteractionTrackerInertiaNaturalMotion",
        sizeof(py::wrapper::Microsoft::UI::Composition::Interactions::InteractionTrackerInertiaNaturalMotion),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_InteractionTrackerInertiaNaturalMotion};

    static PyGetSetDef getset_InteractionTrackerInertiaNaturalMotion_Static[] = {
        { }};

    static PyMethodDef methods_InteractionTrackerInertiaNaturalMotion_Static[] = {
        { "create", reinterpret_cast<PyCFunction>(InteractionTrackerInertiaNaturalMotion_Create), METH_VARARGS, nullptr },
        { }};

    static PyType_Slot type_slots_InteractionTrackerInertiaNaturalMotion_Static[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_InteractionTrackerInertiaNaturalMotion_Static) },
        { Py_tp_methods, reinterpret_cast<void*>(methods_InteractionTrackerInertiaNaturalMotion_Static) },
        { }
    };

    static PyType_Spec type_spec_InteractionTrackerInertiaNaturalMotion_Static = {
        "winui3._winui3_microsoft_ui_composition_interactions.InteractionTrackerInertiaNaturalMotion_Static",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT,
        type_slots_InteractionTrackerInertiaNaturalMotion_Static};

    // ----- InteractionTrackerInertiaRestingValue class --------------------

    static PyObject* _new_InteractionTrackerInertiaRestingValue(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Microsoft::UI::Composition::Interactions::InteractionTrackerInertiaRestingValue>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Microsoft::UI::Composition::Interactions::InteractionTrackerInertiaRestingValue>::type_name);
        return nullptr;
    }

    static void _dealloc_InteractionTrackerInertiaRestingValue(py::wrapper::Microsoft::UI::Composition::Interactions::InteractionTrackerInertiaRestingValue* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* InteractionTrackerInertiaRestingValue_Create(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Composition.Interactions.InteractionTrackerInertiaRestingValue", L"Create", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Microsoft::UI::Composition::Compositor>(args, 0);

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return winrt::Microsoft::UI::Composition::Interactions::InteractionTrackerInertiaRestingValue::Create(param0);
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* InteractionTrackerInertiaRestingValue_get_RestingValue(py::wrapper::Microsoft::UI::Composition::Interactions::InteractionTrackerInertiaRestingValue* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Composition.Interactions.InteractionTrackerInertiaRestingValue", L"RestingValue");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.RestingValue();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int InteractionTrackerInertiaRestingValue_put_RestingValue(py::wrapper::Microsoft::UI::Composition::Interactions::InteractionTrackerInertiaRestingValue* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Composition.Interactions.InteractionTrackerInertiaRestingValue", L"RestingValue");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Microsoft::UI::Composition::ExpressionAnimation>(arg);

            {
                auto _gil = release_gil();
                self->obj.RestingValue(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* InteractionTrackerInertiaRestingValue_get_Condition(py::wrapper::Microsoft::UI::Composition::Interactions::InteractionTrackerInertiaRestingValue* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Composition.Interactions.InteractionTrackerInertiaRestingValue", L"Condition");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Condition();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int InteractionTrackerInertiaRestingValue_put_Condition(py::wrapper::Microsoft::UI::Composition::Interactions::InteractionTrackerInertiaRestingValue* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Composition.Interactions.InteractionTrackerInertiaRestingValue", L"Condition");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Microsoft::UI::Composition::ExpressionAnimation>(arg);

            {
                auto _gil = release_gil();
                self->obj.Condition(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* _assign_array_InteractionTrackerInertiaRestingValue(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Microsoft::UI::Composition::Interactions::InteractionTrackerInertiaRestingValue>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_InteractionTrackerInertiaRestingValue(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Microsoft::UI::Composition::Interactions::InteractionTrackerInertiaRestingValue>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_InteractionTrackerInertiaRestingValue[] = {
        { "_assign_array_", _assign_array_InteractionTrackerInertiaRestingValue, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_InteractionTrackerInertiaRestingValue), METH_O | METH_STATIC, nullptr },
        { }};

    static PyGetSetDef _getset_InteractionTrackerInertiaRestingValue[] = {
        { "resting_value", reinterpret_cast<getter>(InteractionTrackerInertiaRestingValue_get_RestingValue), reinterpret_cast<setter>(InteractionTrackerInertiaRestingValue_put_RestingValue), nullptr, nullptr },
        { "condition", reinterpret_cast<getter>(InteractionTrackerInertiaRestingValue_get_Condition), reinterpret_cast<setter>(InteractionTrackerInertiaRestingValue_put_Condition), nullptr, nullptr },
        { }};

    static PyType_Slot _type_slots_InteractionTrackerInertiaRestingValue[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_InteractionTrackerInertiaRestingValue) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_InteractionTrackerInertiaRestingValue) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_InteractionTrackerInertiaRestingValue) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_InteractionTrackerInertiaRestingValue) },
        { }};

    static PyType_Spec type_spec_InteractionTrackerInertiaRestingValue = {
        "winui3._winui3_microsoft_ui_composition_interactions.InteractionTrackerInertiaRestingValue",
        sizeof(py::wrapper::Microsoft::UI::Composition::Interactions::InteractionTrackerInertiaRestingValue),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_InteractionTrackerInertiaRestingValue};

    static PyGetSetDef getset_InteractionTrackerInertiaRestingValue_Static[] = {
        { }};

    static PyMethodDef methods_InteractionTrackerInertiaRestingValue_Static[] = {
        { "create", reinterpret_cast<PyCFunction>(InteractionTrackerInertiaRestingValue_Create), METH_VARARGS, nullptr },
        { }};

    static PyType_Slot type_slots_InteractionTrackerInertiaRestingValue_Static[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_InteractionTrackerInertiaRestingValue_Static) },
        { Py_tp_methods, reinterpret_cast<void*>(methods_InteractionTrackerInertiaRestingValue_Static) },
        { }
    };

    static PyType_Spec type_spec_InteractionTrackerInertiaRestingValue_Static = {
        "winui3._winui3_microsoft_ui_composition_interactions.InteractionTrackerInertiaRestingValue_Static",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT,
        type_slots_InteractionTrackerInertiaRestingValue_Static};

    // ----- InteractionTrackerInertiaStateEnteredArgs class --------------------

    static PyObject* _new_InteractionTrackerInertiaStateEnteredArgs(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Microsoft::UI::Composition::Interactions::InteractionTrackerInertiaStateEnteredArgs>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Microsoft::UI::Composition::Interactions::InteractionTrackerInertiaStateEnteredArgs>::type_name);
        return nullptr;
    }

    static void _dealloc_InteractionTrackerInertiaStateEnteredArgs(py::wrapper::Microsoft::UI::Composition::Interactions::InteractionTrackerInertiaStateEnteredArgs* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* InteractionTrackerInertiaStateEnteredArgs_get_ModifiedRestingPosition(py::wrapper::Microsoft::UI::Composition::Interactions::InteractionTrackerInertiaStateEnteredArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Composition.Interactions.InteractionTrackerInertiaStateEnteredArgs", L"ModifiedRestingPosition");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.ModifiedRestingPosition();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* InteractionTrackerInertiaStateEnteredArgs_get_ModifiedRestingScale(py::wrapper::Microsoft::UI::Composition::Interactions::InteractionTrackerInertiaStateEnteredArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Composition.Interactions.InteractionTrackerInertiaStateEnteredArgs", L"ModifiedRestingScale");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.ModifiedRestingScale();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* InteractionTrackerInertiaStateEnteredArgs_get_NaturalRestingPosition(py::wrapper::Microsoft::UI::Composition::Interactions::InteractionTrackerInertiaStateEnteredArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Composition.Interactions.InteractionTrackerInertiaStateEnteredArgs", L"NaturalRestingPosition");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.NaturalRestingPosition();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* InteractionTrackerInertiaStateEnteredArgs_get_NaturalRestingScale(py::wrapper::Microsoft::UI::Composition::Interactions::InteractionTrackerInertiaStateEnteredArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Composition.Interactions.InteractionTrackerInertiaStateEnteredArgs", L"NaturalRestingScale");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.NaturalRestingScale();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* InteractionTrackerInertiaStateEnteredArgs_get_PositionVelocityInPixelsPerSecond(py::wrapper::Microsoft::UI::Composition::Interactions::InteractionTrackerInertiaStateEnteredArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Composition.Interactions.InteractionTrackerInertiaStateEnteredArgs", L"PositionVelocityInPixelsPerSecond");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.PositionVelocityInPixelsPerSecond();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* InteractionTrackerInertiaStateEnteredArgs_get_RequestId(py::wrapper::Microsoft::UI::Composition::Interactions::InteractionTrackerInertiaStateEnteredArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Composition.Interactions.InteractionTrackerInertiaStateEnteredArgs", L"RequestId");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.RequestId();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* InteractionTrackerInertiaStateEnteredArgs_get_ScaleVelocityInPercentPerSecond(py::wrapper::Microsoft::UI::Composition::Interactions::InteractionTrackerInertiaStateEnteredArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Composition.Interactions.InteractionTrackerInertiaStateEnteredArgs", L"ScaleVelocityInPercentPerSecond");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.ScaleVelocityInPercentPerSecond();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* InteractionTrackerInertiaStateEnteredArgs_get_IsInertiaFromImpulse(py::wrapper::Microsoft::UI::Composition::Interactions::InteractionTrackerInertiaStateEnteredArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Composition.Interactions.InteractionTrackerInertiaStateEnteredArgs", L"IsInertiaFromImpulse");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.IsInertiaFromImpulse();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* InteractionTrackerInertiaStateEnteredArgs_get_IsFromBinding(py::wrapper::Microsoft::UI::Composition::Interactions::InteractionTrackerInertiaStateEnteredArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Composition.Interactions.InteractionTrackerInertiaStateEnteredArgs", L"IsFromBinding");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.IsFromBinding();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_InteractionTrackerInertiaStateEnteredArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Microsoft::UI::Composition::Interactions::InteractionTrackerInertiaStateEnteredArgs>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_InteractionTrackerInertiaStateEnteredArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Microsoft::UI::Composition::Interactions::InteractionTrackerInertiaStateEnteredArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_InteractionTrackerInertiaStateEnteredArgs[] = {
        { "_assign_array_", _assign_array_InteractionTrackerInertiaStateEnteredArgs, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_InteractionTrackerInertiaStateEnteredArgs), METH_O | METH_STATIC, nullptr },
        { }};

    static PyGetSetDef _getset_InteractionTrackerInertiaStateEnteredArgs[] = {
        { "modified_resting_position", reinterpret_cast<getter>(InteractionTrackerInertiaStateEnteredArgs_get_ModifiedRestingPosition), nullptr, nullptr, nullptr },
        { "modified_resting_scale", reinterpret_cast<getter>(InteractionTrackerInertiaStateEnteredArgs_get_ModifiedRestingScale), nullptr, nullptr, nullptr },
        { "natural_resting_position", reinterpret_cast<getter>(InteractionTrackerInertiaStateEnteredArgs_get_NaturalRestingPosition), nullptr, nullptr, nullptr },
        { "natural_resting_scale", reinterpret_cast<getter>(InteractionTrackerInertiaStateEnteredArgs_get_NaturalRestingScale), nullptr, nullptr, nullptr },
        { "position_velocity_in_pixels_per_second", reinterpret_cast<getter>(InteractionTrackerInertiaStateEnteredArgs_get_PositionVelocityInPixelsPerSecond), nullptr, nullptr, nullptr },
        { "request_id", reinterpret_cast<getter>(InteractionTrackerInertiaStateEnteredArgs_get_RequestId), nullptr, nullptr, nullptr },
        { "scale_velocity_in_percent_per_second", reinterpret_cast<getter>(InteractionTrackerInertiaStateEnteredArgs_get_ScaleVelocityInPercentPerSecond), nullptr, nullptr, nullptr },
        { "is_inertia_from_impulse", reinterpret_cast<getter>(InteractionTrackerInertiaStateEnteredArgs_get_IsInertiaFromImpulse), nullptr, nullptr, nullptr },
        { "is_from_binding", reinterpret_cast<getter>(InteractionTrackerInertiaStateEnteredArgs_get_IsFromBinding), nullptr, nullptr, nullptr },
        { }};

    static PyType_Slot _type_slots_InteractionTrackerInertiaStateEnteredArgs[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_InteractionTrackerInertiaStateEnteredArgs) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_InteractionTrackerInertiaStateEnteredArgs) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_InteractionTrackerInertiaStateEnteredArgs) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_InteractionTrackerInertiaStateEnteredArgs) },
        { }};

    static PyType_Spec type_spec_InteractionTrackerInertiaStateEnteredArgs = {
        "winui3._winui3_microsoft_ui_composition_interactions.InteractionTrackerInertiaStateEnteredArgs",
        sizeof(py::wrapper::Microsoft::UI::Composition::Interactions::InteractionTrackerInertiaStateEnteredArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_InteractionTrackerInertiaStateEnteredArgs};

    // ----- InteractionTrackerInteractingStateEnteredArgs class --------------------

    static PyObject* _new_InteractionTrackerInteractingStateEnteredArgs(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Microsoft::UI::Composition::Interactions::InteractionTrackerInteractingStateEnteredArgs>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Microsoft::UI::Composition::Interactions::InteractionTrackerInteractingStateEnteredArgs>::type_name);
        return nullptr;
    }

    static void _dealloc_InteractionTrackerInteractingStateEnteredArgs(py::wrapper::Microsoft::UI::Composition::Interactions::InteractionTrackerInteractingStateEnteredArgs* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* InteractionTrackerInteractingStateEnteredArgs_get_RequestId(py::wrapper::Microsoft::UI::Composition::Interactions::InteractionTrackerInteractingStateEnteredArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Composition.Interactions.InteractionTrackerInteractingStateEnteredArgs", L"RequestId");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.RequestId();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* InteractionTrackerInteractingStateEnteredArgs_get_IsFromBinding(py::wrapper::Microsoft::UI::Composition::Interactions::InteractionTrackerInteractingStateEnteredArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Composition.Interactions.InteractionTrackerInteractingStateEnteredArgs", L"IsFromBinding");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.IsFromBinding();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_InteractionTrackerInteractingStateEnteredArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Microsoft::UI::Composition::Interactions::InteractionTrackerInteractingStateEnteredArgs>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_InteractionTrackerInteractingStateEnteredArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Microsoft::UI::Composition::Interactions::InteractionTrackerInteractingStateEnteredArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_InteractionTrackerInteractingStateEnteredArgs[] = {
        { "_assign_array_", _assign_array_InteractionTrackerInteractingStateEnteredArgs, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_InteractionTrackerInteractingStateEnteredArgs), METH_O | METH_STATIC, nullptr },
        { }};

    static PyGetSetDef _getset_InteractionTrackerInteractingStateEnteredArgs[] = {
        { "request_id", reinterpret_cast<getter>(InteractionTrackerInteractingStateEnteredArgs_get_RequestId), nullptr, nullptr, nullptr },
        { "is_from_binding", reinterpret_cast<getter>(InteractionTrackerInteractingStateEnteredArgs_get_IsFromBinding), nullptr, nullptr, nullptr },
        { }};

    static PyType_Slot _type_slots_InteractionTrackerInteractingStateEnteredArgs[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_InteractionTrackerInteractingStateEnteredArgs) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_InteractionTrackerInteractingStateEnteredArgs) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_InteractionTrackerInteractingStateEnteredArgs) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_InteractionTrackerInteractingStateEnteredArgs) },
        { }};

    static PyType_Spec type_spec_InteractionTrackerInteractingStateEnteredArgs = {
        "winui3._winui3_microsoft_ui_composition_interactions.InteractionTrackerInteractingStateEnteredArgs",
        sizeof(py::wrapper::Microsoft::UI::Composition::Interactions::InteractionTrackerInteractingStateEnteredArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_InteractionTrackerInteractingStateEnteredArgs};

    // ----- InteractionTrackerRequestIgnoredArgs class --------------------

    static PyObject* _new_InteractionTrackerRequestIgnoredArgs(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Microsoft::UI::Composition::Interactions::InteractionTrackerRequestIgnoredArgs>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Microsoft::UI::Composition::Interactions::InteractionTrackerRequestIgnoredArgs>::type_name);
        return nullptr;
    }

    static void _dealloc_InteractionTrackerRequestIgnoredArgs(py::wrapper::Microsoft::UI::Composition::Interactions::InteractionTrackerRequestIgnoredArgs* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* InteractionTrackerRequestIgnoredArgs_get_RequestId(py::wrapper::Microsoft::UI::Composition::Interactions::InteractionTrackerRequestIgnoredArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Composition.Interactions.InteractionTrackerRequestIgnoredArgs", L"RequestId");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.RequestId();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_InteractionTrackerRequestIgnoredArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Microsoft::UI::Composition::Interactions::InteractionTrackerRequestIgnoredArgs>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_InteractionTrackerRequestIgnoredArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Microsoft::UI::Composition::Interactions::InteractionTrackerRequestIgnoredArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_InteractionTrackerRequestIgnoredArgs[] = {
        { "_assign_array_", _assign_array_InteractionTrackerRequestIgnoredArgs, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_InteractionTrackerRequestIgnoredArgs), METH_O | METH_STATIC, nullptr },
        { }};

    static PyGetSetDef _getset_InteractionTrackerRequestIgnoredArgs[] = {
        { "request_id", reinterpret_cast<getter>(InteractionTrackerRequestIgnoredArgs_get_RequestId), nullptr, nullptr, nullptr },
        { }};

    static PyType_Slot _type_slots_InteractionTrackerRequestIgnoredArgs[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_InteractionTrackerRequestIgnoredArgs) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_InteractionTrackerRequestIgnoredArgs) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_InteractionTrackerRequestIgnoredArgs) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_InteractionTrackerRequestIgnoredArgs) },
        { }};

    static PyType_Spec type_spec_InteractionTrackerRequestIgnoredArgs = {
        "winui3._winui3_microsoft_ui_composition_interactions.InteractionTrackerRequestIgnoredArgs",
        sizeof(py::wrapper::Microsoft::UI::Composition::Interactions::InteractionTrackerRequestIgnoredArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_InteractionTrackerRequestIgnoredArgs};

    // ----- InteractionTrackerValuesChangedArgs class --------------------

    static PyObject* _new_InteractionTrackerValuesChangedArgs(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Microsoft::UI::Composition::Interactions::InteractionTrackerValuesChangedArgs>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Microsoft::UI::Composition::Interactions::InteractionTrackerValuesChangedArgs>::type_name);
        return nullptr;
    }

    static void _dealloc_InteractionTrackerValuesChangedArgs(py::wrapper::Microsoft::UI::Composition::Interactions::InteractionTrackerValuesChangedArgs* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* InteractionTrackerValuesChangedArgs_get_Position(py::wrapper::Microsoft::UI::Composition::Interactions::InteractionTrackerValuesChangedArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Composition.Interactions.InteractionTrackerValuesChangedArgs", L"Position");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Position();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* InteractionTrackerValuesChangedArgs_get_RequestId(py::wrapper::Microsoft::UI::Composition::Interactions::InteractionTrackerValuesChangedArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Composition.Interactions.InteractionTrackerValuesChangedArgs", L"RequestId");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.RequestId();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* InteractionTrackerValuesChangedArgs_get_Scale(py::wrapper::Microsoft::UI::Composition::Interactions::InteractionTrackerValuesChangedArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Composition.Interactions.InteractionTrackerValuesChangedArgs", L"Scale");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Scale();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_InteractionTrackerValuesChangedArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Microsoft::UI::Composition::Interactions::InteractionTrackerValuesChangedArgs>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_InteractionTrackerValuesChangedArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Microsoft::UI::Composition::Interactions::InteractionTrackerValuesChangedArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_InteractionTrackerValuesChangedArgs[] = {
        { "_assign_array_", _assign_array_InteractionTrackerValuesChangedArgs, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_InteractionTrackerValuesChangedArgs), METH_O | METH_STATIC, nullptr },
        { }};

    static PyGetSetDef _getset_InteractionTrackerValuesChangedArgs[] = {
        { "position", reinterpret_cast<getter>(InteractionTrackerValuesChangedArgs_get_Position), nullptr, nullptr, nullptr },
        { "request_id", reinterpret_cast<getter>(InteractionTrackerValuesChangedArgs_get_RequestId), nullptr, nullptr, nullptr },
        { "scale", reinterpret_cast<getter>(InteractionTrackerValuesChangedArgs_get_Scale), nullptr, nullptr, nullptr },
        { }};

    static PyType_Slot _type_slots_InteractionTrackerValuesChangedArgs[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_InteractionTrackerValuesChangedArgs) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_InteractionTrackerValuesChangedArgs) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_InteractionTrackerValuesChangedArgs) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_InteractionTrackerValuesChangedArgs) },
        { }};

    static PyType_Spec type_spec_InteractionTrackerValuesChangedArgs = {
        "winui3._winui3_microsoft_ui_composition_interactions.InteractionTrackerValuesChangedArgs",
        sizeof(py::wrapper::Microsoft::UI::Composition::Interactions::InteractionTrackerValuesChangedArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_InteractionTrackerValuesChangedArgs};

    // ----- InteractionTrackerVector2InertiaModifier class --------------------

    static PyObject* _new_InteractionTrackerVector2InertiaModifier(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Microsoft::UI::Composition::Interactions::InteractionTrackerVector2InertiaModifier>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Microsoft::UI::Composition::Interactions::InteractionTrackerVector2InertiaModifier>::type_name);
        return nullptr;
    }

    static void _dealloc_InteractionTrackerVector2InertiaModifier(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* _assign_array_InteractionTrackerVector2InertiaModifier(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Microsoft::UI::Composition::Interactions::InteractionTrackerVector2InertiaModifier>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_InteractionTrackerVector2InertiaModifier(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Microsoft::UI::Composition::Interactions::InteractionTrackerVector2InertiaModifier>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_InteractionTrackerVector2InertiaModifier[] = {
        { "_assign_array_", _assign_array_InteractionTrackerVector2InertiaModifier, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_InteractionTrackerVector2InertiaModifier), METH_O | METH_STATIC, nullptr },
        { }};

    static PyGetSetDef _getset_InteractionTrackerVector2InertiaModifier[] = {
        { }};

    static PyType_Slot _type_slots_InteractionTrackerVector2InertiaModifier[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_InteractionTrackerVector2InertiaModifier) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_InteractionTrackerVector2InertiaModifier) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_InteractionTrackerVector2InertiaModifier) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_InteractionTrackerVector2InertiaModifier) },
        { }};

    static PyType_Spec type_spec_InteractionTrackerVector2InertiaModifier = {
        "winui3._winui3_microsoft_ui_composition_interactions.InteractionTrackerVector2InertiaModifier",
        sizeof(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>),
        0,
        Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,
        _type_slots_InteractionTrackerVector2InertiaModifier};

    static PyGetSetDef getset_InteractionTrackerVector2InertiaModifier_Static[] = {
        { }};

    static PyMethodDef methods_InteractionTrackerVector2InertiaModifier_Static[] = {
        { }};

    static PyType_Slot type_slots_InteractionTrackerVector2InertiaModifier_Static[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_InteractionTrackerVector2InertiaModifier_Static) },
        { Py_tp_methods, reinterpret_cast<void*>(methods_InteractionTrackerVector2InertiaModifier_Static) },
        { }
    };

    static PyType_Spec type_spec_InteractionTrackerVector2InertiaModifier_Static = {
        "winui3._winui3_microsoft_ui_composition_interactions.InteractionTrackerVector2InertiaModifier_Static",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,
        type_slots_InteractionTrackerVector2InertiaModifier_Static};

    // ----- InteractionTrackerVector2InertiaNaturalMotion class --------------------

    static PyObject* _new_InteractionTrackerVector2InertiaNaturalMotion(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Microsoft::UI::Composition::Interactions::InteractionTrackerVector2InertiaNaturalMotion>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Microsoft::UI::Composition::Interactions::InteractionTrackerVector2InertiaNaturalMotion>::type_name);
        return nullptr;
    }

    static void _dealloc_InteractionTrackerVector2InertiaNaturalMotion(py::wrapper::Microsoft::UI::Composition::Interactions::InteractionTrackerVector2InertiaNaturalMotion* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* InteractionTrackerVector2InertiaNaturalMotion_Create(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Composition.Interactions.InteractionTrackerVector2InertiaNaturalMotion", L"Create", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Microsoft::UI::Composition::Compositor>(args, 0);

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return winrt::Microsoft::UI::Composition::Interactions::InteractionTrackerVector2InertiaNaturalMotion::Create(param0);
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* InteractionTrackerVector2InertiaNaturalMotion_get_NaturalMotion(py::wrapper::Microsoft::UI::Composition::Interactions::InteractionTrackerVector2InertiaNaturalMotion* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Composition.Interactions.InteractionTrackerVector2InertiaNaturalMotion", L"NaturalMotion");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.NaturalMotion();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int InteractionTrackerVector2InertiaNaturalMotion_put_NaturalMotion(py::wrapper::Microsoft::UI::Composition::Interactions::InteractionTrackerVector2InertiaNaturalMotion* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Composition.Interactions.InteractionTrackerVector2InertiaNaturalMotion", L"NaturalMotion");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Microsoft::UI::Composition::Vector2NaturalMotionAnimation>(arg);

            {
                auto _gil = release_gil();
                self->obj.NaturalMotion(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* InteractionTrackerVector2InertiaNaturalMotion_get_Condition(py::wrapper::Microsoft::UI::Composition::Interactions::InteractionTrackerVector2InertiaNaturalMotion* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Composition.Interactions.InteractionTrackerVector2InertiaNaturalMotion", L"Condition");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Condition();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int InteractionTrackerVector2InertiaNaturalMotion_put_Condition(py::wrapper::Microsoft::UI::Composition::Interactions::InteractionTrackerVector2InertiaNaturalMotion* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Composition.Interactions.InteractionTrackerVector2InertiaNaturalMotion", L"Condition");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Microsoft::UI::Composition::ExpressionAnimation>(arg);

            {
                auto _gil = release_gil();
                self->obj.Condition(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* _assign_array_InteractionTrackerVector2InertiaNaturalMotion(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Microsoft::UI::Composition::Interactions::InteractionTrackerVector2InertiaNaturalMotion>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_InteractionTrackerVector2InertiaNaturalMotion(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Microsoft::UI::Composition::Interactions::InteractionTrackerVector2InertiaNaturalMotion>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_InteractionTrackerVector2InertiaNaturalMotion[] = {
        { "_assign_array_", _assign_array_InteractionTrackerVector2InertiaNaturalMotion, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_InteractionTrackerVector2InertiaNaturalMotion), METH_O | METH_STATIC, nullptr },
        { }};

    static PyGetSetDef _getset_InteractionTrackerVector2InertiaNaturalMotion[] = {
        { "natural_motion", reinterpret_cast<getter>(InteractionTrackerVector2InertiaNaturalMotion_get_NaturalMotion), reinterpret_cast<setter>(InteractionTrackerVector2InertiaNaturalMotion_put_NaturalMotion), nullptr, nullptr },
        { "condition", reinterpret_cast<getter>(InteractionTrackerVector2InertiaNaturalMotion_get_Condition), reinterpret_cast<setter>(InteractionTrackerVector2InertiaNaturalMotion_put_Condition), nullptr, nullptr },
        { }};

    static PyType_Slot _type_slots_InteractionTrackerVector2InertiaNaturalMotion[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_InteractionTrackerVector2InertiaNaturalMotion) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_InteractionTrackerVector2InertiaNaturalMotion) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_InteractionTrackerVector2InertiaNaturalMotion) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_InteractionTrackerVector2InertiaNaturalMotion) },
        { }};

    static PyType_Spec type_spec_InteractionTrackerVector2InertiaNaturalMotion = {
        "winui3._winui3_microsoft_ui_composition_interactions.InteractionTrackerVector2InertiaNaturalMotion",
        sizeof(py::wrapper::Microsoft::UI::Composition::Interactions::InteractionTrackerVector2InertiaNaturalMotion),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_InteractionTrackerVector2InertiaNaturalMotion};

    static PyGetSetDef getset_InteractionTrackerVector2InertiaNaturalMotion_Static[] = {
        { }};

    static PyMethodDef methods_InteractionTrackerVector2InertiaNaturalMotion_Static[] = {
        { "create", reinterpret_cast<PyCFunction>(InteractionTrackerVector2InertiaNaturalMotion_Create), METH_VARARGS, nullptr },
        { }};

    static PyType_Slot type_slots_InteractionTrackerVector2InertiaNaturalMotion_Static[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_InteractionTrackerVector2InertiaNaturalMotion_Static) },
        { Py_tp_methods, reinterpret_cast<void*>(methods_InteractionTrackerVector2InertiaNaturalMotion_Static) },
        { }
    };

    static PyType_Spec type_spec_InteractionTrackerVector2InertiaNaturalMotion_Static = {
        "winui3._winui3_microsoft_ui_composition_interactions.InteractionTrackerVector2InertiaNaturalMotion_Static",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT,
        type_slots_InteractionTrackerVector2InertiaNaturalMotion_Static};

    // ----- VisualInteractionSource class --------------------

    static PyObject* _new_VisualInteractionSource(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Microsoft::UI::Composition::Interactions::VisualInteractionSource>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Microsoft::UI::Composition::Interactions::VisualInteractionSource>::type_name);
        return nullptr;
    }

    static void _dealloc_VisualInteractionSource(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* VisualInteractionSource_ConfigureCenterPointXModifiers(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Composition.Interactions.VisualInteractionSource", L"ConfigureCenterPointXModifiers", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Foundation::Collections::IIterable<winrt::Microsoft::UI::Composition::Interactions::CompositionConditionalValue>>(args, 0);

                {
                    auto _gil = release_gil();
                    self->obj.try_as<winrt::Microsoft::UI::Composition::Interactions::VisualInteractionSource>().ConfigureCenterPointXModifiers(param0);
                }

                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* VisualInteractionSource_ConfigureCenterPointYModifiers(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Composition.Interactions.VisualInteractionSource", L"ConfigureCenterPointYModifiers", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Foundation::Collections::IIterable<winrt::Microsoft::UI::Composition::Interactions::CompositionConditionalValue>>(args, 0);

                {
                    auto _gil = release_gil();
                    self->obj.try_as<winrt::Microsoft::UI::Composition::Interactions::VisualInteractionSource>().ConfigureCenterPointYModifiers(param0);
                }

                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* VisualInteractionSource_ConfigureDeltaPositionXModifiers(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Composition.Interactions.VisualInteractionSource", L"ConfigureDeltaPositionXModifiers", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Foundation::Collections::IIterable<winrt::Microsoft::UI::Composition::Interactions::CompositionConditionalValue>>(args, 0);

                {
                    auto _gil = release_gil();
                    self->obj.try_as<winrt::Microsoft::UI::Composition::Interactions::VisualInteractionSource>().ConfigureDeltaPositionXModifiers(param0);
                }

                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* VisualInteractionSource_ConfigureDeltaPositionYModifiers(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Composition.Interactions.VisualInteractionSource", L"ConfigureDeltaPositionYModifiers", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Foundation::Collections::IIterable<winrt::Microsoft::UI::Composition::Interactions::CompositionConditionalValue>>(args, 0);

                {
                    auto _gil = release_gil();
                    self->obj.try_as<winrt::Microsoft::UI::Composition::Interactions::VisualInteractionSource>().ConfigureDeltaPositionYModifiers(param0);
                }

                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* VisualInteractionSource_ConfigureDeltaScaleModifiers(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Composition.Interactions.VisualInteractionSource", L"ConfigureDeltaScaleModifiers", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Foundation::Collections::IIterable<winrt::Microsoft::UI::Composition::Interactions::CompositionConditionalValue>>(args, 0);

                {
                    auto _gil = release_gil();
                    self->obj.try_as<winrt::Microsoft::UI::Composition::Interactions::VisualInteractionSource>().ConfigureDeltaScaleModifiers(param0);
                }

                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* VisualInteractionSource_Create(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Composition.Interactions.VisualInteractionSource", L"Create", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Microsoft::UI::Composition::Visual>(args, 0);

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return winrt::Microsoft::UI::Composition::Interactions::VisualInteractionSource::Create(param0);
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* VisualInteractionSource_CreateFromIVisualElement(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Composition.Interactions.VisualInteractionSource", L"CreateFromIVisualElement", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Microsoft::UI::Composition::IVisualElement>(args, 0);

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return winrt::Microsoft::UI::Composition::Interactions::VisualInteractionSource::CreateFromIVisualElement(param0);
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* VisualInteractionSource_TryRedirectForManipulation(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Composition.Interactions.VisualInteractionSource", L"TryRedirectForManipulation", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Microsoft::UI::Input::PointerPoint>(args, 0);

                {
                    auto _gil = release_gil();
                    self->obj.try_as<winrt::Microsoft::UI::Composition::Interactions::VisualInteractionSource>().TryRedirectForManipulation(param0);
                }

                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* VisualInteractionSource_get_ScaleSourceMode(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Composition.Interactions.VisualInteractionSource", L"ScaleSourceMode");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.try_as<winrt::Microsoft::UI::Composition::Interactions::VisualInteractionSource>().ScaleSourceMode();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int VisualInteractionSource_put_ScaleSourceMode(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Composition.Interactions.VisualInteractionSource", L"ScaleSourceMode");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Microsoft::UI::Composition::Interactions::InteractionSourceMode>(arg);

            {
                auto _gil = release_gil();
                self->obj.try_as<winrt::Microsoft::UI::Composition::Interactions::VisualInteractionSource>().ScaleSourceMode(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* VisualInteractionSource_get_ScaleChainingMode(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Composition.Interactions.VisualInteractionSource", L"ScaleChainingMode");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.try_as<winrt::Microsoft::UI::Composition::Interactions::VisualInteractionSource>().ScaleChainingMode();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int VisualInteractionSource_put_ScaleChainingMode(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Composition.Interactions.VisualInteractionSource", L"ScaleChainingMode");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Microsoft::UI::Composition::Interactions::InteractionChainingMode>(arg);

            {
                auto _gil = release_gil();
                self->obj.try_as<winrt::Microsoft::UI::Composition::Interactions::VisualInteractionSource>().ScaleChainingMode(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* VisualInteractionSource_get_PositionYSourceMode(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Composition.Interactions.VisualInteractionSource", L"PositionYSourceMode");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.try_as<winrt::Microsoft::UI::Composition::Interactions::VisualInteractionSource>().PositionYSourceMode();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int VisualInteractionSource_put_PositionYSourceMode(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Composition.Interactions.VisualInteractionSource", L"PositionYSourceMode");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Microsoft::UI::Composition::Interactions::InteractionSourceMode>(arg);

            {
                auto _gil = release_gil();
                self->obj.try_as<winrt::Microsoft::UI::Composition::Interactions::VisualInteractionSource>().PositionYSourceMode(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* VisualInteractionSource_get_PositionYChainingMode(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Composition.Interactions.VisualInteractionSource", L"PositionYChainingMode");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.try_as<winrt::Microsoft::UI::Composition::Interactions::VisualInteractionSource>().PositionYChainingMode();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int VisualInteractionSource_put_PositionYChainingMode(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Composition.Interactions.VisualInteractionSource", L"PositionYChainingMode");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Microsoft::UI::Composition::Interactions::InteractionChainingMode>(arg);

            {
                auto _gil = release_gil();
                self->obj.try_as<winrt::Microsoft::UI::Composition::Interactions::VisualInteractionSource>().PositionYChainingMode(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* VisualInteractionSource_get_PositionXSourceMode(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Composition.Interactions.VisualInteractionSource", L"PositionXSourceMode");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.try_as<winrt::Microsoft::UI::Composition::Interactions::VisualInteractionSource>().PositionXSourceMode();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int VisualInteractionSource_put_PositionXSourceMode(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Composition.Interactions.VisualInteractionSource", L"PositionXSourceMode");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Microsoft::UI::Composition::Interactions::InteractionSourceMode>(arg);

            {
                auto _gil = release_gil();
                self->obj.try_as<winrt::Microsoft::UI::Composition::Interactions::VisualInteractionSource>().PositionXSourceMode(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* VisualInteractionSource_get_PositionXChainingMode(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Composition.Interactions.VisualInteractionSource", L"PositionXChainingMode");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.try_as<winrt::Microsoft::UI::Composition::Interactions::VisualInteractionSource>().PositionXChainingMode();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int VisualInteractionSource_put_PositionXChainingMode(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Composition.Interactions.VisualInteractionSource", L"PositionXChainingMode");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Microsoft::UI::Composition::Interactions::InteractionChainingMode>(arg);

            {
                auto _gil = release_gil();
                self->obj.try_as<winrt::Microsoft::UI::Composition::Interactions::VisualInteractionSource>().PositionXChainingMode(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* VisualInteractionSource_get_ManipulationRedirectionMode(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Composition.Interactions.VisualInteractionSource", L"ManipulationRedirectionMode");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.try_as<winrt::Microsoft::UI::Composition::Interactions::VisualInteractionSource>().ManipulationRedirectionMode();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int VisualInteractionSource_put_ManipulationRedirectionMode(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Composition.Interactions.VisualInteractionSource", L"ManipulationRedirectionMode");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Microsoft::UI::Composition::Interactions::VisualInteractionSourceRedirectionMode>(arg);

            {
                auto _gil = release_gil();
                self->obj.try_as<winrt::Microsoft::UI::Composition::Interactions::VisualInteractionSource>().ManipulationRedirectionMode(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* VisualInteractionSource_get_IsPositionYRailsEnabled(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Composition.Interactions.VisualInteractionSource", L"IsPositionYRailsEnabled");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.try_as<winrt::Microsoft::UI::Composition::Interactions::VisualInteractionSource>().IsPositionYRailsEnabled();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int VisualInteractionSource_put_IsPositionYRailsEnabled(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Composition.Interactions.VisualInteractionSource", L"IsPositionYRailsEnabled");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<bool>(arg);

            {
                auto _gil = release_gil();
                self->obj.try_as<winrt::Microsoft::UI::Composition::Interactions::VisualInteractionSource>().IsPositionYRailsEnabled(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* VisualInteractionSource_get_IsPositionXRailsEnabled(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Composition.Interactions.VisualInteractionSource", L"IsPositionXRailsEnabled");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.try_as<winrt::Microsoft::UI::Composition::Interactions::VisualInteractionSource>().IsPositionXRailsEnabled();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int VisualInteractionSource_put_IsPositionXRailsEnabled(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Composition.Interactions.VisualInteractionSource", L"IsPositionXRailsEnabled");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<bool>(arg);

            {
                auto _gil = release_gil();
                self->obj.try_as<winrt::Microsoft::UI::Composition::Interactions::VisualInteractionSource>().IsPositionXRailsEnabled(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* VisualInteractionSource_get_Source(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Composition.Interactions.VisualInteractionSource", L"Source");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.try_as<winrt::Microsoft::UI::Composition::Interactions::VisualInteractionSource>().Source();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* VisualInteractionSource_get_DeltaPosition(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Composition.Interactions.VisualInteractionSource", L"DeltaPosition");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.try_as<winrt::Microsoft::UI::Composition::Interactions::VisualInteractionSource>().DeltaPosition();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* VisualInteractionSource_get_DeltaScale(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Composition.Interactions.VisualInteractionSource", L"DeltaScale");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.try_as<winrt::Microsoft::UI::Composition::Interactions::VisualInteractionSource>().DeltaScale();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* VisualInteractionSource_get_Position(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Composition.Interactions.VisualInteractionSource", L"Position");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.try_as<winrt::Microsoft::UI::Composition::Interactions::VisualInteractionSource>().Position();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* VisualInteractionSource_get_PositionVelocity(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Composition.Interactions.VisualInteractionSource", L"PositionVelocity");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.try_as<winrt::Microsoft::UI::Composition::Interactions::VisualInteractionSource>().PositionVelocity();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* VisualInteractionSource_get_Scale(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Composition.Interactions.VisualInteractionSource", L"Scale");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.try_as<winrt::Microsoft::UI::Composition::Interactions::VisualInteractionSource>().Scale();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* VisualInteractionSource_get_ScaleVelocity(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Composition.Interactions.VisualInteractionSource", L"ScaleVelocity");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.try_as<winrt::Microsoft::UI::Composition::Interactions::VisualInteractionSource>().ScaleVelocity();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* VisualInteractionSource_get_PointerWheelConfig(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Composition.Interactions.VisualInteractionSource", L"PointerWheelConfig");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.try_as<winrt::Microsoft::UI::Composition::Interactions::VisualInteractionSource>().PointerWheelConfig();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_VisualInteractionSource(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Microsoft::UI::Composition::Interactions::VisualInteractionSource>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_VisualInteractionSource(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Microsoft::UI::Composition::Interactions::VisualInteractionSource>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_VisualInteractionSource[] = {
        { "configure_center_point_x_modifiers", reinterpret_cast<PyCFunction>(VisualInteractionSource_ConfigureCenterPointXModifiers), METH_VARARGS, nullptr },
        { "configure_center_point_y_modifiers", reinterpret_cast<PyCFunction>(VisualInteractionSource_ConfigureCenterPointYModifiers), METH_VARARGS, nullptr },
        { "configure_delta_position_x_modifiers", reinterpret_cast<PyCFunction>(VisualInteractionSource_ConfigureDeltaPositionXModifiers), METH_VARARGS, nullptr },
        { "configure_delta_position_y_modifiers", reinterpret_cast<PyCFunction>(VisualInteractionSource_ConfigureDeltaPositionYModifiers), METH_VARARGS, nullptr },
        { "configure_delta_scale_modifiers", reinterpret_cast<PyCFunction>(VisualInteractionSource_ConfigureDeltaScaleModifiers), METH_VARARGS, nullptr },
        { "try_redirect_for_manipulation", reinterpret_cast<PyCFunction>(VisualInteractionSource_TryRedirectForManipulation), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_VisualInteractionSource, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_VisualInteractionSource), METH_O | METH_STATIC, nullptr },
        { }};

    static PyGetSetDef _getset_VisualInteractionSource[] = {
        { "scale_source_mode", reinterpret_cast<getter>(VisualInteractionSource_get_ScaleSourceMode), reinterpret_cast<setter>(VisualInteractionSource_put_ScaleSourceMode), nullptr, nullptr },
        { "scale_chaining_mode", reinterpret_cast<getter>(VisualInteractionSource_get_ScaleChainingMode), reinterpret_cast<setter>(VisualInteractionSource_put_ScaleChainingMode), nullptr, nullptr },
        { "position_y_source_mode", reinterpret_cast<getter>(VisualInteractionSource_get_PositionYSourceMode), reinterpret_cast<setter>(VisualInteractionSource_put_PositionYSourceMode), nullptr, nullptr },
        { "position_y_chaining_mode", reinterpret_cast<getter>(VisualInteractionSource_get_PositionYChainingMode), reinterpret_cast<setter>(VisualInteractionSource_put_PositionYChainingMode), nullptr, nullptr },
        { "position_x_source_mode", reinterpret_cast<getter>(VisualInteractionSource_get_PositionXSourceMode), reinterpret_cast<setter>(VisualInteractionSource_put_PositionXSourceMode), nullptr, nullptr },
        { "position_x_chaining_mode", reinterpret_cast<getter>(VisualInteractionSource_get_PositionXChainingMode), reinterpret_cast<setter>(VisualInteractionSource_put_PositionXChainingMode), nullptr, nullptr },
        { "manipulation_redirection_mode", reinterpret_cast<getter>(VisualInteractionSource_get_ManipulationRedirectionMode), reinterpret_cast<setter>(VisualInteractionSource_put_ManipulationRedirectionMode), nullptr, nullptr },
        { "is_position_y_rails_enabled", reinterpret_cast<getter>(VisualInteractionSource_get_IsPositionYRailsEnabled), reinterpret_cast<setter>(VisualInteractionSource_put_IsPositionYRailsEnabled), nullptr, nullptr },
        { "is_position_x_rails_enabled", reinterpret_cast<getter>(VisualInteractionSource_get_IsPositionXRailsEnabled), reinterpret_cast<setter>(VisualInteractionSource_put_IsPositionXRailsEnabled), nullptr, nullptr },
        { "source", reinterpret_cast<getter>(VisualInteractionSource_get_Source), nullptr, nullptr, nullptr },
        { "delta_position", reinterpret_cast<getter>(VisualInteractionSource_get_DeltaPosition), nullptr, nullptr, nullptr },
        { "delta_scale", reinterpret_cast<getter>(VisualInteractionSource_get_DeltaScale), nullptr, nullptr, nullptr },
        { "position", reinterpret_cast<getter>(VisualInteractionSource_get_Position), nullptr, nullptr, nullptr },
        { "position_velocity", reinterpret_cast<getter>(VisualInteractionSource_get_PositionVelocity), nullptr, nullptr, nullptr },
        { "scale", reinterpret_cast<getter>(VisualInteractionSource_get_Scale), nullptr, nullptr, nullptr },
        { "scale_velocity", reinterpret_cast<getter>(VisualInteractionSource_get_ScaleVelocity), nullptr, nullptr, nullptr },
        { "pointer_wheel_config", reinterpret_cast<getter>(VisualInteractionSource_get_PointerWheelConfig), nullptr, nullptr, nullptr },
        { }};

    static PyType_Slot _type_slots_VisualInteractionSource[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_VisualInteractionSource) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_VisualInteractionSource) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_VisualInteractionSource) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_VisualInteractionSource) },
        { }};

    static PyType_Spec type_spec_VisualInteractionSource = {
        "winui3._winui3_microsoft_ui_composition_interactions.VisualInteractionSource",
        sizeof(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>),
        0,
        Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,
        _type_slots_VisualInteractionSource};

    static PyGetSetDef getset_VisualInteractionSource_Static[] = {
        { }};

    static PyMethodDef methods_VisualInteractionSource_Static[] = {
        { "create", reinterpret_cast<PyCFunction>(VisualInteractionSource_Create), METH_VARARGS, nullptr },
        { "create_from_ivisual_element", reinterpret_cast<PyCFunction>(VisualInteractionSource_CreateFromIVisualElement), METH_VARARGS, nullptr },
        { }};

    static PyType_Slot type_slots_VisualInteractionSource_Static[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_VisualInteractionSource_Static) },
        { Py_tp_methods, reinterpret_cast<void*>(methods_VisualInteractionSource_Static) },
        { }
    };

    static PyType_Spec type_spec_VisualInteractionSource_Static = {
        "winui3._winui3_microsoft_ui_composition_interactions.VisualInteractionSource_Static",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,
        type_slots_VisualInteractionSource_Static};

    // ----- ICompositionInteractionSource interface --------------------

    #if PY_VERSION_HEX < 0x030A0000
    static PyObject* _new_ICompositionInteractionSource(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Microsoft::UI::Composition::Interactions::ICompositionInteractionSource>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Microsoft::UI::Composition::Interactions::ICompositionInteractionSource>::type_name);
        return nullptr;
    }
    #endif

    static void _dealloc_ICompositionInteractionSource(py::wrapper::Microsoft::UI::Composition::Interactions::ICompositionInteractionSource* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyMethodDef _methods_ICompositionInteractionSource[] = {
        { }};

    static PyGetSetDef _getset_ICompositionInteractionSource[] = {
        { }};

    static PyType_Slot _type_slots_ICompositionInteractionSource[] = {
        #if PY_VERSION_HEX < 0x030A0000
        { Py_tp_new, reinterpret_cast<void*>(_new_ICompositionInteractionSource) },
        #endif
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_ICompositionInteractionSource) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_ICompositionInteractionSource) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_ICompositionInteractionSource) },
        { }};

    static PyType_Spec type_spec_ICompositionInteractionSource = {
        "winui3._winui3_microsoft_ui_composition_interactions._ICompositionInteractionSource",
        sizeof(py::wrapper::Microsoft::UI::Composition::Interactions::ICompositionInteractionSource),
        0,
        Py_TPFLAGS_DEFAULT
        #if PY_VERSION_HEX >= 0x030A0000
        | Py_TPFLAGS_DISALLOW_INSTANTIATION
        #endif
        ,
        _type_slots_ICompositionInteractionSource};

    struct ImplementsICompositionInteractionSource : py::ImplementsInterfaceT<ImplementsICompositionInteractionSource, winrt::Microsoft::UI::Composition::Interactions::ICompositionInteractionSource>
    {
        ImplementsICompositionInteractionSource() = delete;
        ImplementsICompositionInteractionSource(PyObject* py_obj, winrt::impl::inspectable_abi* runtime_class) : py::ImplementsInterfaceT<ImplementsICompositionInteractionSource, winrt::Microsoft::UI::Composition::Interactions::ICompositionInteractionSource>(py_obj, runtime_class)
        {
        }
    };

    static PyObject* _assign_array_ICompositionInteractionSource(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Microsoft::UI::Composition::Interactions::ICompositionInteractionSource>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_ICompositionInteractionSource(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Microsoft::UI::Composition::Interactions::ICompositionInteractionSource>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _guid_ImplementsICompositionInteractionSource(PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::guid_of<winrt::Microsoft::UI::Composition::Interactions::ICompositionInteractionSource>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _make_ImplementsICompositionInteractionSource(PyObject* /*unused*/, PyObject* args) noexcept
    {
        try
        {
            PyObject* py_obj;
            winrt::impl::inspectable_abi* runtime_class;

            if (!PyArg_ParseTuple(args, "On", &py_obj, &runtime_class))
            {
                return nullptr;
            }

            auto iface{std::make_unique<ImplementsICompositionInteractionSource>(py_obj, runtime_class)};

            return PyLong_FromVoidPtr(iface.release());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef methods_ImplementsICompositionInteractionSource[] = {
        { "_assign_array_", _assign_array_ICompositionInteractionSource, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_ICompositionInteractionSource), METH_O | METH_STATIC, nullptr },
        { "_guid_", reinterpret_cast<PyCFunction>(_guid_ImplementsICompositionInteractionSource), METH_NOARGS | METH_STATIC, nullptr },
        { "_make_", reinterpret_cast<PyCFunction>(_make_ImplementsICompositionInteractionSource), METH_VARARGS | METH_STATIC, nullptr },
        { }};

    static PyType_Slot type_slots_ImplementsICompositionInteractionSource[] = {
        { Py_tp_methods, reinterpret_cast<void*>(methods_ImplementsICompositionInteractionSource) },
        { }};

    static PyType_Spec type_spec_ImplementsICompositionInteractionSource = {
        "winui3._winui3_microsoft_ui_composition_interactions.ICompositionInteractionSource",
        0,
        0,
        Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE
        #if PY_VERSION_HEX >= 0x030A0000
        | Py_TPFLAGS_DISALLOW_INSTANTIATION
        #endif
        ,
        type_slots_ImplementsICompositionInteractionSource};

    // ----- IInteractionTrackerOwner interface --------------------

    #if PY_VERSION_HEX < 0x030A0000
    static PyObject* _new_IInteractionTrackerOwner(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Microsoft::UI::Composition::Interactions::IInteractionTrackerOwner>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Microsoft::UI::Composition::Interactions::IInteractionTrackerOwner>::type_name);
        return nullptr;
    }
    #endif

    static void _dealloc_IInteractionTrackerOwner(py::wrapper::Microsoft::UI::Composition::Interactions::IInteractionTrackerOwner* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* IInteractionTrackerOwner_CustomAnimationStateEntered(py::wrapper::Microsoft::UI::Composition::Interactions::IInteractionTrackerOwner* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 2)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Composition.Interactions.IInteractionTrackerOwner", L"CustomAnimationStateEntered", 2);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(2);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Microsoft::UI::Composition::Interactions::InteractionTracker>(args, 0);
                auto param1 = py::convert_to<winrt::Microsoft::UI::Composition::Interactions::InteractionTrackerCustomAnimationStateEnteredArgs>(args, 1);

                {
                    auto _gil = release_gil();
                    self->obj.CustomAnimationStateEntered(param0, param1);
                }

                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* IInteractionTrackerOwner_IdleStateEntered(py::wrapper::Microsoft::UI::Composition::Interactions::IInteractionTrackerOwner* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 2)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Composition.Interactions.IInteractionTrackerOwner", L"IdleStateEntered", 2);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(2);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Microsoft::UI::Composition::Interactions::InteractionTracker>(args, 0);
                auto param1 = py::convert_to<winrt::Microsoft::UI::Composition::Interactions::InteractionTrackerIdleStateEnteredArgs>(args, 1);

                {
                    auto _gil = release_gil();
                    self->obj.IdleStateEntered(param0, param1);
                }

                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* IInteractionTrackerOwner_InertiaStateEntered(py::wrapper::Microsoft::UI::Composition::Interactions::IInteractionTrackerOwner* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 2)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Composition.Interactions.IInteractionTrackerOwner", L"InertiaStateEntered", 2);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(2);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Microsoft::UI::Composition::Interactions::InteractionTracker>(args, 0);
                auto param1 = py::convert_to<winrt::Microsoft::UI::Composition::Interactions::InteractionTrackerInertiaStateEnteredArgs>(args, 1);

                {
                    auto _gil = release_gil();
                    self->obj.InertiaStateEntered(param0, param1);
                }

                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* IInteractionTrackerOwner_InteractingStateEntered(py::wrapper::Microsoft::UI::Composition::Interactions::IInteractionTrackerOwner* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 2)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Composition.Interactions.IInteractionTrackerOwner", L"InteractingStateEntered", 2);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(2);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Microsoft::UI::Composition::Interactions::InteractionTracker>(args, 0);
                auto param1 = py::convert_to<winrt::Microsoft::UI::Composition::Interactions::InteractionTrackerInteractingStateEnteredArgs>(args, 1);

                {
                    auto _gil = release_gil();
                    self->obj.InteractingStateEntered(param0, param1);
                }

                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* IInteractionTrackerOwner_RequestIgnored(py::wrapper::Microsoft::UI::Composition::Interactions::IInteractionTrackerOwner* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 2)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Composition.Interactions.IInteractionTrackerOwner", L"RequestIgnored", 2);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(2);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Microsoft::UI::Composition::Interactions::InteractionTracker>(args, 0);
                auto param1 = py::convert_to<winrt::Microsoft::UI::Composition::Interactions::InteractionTrackerRequestIgnoredArgs>(args, 1);

                {
                    auto _gil = release_gil();
                    self->obj.RequestIgnored(param0, param1);
                }

                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* IInteractionTrackerOwner_ValuesChanged(py::wrapper::Microsoft::UI::Composition::Interactions::IInteractionTrackerOwner* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 2)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Composition.Interactions.IInteractionTrackerOwner", L"ValuesChanged", 2);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(2);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Microsoft::UI::Composition::Interactions::InteractionTracker>(args, 0);
                auto param1 = py::convert_to<winrt::Microsoft::UI::Composition::Interactions::InteractionTrackerValuesChangedArgs>(args, 1);

                {
                    auto _gil = release_gil();
                    self->obj.ValuesChanged(param0, param1);
                }

                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyMethodDef _methods_IInteractionTrackerOwner[] = {
        { "custom_animation_state_entered", reinterpret_cast<PyCFunction>(IInteractionTrackerOwner_CustomAnimationStateEntered), METH_VARARGS, nullptr },
        { "idle_state_entered", reinterpret_cast<PyCFunction>(IInteractionTrackerOwner_IdleStateEntered), METH_VARARGS, nullptr },
        { "inertia_state_entered", reinterpret_cast<PyCFunction>(IInteractionTrackerOwner_InertiaStateEntered), METH_VARARGS, nullptr },
        { "interacting_state_entered", reinterpret_cast<PyCFunction>(IInteractionTrackerOwner_InteractingStateEntered), METH_VARARGS, nullptr },
        { "request_ignored", reinterpret_cast<PyCFunction>(IInteractionTrackerOwner_RequestIgnored), METH_VARARGS, nullptr },
        { "values_changed", reinterpret_cast<PyCFunction>(IInteractionTrackerOwner_ValuesChanged), METH_VARARGS, nullptr },
        { }};

    static PyGetSetDef _getset_IInteractionTrackerOwner[] = {
        { }};

    static PyType_Slot _type_slots_IInteractionTrackerOwner[] = {
        #if PY_VERSION_HEX < 0x030A0000
        { Py_tp_new, reinterpret_cast<void*>(_new_IInteractionTrackerOwner) },
        #endif
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_IInteractionTrackerOwner) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_IInteractionTrackerOwner) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_IInteractionTrackerOwner) },
        { }};

    static PyType_Spec type_spec_IInteractionTrackerOwner = {
        "winui3._winui3_microsoft_ui_composition_interactions._IInteractionTrackerOwner",
        sizeof(py::wrapper::Microsoft::UI::Composition::Interactions::IInteractionTrackerOwner),
        0,
        Py_TPFLAGS_DEFAULT
        #if PY_VERSION_HEX >= 0x030A0000
        | Py_TPFLAGS_DISALLOW_INSTANTIATION
        #endif
        ,
        _type_slots_IInteractionTrackerOwner};

    struct ImplementsIInteractionTrackerOwner : py::ImplementsInterfaceT<ImplementsIInteractionTrackerOwner, winrt::Microsoft::UI::Composition::Interactions::IInteractionTrackerOwner>
    {
        ImplementsIInteractionTrackerOwner() = delete;
        ImplementsIInteractionTrackerOwner(PyObject* py_obj, winrt::impl::inspectable_abi* runtime_class) : py::ImplementsInterfaceT<ImplementsIInteractionTrackerOwner, winrt::Microsoft::UI::Composition::Interactions::IInteractionTrackerOwner>(py_obj, runtime_class)
        {
        }

        auto CustomAnimationStateEntered(winrt::Microsoft::UI::Composition::Interactions::InteractionTracker const& param0, winrt::Microsoft::UI::Composition::Interactions::InteractionTrackerCustomAnimationStateEnteredArgs const& param1)
        {
            try
            {
                py::pyobj_handle self{this->get_py_obj()};

                py::pyobj_handle method{PyObject_GetAttrString(self.get(), "custom_animation_state_entered")};
                if (!method)
                {
                    throw python_exception();
                }

                py::pyobj_handle py_param0{py::convert(param0)};
                if (!py_param0)
                {
                    throw python_exception();
                }

                py::pyobj_handle py_param1{py::convert(param1)};
                if (!py_param1)
                {
                    throw python_exception();
                }

                py::pyobj_handle args{PyTuple_Pack(2, py_param0.get(), py_param1.get())};
                if (!args)
                {
                    throw python_exception();
                }

                py::pyobj_handle return_value{PyObject_CallObject(method.get(), args.get())};
                if (!return_value)
                {
                    throw python_exception();
                }
            }
            catch (python_exception)
            {
                py::write_unraisable_and_throw();
            }
        }

        auto IdleStateEntered(winrt::Microsoft::UI::Composition::Interactions::InteractionTracker const& param0, winrt::Microsoft::UI::Composition::Interactions::InteractionTrackerIdleStateEnteredArgs const& param1)
        {
            try
            {
                py::pyobj_handle self{this->get_py_obj()};

                py::pyobj_handle method{PyObject_GetAttrString(self.get(), "idle_state_entered")};
                if (!method)
                {
                    throw python_exception();
                }

                py::pyobj_handle py_param0{py::convert(param0)};
                if (!py_param0)
                {
                    throw python_exception();
                }

                py::pyobj_handle py_param1{py::convert(param1)};
                if (!py_param1)
                {
                    throw python_exception();
                }

                py::pyobj_handle args{PyTuple_Pack(2, py_param0.get(), py_param1.get())};
                if (!args)
                {
                    throw python_exception();
                }

                py::pyobj_handle return_value{PyObject_CallObject(method.get(), args.get())};
                if (!return_value)
                {
                    throw python_exception();
                }
            }
            catch (python_exception)
            {
                py::write_unraisable_and_throw();
            }
        }

        auto InertiaStateEntered(winrt::Microsoft::UI::Composition::Interactions::InteractionTracker const& param0, winrt::Microsoft::UI::Composition::Interactions::InteractionTrackerInertiaStateEnteredArgs const& param1)
        {
            try
            {
                py::pyobj_handle self{this->get_py_obj()};

                py::pyobj_handle method{PyObject_GetAttrString(self.get(), "inertia_state_entered")};
                if (!method)
                {
                    throw python_exception();
                }

                py::pyobj_handle py_param0{py::convert(param0)};
                if (!py_param0)
                {
                    throw python_exception();
                }

                py::pyobj_handle py_param1{py::convert(param1)};
                if (!py_param1)
                {
                    throw python_exception();
                }

                py::pyobj_handle args{PyTuple_Pack(2, py_param0.get(), py_param1.get())};
                if (!args)
                {
                    throw python_exception();
                }

                py::pyobj_handle return_value{PyObject_CallObject(method.get(), args.get())};
                if (!return_value)
                {
                    throw python_exception();
                }
            }
            catch (python_exception)
            {
                py::write_unraisable_and_throw();
            }
        }

        auto InteractingStateEntered(winrt::Microsoft::UI::Composition::Interactions::InteractionTracker const& param0, winrt::Microsoft::UI::Composition::Interactions::InteractionTrackerInteractingStateEnteredArgs const& param1)
        {
            try
            {
                py::pyobj_handle self{this->get_py_obj()};

                py::pyobj_handle method{PyObject_GetAttrString(self.get(), "interacting_state_entered")};
                if (!method)
                {
                    throw python_exception();
                }

                py::pyobj_handle py_param0{py::convert(param0)};
                if (!py_param0)
                {
                    throw python_exception();
                }

                py::pyobj_handle py_param1{py::convert(param1)};
                if (!py_param1)
                {
                    throw python_exception();
                }

                py::pyobj_handle args{PyTuple_Pack(2, py_param0.get(), py_param1.get())};
                if (!args)
                {
                    throw python_exception();
                }

                py::pyobj_handle return_value{PyObject_CallObject(method.get(), args.get())};
                if (!return_value)
                {
                    throw python_exception();
                }
            }
            catch (python_exception)
            {
                py::write_unraisable_and_throw();
            }
        }

        auto RequestIgnored(winrt::Microsoft::UI::Composition::Interactions::InteractionTracker const& param0, winrt::Microsoft::UI::Composition::Interactions::InteractionTrackerRequestIgnoredArgs const& param1)
        {
            try
            {
                py::pyobj_handle self{this->get_py_obj()};

                py::pyobj_handle method{PyObject_GetAttrString(self.get(), "request_ignored")};
                if (!method)
                {
                    throw python_exception();
                }

                py::pyobj_handle py_param0{py::convert(param0)};
                if (!py_param0)
                {
                    throw python_exception();
                }

                py::pyobj_handle py_param1{py::convert(param1)};
                if (!py_param1)
                {
                    throw python_exception();
                }

                py::pyobj_handle args{PyTuple_Pack(2, py_param0.get(), py_param1.get())};
                if (!args)
                {
                    throw python_exception();
                }

                py::pyobj_handle return_value{PyObject_CallObject(method.get(), args.get())};
                if (!return_value)
                {
                    throw python_exception();
                }
            }
            catch (python_exception)
            {
                py::write_unraisable_and_throw();
            }
        }

        auto ValuesChanged(winrt::Microsoft::UI::Composition::Interactions::InteractionTracker const& param0, winrt::Microsoft::UI::Composition::Interactions::InteractionTrackerValuesChangedArgs const& param1)
        {
            try
            {
                py::pyobj_handle self{this->get_py_obj()};

                py::pyobj_handle method{PyObject_GetAttrString(self.get(), "values_changed")};
                if (!method)
                {
                    throw python_exception();
                }

                py::pyobj_handle py_param0{py::convert(param0)};
                if (!py_param0)
                {
                    throw python_exception();
                }

                py::pyobj_handle py_param1{py::convert(param1)};
                if (!py_param1)
                {
                    throw python_exception();
                }

                py::pyobj_handle args{PyTuple_Pack(2, py_param0.get(), py_param1.get())};
                if (!args)
                {
                    throw python_exception();
                }

                py::pyobj_handle return_value{PyObject_CallObject(method.get(), args.get())};
                if (!return_value)
                {
                    throw python_exception();
                }
            }
            catch (python_exception)
            {
                py::write_unraisable_and_throw();
            }
        }
    };

    static PyObject* _assign_array_IInteractionTrackerOwner(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Microsoft::UI::Composition::Interactions::IInteractionTrackerOwner>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_IInteractionTrackerOwner(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Microsoft::UI::Composition::Interactions::IInteractionTrackerOwner>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _guid_ImplementsIInteractionTrackerOwner(PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::guid_of<winrt::Microsoft::UI::Composition::Interactions::IInteractionTrackerOwner>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _make_ImplementsIInteractionTrackerOwner(PyObject* /*unused*/, PyObject* args) noexcept
    {
        try
        {
            PyObject* py_obj;
            winrt::impl::inspectable_abi* runtime_class;

            if (!PyArg_ParseTuple(args, "On", &py_obj, &runtime_class))
            {
                return nullptr;
            }

            auto iface{std::make_unique<ImplementsIInteractionTrackerOwner>(py_obj, runtime_class)};

            return PyLong_FromVoidPtr(iface.release());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef methods_ImplementsIInteractionTrackerOwner[] = {
        { "_assign_array_", _assign_array_IInteractionTrackerOwner, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_IInteractionTrackerOwner), METH_O | METH_STATIC, nullptr },
        { "_guid_", reinterpret_cast<PyCFunction>(_guid_ImplementsIInteractionTrackerOwner), METH_NOARGS | METH_STATIC, nullptr },
        { "_make_", reinterpret_cast<PyCFunction>(_make_ImplementsIInteractionTrackerOwner), METH_VARARGS | METH_STATIC, nullptr },
        { }};

    static PyType_Slot type_slots_ImplementsIInteractionTrackerOwner[] = {
        { Py_tp_methods, reinterpret_cast<void*>(methods_ImplementsIInteractionTrackerOwner) },
        { }};

    static PyType_Spec type_spec_ImplementsIInteractionTrackerOwner = {
        "winui3._winui3_microsoft_ui_composition_interactions.IInteractionTrackerOwner",
        0,
        0,
        Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE
        #if PY_VERSION_HEX >= 0x030A0000
        | Py_TPFLAGS_DISALLOW_INSTANTIATION
        #endif
        ,
        type_slots_ImplementsIInteractionTrackerOwner};

    // ----- Microsoft.UI.Composition.Interactions Initialization --------------------

    PyDoc_STRVAR(module_doc, "Microsoft.UI.Composition.Interactions");

    static PyModuleDef module_def = {
        PyModuleDef_HEAD_INIT,
        "_winui3_microsoft_ui_composition_interactions",
        module_doc,
        0,
        nullptr,
        nullptr,
        nullptr,
        nullptr,
        nullptr};
} // py::cpp::Microsoft::UI::Composition::Interactions

PyMODINIT_FUNC PyInit__winui3_microsoft_ui_composition_interactions(void) noexcept
{
    using namespace py::cpp::Microsoft::UI::Composition::Interactions;

    if (py::import_winrt_runtime() == -1)
    {
        return nullptr;
    }

    py::pyobj_handle module{PyModule_Create(&module_def)};

    if (!module)
    {
        return nullptr;
    }

    auto inspectable_meta_type = py::get_inspectable_meta_type();
    if (!inspectable_meta_type)
    {
        return nullptr;
    }

    auto object_type = py::get_object_type();
    if (!object_type)
    {
        return nullptr;
    }

    py::pyobj_handle object_bases{PyTuple_Pack(1, object_type)};

    if (!object_bases)
    {
        return nullptr;
    }

    py::pyobj_handle microsoft_ui_composition_module{PyImport_ImportModule("winui3._winui3_microsoft_ui_composition")};
    if (!microsoft_ui_composition_module)
    {
        return nullptr;
    }

    py::pyobj_handle microsoft_ui_composition_CompositionObject_type{PyObject_GetAttrString(microsoft_ui_composition_module.get(), "CompositionObject")};
    if (!microsoft_ui_composition_CompositionObject_type)
    {
        return nullptr;
    }

    py::pyobj_handle CompositionConditionalValue_Static_bases{PyTuple_Pack(1, reinterpret_cast<PyObject*>(Py_TYPE(microsoft_ui_composition_CompositionObject_type.get())))};
    if (!CompositionConditionalValue_Static_bases)
    {
        return nullptr;
    }

    py::pyobj_handle type_CompositionConditionalValue_Static{PyType_FromSpecWithBases(&type_spec_CompositionConditionalValue_Static, CompositionConditionalValue_Static_bases.get())};
    if (!type_CompositionConditionalValue_Static)
    {
        return nullptr;
    }

    py::pyobj_handle CompositionConditionalValue_bases{PyTuple_Pack(1, microsoft_ui_composition_CompositionObject_type.get())};
    if (!CompositionConditionalValue_bases)
    {
        return nullptr;
    }

    py::pytype_handle CompositionConditionalValue_type{py::register_python_type(module.get(), &type_spec_CompositionConditionalValue, CompositionConditionalValue_bases.get(), reinterpret_cast<PyTypeObject*>(type_CompositionConditionalValue_Static.get()))};
    if (!CompositionConditionalValue_type)
    {
        return nullptr;
    }

    py::pyobj_handle CompositionInteractionSourceCollection_bases{PyTuple_Pack(1, microsoft_ui_composition_CompositionObject_type.get())};
    if (!CompositionInteractionSourceCollection_bases)
    {
        return nullptr;
    }

    py::pytype_handle CompositionInteractionSourceCollection_type{py::register_python_type(module.get(), &type_spec_CompositionInteractionSourceCollection, CompositionInteractionSourceCollection_bases.get(), inspectable_meta_type)};
    if (!CompositionInteractionSourceCollection_type)
    {
        return nullptr;
    }

    py::pyobj_handle InteractionSourceConfiguration_bases{PyTuple_Pack(1, microsoft_ui_composition_CompositionObject_type.get())};
    if (!InteractionSourceConfiguration_bases)
    {
        return nullptr;
    }

    py::pytype_handle InteractionSourceConfiguration_type{py::register_python_type(module.get(), &type_spec_InteractionSourceConfiguration, InteractionSourceConfiguration_bases.get(), inspectable_meta_type)};
    if (!InteractionSourceConfiguration_type)
    {
        return nullptr;
    }

    py::pyobj_handle InteractionTracker_Static_bases{PyTuple_Pack(1, reinterpret_cast<PyObject*>(Py_TYPE(microsoft_ui_composition_CompositionObject_type.get())))};
    if (!InteractionTracker_Static_bases)
    {
        return nullptr;
    }

    py::pyobj_handle type_InteractionTracker_Static{PyType_FromSpecWithBases(&type_spec_InteractionTracker_Static, InteractionTracker_Static_bases.get())};
    if (!type_InteractionTracker_Static)
    {
        return nullptr;
    }

    py::pyobj_handle InteractionTracker_bases{PyTuple_Pack(1, microsoft_ui_composition_CompositionObject_type.get())};
    if (!InteractionTracker_bases)
    {
        return nullptr;
    }

    py::pytype_handle InteractionTracker_type{py::register_python_type(module.get(), &type_spec_InteractionTracker, InteractionTracker_bases.get(), reinterpret_cast<PyTypeObject*>(type_InteractionTracker_Static.get()))};
    if (!InteractionTracker_type)
    {
        return nullptr;
    }

    py::pytype_handle InteractionTrackerCustomAnimationStateEnteredArgs_type{py::register_python_type(module.get(), &type_spec_InteractionTrackerCustomAnimationStateEnteredArgs, object_bases.get(), inspectable_meta_type)};
    if (!InteractionTrackerCustomAnimationStateEnteredArgs_type)
    {
        return nullptr;
    }

    py::pytype_handle InteractionTrackerIdleStateEnteredArgs_type{py::register_python_type(module.get(), &type_spec_InteractionTrackerIdleStateEnteredArgs, object_bases.get(), inspectable_meta_type)};
    if (!InteractionTrackerIdleStateEnteredArgs_type)
    {
        return nullptr;
    }

    py::pyobj_handle InteractionTrackerInertiaModifier_Static_bases{PyTuple_Pack(1, reinterpret_cast<PyObject*>(Py_TYPE(microsoft_ui_composition_CompositionObject_type.get())))};
    if (!InteractionTrackerInertiaModifier_Static_bases)
    {
        return nullptr;
    }

    py::pyobj_handle type_InteractionTrackerInertiaModifier_Static{PyType_FromSpecWithBases(&type_spec_InteractionTrackerInertiaModifier_Static, InteractionTrackerInertiaModifier_Static_bases.get())};
    if (!type_InteractionTrackerInertiaModifier_Static)
    {
        return nullptr;
    }

    py::pyobj_handle InteractionTrackerInertiaModifier_bases{PyTuple_Pack(1, microsoft_ui_composition_CompositionObject_type.get())};
    if (!InteractionTrackerInertiaModifier_bases)
    {
        return nullptr;
    }

    py::pytype_handle InteractionTrackerInertiaModifier_type{py::register_python_type(module.get(), &type_spec_InteractionTrackerInertiaModifier, InteractionTrackerInertiaModifier_bases.get(), reinterpret_cast<PyTypeObject*>(type_InteractionTrackerInertiaModifier_Static.get()))};
    if (!InteractionTrackerInertiaModifier_type)
    {
        return nullptr;
    }

    py::pyobj_handle InteractionTrackerInertiaMotion_Static_bases{PyTuple_Pack(1, reinterpret_cast<PyObject*>(Py_TYPE(InteractionTrackerInertiaModifier_type.get())))};
    if (!InteractionTrackerInertiaMotion_Static_bases)
    {
        return nullptr;
    }

    py::pyobj_handle type_InteractionTrackerInertiaMotion_Static{PyType_FromSpecWithBases(&type_spec_InteractionTrackerInertiaMotion_Static, InteractionTrackerInertiaMotion_Static_bases.get())};
    if (!type_InteractionTrackerInertiaMotion_Static)
    {
        return nullptr;
    }

    py::pyobj_handle InteractionTrackerInertiaMotion_bases{PyTuple_Pack(1, InteractionTrackerInertiaModifier_type.get())};
    if (!InteractionTrackerInertiaMotion_bases)
    {
        return nullptr;
    }

    py::pytype_handle InteractionTrackerInertiaMotion_type{py::register_python_type(module.get(), &type_spec_InteractionTrackerInertiaMotion, InteractionTrackerInertiaMotion_bases.get(), reinterpret_cast<PyTypeObject*>(type_InteractionTrackerInertiaMotion_Static.get()))};
    if (!InteractionTrackerInertiaMotion_type)
    {
        return nullptr;
    }

    py::pyobj_handle InteractionTrackerInertiaNaturalMotion_Static_bases{PyTuple_Pack(1, reinterpret_cast<PyObject*>(Py_TYPE(InteractionTrackerInertiaModifier_type.get())))};
    if (!InteractionTrackerInertiaNaturalMotion_Static_bases)
    {
        return nullptr;
    }

    py::pyobj_handle type_InteractionTrackerInertiaNaturalMotion_Static{PyType_FromSpecWithBases(&type_spec_InteractionTrackerInertiaNaturalMotion_Static, InteractionTrackerInertiaNaturalMotion_Static_bases.get())};
    if (!type_InteractionTrackerInertiaNaturalMotion_Static)
    {
        return nullptr;
    }

    py::pyobj_handle InteractionTrackerInertiaNaturalMotion_bases{PyTuple_Pack(1, InteractionTrackerInertiaModifier_type.get())};
    if (!InteractionTrackerInertiaNaturalMotion_bases)
    {
        return nullptr;
    }

    py::pytype_handle InteractionTrackerInertiaNaturalMotion_type{py::register_python_type(module.get(), &type_spec_InteractionTrackerInertiaNaturalMotion, InteractionTrackerInertiaNaturalMotion_bases.get(), reinterpret_cast<PyTypeObject*>(type_InteractionTrackerInertiaNaturalMotion_Static.get()))};
    if (!InteractionTrackerInertiaNaturalMotion_type)
    {
        return nullptr;
    }

    py::pyobj_handle InteractionTrackerInertiaRestingValue_Static_bases{PyTuple_Pack(1, reinterpret_cast<PyObject*>(Py_TYPE(InteractionTrackerInertiaModifier_type.get())))};
    if (!InteractionTrackerInertiaRestingValue_Static_bases)
    {
        return nullptr;
    }

    py::pyobj_handle type_InteractionTrackerInertiaRestingValue_Static{PyType_FromSpecWithBases(&type_spec_InteractionTrackerInertiaRestingValue_Static, InteractionTrackerInertiaRestingValue_Static_bases.get())};
    if (!type_InteractionTrackerInertiaRestingValue_Static)
    {
        return nullptr;
    }

    py::pyobj_handle InteractionTrackerInertiaRestingValue_bases{PyTuple_Pack(1, InteractionTrackerInertiaModifier_type.get())};
    if (!InteractionTrackerInertiaRestingValue_bases)
    {
        return nullptr;
    }

    py::pytype_handle InteractionTrackerInertiaRestingValue_type{py::register_python_type(module.get(), &type_spec_InteractionTrackerInertiaRestingValue, InteractionTrackerInertiaRestingValue_bases.get(), reinterpret_cast<PyTypeObject*>(type_InteractionTrackerInertiaRestingValue_Static.get()))};
    if (!InteractionTrackerInertiaRestingValue_type)
    {
        return nullptr;
    }

    py::pytype_handle InteractionTrackerInertiaStateEnteredArgs_type{py::register_python_type(module.get(), &type_spec_InteractionTrackerInertiaStateEnteredArgs, object_bases.get(), inspectable_meta_type)};
    if (!InteractionTrackerInertiaStateEnteredArgs_type)
    {
        return nullptr;
    }

    py::pytype_handle InteractionTrackerInteractingStateEnteredArgs_type{py::register_python_type(module.get(), &type_spec_InteractionTrackerInteractingStateEnteredArgs, object_bases.get(), inspectable_meta_type)};
    if (!InteractionTrackerInteractingStateEnteredArgs_type)
    {
        return nullptr;
    }

    py::pytype_handle InteractionTrackerRequestIgnoredArgs_type{py::register_python_type(module.get(), &type_spec_InteractionTrackerRequestIgnoredArgs, object_bases.get(), inspectable_meta_type)};
    if (!InteractionTrackerRequestIgnoredArgs_type)
    {
        return nullptr;
    }

    py::pytype_handle InteractionTrackerValuesChangedArgs_type{py::register_python_type(module.get(), &type_spec_InteractionTrackerValuesChangedArgs, object_bases.get(), inspectable_meta_type)};
    if (!InteractionTrackerValuesChangedArgs_type)
    {
        return nullptr;
    }

    py::pyobj_handle InteractionTrackerVector2InertiaModifier_Static_bases{PyTuple_Pack(1, reinterpret_cast<PyObject*>(Py_TYPE(microsoft_ui_composition_CompositionObject_type.get())))};
    if (!InteractionTrackerVector2InertiaModifier_Static_bases)
    {
        return nullptr;
    }

    py::pyobj_handle type_InteractionTrackerVector2InertiaModifier_Static{PyType_FromSpecWithBases(&type_spec_InteractionTrackerVector2InertiaModifier_Static, InteractionTrackerVector2InertiaModifier_Static_bases.get())};
    if (!type_InteractionTrackerVector2InertiaModifier_Static)
    {
        return nullptr;
    }

    py::pyobj_handle InteractionTrackerVector2InertiaModifier_bases{PyTuple_Pack(1, microsoft_ui_composition_CompositionObject_type.get())};
    if (!InteractionTrackerVector2InertiaModifier_bases)
    {
        return nullptr;
    }

    py::pytype_handle InteractionTrackerVector2InertiaModifier_type{py::register_python_type(module.get(), &type_spec_InteractionTrackerVector2InertiaModifier, InteractionTrackerVector2InertiaModifier_bases.get(), reinterpret_cast<PyTypeObject*>(type_InteractionTrackerVector2InertiaModifier_Static.get()))};
    if (!InteractionTrackerVector2InertiaModifier_type)
    {
        return nullptr;
    }

    py::pyobj_handle InteractionTrackerVector2InertiaNaturalMotion_Static_bases{PyTuple_Pack(1, reinterpret_cast<PyObject*>(Py_TYPE(InteractionTrackerVector2InertiaModifier_type.get())))};
    if (!InteractionTrackerVector2InertiaNaturalMotion_Static_bases)
    {
        return nullptr;
    }

    py::pyobj_handle type_InteractionTrackerVector2InertiaNaturalMotion_Static{PyType_FromSpecWithBases(&type_spec_InteractionTrackerVector2InertiaNaturalMotion_Static, InteractionTrackerVector2InertiaNaturalMotion_Static_bases.get())};
    if (!type_InteractionTrackerVector2InertiaNaturalMotion_Static)
    {
        return nullptr;
    }

    py::pyobj_handle InteractionTrackerVector2InertiaNaturalMotion_bases{PyTuple_Pack(1, InteractionTrackerVector2InertiaModifier_type.get())};
    if (!InteractionTrackerVector2InertiaNaturalMotion_bases)
    {
        return nullptr;
    }

    py::pytype_handle InteractionTrackerVector2InertiaNaturalMotion_type{py::register_python_type(module.get(), &type_spec_InteractionTrackerVector2InertiaNaturalMotion, InteractionTrackerVector2InertiaNaturalMotion_bases.get(), reinterpret_cast<PyTypeObject*>(type_InteractionTrackerVector2InertiaNaturalMotion_Static.get()))};
    if (!InteractionTrackerVector2InertiaNaturalMotion_type)
    {
        return nullptr;
    }

    py::pyobj_handle VisualInteractionSource_Static_bases{PyTuple_Pack(1, reinterpret_cast<PyObject*>(Py_TYPE(microsoft_ui_composition_CompositionObject_type.get())))};
    if (!VisualInteractionSource_Static_bases)
    {
        return nullptr;
    }

    py::pyobj_handle type_VisualInteractionSource_Static{PyType_FromSpecWithBases(&type_spec_VisualInteractionSource_Static, VisualInteractionSource_Static_bases.get())};
    if (!type_VisualInteractionSource_Static)
    {
        return nullptr;
    }

    py::pyobj_handle VisualInteractionSource_bases{PyTuple_Pack(1, microsoft_ui_composition_CompositionObject_type.get())};
    if (!VisualInteractionSource_bases)
    {
        return nullptr;
    }

    py::pytype_handle VisualInteractionSource_type{py::register_python_type(module.get(), &type_spec_VisualInteractionSource, VisualInteractionSource_bases.get(), reinterpret_cast<PyTypeObject*>(type_VisualInteractionSource_Static.get()))};
    if (!VisualInteractionSource_type)
    {
        return nullptr;
    }

    py::pytype_handle ICompositionInteractionSource_type{py::register_python_type(module.get(), &type_spec_ICompositionInteractionSource, object_bases.get(), nullptr)};
    if (!ICompositionInteractionSource_type)
    {
        return nullptr;
    }

    py::pytype_handle ImplementsICompositionInteractionSource_type{py::register_python_type(module.get(), &type_spec_ImplementsICompositionInteractionSource, nullptr, inspectable_meta_type)};
    if (!ImplementsICompositionInteractionSource_type)
    {
        return nullptr;
    }

    if (PyModule_AddType(module.get(), ImplementsICompositionInteractionSource_type.get()) == -1)
    {
        return nullptr;
    }

    py::pytype_handle IInteractionTrackerOwner_type{py::register_python_type(module.get(), &type_spec_IInteractionTrackerOwner, object_bases.get(), nullptr)};
    if (!IInteractionTrackerOwner_type)
    {
        return nullptr;
    }

    py::pytype_handle ImplementsIInteractionTrackerOwner_type{py::register_python_type(module.get(), &type_spec_ImplementsIInteractionTrackerOwner, nullptr, inspectable_meta_type)};
    if (!ImplementsIInteractionTrackerOwner_type)
    {
        return nullptr;
    }

    if (PyModule_AddType(module.get(), ImplementsIInteractionTrackerOwner_type.get()) == -1)
    {
        return nullptr;
    }


    return module.detach();
}
