// WARNING: Please don't edit this file. It was generated by Python/WinRT v3.1.0

#include "py.Microsoft.Security.Authentication.OAuth.h"

namespace py::cpp::Microsoft::Security::Authentication::OAuth
{
    // ----- AuthFailure class --------------------

    static PyObject* _new_AuthFailure(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Microsoft::Security::Authentication::OAuth::AuthFailure>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Microsoft::Security::Authentication::OAuth::AuthFailure>::type_name);
        return nullptr;
    }

    static void _dealloc_AuthFailure(py::wrapper::Microsoft::Security::Authentication::OAuth::AuthFailure* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* AuthFailure_get_AdditionalParams(py::wrapper::Microsoft::Security::Authentication::OAuth::AuthFailure* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.Security.Authentication.OAuth.AuthFailure", L"AdditionalParams");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.AdditionalParams();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AuthFailure_get_Error(py::wrapper::Microsoft::Security::Authentication::OAuth::AuthFailure* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.Security.Authentication.OAuth.AuthFailure", L"Error");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Error();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AuthFailure_get_ErrorDescription(py::wrapper::Microsoft::Security::Authentication::OAuth::AuthFailure* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.Security.Authentication.OAuth.AuthFailure", L"ErrorDescription");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.ErrorDescription();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AuthFailure_get_ErrorUri(py::wrapper::Microsoft::Security::Authentication::OAuth::AuthFailure* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.Security.Authentication.OAuth.AuthFailure", L"ErrorUri");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.ErrorUri();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AuthFailure_get_State(py::wrapper::Microsoft::Security::Authentication::OAuth::AuthFailure* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.Security.Authentication.OAuth.AuthFailure", L"State");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.State();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_AuthFailure(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Microsoft::Security::Authentication::OAuth::AuthFailure>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_AuthFailure(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Microsoft::Security::Authentication::OAuth::AuthFailure>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_AuthFailure[] = {
        { "_assign_array_", _assign_array_AuthFailure, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_AuthFailure), METH_O | METH_STATIC, nullptr },
        { }};

    static PyGetSetDef _getset_AuthFailure[] = {
        { "additional_params", reinterpret_cast<getter>(AuthFailure_get_AdditionalParams), nullptr, nullptr, nullptr },
        { "error", reinterpret_cast<getter>(AuthFailure_get_Error), nullptr, nullptr, nullptr },
        { "error_description", reinterpret_cast<getter>(AuthFailure_get_ErrorDescription), nullptr, nullptr, nullptr },
        { "error_uri", reinterpret_cast<getter>(AuthFailure_get_ErrorUri), nullptr, nullptr, nullptr },
        { "state", reinterpret_cast<getter>(AuthFailure_get_State), nullptr, nullptr, nullptr },
        { }};

    static PyType_Slot _type_slots_AuthFailure[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_AuthFailure) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_AuthFailure) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_AuthFailure) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_AuthFailure) },
        { }};

    static PyType_Spec type_spec_AuthFailure = {
        "winui3._winui3_microsoft_security_authentication_oauth.AuthFailure",
        sizeof(py::wrapper::Microsoft::Security::Authentication::OAuth::AuthFailure),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_AuthFailure};

    // ----- AuthRequestParams class --------------------

    static PyObject* _new_AuthRequestParams(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_GET_SIZE(args);
        if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::hstring>(args, 1);

                winrt::Microsoft::Security::Authentication::OAuth::AuthRequestParams instance{param0, param1};
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 3)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::hstring>(args, 1);
                auto param2 = py::convert_to<winrt::Windows::Foundation::Uri>(args, 2);

                winrt::Microsoft::Security::Authentication::OAuth::AuthRequestParams instance{param0, param1, param2};
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_AuthRequestParams(py::wrapper::Microsoft::Security::Authentication::OAuth::AuthRequestParams* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* AuthRequestParams_CreateForAuthorizationCodeRequest(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.Security.Authentication.OAuth.AuthRequestParams", L"CreateForAuthorizationCodeRequest", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return winrt::Microsoft::Security::Authentication::OAuth::AuthRequestParams::CreateForAuthorizationCodeRequest(param0);
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AuthRequestParams_CreateForAuthorizationCodeRequest2(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 2)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.Security.Authentication.OAuth.AuthRequestParams", L"CreateForAuthorizationCodeRequest", 2);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(2);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Foundation::Uri>(args, 1);

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return winrt::Microsoft::Security::Authentication::OAuth::AuthRequestParams::CreateForAuthorizationCodeRequest(param0, param1);
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AuthRequestParams_get_State(py::wrapper::Microsoft::Security::Authentication::OAuth::AuthRequestParams* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.Security.Authentication.OAuth.AuthRequestParams", L"State");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.State();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int AuthRequestParams_put_State(py::wrapper::Microsoft::Security::Authentication::OAuth::AuthRequestParams* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.Security.Authentication.OAuth.AuthRequestParams", L"State");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::hstring>(arg);

            {
                auto _gil = release_gil();
                self->obj.State(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* AuthRequestParams_get_Scope(py::wrapper::Microsoft::Security::Authentication::OAuth::AuthRequestParams* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.Security.Authentication.OAuth.AuthRequestParams", L"Scope");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Scope();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int AuthRequestParams_put_Scope(py::wrapper::Microsoft::Security::Authentication::OAuth::AuthRequestParams* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.Security.Authentication.OAuth.AuthRequestParams", L"Scope");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::hstring>(arg);

            {
                auto _gil = release_gil();
                self->obj.Scope(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* AuthRequestParams_get_ResponseType(py::wrapper::Microsoft::Security::Authentication::OAuth::AuthRequestParams* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.Security.Authentication.OAuth.AuthRequestParams", L"ResponseType");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.ResponseType();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int AuthRequestParams_put_ResponseType(py::wrapper::Microsoft::Security::Authentication::OAuth::AuthRequestParams* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.Security.Authentication.OAuth.AuthRequestParams", L"ResponseType");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::hstring>(arg);

            {
                auto _gil = release_gil();
                self->obj.ResponseType(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* AuthRequestParams_get_RedirectUri(py::wrapper::Microsoft::Security::Authentication::OAuth::AuthRequestParams* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.Security.Authentication.OAuth.AuthRequestParams", L"RedirectUri");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.RedirectUri();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int AuthRequestParams_put_RedirectUri(py::wrapper::Microsoft::Security::Authentication::OAuth::AuthRequestParams* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.Security.Authentication.OAuth.AuthRequestParams", L"RedirectUri");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::Uri>(arg);

            {
                auto _gil = release_gil();
                self->obj.RedirectUri(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* AuthRequestParams_get_CodeChallengeMethod(py::wrapper::Microsoft::Security::Authentication::OAuth::AuthRequestParams* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.Security.Authentication.OAuth.AuthRequestParams", L"CodeChallengeMethod");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.CodeChallengeMethod();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int AuthRequestParams_put_CodeChallengeMethod(py::wrapper::Microsoft::Security::Authentication::OAuth::AuthRequestParams* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.Security.Authentication.OAuth.AuthRequestParams", L"CodeChallengeMethod");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Microsoft::Security::Authentication::OAuth::CodeChallengeMethodKind>(arg);

            {
                auto _gil = release_gil();
                self->obj.CodeChallengeMethod(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* AuthRequestParams_get_CodeChallenge(py::wrapper::Microsoft::Security::Authentication::OAuth::AuthRequestParams* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.Security.Authentication.OAuth.AuthRequestParams", L"CodeChallenge");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.CodeChallenge();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int AuthRequestParams_put_CodeChallenge(py::wrapper::Microsoft::Security::Authentication::OAuth::AuthRequestParams* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.Security.Authentication.OAuth.AuthRequestParams", L"CodeChallenge");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::hstring>(arg);

            {
                auto _gil = release_gil();
                self->obj.CodeChallenge(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* AuthRequestParams_get_ClientId(py::wrapper::Microsoft::Security::Authentication::OAuth::AuthRequestParams* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.Security.Authentication.OAuth.AuthRequestParams", L"ClientId");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.ClientId();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int AuthRequestParams_put_ClientId(py::wrapper::Microsoft::Security::Authentication::OAuth::AuthRequestParams* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.Security.Authentication.OAuth.AuthRequestParams", L"ClientId");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::hstring>(arg);

            {
                auto _gil = release_gil();
                self->obj.ClientId(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* AuthRequestParams_get_AdditionalParams(py::wrapper::Microsoft::Security::Authentication::OAuth::AuthRequestParams* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.Security.Authentication.OAuth.AuthRequestParams", L"AdditionalParams");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.AdditionalParams();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_AuthRequestParams(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Microsoft::Security::Authentication::OAuth::AuthRequestParams>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_AuthRequestParams(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Microsoft::Security::Authentication::OAuth::AuthRequestParams>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_AuthRequestParams[] = {
        { "_assign_array_", _assign_array_AuthRequestParams, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_AuthRequestParams), METH_O | METH_STATIC, nullptr },
        { }};

    static PyGetSetDef _getset_AuthRequestParams[] = {
        { "state", reinterpret_cast<getter>(AuthRequestParams_get_State), reinterpret_cast<setter>(AuthRequestParams_put_State), nullptr, nullptr },
        { "scope", reinterpret_cast<getter>(AuthRequestParams_get_Scope), reinterpret_cast<setter>(AuthRequestParams_put_Scope), nullptr, nullptr },
        { "response_type", reinterpret_cast<getter>(AuthRequestParams_get_ResponseType), reinterpret_cast<setter>(AuthRequestParams_put_ResponseType), nullptr, nullptr },
        { "redirect_uri", reinterpret_cast<getter>(AuthRequestParams_get_RedirectUri), reinterpret_cast<setter>(AuthRequestParams_put_RedirectUri), nullptr, nullptr },
        { "code_challenge_method", reinterpret_cast<getter>(AuthRequestParams_get_CodeChallengeMethod), reinterpret_cast<setter>(AuthRequestParams_put_CodeChallengeMethod), nullptr, nullptr },
        { "code_challenge", reinterpret_cast<getter>(AuthRequestParams_get_CodeChallenge), reinterpret_cast<setter>(AuthRequestParams_put_CodeChallenge), nullptr, nullptr },
        { "client_id", reinterpret_cast<getter>(AuthRequestParams_get_ClientId), reinterpret_cast<setter>(AuthRequestParams_put_ClientId), nullptr, nullptr },
        { "additional_params", reinterpret_cast<getter>(AuthRequestParams_get_AdditionalParams), nullptr, nullptr, nullptr },
        { }};

    static PyType_Slot _type_slots_AuthRequestParams[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_AuthRequestParams) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_AuthRequestParams) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_AuthRequestParams) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_AuthRequestParams) },
        { }};

    static PyType_Spec type_spec_AuthRequestParams = {
        "winui3._winui3_microsoft_security_authentication_oauth.AuthRequestParams",
        sizeof(py::wrapper::Microsoft::Security::Authentication::OAuth::AuthRequestParams),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_AuthRequestParams};

    static PyGetSetDef getset_AuthRequestParams_Static[] = {
        { }};

    static PyMethodDef methods_AuthRequestParams_Static[] = {
        { "create_for_authorization_code_request", reinterpret_cast<PyCFunction>(AuthRequestParams_CreateForAuthorizationCodeRequest), METH_VARARGS, nullptr },
        { "create_for_authorization_code_request2", reinterpret_cast<PyCFunction>(AuthRequestParams_CreateForAuthorizationCodeRequest2), METH_VARARGS, nullptr },
        { }};

    static PyType_Slot type_slots_AuthRequestParams_Static[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_AuthRequestParams_Static) },
        { Py_tp_methods, reinterpret_cast<void*>(methods_AuthRequestParams_Static) },
        { }
    };

    static PyType_Spec type_spec_AuthRequestParams_Static = {
        "winui3._winui3_microsoft_security_authentication_oauth.AuthRequestParams_Static",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT,
        type_slots_AuthRequestParams_Static};

    // ----- AuthRequestResult class --------------------

    static PyObject* _new_AuthRequestResult(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Microsoft::Security::Authentication::OAuth::AuthRequestResult>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Microsoft::Security::Authentication::OAuth::AuthRequestResult>::type_name);
        return nullptr;
    }

    static void _dealloc_AuthRequestResult(py::wrapper::Microsoft::Security::Authentication::OAuth::AuthRequestResult* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* AuthRequestResult_get_Failure(py::wrapper::Microsoft::Security::Authentication::OAuth::AuthRequestResult* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.Security.Authentication.OAuth.AuthRequestResult", L"Failure");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Failure();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AuthRequestResult_get_Response(py::wrapper::Microsoft::Security::Authentication::OAuth::AuthRequestResult* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.Security.Authentication.OAuth.AuthRequestResult", L"Response");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Response();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AuthRequestResult_get_ResponseUri(py::wrapper::Microsoft::Security::Authentication::OAuth::AuthRequestResult* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.Security.Authentication.OAuth.AuthRequestResult", L"ResponseUri");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.ResponseUri();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_AuthRequestResult(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Microsoft::Security::Authentication::OAuth::AuthRequestResult>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_AuthRequestResult(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Microsoft::Security::Authentication::OAuth::AuthRequestResult>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_AuthRequestResult[] = {
        { "_assign_array_", _assign_array_AuthRequestResult, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_AuthRequestResult), METH_O | METH_STATIC, nullptr },
        { }};

    static PyGetSetDef _getset_AuthRequestResult[] = {
        { "failure", reinterpret_cast<getter>(AuthRequestResult_get_Failure), nullptr, nullptr, nullptr },
        { "response", reinterpret_cast<getter>(AuthRequestResult_get_Response), nullptr, nullptr, nullptr },
        { "response_uri", reinterpret_cast<getter>(AuthRequestResult_get_ResponseUri), nullptr, nullptr, nullptr },
        { }};

    static PyType_Slot _type_slots_AuthRequestResult[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_AuthRequestResult) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_AuthRequestResult) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_AuthRequestResult) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_AuthRequestResult) },
        { }};

    static PyType_Spec type_spec_AuthRequestResult = {
        "winui3._winui3_microsoft_security_authentication_oauth.AuthRequestResult",
        sizeof(py::wrapper::Microsoft::Security::Authentication::OAuth::AuthRequestResult),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_AuthRequestResult};

    // ----- AuthResponse class --------------------

    static PyObject* _new_AuthResponse(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Microsoft::Security::Authentication::OAuth::AuthResponse>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Microsoft::Security::Authentication::OAuth::AuthResponse>::type_name);
        return nullptr;
    }

    static void _dealloc_AuthResponse(py::wrapper::Microsoft::Security::Authentication::OAuth::AuthResponse* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* AuthResponse_get_AccessToken(py::wrapper::Microsoft::Security::Authentication::OAuth::AuthResponse* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.Security.Authentication.OAuth.AuthResponse", L"AccessToken");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.AccessToken();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AuthResponse_get_AdditionalParams(py::wrapper::Microsoft::Security::Authentication::OAuth::AuthResponse* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.Security.Authentication.OAuth.AuthResponse", L"AdditionalParams");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.AdditionalParams();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AuthResponse_get_Code(py::wrapper::Microsoft::Security::Authentication::OAuth::AuthResponse* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.Security.Authentication.OAuth.AuthResponse", L"Code");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Code();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AuthResponse_get_ExpiresIn(py::wrapper::Microsoft::Security::Authentication::OAuth::AuthResponse* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.Security.Authentication.OAuth.AuthResponse", L"ExpiresIn");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.ExpiresIn();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AuthResponse_get_Scope(py::wrapper::Microsoft::Security::Authentication::OAuth::AuthResponse* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.Security.Authentication.OAuth.AuthResponse", L"Scope");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Scope();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AuthResponse_get_State(py::wrapper::Microsoft::Security::Authentication::OAuth::AuthResponse* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.Security.Authentication.OAuth.AuthResponse", L"State");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.State();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AuthResponse_get_TokenType(py::wrapper::Microsoft::Security::Authentication::OAuth::AuthResponse* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.Security.Authentication.OAuth.AuthResponse", L"TokenType");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.TokenType();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_AuthResponse(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Microsoft::Security::Authentication::OAuth::AuthResponse>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_AuthResponse(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Microsoft::Security::Authentication::OAuth::AuthResponse>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_AuthResponse[] = {
        { "_assign_array_", _assign_array_AuthResponse, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_AuthResponse), METH_O | METH_STATIC, nullptr },
        { }};

    static PyGetSetDef _getset_AuthResponse[] = {
        { "access_token", reinterpret_cast<getter>(AuthResponse_get_AccessToken), nullptr, nullptr, nullptr },
        { "additional_params", reinterpret_cast<getter>(AuthResponse_get_AdditionalParams), nullptr, nullptr, nullptr },
        { "code", reinterpret_cast<getter>(AuthResponse_get_Code), nullptr, nullptr, nullptr },
        { "expires_in", reinterpret_cast<getter>(AuthResponse_get_ExpiresIn), nullptr, nullptr, nullptr },
        { "scope", reinterpret_cast<getter>(AuthResponse_get_Scope), nullptr, nullptr, nullptr },
        { "state", reinterpret_cast<getter>(AuthResponse_get_State), nullptr, nullptr, nullptr },
        { "token_type", reinterpret_cast<getter>(AuthResponse_get_TokenType), nullptr, nullptr, nullptr },
        { }};

    static PyType_Slot _type_slots_AuthResponse[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_AuthResponse) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_AuthResponse) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_AuthResponse) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_AuthResponse) },
        { }};

    static PyType_Spec type_spec_AuthResponse = {
        "winui3._winui3_microsoft_security_authentication_oauth.AuthResponse",
        sizeof(py::wrapper::Microsoft::Security::Authentication::OAuth::AuthResponse),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_AuthResponse};

    // ----- ClientAuthentication class --------------------

    static PyObject* _new_ClientAuthentication(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_GET_SIZE(args);
        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Web::Http::Headers::HttpCredentialsHeaderValue>(args, 0);

                winrt::Microsoft::Security::Authentication::OAuth::ClientAuthentication instance{param0};
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 0)
        {
            try
            {
                winrt::Microsoft::Security::Authentication::OAuth::ClientAuthentication instance{};
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_ClientAuthentication(py::wrapper::Microsoft::Security::Authentication::OAuth::ClientAuthentication* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* ClientAuthentication_CreateForBasicAuthorization(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 2)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.Security.Authentication.OAuth.ClientAuthentication", L"CreateForBasicAuthorization", 2);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(2);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::hstring>(args, 1);

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return winrt::Microsoft::Security::Authentication::OAuth::ClientAuthentication::CreateForBasicAuthorization(param0, param1);
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ClientAuthentication_get_ProxyAuthorization(py::wrapper::Microsoft::Security::Authentication::OAuth::ClientAuthentication* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.Security.Authentication.OAuth.ClientAuthentication", L"ProxyAuthorization");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.ProxyAuthorization();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ClientAuthentication_put_ProxyAuthorization(py::wrapper::Microsoft::Security::Authentication::OAuth::ClientAuthentication* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.Security.Authentication.OAuth.ClientAuthentication", L"ProxyAuthorization");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::Web::Http::Headers::HttpCredentialsHeaderValue>(arg);

            {
                auto _gil = release_gil();
                self->obj.ProxyAuthorization(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ClientAuthentication_get_Authorization(py::wrapper::Microsoft::Security::Authentication::OAuth::ClientAuthentication* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.Security.Authentication.OAuth.ClientAuthentication", L"Authorization");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Authorization();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ClientAuthentication_put_Authorization(py::wrapper::Microsoft::Security::Authentication::OAuth::ClientAuthentication* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.Security.Authentication.OAuth.ClientAuthentication", L"Authorization");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::Web::Http::Headers::HttpCredentialsHeaderValue>(arg);

            {
                auto _gil = release_gil();
                self->obj.Authorization(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ClientAuthentication_get_AdditionalHeaders(py::wrapper::Microsoft::Security::Authentication::OAuth::ClientAuthentication* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.Security.Authentication.OAuth.ClientAuthentication", L"AdditionalHeaders");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.AdditionalHeaders();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_ClientAuthentication(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Microsoft::Security::Authentication::OAuth::ClientAuthentication>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_ClientAuthentication(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Microsoft::Security::Authentication::OAuth::ClientAuthentication>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_ClientAuthentication[] = {
        { "_assign_array_", _assign_array_ClientAuthentication, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_ClientAuthentication), METH_O | METH_STATIC, nullptr },
        { }};

    static PyGetSetDef _getset_ClientAuthentication[] = {
        { "proxy_authorization", reinterpret_cast<getter>(ClientAuthentication_get_ProxyAuthorization), reinterpret_cast<setter>(ClientAuthentication_put_ProxyAuthorization), nullptr, nullptr },
        { "authorization", reinterpret_cast<getter>(ClientAuthentication_get_Authorization), reinterpret_cast<setter>(ClientAuthentication_put_Authorization), nullptr, nullptr },
        { "additional_headers", reinterpret_cast<getter>(ClientAuthentication_get_AdditionalHeaders), nullptr, nullptr, nullptr },
        { }};

    static PyType_Slot _type_slots_ClientAuthentication[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_ClientAuthentication) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_ClientAuthentication) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_ClientAuthentication) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_ClientAuthentication) },
        { }};

    static PyType_Spec type_spec_ClientAuthentication = {
        "winui3._winui3_microsoft_security_authentication_oauth.ClientAuthentication",
        sizeof(py::wrapper::Microsoft::Security::Authentication::OAuth::ClientAuthentication),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_ClientAuthentication};

    static PyGetSetDef getset_ClientAuthentication_Static[] = {
        { }};

    static PyMethodDef methods_ClientAuthentication_Static[] = {
        { "create_for_basic_authorization", reinterpret_cast<PyCFunction>(ClientAuthentication_CreateForBasicAuthorization), METH_VARARGS, nullptr },
        { }};

    static PyType_Slot type_slots_ClientAuthentication_Static[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_ClientAuthentication_Static) },
        { Py_tp_methods, reinterpret_cast<void*>(methods_ClientAuthentication_Static) },
        { }
    };

    static PyType_Spec type_spec_ClientAuthentication_Static = {
        "winui3._winui3_microsoft_security_authentication_oauth.ClientAuthentication_Static",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT,
        type_slots_ClientAuthentication_Static};

    // ----- OAuth2Manager class --------------------

    static PyObject* _new_OAuth2Manager(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Microsoft::Security::Authentication::OAuth::OAuth2Manager>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Microsoft::Security::Authentication::OAuth::OAuth2Manager>::type_name);
        return nullptr;
    }

    static PyObject* OAuth2Manager_CompleteAuthRequest(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.Security.Authentication.OAuth.OAuth2Manager", L"CompleteAuthRequest", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Foundation::Uri>(args, 0);

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return winrt::Microsoft::Security::Authentication::OAuth::OAuth2Manager::CompleteAuthRequest(param0);
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* OAuth2Manager_RequestAuthWithParamsAsync(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 3)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.Security.Authentication.OAuth.OAuth2Manager", L"RequestAuthWithParamsAsync", 3);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(3);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Microsoft::UI::WindowId>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Foundation::Uri>(args, 1);
                auto param2 = py::convert_to<winrt::Microsoft::Security::Authentication::OAuth::AuthRequestParams>(args, 2);

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return winrt::Microsoft::Security::Authentication::OAuth::OAuth2Manager::RequestAuthWithParamsAsync(param0, param1, param2);
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* OAuth2Manager_RequestTokenAsync(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 2)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.Security.Authentication.OAuth.OAuth2Manager", L"RequestTokenAsync", 2);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(2);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Foundation::Uri>(args, 0);
                auto param1 = py::convert_to<winrt::Microsoft::Security::Authentication::OAuth::TokenRequestParams>(args, 1);

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return winrt::Microsoft::Security::Authentication::OAuth::OAuth2Manager::RequestTokenAsync(param0, param1);
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* OAuth2Manager_RequestTokenAsync2(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 3)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.Security.Authentication.OAuth.OAuth2Manager", L"RequestTokenAsync", 3);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(3);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Foundation::Uri>(args, 0);
                auto param1 = py::convert_to<winrt::Microsoft::Security::Authentication::OAuth::TokenRequestParams>(args, 1);
                auto param2 = py::convert_to<winrt::Microsoft::Security::Authentication::OAuth::ClientAuthentication>(args, 2);

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return winrt::Microsoft::Security::Authentication::OAuth::OAuth2Manager::RequestTokenAsync(param0, param1, param2);
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyMethodDef _methods_OAuth2Manager[] = {
        { }};

    static PyGetSetDef _getset_OAuth2Manager[] = {
        { }};

    static PyType_Slot _type_slots_OAuth2Manager[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_OAuth2Manager) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_OAuth2Manager) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_OAuth2Manager) },
        { }};

    static PyType_Spec type_spec_OAuth2Manager = {
        "winui3._winui3_microsoft_security_authentication_oauth.OAuth2Manager",
        0,
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_OAuth2Manager};

    static PyGetSetDef getset_OAuth2Manager_Static[] = {
        { }};

    static PyMethodDef methods_OAuth2Manager_Static[] = {
        { "complete_auth_request", reinterpret_cast<PyCFunction>(OAuth2Manager_CompleteAuthRequest), METH_VARARGS, nullptr },
        { "request_auth_with_params_async", reinterpret_cast<PyCFunction>(OAuth2Manager_RequestAuthWithParamsAsync), METH_VARARGS, nullptr },
        { "request_token_async", reinterpret_cast<PyCFunction>(OAuth2Manager_RequestTokenAsync), METH_VARARGS, nullptr },
        { "request_token_async2", reinterpret_cast<PyCFunction>(OAuth2Manager_RequestTokenAsync2), METH_VARARGS, nullptr },
        { }};

    static PyType_Slot type_slots_OAuth2Manager_Static[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_OAuth2Manager_Static) },
        { Py_tp_methods, reinterpret_cast<void*>(methods_OAuth2Manager_Static) },
        { }
    };

    static PyType_Spec type_spec_OAuth2Manager_Static = {
        "winui3._winui3_microsoft_security_authentication_oauth.OAuth2Manager_Static",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT,
        type_slots_OAuth2Manager_Static};

    // ----- TokenFailure class --------------------

    static PyObject* _new_TokenFailure(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Microsoft::Security::Authentication::OAuth::TokenFailure>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Microsoft::Security::Authentication::OAuth::TokenFailure>::type_name);
        return nullptr;
    }

    static void _dealloc_TokenFailure(py::wrapper::Microsoft::Security::Authentication::OAuth::TokenFailure* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* TokenFailure_get_AdditionalParams(py::wrapper::Microsoft::Security::Authentication::OAuth::TokenFailure* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.Security.Authentication.OAuth.TokenFailure", L"AdditionalParams");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.AdditionalParams();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* TokenFailure_get_Error(py::wrapper::Microsoft::Security::Authentication::OAuth::TokenFailure* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.Security.Authentication.OAuth.TokenFailure", L"Error");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Error();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* TokenFailure_get_ErrorCode(py::wrapper::Microsoft::Security::Authentication::OAuth::TokenFailure* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.Security.Authentication.OAuth.TokenFailure", L"ErrorCode");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.ErrorCode();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* TokenFailure_get_ErrorDescription(py::wrapper::Microsoft::Security::Authentication::OAuth::TokenFailure* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.Security.Authentication.OAuth.TokenFailure", L"ErrorDescription");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.ErrorDescription();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* TokenFailure_get_ErrorUri(py::wrapper::Microsoft::Security::Authentication::OAuth::TokenFailure* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.Security.Authentication.OAuth.TokenFailure", L"ErrorUri");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.ErrorUri();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* TokenFailure_get_Kind(py::wrapper::Microsoft::Security::Authentication::OAuth::TokenFailure* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.Security.Authentication.OAuth.TokenFailure", L"Kind");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Kind();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_TokenFailure(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Microsoft::Security::Authentication::OAuth::TokenFailure>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_TokenFailure(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Microsoft::Security::Authentication::OAuth::TokenFailure>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_TokenFailure[] = {
        { "_assign_array_", _assign_array_TokenFailure, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_TokenFailure), METH_O | METH_STATIC, nullptr },
        { }};

    static PyGetSetDef _getset_TokenFailure[] = {
        { "additional_params", reinterpret_cast<getter>(TokenFailure_get_AdditionalParams), nullptr, nullptr, nullptr },
        { "error", reinterpret_cast<getter>(TokenFailure_get_Error), nullptr, nullptr, nullptr },
        { "error_code", reinterpret_cast<getter>(TokenFailure_get_ErrorCode), nullptr, nullptr, nullptr },
        { "error_description", reinterpret_cast<getter>(TokenFailure_get_ErrorDescription), nullptr, nullptr, nullptr },
        { "error_uri", reinterpret_cast<getter>(TokenFailure_get_ErrorUri), nullptr, nullptr, nullptr },
        { "kind", reinterpret_cast<getter>(TokenFailure_get_Kind), nullptr, nullptr, nullptr },
        { }};

    static PyType_Slot _type_slots_TokenFailure[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_TokenFailure) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_TokenFailure) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_TokenFailure) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_TokenFailure) },
        { }};

    static PyType_Spec type_spec_TokenFailure = {
        "winui3._winui3_microsoft_security_authentication_oauth.TokenFailure",
        sizeof(py::wrapper::Microsoft::Security::Authentication::OAuth::TokenFailure),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_TokenFailure};

    // ----- TokenRequestParams class --------------------

    static PyObject* _new_TokenRequestParams(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_GET_SIZE(args);
        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                winrt::Microsoft::Security::Authentication::OAuth::TokenRequestParams instance{param0};
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_TokenRequestParams(py::wrapper::Microsoft::Security::Authentication::OAuth::TokenRequestParams* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* TokenRequestParams_CreateForAuthorizationCodeRequest(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.Security.Authentication.OAuth.TokenRequestParams", L"CreateForAuthorizationCodeRequest", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Microsoft::Security::Authentication::OAuth::AuthResponse>(args, 0);

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return winrt::Microsoft::Security::Authentication::OAuth::TokenRequestParams::CreateForAuthorizationCodeRequest(param0);
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* TokenRequestParams_CreateForClientCredentials(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.Security.Authentication.OAuth.TokenRequestParams", L"CreateForClientCredentials", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return winrt::Microsoft::Security::Authentication::OAuth::TokenRequestParams::CreateForClientCredentials();
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* TokenRequestParams_CreateForExtension(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.Security.Authentication.OAuth.TokenRequestParams", L"CreateForExtension", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Foundation::Uri>(args, 0);

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return winrt::Microsoft::Security::Authentication::OAuth::TokenRequestParams::CreateForExtension(param0);
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* TokenRequestParams_CreateForRefreshToken(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.Security.Authentication.OAuth.TokenRequestParams", L"CreateForRefreshToken", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return winrt::Microsoft::Security::Authentication::OAuth::TokenRequestParams::CreateForRefreshToken(param0);
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* TokenRequestParams_get_Username(py::wrapper::Microsoft::Security::Authentication::OAuth::TokenRequestParams* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.Security.Authentication.OAuth.TokenRequestParams", L"Username");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Username();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int TokenRequestParams_put_Username(py::wrapper::Microsoft::Security::Authentication::OAuth::TokenRequestParams* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.Security.Authentication.OAuth.TokenRequestParams", L"Username");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::hstring>(arg);

            {
                auto _gil = release_gil();
                self->obj.Username(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* TokenRequestParams_get_Scope(py::wrapper::Microsoft::Security::Authentication::OAuth::TokenRequestParams* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.Security.Authentication.OAuth.TokenRequestParams", L"Scope");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Scope();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int TokenRequestParams_put_Scope(py::wrapper::Microsoft::Security::Authentication::OAuth::TokenRequestParams* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.Security.Authentication.OAuth.TokenRequestParams", L"Scope");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::hstring>(arg);

            {
                auto _gil = release_gil();
                self->obj.Scope(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* TokenRequestParams_get_RefreshToken(py::wrapper::Microsoft::Security::Authentication::OAuth::TokenRequestParams* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.Security.Authentication.OAuth.TokenRequestParams", L"RefreshToken");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.RefreshToken();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int TokenRequestParams_put_RefreshToken(py::wrapper::Microsoft::Security::Authentication::OAuth::TokenRequestParams* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.Security.Authentication.OAuth.TokenRequestParams", L"RefreshToken");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::hstring>(arg);

            {
                auto _gil = release_gil();
                self->obj.RefreshToken(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* TokenRequestParams_get_RedirectUri(py::wrapper::Microsoft::Security::Authentication::OAuth::TokenRequestParams* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.Security.Authentication.OAuth.TokenRequestParams", L"RedirectUri");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.RedirectUri();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int TokenRequestParams_put_RedirectUri(py::wrapper::Microsoft::Security::Authentication::OAuth::TokenRequestParams* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.Security.Authentication.OAuth.TokenRequestParams", L"RedirectUri");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::Uri>(arg);

            {
                auto _gil = release_gil();
                self->obj.RedirectUri(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* TokenRequestParams_get_Password(py::wrapper::Microsoft::Security::Authentication::OAuth::TokenRequestParams* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.Security.Authentication.OAuth.TokenRequestParams", L"Password");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Password();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int TokenRequestParams_put_Password(py::wrapper::Microsoft::Security::Authentication::OAuth::TokenRequestParams* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.Security.Authentication.OAuth.TokenRequestParams", L"Password");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::hstring>(arg);

            {
                auto _gil = release_gil();
                self->obj.Password(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* TokenRequestParams_get_GrantType(py::wrapper::Microsoft::Security::Authentication::OAuth::TokenRequestParams* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.Security.Authentication.OAuth.TokenRequestParams", L"GrantType");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.GrantType();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int TokenRequestParams_put_GrantType(py::wrapper::Microsoft::Security::Authentication::OAuth::TokenRequestParams* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.Security.Authentication.OAuth.TokenRequestParams", L"GrantType");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::hstring>(arg);

            {
                auto _gil = release_gil();
                self->obj.GrantType(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* TokenRequestParams_get_CodeVerifier(py::wrapper::Microsoft::Security::Authentication::OAuth::TokenRequestParams* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.Security.Authentication.OAuth.TokenRequestParams", L"CodeVerifier");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.CodeVerifier();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int TokenRequestParams_put_CodeVerifier(py::wrapper::Microsoft::Security::Authentication::OAuth::TokenRequestParams* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.Security.Authentication.OAuth.TokenRequestParams", L"CodeVerifier");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::hstring>(arg);

            {
                auto _gil = release_gil();
                self->obj.CodeVerifier(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* TokenRequestParams_get_Code(py::wrapper::Microsoft::Security::Authentication::OAuth::TokenRequestParams* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.Security.Authentication.OAuth.TokenRequestParams", L"Code");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Code();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int TokenRequestParams_put_Code(py::wrapper::Microsoft::Security::Authentication::OAuth::TokenRequestParams* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.Security.Authentication.OAuth.TokenRequestParams", L"Code");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::hstring>(arg);

            {
                auto _gil = release_gil();
                self->obj.Code(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* TokenRequestParams_get_ClientId(py::wrapper::Microsoft::Security::Authentication::OAuth::TokenRequestParams* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.Security.Authentication.OAuth.TokenRequestParams", L"ClientId");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.ClientId();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int TokenRequestParams_put_ClientId(py::wrapper::Microsoft::Security::Authentication::OAuth::TokenRequestParams* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.Security.Authentication.OAuth.TokenRequestParams", L"ClientId");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::hstring>(arg);

            {
                auto _gil = release_gil();
                self->obj.ClientId(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* TokenRequestParams_get_AdditionalParams(py::wrapper::Microsoft::Security::Authentication::OAuth::TokenRequestParams* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.Security.Authentication.OAuth.TokenRequestParams", L"AdditionalParams");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.AdditionalParams();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_TokenRequestParams(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Microsoft::Security::Authentication::OAuth::TokenRequestParams>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_TokenRequestParams(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Microsoft::Security::Authentication::OAuth::TokenRequestParams>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_TokenRequestParams[] = {
        { "_assign_array_", _assign_array_TokenRequestParams, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_TokenRequestParams), METH_O | METH_STATIC, nullptr },
        { }};

    static PyGetSetDef _getset_TokenRequestParams[] = {
        { "username", reinterpret_cast<getter>(TokenRequestParams_get_Username), reinterpret_cast<setter>(TokenRequestParams_put_Username), nullptr, nullptr },
        { "scope", reinterpret_cast<getter>(TokenRequestParams_get_Scope), reinterpret_cast<setter>(TokenRequestParams_put_Scope), nullptr, nullptr },
        { "refresh_token", reinterpret_cast<getter>(TokenRequestParams_get_RefreshToken), reinterpret_cast<setter>(TokenRequestParams_put_RefreshToken), nullptr, nullptr },
        { "redirect_uri", reinterpret_cast<getter>(TokenRequestParams_get_RedirectUri), reinterpret_cast<setter>(TokenRequestParams_put_RedirectUri), nullptr, nullptr },
        { "password", reinterpret_cast<getter>(TokenRequestParams_get_Password), reinterpret_cast<setter>(TokenRequestParams_put_Password), nullptr, nullptr },
        { "grant_type", reinterpret_cast<getter>(TokenRequestParams_get_GrantType), reinterpret_cast<setter>(TokenRequestParams_put_GrantType), nullptr, nullptr },
        { "code_verifier", reinterpret_cast<getter>(TokenRequestParams_get_CodeVerifier), reinterpret_cast<setter>(TokenRequestParams_put_CodeVerifier), nullptr, nullptr },
        { "code", reinterpret_cast<getter>(TokenRequestParams_get_Code), reinterpret_cast<setter>(TokenRequestParams_put_Code), nullptr, nullptr },
        { "client_id", reinterpret_cast<getter>(TokenRequestParams_get_ClientId), reinterpret_cast<setter>(TokenRequestParams_put_ClientId), nullptr, nullptr },
        { "additional_params", reinterpret_cast<getter>(TokenRequestParams_get_AdditionalParams), nullptr, nullptr, nullptr },
        { }};

    static PyType_Slot _type_slots_TokenRequestParams[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_TokenRequestParams) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_TokenRequestParams) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_TokenRequestParams) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_TokenRequestParams) },
        { }};

    static PyType_Spec type_spec_TokenRequestParams = {
        "winui3._winui3_microsoft_security_authentication_oauth.TokenRequestParams",
        sizeof(py::wrapper::Microsoft::Security::Authentication::OAuth::TokenRequestParams),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_TokenRequestParams};

    static PyGetSetDef getset_TokenRequestParams_Static[] = {
        { }};

    static PyMethodDef methods_TokenRequestParams_Static[] = {
        { "create_for_authorization_code_request", reinterpret_cast<PyCFunction>(TokenRequestParams_CreateForAuthorizationCodeRequest), METH_VARARGS, nullptr },
        { "create_for_client_credentials", reinterpret_cast<PyCFunction>(TokenRequestParams_CreateForClientCredentials), METH_VARARGS, nullptr },
        { "create_for_extension", reinterpret_cast<PyCFunction>(TokenRequestParams_CreateForExtension), METH_VARARGS, nullptr },
        { "create_for_refresh_token", reinterpret_cast<PyCFunction>(TokenRequestParams_CreateForRefreshToken), METH_VARARGS, nullptr },
        { }};

    static PyType_Slot type_slots_TokenRequestParams_Static[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_TokenRequestParams_Static) },
        { Py_tp_methods, reinterpret_cast<void*>(methods_TokenRequestParams_Static) },
        { }
    };

    static PyType_Spec type_spec_TokenRequestParams_Static = {
        "winui3._winui3_microsoft_security_authentication_oauth.TokenRequestParams_Static",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT,
        type_slots_TokenRequestParams_Static};

    // ----- TokenRequestResult class --------------------

    static PyObject* _new_TokenRequestResult(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Microsoft::Security::Authentication::OAuth::TokenRequestResult>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Microsoft::Security::Authentication::OAuth::TokenRequestResult>::type_name);
        return nullptr;
    }

    static void _dealloc_TokenRequestResult(py::wrapper::Microsoft::Security::Authentication::OAuth::TokenRequestResult* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* TokenRequestResult_get_Failure(py::wrapper::Microsoft::Security::Authentication::OAuth::TokenRequestResult* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.Security.Authentication.OAuth.TokenRequestResult", L"Failure");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Failure();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* TokenRequestResult_get_Response(py::wrapper::Microsoft::Security::Authentication::OAuth::TokenRequestResult* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.Security.Authentication.OAuth.TokenRequestResult", L"Response");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Response();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* TokenRequestResult_get_ResponseMessage(py::wrapper::Microsoft::Security::Authentication::OAuth::TokenRequestResult* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.Security.Authentication.OAuth.TokenRequestResult", L"ResponseMessage");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.ResponseMessage();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_TokenRequestResult(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Microsoft::Security::Authentication::OAuth::TokenRequestResult>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_TokenRequestResult(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Microsoft::Security::Authentication::OAuth::TokenRequestResult>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_TokenRequestResult[] = {
        { "_assign_array_", _assign_array_TokenRequestResult, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_TokenRequestResult), METH_O | METH_STATIC, nullptr },
        { }};

    static PyGetSetDef _getset_TokenRequestResult[] = {
        { "failure", reinterpret_cast<getter>(TokenRequestResult_get_Failure), nullptr, nullptr, nullptr },
        { "response", reinterpret_cast<getter>(TokenRequestResult_get_Response), nullptr, nullptr, nullptr },
        { "response_message", reinterpret_cast<getter>(TokenRequestResult_get_ResponseMessage), nullptr, nullptr, nullptr },
        { }};

    static PyType_Slot _type_slots_TokenRequestResult[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_TokenRequestResult) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_TokenRequestResult) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_TokenRequestResult) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_TokenRequestResult) },
        { }};

    static PyType_Spec type_spec_TokenRequestResult = {
        "winui3._winui3_microsoft_security_authentication_oauth.TokenRequestResult",
        sizeof(py::wrapper::Microsoft::Security::Authentication::OAuth::TokenRequestResult),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_TokenRequestResult};

    // ----- TokenResponse class --------------------

    static PyObject* _new_TokenResponse(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Microsoft::Security::Authentication::OAuth::TokenResponse>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Microsoft::Security::Authentication::OAuth::TokenResponse>::type_name);
        return nullptr;
    }

    static void _dealloc_TokenResponse(py::wrapper::Microsoft::Security::Authentication::OAuth::TokenResponse* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* TokenResponse_get_AccessToken(py::wrapper::Microsoft::Security::Authentication::OAuth::TokenResponse* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.Security.Authentication.OAuth.TokenResponse", L"AccessToken");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.AccessToken();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* TokenResponse_get_AdditionalParams(py::wrapper::Microsoft::Security::Authentication::OAuth::TokenResponse* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.Security.Authentication.OAuth.TokenResponse", L"AdditionalParams");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.AdditionalParams();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* TokenResponse_get_ExpiresIn(py::wrapper::Microsoft::Security::Authentication::OAuth::TokenResponse* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.Security.Authentication.OAuth.TokenResponse", L"ExpiresIn");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.ExpiresIn();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* TokenResponse_get_RefreshToken(py::wrapper::Microsoft::Security::Authentication::OAuth::TokenResponse* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.Security.Authentication.OAuth.TokenResponse", L"RefreshToken");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.RefreshToken();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* TokenResponse_get_Scope(py::wrapper::Microsoft::Security::Authentication::OAuth::TokenResponse* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.Security.Authentication.OAuth.TokenResponse", L"Scope");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Scope();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* TokenResponse_get_TokenType(py::wrapper::Microsoft::Security::Authentication::OAuth::TokenResponse* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.Security.Authentication.OAuth.TokenResponse", L"TokenType");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.TokenType();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_TokenResponse(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Microsoft::Security::Authentication::OAuth::TokenResponse>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_TokenResponse(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Microsoft::Security::Authentication::OAuth::TokenResponse>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_TokenResponse[] = {
        { "_assign_array_", _assign_array_TokenResponse, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_TokenResponse), METH_O | METH_STATIC, nullptr },
        { }};

    static PyGetSetDef _getset_TokenResponse[] = {
        { "access_token", reinterpret_cast<getter>(TokenResponse_get_AccessToken), nullptr, nullptr, nullptr },
        { "additional_params", reinterpret_cast<getter>(TokenResponse_get_AdditionalParams), nullptr, nullptr, nullptr },
        { "expires_in", reinterpret_cast<getter>(TokenResponse_get_ExpiresIn), nullptr, nullptr, nullptr },
        { "refresh_token", reinterpret_cast<getter>(TokenResponse_get_RefreshToken), nullptr, nullptr, nullptr },
        { "scope", reinterpret_cast<getter>(TokenResponse_get_Scope), nullptr, nullptr, nullptr },
        { "token_type", reinterpret_cast<getter>(TokenResponse_get_TokenType), nullptr, nullptr, nullptr },
        { }};

    static PyType_Slot _type_slots_TokenResponse[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_TokenResponse) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_TokenResponse) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_TokenResponse) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_TokenResponse) },
        { }};

    static PyType_Spec type_spec_TokenResponse = {
        "winui3._winui3_microsoft_security_authentication_oauth.TokenResponse",
        sizeof(py::wrapper::Microsoft::Security::Authentication::OAuth::TokenResponse),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_TokenResponse};

    // ----- Microsoft.Security.Authentication.OAuth Initialization --------------------

    PyDoc_STRVAR(module_doc, "Microsoft.Security.Authentication.OAuth");

    static PyModuleDef module_def = {
        PyModuleDef_HEAD_INIT,
        "_winui3_microsoft_security_authentication_oauth",
        module_doc,
        0,
        nullptr,
        nullptr,
        nullptr,
        nullptr,
        nullptr};
} // py::cpp::Microsoft::Security::Authentication::OAuth

PyMODINIT_FUNC PyInit__winui3_microsoft_security_authentication_oauth(void) noexcept
{
    using namespace py::cpp::Microsoft::Security::Authentication::OAuth;

    if (py::import_winrt_runtime() == -1)
    {
        return nullptr;
    }

    py::pyobj_handle module{PyModule_Create(&module_def)};

    if (!module)
    {
        return nullptr;
    }

    auto inspectable_meta_type = py::get_inspectable_meta_type();
    if (!inspectable_meta_type)
    {
        return nullptr;
    }

    auto object_type = py::get_object_type();
    if (!object_type)
    {
        return nullptr;
    }

    py::pyobj_handle object_bases{PyTuple_Pack(1, object_type)};

    if (!object_bases)
    {
        return nullptr;
    }

    py::pytype_handle AuthFailure_type{py::register_python_type(module.get(), &type_spec_AuthFailure, object_bases.get(), inspectable_meta_type)};
    if (!AuthFailure_type)
    {
        return nullptr;
    }

    py::pyobj_handle AuthRequestParams_Static_bases{PyTuple_Pack(1, reinterpret_cast<PyObject*>(inspectable_meta_type))};
    if (!AuthRequestParams_Static_bases)
    {
        return nullptr;
    }

    py::pyobj_handle type_AuthRequestParams_Static{PyType_FromSpecWithBases(&type_spec_AuthRequestParams_Static, AuthRequestParams_Static_bases.get())};
    if (!type_AuthRequestParams_Static)
    {
        return nullptr;
    }

    py::pytype_handle AuthRequestParams_type{py::register_python_type(module.get(), &type_spec_AuthRequestParams, object_bases.get(), reinterpret_cast<PyTypeObject*>(type_AuthRequestParams_Static.get()))};
    if (!AuthRequestParams_type)
    {
        return nullptr;
    }

    py::pytype_handle AuthRequestResult_type{py::register_python_type(module.get(), &type_spec_AuthRequestResult, object_bases.get(), inspectable_meta_type)};
    if (!AuthRequestResult_type)
    {
        return nullptr;
    }

    py::pytype_handle AuthResponse_type{py::register_python_type(module.get(), &type_spec_AuthResponse, object_bases.get(), inspectable_meta_type)};
    if (!AuthResponse_type)
    {
        return nullptr;
    }

    py::pyobj_handle ClientAuthentication_Static_bases{PyTuple_Pack(1, reinterpret_cast<PyObject*>(inspectable_meta_type))};
    if (!ClientAuthentication_Static_bases)
    {
        return nullptr;
    }

    py::pyobj_handle type_ClientAuthentication_Static{PyType_FromSpecWithBases(&type_spec_ClientAuthentication_Static, ClientAuthentication_Static_bases.get())};
    if (!type_ClientAuthentication_Static)
    {
        return nullptr;
    }

    py::pytype_handle ClientAuthentication_type{py::register_python_type(module.get(), &type_spec_ClientAuthentication, object_bases.get(), reinterpret_cast<PyTypeObject*>(type_ClientAuthentication_Static.get()))};
    if (!ClientAuthentication_type)
    {
        return nullptr;
    }

    py::pyobj_handle OAuth2Manager_Static_bases{PyTuple_Pack(1, reinterpret_cast<PyObject*>(inspectable_meta_type))};
    if (!OAuth2Manager_Static_bases)
    {
        return nullptr;
    }

    py::pyobj_handle type_OAuth2Manager_Static{PyType_FromSpecWithBases(&type_spec_OAuth2Manager_Static, OAuth2Manager_Static_bases.get())};
    if (!type_OAuth2Manager_Static)
    {
        return nullptr;
    }

    py::pytype_handle OAuth2Manager_type{py::register_python_type(module.get(), &type_spec_OAuth2Manager, object_bases.get(), reinterpret_cast<PyTypeObject*>(type_OAuth2Manager_Static.get()))};
    if (!OAuth2Manager_type)
    {
        return nullptr;
    }

    py::pytype_handle TokenFailure_type{py::register_python_type(module.get(), &type_spec_TokenFailure, object_bases.get(), inspectable_meta_type)};
    if (!TokenFailure_type)
    {
        return nullptr;
    }

    py::pyobj_handle TokenRequestParams_Static_bases{PyTuple_Pack(1, reinterpret_cast<PyObject*>(inspectable_meta_type))};
    if (!TokenRequestParams_Static_bases)
    {
        return nullptr;
    }

    py::pyobj_handle type_TokenRequestParams_Static{PyType_FromSpecWithBases(&type_spec_TokenRequestParams_Static, TokenRequestParams_Static_bases.get())};
    if (!type_TokenRequestParams_Static)
    {
        return nullptr;
    }

    py::pytype_handle TokenRequestParams_type{py::register_python_type(module.get(), &type_spec_TokenRequestParams, object_bases.get(), reinterpret_cast<PyTypeObject*>(type_TokenRequestParams_Static.get()))};
    if (!TokenRequestParams_type)
    {
        return nullptr;
    }

    py::pytype_handle TokenRequestResult_type{py::register_python_type(module.get(), &type_spec_TokenRequestResult, object_bases.get(), inspectable_meta_type)};
    if (!TokenRequestResult_type)
    {
        return nullptr;
    }

    py::pytype_handle TokenResponse_type{py::register_python_type(module.get(), &type_spec_TokenResponse, object_bases.get(), inspectable_meta_type)};
    if (!TokenResponse_type)
    {
        return nullptr;
    }


    return module.detach();
}
