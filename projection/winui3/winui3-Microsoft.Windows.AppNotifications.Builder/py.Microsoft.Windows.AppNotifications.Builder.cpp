// WARNING: Please don't edit this file. It was generated by Python/WinRT v3.2.1

#include "py.Microsoft.Windows.AppNotifications.Builder.h"

namespace py::cpp::Microsoft::Windows::AppNotifications::Builder
{
    // ----- AppNotificationBuilder class --------------------

    static PyObject* _new_AppNotificationBuilder(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_GET_SIZE(args);
        if (arg_count == 0)
        {
            try
            {
                winrt::Microsoft::Windows::AppNotifications::Builder::AppNotificationBuilder instance{};
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_AppNotificationBuilder(py::wrapper::Microsoft::Windows::AppNotifications::Builder::AppNotificationBuilder* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* AppNotificationBuilder_AddArgument(py::wrapper::Microsoft::Windows::AppNotifications::Builder::AppNotificationBuilder* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 2)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.Windows.AppNotifications.Builder.AppNotificationBuilder", L"AddArgument", 2);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(2);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::hstring>(args, 1);

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return self->obj.AddArgument(param0, param1);
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AppNotificationBuilder_AddButton(py::wrapper::Microsoft::Windows::AppNotifications::Builder::AppNotificationBuilder* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.Windows.AppNotifications.Builder.AppNotificationBuilder", L"AddButton", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Microsoft::Windows::AppNotifications::Builder::AppNotificationButton>(args, 0);

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return self->obj.AddButton(param0);
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AppNotificationBuilder_AddComboBox(py::wrapper::Microsoft::Windows::AppNotifications::Builder::AppNotificationBuilder* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.Windows.AppNotifications.Builder.AppNotificationBuilder", L"AddComboBox", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Microsoft::Windows::AppNotifications::Builder::AppNotificationComboBox>(args, 0);

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return self->obj.AddComboBox(param0);
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AppNotificationBuilder_AddProgressBar(py::wrapper::Microsoft::Windows::AppNotifications::Builder::AppNotificationBuilder* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.Windows.AppNotifications.Builder.AppNotificationBuilder", L"AddProgressBar", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Microsoft::Windows::AppNotifications::Builder::AppNotificationProgressBar>(args, 0);

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return self->obj.AddProgressBar(param0);
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AppNotificationBuilder_AddText(py::wrapper::Microsoft::Windows::AppNotifications::Builder::AppNotificationBuilder* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.Windows.AppNotifications.Builder.AppNotificationBuilder", L"AddText", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return self->obj.AddText(param0);
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AppNotificationBuilder_AddText2(py::wrapper::Microsoft::Windows::AppNotifications::Builder::AppNotificationBuilder* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 2)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.Windows.AppNotifications.Builder.AppNotificationBuilder", L"AddText", 2);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(2);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::Microsoft::Windows::AppNotifications::Builder::AppNotificationTextProperties>(args, 1);

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return self->obj.AddText(param0, param1);
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AppNotificationBuilder_AddTextBox(py::wrapper::Microsoft::Windows::AppNotifications::Builder::AppNotificationBuilder* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.Windows.AppNotifications.Builder.AppNotificationBuilder", L"AddTextBox", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return self->obj.AddTextBox(param0);
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AppNotificationBuilder_AddTextBox2(py::wrapper::Microsoft::Windows::AppNotifications::Builder::AppNotificationBuilder* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 3)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.Windows.AppNotifications.Builder.AppNotificationBuilder", L"AddTextBox", 3);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(3);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::hstring>(args, 1);
                auto param2 = py::convert_to<winrt::hstring>(args, 2);

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return self->obj.AddTextBox(param0, param1, param2);
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AppNotificationBuilder_BuildNotification(py::wrapper::Microsoft::Windows::AppNotifications::Builder::AppNotificationBuilder* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.Windows.AppNotifications.Builder.AppNotificationBuilder", L"BuildNotification", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return self->obj.BuildNotification();
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AppNotificationBuilder_IsUrgentScenarioSupported(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.Windows.AppNotifications.Builder.AppNotificationBuilder", L"IsUrgentScenarioSupported", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return winrt::Microsoft::Windows::AppNotifications::Builder::AppNotificationBuilder::IsUrgentScenarioSupported();
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AppNotificationBuilder_MuteAudio(py::wrapper::Microsoft::Windows::AppNotifications::Builder::AppNotificationBuilder* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.Windows.AppNotifications.Builder.AppNotificationBuilder", L"MuteAudio", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return self->obj.MuteAudio();
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AppNotificationBuilder_SetAppLogoOverride(py::wrapper::Microsoft::Windows::AppNotifications::Builder::AppNotificationBuilder* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.Windows.AppNotifications.Builder.AppNotificationBuilder", L"SetAppLogoOverride", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Foundation::Uri>(args, 0);

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return self->obj.SetAppLogoOverride(param0);
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AppNotificationBuilder_SetAppLogoOverride2(py::wrapper::Microsoft::Windows::AppNotifications::Builder::AppNotificationBuilder* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 2)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.Windows.AppNotifications.Builder.AppNotificationBuilder", L"SetAppLogoOverride", 2);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(2);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Foundation::Uri>(args, 0);
                auto param1 = py::convert_to<winrt::Microsoft::Windows::AppNotifications::Builder::AppNotificationImageCrop>(args, 1);

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return self->obj.SetAppLogoOverride(param0, param1);
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AppNotificationBuilder_SetAppLogoOverride3(py::wrapper::Microsoft::Windows::AppNotifications::Builder::AppNotificationBuilder* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 3)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.Windows.AppNotifications.Builder.AppNotificationBuilder", L"SetAppLogoOverride", 3);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(3);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Foundation::Uri>(args, 0);
                auto param1 = py::convert_to<winrt::Microsoft::Windows::AppNotifications::Builder::AppNotificationImageCrop>(args, 1);
                auto param2 = py::convert_to<winrt::hstring>(args, 2);

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return self->obj.SetAppLogoOverride(param0, param1, param2);
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AppNotificationBuilder_SetAttributionText(py::wrapper::Microsoft::Windows::AppNotifications::Builder::AppNotificationBuilder* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.Windows.AppNotifications.Builder.AppNotificationBuilder", L"SetAttributionText", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return self->obj.SetAttributionText(param0);
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AppNotificationBuilder_SetAttributionText2(py::wrapper::Microsoft::Windows::AppNotifications::Builder::AppNotificationBuilder* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 2)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.Windows.AppNotifications.Builder.AppNotificationBuilder", L"SetAttributionText", 2);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(2);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::hstring>(args, 1);

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return self->obj.SetAttributionText(param0, param1);
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AppNotificationBuilder_SetAudioEvent(py::wrapper::Microsoft::Windows::AppNotifications::Builder::AppNotificationBuilder* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.Windows.AppNotifications.Builder.AppNotificationBuilder", L"SetAudioEvent", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Microsoft::Windows::AppNotifications::Builder::AppNotificationSoundEvent>(args, 0);

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return self->obj.SetAudioEvent(param0);
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AppNotificationBuilder_SetAudioEvent2(py::wrapper::Microsoft::Windows::AppNotifications::Builder::AppNotificationBuilder* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 2)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.Windows.AppNotifications.Builder.AppNotificationBuilder", L"SetAudioEvent", 2);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(2);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Microsoft::Windows::AppNotifications::Builder::AppNotificationSoundEvent>(args, 0);
                auto param1 = py::convert_to<winrt::Microsoft::Windows::AppNotifications::Builder::AppNotificationAudioLooping>(args, 1);

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return self->obj.SetAudioEvent(param0, param1);
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AppNotificationBuilder_SetAudioUri(py::wrapper::Microsoft::Windows::AppNotifications::Builder::AppNotificationBuilder* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.Windows.AppNotifications.Builder.AppNotificationBuilder", L"SetAudioUri", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Foundation::Uri>(args, 0);

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return self->obj.SetAudioUri(param0);
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AppNotificationBuilder_SetAudioUri2(py::wrapper::Microsoft::Windows::AppNotifications::Builder::AppNotificationBuilder* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 2)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.Windows.AppNotifications.Builder.AppNotificationBuilder", L"SetAudioUri", 2);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(2);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Foundation::Uri>(args, 0);
                auto param1 = py::convert_to<winrt::Microsoft::Windows::AppNotifications::Builder::AppNotificationAudioLooping>(args, 1);

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return self->obj.SetAudioUri(param0, param1);
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AppNotificationBuilder_SetDuration(py::wrapper::Microsoft::Windows::AppNotifications::Builder::AppNotificationBuilder* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.Windows.AppNotifications.Builder.AppNotificationBuilder", L"SetDuration", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Microsoft::Windows::AppNotifications::Builder::AppNotificationDuration>(args, 0);

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return self->obj.SetDuration(param0);
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AppNotificationBuilder_SetGroup(py::wrapper::Microsoft::Windows::AppNotifications::Builder::AppNotificationBuilder* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.Windows.AppNotifications.Builder.AppNotificationBuilder", L"SetGroup", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return self->obj.SetGroup(param0);
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AppNotificationBuilder_SetHeroImage(py::wrapper::Microsoft::Windows::AppNotifications::Builder::AppNotificationBuilder* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.Windows.AppNotifications.Builder.AppNotificationBuilder", L"SetHeroImage", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Foundation::Uri>(args, 0);

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return self->obj.SetHeroImage(param0);
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AppNotificationBuilder_SetHeroImage2(py::wrapper::Microsoft::Windows::AppNotifications::Builder::AppNotificationBuilder* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 2)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.Windows.AppNotifications.Builder.AppNotificationBuilder", L"SetHeroImage", 2);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(2);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Foundation::Uri>(args, 0);
                auto param1 = py::convert_to<winrt::hstring>(args, 1);

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return self->obj.SetHeroImage(param0, param1);
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AppNotificationBuilder_SetInlineImage(py::wrapper::Microsoft::Windows::AppNotifications::Builder::AppNotificationBuilder* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.Windows.AppNotifications.Builder.AppNotificationBuilder", L"SetInlineImage", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Foundation::Uri>(args, 0);

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return self->obj.SetInlineImage(param0);
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AppNotificationBuilder_SetInlineImage2(py::wrapper::Microsoft::Windows::AppNotifications::Builder::AppNotificationBuilder* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 2)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.Windows.AppNotifications.Builder.AppNotificationBuilder", L"SetInlineImage", 2);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(2);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Foundation::Uri>(args, 0);
                auto param1 = py::convert_to<winrt::Microsoft::Windows::AppNotifications::Builder::AppNotificationImageCrop>(args, 1);

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return self->obj.SetInlineImage(param0, param1);
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AppNotificationBuilder_SetInlineImage3(py::wrapper::Microsoft::Windows::AppNotifications::Builder::AppNotificationBuilder* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 3)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.Windows.AppNotifications.Builder.AppNotificationBuilder", L"SetInlineImage", 3);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(3);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Foundation::Uri>(args, 0);
                auto param1 = py::convert_to<winrt::Microsoft::Windows::AppNotifications::Builder::AppNotificationImageCrop>(args, 1);
                auto param2 = py::convert_to<winrt::hstring>(args, 2);

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return self->obj.SetInlineImage(param0, param1, param2);
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AppNotificationBuilder_SetScenario(py::wrapper::Microsoft::Windows::AppNotifications::Builder::AppNotificationBuilder* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.Windows.AppNotifications.Builder.AppNotificationBuilder", L"SetScenario", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Microsoft::Windows::AppNotifications::Builder::AppNotificationScenario>(args, 0);

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return self->obj.SetScenario(param0);
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AppNotificationBuilder_SetTag(py::wrapper::Microsoft::Windows::AppNotifications::Builder::AppNotificationBuilder* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.Windows.AppNotifications.Builder.AppNotificationBuilder", L"SetTag", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return self->obj.SetTag(param0);
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AppNotificationBuilder_SetTimeStamp(py::wrapper::Microsoft::Windows::AppNotifications::Builder::AppNotificationBuilder* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.Windows.AppNotifications.Builder.AppNotificationBuilder", L"SetTimeStamp", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Foundation::DateTime>(args, 0);

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return self->obj.SetTimeStamp(param0);
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* _assign_array_AppNotificationBuilder(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Microsoft::Windows::AppNotifications::Builder::AppNotificationBuilder>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_AppNotificationBuilder(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Microsoft::Windows::AppNotifications::Builder::AppNotificationBuilder>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_AppNotificationBuilder[] = {
        { "add_argument", reinterpret_cast<PyCFunction>(AppNotificationBuilder_AddArgument), METH_VARARGS, nullptr },
        { "add_button", reinterpret_cast<PyCFunction>(AppNotificationBuilder_AddButton), METH_VARARGS, nullptr },
        { "add_combo_box", reinterpret_cast<PyCFunction>(AppNotificationBuilder_AddComboBox), METH_VARARGS, nullptr },
        { "add_progress_bar", reinterpret_cast<PyCFunction>(AppNotificationBuilder_AddProgressBar), METH_VARARGS, nullptr },
        { "add_text", reinterpret_cast<PyCFunction>(AppNotificationBuilder_AddText), METH_VARARGS, nullptr },
        { "add_text2", reinterpret_cast<PyCFunction>(AppNotificationBuilder_AddText2), METH_VARARGS, nullptr },
        { "add_text_box", reinterpret_cast<PyCFunction>(AppNotificationBuilder_AddTextBox), METH_VARARGS, nullptr },
        { "add_text_box2", reinterpret_cast<PyCFunction>(AppNotificationBuilder_AddTextBox2), METH_VARARGS, nullptr },
        { "build_notification", reinterpret_cast<PyCFunction>(AppNotificationBuilder_BuildNotification), METH_VARARGS, nullptr },
        { "mute_audio", reinterpret_cast<PyCFunction>(AppNotificationBuilder_MuteAudio), METH_VARARGS, nullptr },
        { "set_app_logo_override", reinterpret_cast<PyCFunction>(AppNotificationBuilder_SetAppLogoOverride), METH_VARARGS, nullptr },
        { "set_app_logo_override2", reinterpret_cast<PyCFunction>(AppNotificationBuilder_SetAppLogoOverride2), METH_VARARGS, nullptr },
        { "set_app_logo_override3", reinterpret_cast<PyCFunction>(AppNotificationBuilder_SetAppLogoOverride3), METH_VARARGS, nullptr },
        { "set_attribution_text", reinterpret_cast<PyCFunction>(AppNotificationBuilder_SetAttributionText), METH_VARARGS, nullptr },
        { "set_attribution_text2", reinterpret_cast<PyCFunction>(AppNotificationBuilder_SetAttributionText2), METH_VARARGS, nullptr },
        { "set_audio_event", reinterpret_cast<PyCFunction>(AppNotificationBuilder_SetAudioEvent), METH_VARARGS, nullptr },
        { "set_audio_event2", reinterpret_cast<PyCFunction>(AppNotificationBuilder_SetAudioEvent2), METH_VARARGS, nullptr },
        { "set_audio_uri", reinterpret_cast<PyCFunction>(AppNotificationBuilder_SetAudioUri), METH_VARARGS, nullptr },
        { "set_audio_uri2", reinterpret_cast<PyCFunction>(AppNotificationBuilder_SetAudioUri2), METH_VARARGS, nullptr },
        { "set_duration", reinterpret_cast<PyCFunction>(AppNotificationBuilder_SetDuration), METH_VARARGS, nullptr },
        { "set_group", reinterpret_cast<PyCFunction>(AppNotificationBuilder_SetGroup), METH_VARARGS, nullptr },
        { "set_hero_image", reinterpret_cast<PyCFunction>(AppNotificationBuilder_SetHeroImage), METH_VARARGS, nullptr },
        { "set_hero_image2", reinterpret_cast<PyCFunction>(AppNotificationBuilder_SetHeroImage2), METH_VARARGS, nullptr },
        { "set_inline_image", reinterpret_cast<PyCFunction>(AppNotificationBuilder_SetInlineImage), METH_VARARGS, nullptr },
        { "set_inline_image2", reinterpret_cast<PyCFunction>(AppNotificationBuilder_SetInlineImage2), METH_VARARGS, nullptr },
        { "set_inline_image3", reinterpret_cast<PyCFunction>(AppNotificationBuilder_SetInlineImage3), METH_VARARGS, nullptr },
        { "set_scenario", reinterpret_cast<PyCFunction>(AppNotificationBuilder_SetScenario), METH_VARARGS, nullptr },
        { "set_tag", reinterpret_cast<PyCFunction>(AppNotificationBuilder_SetTag), METH_VARARGS, nullptr },
        { "set_time_stamp", reinterpret_cast<PyCFunction>(AppNotificationBuilder_SetTimeStamp), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_AppNotificationBuilder, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_AppNotificationBuilder), METH_O | METH_STATIC, nullptr },
        { }};

    static PyGetSetDef _getset_AppNotificationBuilder[] = {
        { }};

    static PyType_Slot _type_slots_AppNotificationBuilder[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_AppNotificationBuilder) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_AppNotificationBuilder) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_AppNotificationBuilder) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_AppNotificationBuilder) },
        { }};

    static PyType_Spec type_spec_AppNotificationBuilder = {
        "winui3._winui3_microsoft_windows_appnotifications_builder.AppNotificationBuilder",
        sizeof(py::wrapper::Microsoft::Windows::AppNotifications::Builder::AppNotificationBuilder),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_AppNotificationBuilder};

    static PyGetSetDef getset_AppNotificationBuilder_Static[] = {
        { }};

    static PyMethodDef methods_AppNotificationBuilder_Static[] = {
        { "is_urgent_scenario_supported", reinterpret_cast<PyCFunction>(AppNotificationBuilder_IsUrgentScenarioSupported), METH_VARARGS, nullptr },
        { }};

    static PyType_Slot type_slots_AppNotificationBuilder_Static[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_AppNotificationBuilder_Static) },
        { Py_tp_methods, reinterpret_cast<void*>(methods_AppNotificationBuilder_Static) },
        { }
    };

    static PyType_Spec type_spec_AppNotificationBuilder_Static = {
        "winui3._winui3_microsoft_windows_appnotifications_builder.AppNotificationBuilder_Static",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT,
        type_slots_AppNotificationBuilder_Static};

    // ----- AppNotificationButton class --------------------

    static PyObject* _new_AppNotificationButton(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_GET_SIZE(args);
        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                winrt::Microsoft::Windows::AppNotifications::Builder::AppNotificationButton instance{param0};
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 0)
        {
            try
            {
                winrt::Microsoft::Windows::AppNotifications::Builder::AppNotificationButton instance{};
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_AppNotificationButton(py::wrapper::Microsoft::Windows::AppNotifications::Builder::AppNotificationButton* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* AppNotificationButton_AddArgument(py::wrapper::Microsoft::Windows::AppNotifications::Builder::AppNotificationButton* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 2)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.Windows.AppNotifications.Builder.AppNotificationButton", L"AddArgument", 2);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(2);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::hstring>(args, 1);

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return self->obj.AddArgument(param0, param1);
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AppNotificationButton_IsButtonStyleSupported(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.Windows.AppNotifications.Builder.AppNotificationButton", L"IsButtonStyleSupported", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return winrt::Microsoft::Windows::AppNotifications::Builder::AppNotificationButton::IsButtonStyleSupported();
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AppNotificationButton_IsToolTipSupported(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.Windows.AppNotifications.Builder.AppNotificationButton", L"IsToolTipSupported", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return winrt::Microsoft::Windows::AppNotifications::Builder::AppNotificationButton::IsToolTipSupported();
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AppNotificationButton_SetButtonStyle(py::wrapper::Microsoft::Windows::AppNotifications::Builder::AppNotificationButton* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.Windows.AppNotifications.Builder.AppNotificationButton", L"SetButtonStyle", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Microsoft::Windows::AppNotifications::Builder::AppNotificationButtonStyle>(args, 0);

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return self->obj.SetButtonStyle(param0);
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AppNotificationButton_SetContextMenuPlacement(py::wrapper::Microsoft::Windows::AppNotifications::Builder::AppNotificationButton* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.Windows.AppNotifications.Builder.AppNotificationButton", L"SetContextMenuPlacement", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return self->obj.SetContextMenuPlacement();
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AppNotificationButton_SetIcon(py::wrapper::Microsoft::Windows::AppNotifications::Builder::AppNotificationButton* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.Windows.AppNotifications.Builder.AppNotificationButton", L"SetIcon", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Foundation::Uri>(args, 0);

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return self->obj.SetIcon(param0);
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AppNotificationButton_SetInputId(py::wrapper::Microsoft::Windows::AppNotifications::Builder::AppNotificationButton* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.Windows.AppNotifications.Builder.AppNotificationButton", L"SetInputId", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return self->obj.SetInputId(param0);
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AppNotificationButton_SetInvokeUri(py::wrapper::Microsoft::Windows::AppNotifications::Builder::AppNotificationButton* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.Windows.AppNotifications.Builder.AppNotificationButton", L"SetInvokeUri", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Foundation::Uri>(args, 0);

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return self->obj.SetInvokeUri(param0);
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AppNotificationButton_SetInvokeUri2(py::wrapper::Microsoft::Windows::AppNotifications::Builder::AppNotificationButton* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 2)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.Windows.AppNotifications.Builder.AppNotificationButton", L"SetInvokeUri", 2);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(2);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Foundation::Uri>(args, 0);
                auto param1 = py::convert_to<winrt::hstring>(args, 1);

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return self->obj.SetInvokeUri(param0, param1);
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AppNotificationButton_SetToolTip(py::wrapper::Microsoft::Windows::AppNotifications::Builder::AppNotificationButton* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.Windows.AppNotifications.Builder.AppNotificationButton", L"SetToolTip", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return self->obj.SetToolTip(param0);
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AppNotificationButton_get_ToolTip(py::wrapper::Microsoft::Windows::AppNotifications::Builder::AppNotificationButton* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.Windows.AppNotifications.Builder.AppNotificationButton", L"ToolTip");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.ToolTip();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int AppNotificationButton_put_ToolTip(py::wrapper::Microsoft::Windows::AppNotifications::Builder::AppNotificationButton* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.Windows.AppNotifications.Builder.AppNotificationButton", L"ToolTip");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::hstring>(arg);

            {
                auto _gil = release_gil();
                self->obj.ToolTip(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* AppNotificationButton_get_TargetAppId(py::wrapper::Microsoft::Windows::AppNotifications::Builder::AppNotificationButton* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.Windows.AppNotifications.Builder.AppNotificationButton", L"TargetAppId");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.TargetAppId();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int AppNotificationButton_put_TargetAppId(py::wrapper::Microsoft::Windows::AppNotifications::Builder::AppNotificationButton* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.Windows.AppNotifications.Builder.AppNotificationButton", L"TargetAppId");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::hstring>(arg);

            {
                auto _gil = release_gil();
                self->obj.TargetAppId(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* AppNotificationButton_get_InvokeUri(py::wrapper::Microsoft::Windows::AppNotifications::Builder::AppNotificationButton* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.Windows.AppNotifications.Builder.AppNotificationButton", L"InvokeUri");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.InvokeUri();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int AppNotificationButton_put_InvokeUri(py::wrapper::Microsoft::Windows::AppNotifications::Builder::AppNotificationButton* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.Windows.AppNotifications.Builder.AppNotificationButton", L"InvokeUri");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::Uri>(arg);

            {
                auto _gil = release_gil();
                self->obj.InvokeUri(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* AppNotificationButton_get_InputId(py::wrapper::Microsoft::Windows::AppNotifications::Builder::AppNotificationButton* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.Windows.AppNotifications.Builder.AppNotificationButton", L"InputId");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.InputId();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int AppNotificationButton_put_InputId(py::wrapper::Microsoft::Windows::AppNotifications::Builder::AppNotificationButton* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.Windows.AppNotifications.Builder.AppNotificationButton", L"InputId");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::hstring>(arg);

            {
                auto _gil = release_gil();
                self->obj.InputId(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* AppNotificationButton_get_Icon(py::wrapper::Microsoft::Windows::AppNotifications::Builder::AppNotificationButton* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.Windows.AppNotifications.Builder.AppNotificationButton", L"Icon");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Icon();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int AppNotificationButton_put_Icon(py::wrapper::Microsoft::Windows::AppNotifications::Builder::AppNotificationButton* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.Windows.AppNotifications.Builder.AppNotificationButton", L"Icon");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::Uri>(arg);

            {
                auto _gil = release_gil();
                self->obj.Icon(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* AppNotificationButton_get_ContextMenuPlacement(py::wrapper::Microsoft::Windows::AppNotifications::Builder::AppNotificationButton* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.Windows.AppNotifications.Builder.AppNotificationButton", L"ContextMenuPlacement");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.ContextMenuPlacement();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int AppNotificationButton_put_ContextMenuPlacement(py::wrapper::Microsoft::Windows::AppNotifications::Builder::AppNotificationButton* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.Windows.AppNotifications.Builder.AppNotificationButton", L"ContextMenuPlacement");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<bool>(arg);

            {
                auto _gil = release_gil();
                self->obj.ContextMenuPlacement(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* AppNotificationButton_get_Content(py::wrapper::Microsoft::Windows::AppNotifications::Builder::AppNotificationButton* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.Windows.AppNotifications.Builder.AppNotificationButton", L"Content");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Content();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int AppNotificationButton_put_Content(py::wrapper::Microsoft::Windows::AppNotifications::Builder::AppNotificationButton* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.Windows.AppNotifications.Builder.AppNotificationButton", L"Content");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::hstring>(arg);

            {
                auto _gil = release_gil();
                self->obj.Content(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* AppNotificationButton_get_ButtonStyle(py::wrapper::Microsoft::Windows::AppNotifications::Builder::AppNotificationButton* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.Windows.AppNotifications.Builder.AppNotificationButton", L"ButtonStyle");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.ButtonStyle();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int AppNotificationButton_put_ButtonStyle(py::wrapper::Microsoft::Windows::AppNotifications::Builder::AppNotificationButton* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.Windows.AppNotifications.Builder.AppNotificationButton", L"ButtonStyle");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Microsoft::Windows::AppNotifications::Builder::AppNotificationButtonStyle>(arg);

            {
                auto _gil = release_gil();
                self->obj.ButtonStyle(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* AppNotificationButton_get_Arguments(py::wrapper::Microsoft::Windows::AppNotifications::Builder::AppNotificationButton* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.Windows.AppNotifications.Builder.AppNotificationButton", L"Arguments");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Arguments();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int AppNotificationButton_put_Arguments(py::wrapper::Microsoft::Windows::AppNotifications::Builder::AppNotificationButton* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.Windows.AppNotifications.Builder.AppNotificationButton", L"Arguments");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::Collections::IMap<winrt::hstring, winrt::hstring>>(arg);

            {
                auto _gil = release_gil();
                self->obj.Arguments(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* _assign_array_AppNotificationButton(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Microsoft::Windows::AppNotifications::Builder::AppNotificationButton>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_AppNotificationButton(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Microsoft::Windows::AppNotifications::Builder::AppNotificationButton>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_AppNotificationButton[] = {
        { "add_argument", reinterpret_cast<PyCFunction>(AppNotificationButton_AddArgument), METH_VARARGS, nullptr },
        { "set_button_style", reinterpret_cast<PyCFunction>(AppNotificationButton_SetButtonStyle), METH_VARARGS, nullptr },
        { "set_context_menu_placement", reinterpret_cast<PyCFunction>(AppNotificationButton_SetContextMenuPlacement), METH_VARARGS, nullptr },
        { "set_icon", reinterpret_cast<PyCFunction>(AppNotificationButton_SetIcon), METH_VARARGS, nullptr },
        { "set_input_id", reinterpret_cast<PyCFunction>(AppNotificationButton_SetInputId), METH_VARARGS, nullptr },
        { "set_invoke_uri", reinterpret_cast<PyCFunction>(AppNotificationButton_SetInvokeUri), METH_VARARGS, nullptr },
        { "set_invoke_uri2", reinterpret_cast<PyCFunction>(AppNotificationButton_SetInvokeUri2), METH_VARARGS, nullptr },
        { "set_tool_tip", reinterpret_cast<PyCFunction>(AppNotificationButton_SetToolTip), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_AppNotificationButton, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_AppNotificationButton), METH_O | METH_STATIC, nullptr },
        { }};

    static PyGetSetDef _getset_AppNotificationButton[] = {
        { "tool_tip", reinterpret_cast<getter>(AppNotificationButton_get_ToolTip), reinterpret_cast<setter>(AppNotificationButton_put_ToolTip), nullptr, nullptr },
        { "target_app_id", reinterpret_cast<getter>(AppNotificationButton_get_TargetAppId), reinterpret_cast<setter>(AppNotificationButton_put_TargetAppId), nullptr, nullptr },
        { "invoke_uri", reinterpret_cast<getter>(AppNotificationButton_get_InvokeUri), reinterpret_cast<setter>(AppNotificationButton_put_InvokeUri), nullptr, nullptr },
        { "input_id", reinterpret_cast<getter>(AppNotificationButton_get_InputId), reinterpret_cast<setter>(AppNotificationButton_put_InputId), nullptr, nullptr },
        { "icon", reinterpret_cast<getter>(AppNotificationButton_get_Icon), reinterpret_cast<setter>(AppNotificationButton_put_Icon), nullptr, nullptr },
        { "context_menu_placement", reinterpret_cast<getter>(AppNotificationButton_get_ContextMenuPlacement), reinterpret_cast<setter>(AppNotificationButton_put_ContextMenuPlacement), nullptr, nullptr },
        { "content", reinterpret_cast<getter>(AppNotificationButton_get_Content), reinterpret_cast<setter>(AppNotificationButton_put_Content), nullptr, nullptr },
        { "button_style", reinterpret_cast<getter>(AppNotificationButton_get_ButtonStyle), reinterpret_cast<setter>(AppNotificationButton_put_ButtonStyle), nullptr, nullptr },
        { "arguments", reinterpret_cast<getter>(AppNotificationButton_get_Arguments), reinterpret_cast<setter>(AppNotificationButton_put_Arguments), nullptr, nullptr },
        { }};

    static PyType_Slot _type_slots_AppNotificationButton[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_AppNotificationButton) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_AppNotificationButton) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_AppNotificationButton) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_AppNotificationButton) },
        { }};

    static PyType_Spec type_spec_AppNotificationButton = {
        "winui3._winui3_microsoft_windows_appnotifications_builder.AppNotificationButton",
        sizeof(py::wrapper::Microsoft::Windows::AppNotifications::Builder::AppNotificationButton),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_AppNotificationButton};

    static PyGetSetDef getset_AppNotificationButton_Static[] = {
        { }};

    static PyMethodDef methods_AppNotificationButton_Static[] = {
        { "is_button_style_supported", reinterpret_cast<PyCFunction>(AppNotificationButton_IsButtonStyleSupported), METH_VARARGS, nullptr },
        { "is_tool_tip_supported", reinterpret_cast<PyCFunction>(AppNotificationButton_IsToolTipSupported), METH_VARARGS, nullptr },
        { }};

    static PyType_Slot type_slots_AppNotificationButton_Static[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_AppNotificationButton_Static) },
        { Py_tp_methods, reinterpret_cast<void*>(methods_AppNotificationButton_Static) },
        { }
    };

    static PyType_Spec type_spec_AppNotificationButton_Static = {
        "winui3._winui3_microsoft_windows_appnotifications_builder.AppNotificationButton_Static",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT,
        type_slots_AppNotificationButton_Static};

    // ----- AppNotificationComboBox class --------------------

    static PyObject* _new_AppNotificationComboBox(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_GET_SIZE(args);
        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                winrt::Microsoft::Windows::AppNotifications::Builder::AppNotificationComboBox instance{param0};
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_AppNotificationComboBox(py::wrapper::Microsoft::Windows::AppNotifications::Builder::AppNotificationComboBox* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* AppNotificationComboBox_AddItem(py::wrapper::Microsoft::Windows::AppNotifications::Builder::AppNotificationComboBox* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 2)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.Windows.AppNotifications.Builder.AppNotificationComboBox", L"AddItem", 2);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(2);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::hstring>(args, 1);

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return self->obj.AddItem(param0, param1);
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AppNotificationComboBox_SetSelectedItem(py::wrapper::Microsoft::Windows::AppNotifications::Builder::AppNotificationComboBox* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.Windows.AppNotifications.Builder.AppNotificationComboBox", L"SetSelectedItem", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return self->obj.SetSelectedItem(param0);
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AppNotificationComboBox_SetTitle(py::wrapper::Microsoft::Windows::AppNotifications::Builder::AppNotificationComboBox* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.Windows.AppNotifications.Builder.AppNotificationComboBox", L"SetTitle", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return self->obj.SetTitle(param0);
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AppNotificationComboBox_get_Title(py::wrapper::Microsoft::Windows::AppNotifications::Builder::AppNotificationComboBox* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.Windows.AppNotifications.Builder.AppNotificationComboBox", L"Title");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Title();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int AppNotificationComboBox_put_Title(py::wrapper::Microsoft::Windows::AppNotifications::Builder::AppNotificationComboBox* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.Windows.AppNotifications.Builder.AppNotificationComboBox", L"Title");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::hstring>(arg);

            {
                auto _gil = release_gil();
                self->obj.Title(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* AppNotificationComboBox_get_SelectedItem(py::wrapper::Microsoft::Windows::AppNotifications::Builder::AppNotificationComboBox* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.Windows.AppNotifications.Builder.AppNotificationComboBox", L"SelectedItem");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.SelectedItem();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int AppNotificationComboBox_put_SelectedItem(py::wrapper::Microsoft::Windows::AppNotifications::Builder::AppNotificationComboBox* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.Windows.AppNotifications.Builder.AppNotificationComboBox", L"SelectedItem");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::hstring>(arg);

            {
                auto _gil = release_gil();
                self->obj.SelectedItem(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* AppNotificationComboBox_get_Items(py::wrapper::Microsoft::Windows::AppNotifications::Builder::AppNotificationComboBox* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.Windows.AppNotifications.Builder.AppNotificationComboBox", L"Items");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Items();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int AppNotificationComboBox_put_Items(py::wrapper::Microsoft::Windows::AppNotifications::Builder::AppNotificationComboBox* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.Windows.AppNotifications.Builder.AppNotificationComboBox", L"Items");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::Collections::IMap<winrt::hstring, winrt::hstring>>(arg);

            {
                auto _gil = release_gil();
                self->obj.Items(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* _assign_array_AppNotificationComboBox(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Microsoft::Windows::AppNotifications::Builder::AppNotificationComboBox>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_AppNotificationComboBox(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Microsoft::Windows::AppNotifications::Builder::AppNotificationComboBox>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_AppNotificationComboBox[] = {
        { "add_item", reinterpret_cast<PyCFunction>(AppNotificationComboBox_AddItem), METH_VARARGS, nullptr },
        { "set_selected_item", reinterpret_cast<PyCFunction>(AppNotificationComboBox_SetSelectedItem), METH_VARARGS, nullptr },
        { "set_title", reinterpret_cast<PyCFunction>(AppNotificationComboBox_SetTitle), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_AppNotificationComboBox, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_AppNotificationComboBox), METH_O | METH_STATIC, nullptr },
        { }};

    static PyGetSetDef _getset_AppNotificationComboBox[] = {
        { "title", reinterpret_cast<getter>(AppNotificationComboBox_get_Title), reinterpret_cast<setter>(AppNotificationComboBox_put_Title), nullptr, nullptr },
        { "selected_item", reinterpret_cast<getter>(AppNotificationComboBox_get_SelectedItem), reinterpret_cast<setter>(AppNotificationComboBox_put_SelectedItem), nullptr, nullptr },
        { "items", reinterpret_cast<getter>(AppNotificationComboBox_get_Items), reinterpret_cast<setter>(AppNotificationComboBox_put_Items), nullptr, nullptr },
        { }};

    static PyType_Slot _type_slots_AppNotificationComboBox[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_AppNotificationComboBox) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_AppNotificationComboBox) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_AppNotificationComboBox) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_AppNotificationComboBox) },
        { }};

    static PyType_Spec type_spec_AppNotificationComboBox = {
        "winui3._winui3_microsoft_windows_appnotifications_builder.AppNotificationComboBox",
        sizeof(py::wrapper::Microsoft::Windows::AppNotifications::Builder::AppNotificationComboBox),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_AppNotificationComboBox};

    // ----- AppNotificationProgressBar class --------------------

    static PyObject* _new_AppNotificationProgressBar(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_GET_SIZE(args);
        if (arg_count == 0)
        {
            try
            {
                winrt::Microsoft::Windows::AppNotifications::Builder::AppNotificationProgressBar instance{};
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_AppNotificationProgressBar(py::wrapper::Microsoft::Windows::AppNotifications::Builder::AppNotificationProgressBar* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* AppNotificationProgressBar_BindStatus(py::wrapper::Microsoft::Windows::AppNotifications::Builder::AppNotificationProgressBar* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.Windows.AppNotifications.Builder.AppNotificationProgressBar", L"BindStatus", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return self->obj.BindStatus();
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AppNotificationProgressBar_BindTitle(py::wrapper::Microsoft::Windows::AppNotifications::Builder::AppNotificationProgressBar* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.Windows.AppNotifications.Builder.AppNotificationProgressBar", L"BindTitle", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return self->obj.BindTitle();
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AppNotificationProgressBar_BindValue(py::wrapper::Microsoft::Windows::AppNotifications::Builder::AppNotificationProgressBar* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.Windows.AppNotifications.Builder.AppNotificationProgressBar", L"BindValue", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return self->obj.BindValue();
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AppNotificationProgressBar_BindValueStringOverride(py::wrapper::Microsoft::Windows::AppNotifications::Builder::AppNotificationProgressBar* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.Windows.AppNotifications.Builder.AppNotificationProgressBar", L"BindValueStringOverride", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return self->obj.BindValueStringOverride();
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AppNotificationProgressBar_SetStatus(py::wrapper::Microsoft::Windows::AppNotifications::Builder::AppNotificationProgressBar* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.Windows.AppNotifications.Builder.AppNotificationProgressBar", L"SetStatus", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return self->obj.SetStatus(param0);
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AppNotificationProgressBar_SetTitle(py::wrapper::Microsoft::Windows::AppNotifications::Builder::AppNotificationProgressBar* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.Windows.AppNotifications.Builder.AppNotificationProgressBar", L"SetTitle", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return self->obj.SetTitle(param0);
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AppNotificationProgressBar_SetValue(py::wrapper::Microsoft::Windows::AppNotifications::Builder::AppNotificationProgressBar* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.Windows.AppNotifications.Builder.AppNotificationProgressBar", L"SetValue", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<double>(args, 0);

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return self->obj.SetValue(param0);
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AppNotificationProgressBar_SetValueStringOverride(py::wrapper::Microsoft::Windows::AppNotifications::Builder::AppNotificationProgressBar* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.Windows.AppNotifications.Builder.AppNotificationProgressBar", L"SetValueStringOverride", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return self->obj.SetValueStringOverride(param0);
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AppNotificationProgressBar_get_ValueStringOverride(py::wrapper::Microsoft::Windows::AppNotifications::Builder::AppNotificationProgressBar* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.Windows.AppNotifications.Builder.AppNotificationProgressBar", L"ValueStringOverride");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.ValueStringOverride();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int AppNotificationProgressBar_put_ValueStringOverride(py::wrapper::Microsoft::Windows::AppNotifications::Builder::AppNotificationProgressBar* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.Windows.AppNotifications.Builder.AppNotificationProgressBar", L"ValueStringOverride");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::hstring>(arg);

            {
                auto _gil = release_gil();
                self->obj.ValueStringOverride(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* AppNotificationProgressBar_get_Value(py::wrapper::Microsoft::Windows::AppNotifications::Builder::AppNotificationProgressBar* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.Windows.AppNotifications.Builder.AppNotificationProgressBar", L"Value");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Value();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int AppNotificationProgressBar_put_Value(py::wrapper::Microsoft::Windows::AppNotifications::Builder::AppNotificationProgressBar* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.Windows.AppNotifications.Builder.AppNotificationProgressBar", L"Value");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<double>(arg);

            {
                auto _gil = release_gil();
                self->obj.Value(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* AppNotificationProgressBar_get_Title(py::wrapper::Microsoft::Windows::AppNotifications::Builder::AppNotificationProgressBar* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.Windows.AppNotifications.Builder.AppNotificationProgressBar", L"Title");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Title();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int AppNotificationProgressBar_put_Title(py::wrapper::Microsoft::Windows::AppNotifications::Builder::AppNotificationProgressBar* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.Windows.AppNotifications.Builder.AppNotificationProgressBar", L"Title");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::hstring>(arg);

            {
                auto _gil = release_gil();
                self->obj.Title(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* AppNotificationProgressBar_get_Status(py::wrapper::Microsoft::Windows::AppNotifications::Builder::AppNotificationProgressBar* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.Windows.AppNotifications.Builder.AppNotificationProgressBar", L"Status");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Status();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int AppNotificationProgressBar_put_Status(py::wrapper::Microsoft::Windows::AppNotifications::Builder::AppNotificationProgressBar* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.Windows.AppNotifications.Builder.AppNotificationProgressBar", L"Status");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::hstring>(arg);

            {
                auto _gil = release_gil();
                self->obj.Status(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* _assign_array_AppNotificationProgressBar(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Microsoft::Windows::AppNotifications::Builder::AppNotificationProgressBar>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_AppNotificationProgressBar(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Microsoft::Windows::AppNotifications::Builder::AppNotificationProgressBar>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_AppNotificationProgressBar[] = {
        { "bind_status", reinterpret_cast<PyCFunction>(AppNotificationProgressBar_BindStatus), METH_VARARGS, nullptr },
        { "bind_title", reinterpret_cast<PyCFunction>(AppNotificationProgressBar_BindTitle), METH_VARARGS, nullptr },
        { "bind_value", reinterpret_cast<PyCFunction>(AppNotificationProgressBar_BindValue), METH_VARARGS, nullptr },
        { "bind_value_string_override", reinterpret_cast<PyCFunction>(AppNotificationProgressBar_BindValueStringOverride), METH_VARARGS, nullptr },
        { "set_status", reinterpret_cast<PyCFunction>(AppNotificationProgressBar_SetStatus), METH_VARARGS, nullptr },
        { "set_title", reinterpret_cast<PyCFunction>(AppNotificationProgressBar_SetTitle), METH_VARARGS, nullptr },
        { "set_value", reinterpret_cast<PyCFunction>(AppNotificationProgressBar_SetValue), METH_VARARGS, nullptr },
        { "set_value_string_override", reinterpret_cast<PyCFunction>(AppNotificationProgressBar_SetValueStringOverride), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_AppNotificationProgressBar, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_AppNotificationProgressBar), METH_O | METH_STATIC, nullptr },
        { }};

    static PyGetSetDef _getset_AppNotificationProgressBar[] = {
        { "value_string_override", reinterpret_cast<getter>(AppNotificationProgressBar_get_ValueStringOverride), reinterpret_cast<setter>(AppNotificationProgressBar_put_ValueStringOverride), nullptr, nullptr },
        { "value", reinterpret_cast<getter>(AppNotificationProgressBar_get_Value), reinterpret_cast<setter>(AppNotificationProgressBar_put_Value), nullptr, nullptr },
        { "title", reinterpret_cast<getter>(AppNotificationProgressBar_get_Title), reinterpret_cast<setter>(AppNotificationProgressBar_put_Title), nullptr, nullptr },
        { "status", reinterpret_cast<getter>(AppNotificationProgressBar_get_Status), reinterpret_cast<setter>(AppNotificationProgressBar_put_Status), nullptr, nullptr },
        { }};

    static PyType_Slot _type_slots_AppNotificationProgressBar[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_AppNotificationProgressBar) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_AppNotificationProgressBar) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_AppNotificationProgressBar) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_AppNotificationProgressBar) },
        { }};

    static PyType_Spec type_spec_AppNotificationProgressBar = {
        "winui3._winui3_microsoft_windows_appnotifications_builder.AppNotificationProgressBar",
        sizeof(py::wrapper::Microsoft::Windows::AppNotifications::Builder::AppNotificationProgressBar),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_AppNotificationProgressBar};

    // ----- AppNotificationTextProperties class --------------------

    static PyObject* _new_AppNotificationTextProperties(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_GET_SIZE(args);
        if (arg_count == 0)
        {
            try
            {
                winrt::Microsoft::Windows::AppNotifications::Builder::AppNotificationTextProperties instance{};
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_AppNotificationTextProperties(py::wrapper::Microsoft::Windows::AppNotifications::Builder::AppNotificationTextProperties* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* AppNotificationTextProperties_SetIncomingCallAlignment(py::wrapper::Microsoft::Windows::AppNotifications::Builder::AppNotificationTextProperties* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.Windows.AppNotifications.Builder.AppNotificationTextProperties", L"SetIncomingCallAlignment", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return self->obj.SetIncomingCallAlignment();
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AppNotificationTextProperties_SetLanguage(py::wrapper::Microsoft::Windows::AppNotifications::Builder::AppNotificationTextProperties* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.Windows.AppNotifications.Builder.AppNotificationTextProperties", L"SetLanguage", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return self->obj.SetLanguage(param0);
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AppNotificationTextProperties_SetMaxLines(py::wrapper::Microsoft::Windows::AppNotifications::Builder::AppNotificationTextProperties* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.Windows.AppNotifications.Builder.AppNotificationTextProperties", L"SetMaxLines", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<int32_t>(args, 0);

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return self->obj.SetMaxLines(param0);
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AppNotificationTextProperties_get_MaxLines(py::wrapper::Microsoft::Windows::AppNotifications::Builder::AppNotificationTextProperties* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.Windows.AppNotifications.Builder.AppNotificationTextProperties", L"MaxLines");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.MaxLines();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int AppNotificationTextProperties_put_MaxLines(py::wrapper::Microsoft::Windows::AppNotifications::Builder::AppNotificationTextProperties* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.Windows.AppNotifications.Builder.AppNotificationTextProperties", L"MaxLines");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<int32_t>(arg);

            {
                auto _gil = release_gil();
                self->obj.MaxLines(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* AppNotificationTextProperties_get_Language(py::wrapper::Microsoft::Windows::AppNotifications::Builder::AppNotificationTextProperties* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.Windows.AppNotifications.Builder.AppNotificationTextProperties", L"Language");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Language();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int AppNotificationTextProperties_put_Language(py::wrapper::Microsoft::Windows::AppNotifications::Builder::AppNotificationTextProperties* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.Windows.AppNotifications.Builder.AppNotificationTextProperties", L"Language");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::hstring>(arg);

            {
                auto _gil = release_gil();
                self->obj.Language(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* AppNotificationTextProperties_get_IncomingCallAlignment(py::wrapper::Microsoft::Windows::AppNotifications::Builder::AppNotificationTextProperties* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.Windows.AppNotifications.Builder.AppNotificationTextProperties", L"IncomingCallAlignment");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.IncomingCallAlignment();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int AppNotificationTextProperties_put_IncomingCallAlignment(py::wrapper::Microsoft::Windows::AppNotifications::Builder::AppNotificationTextProperties* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.Windows.AppNotifications.Builder.AppNotificationTextProperties", L"IncomingCallAlignment");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<bool>(arg);

            {
                auto _gil = release_gil();
                self->obj.IncomingCallAlignment(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* _assign_array_AppNotificationTextProperties(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Microsoft::Windows::AppNotifications::Builder::AppNotificationTextProperties>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_AppNotificationTextProperties(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Microsoft::Windows::AppNotifications::Builder::AppNotificationTextProperties>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_AppNotificationTextProperties[] = {
        { "set_incoming_call_alignment", reinterpret_cast<PyCFunction>(AppNotificationTextProperties_SetIncomingCallAlignment), METH_VARARGS, nullptr },
        { "set_language", reinterpret_cast<PyCFunction>(AppNotificationTextProperties_SetLanguage), METH_VARARGS, nullptr },
        { "set_max_lines", reinterpret_cast<PyCFunction>(AppNotificationTextProperties_SetMaxLines), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_AppNotificationTextProperties, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_AppNotificationTextProperties), METH_O | METH_STATIC, nullptr },
        { }};

    static PyGetSetDef _getset_AppNotificationTextProperties[] = {
        { "max_lines", reinterpret_cast<getter>(AppNotificationTextProperties_get_MaxLines), reinterpret_cast<setter>(AppNotificationTextProperties_put_MaxLines), nullptr, nullptr },
        { "language", reinterpret_cast<getter>(AppNotificationTextProperties_get_Language), reinterpret_cast<setter>(AppNotificationTextProperties_put_Language), nullptr, nullptr },
        { "incoming_call_alignment", reinterpret_cast<getter>(AppNotificationTextProperties_get_IncomingCallAlignment), reinterpret_cast<setter>(AppNotificationTextProperties_put_IncomingCallAlignment), nullptr, nullptr },
        { }};

    static PyType_Slot _type_slots_AppNotificationTextProperties[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_AppNotificationTextProperties) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_AppNotificationTextProperties) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_AppNotificationTextProperties) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_AppNotificationTextProperties) },
        { }};

    static PyType_Spec type_spec_AppNotificationTextProperties = {
        "winui3._winui3_microsoft_windows_appnotifications_builder.AppNotificationTextProperties",
        sizeof(py::wrapper::Microsoft::Windows::AppNotifications::Builder::AppNotificationTextProperties),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_AppNotificationTextProperties};

    // ----- Microsoft.Windows.AppNotifications.Builder Initialization --------------------

    PyDoc_STRVAR(module_doc, "Microsoft.Windows.AppNotifications.Builder");

    static PyModuleDef module_def = {
        PyModuleDef_HEAD_INIT,
        "_winui3_microsoft_windows_appnotifications_builder",
        module_doc,
        0,
        nullptr,
        nullptr,
        nullptr,
        nullptr,
        nullptr};
} // py::cpp::Microsoft::Windows::AppNotifications::Builder

PyMODINIT_FUNC PyInit__winui3_microsoft_windows_appnotifications_builder(void) noexcept
{
    using namespace py::cpp::Microsoft::Windows::AppNotifications::Builder;

    if (py::import_winrt_runtime() == -1)
    {
        return nullptr;
    }

    py::pyobj_handle module{PyModule_Create(&module_def)};

    if (!module)
    {
        return nullptr;
    }

    auto inspectable_meta_type = py::get_inspectable_meta_type();
    if (!inspectable_meta_type)
    {
        return nullptr;
    }

    auto object_type = py::get_object_type();
    if (!object_type)
    {
        return nullptr;
    }

    py::pyobj_handle object_bases{PyTuple_Pack(1, object_type)};

    if (!object_bases)
    {
        return nullptr;
    }

    py::pyobj_handle AppNotificationBuilder_Static_bases{PyTuple_Pack(1, reinterpret_cast<PyObject*>(inspectable_meta_type))};
    if (!AppNotificationBuilder_Static_bases)
    {
        return nullptr;
    }

    py::pyobj_handle type_AppNotificationBuilder_Static{PyType_FromSpecWithBases(&type_spec_AppNotificationBuilder_Static, AppNotificationBuilder_Static_bases.get())};
    if (!type_AppNotificationBuilder_Static)
    {
        return nullptr;
    }

    py::pytype_handle AppNotificationBuilder_type{py::register_python_type(module.get(), &type_spec_AppNotificationBuilder, object_bases.get(), reinterpret_cast<PyTypeObject*>(type_AppNotificationBuilder_Static.get()))};
    if (!AppNotificationBuilder_type)
    {
        return nullptr;
    }

    py::pyobj_handle AppNotificationButton_Static_bases{PyTuple_Pack(1, reinterpret_cast<PyObject*>(inspectable_meta_type))};
    if (!AppNotificationButton_Static_bases)
    {
        return nullptr;
    }

    py::pyobj_handle type_AppNotificationButton_Static{PyType_FromSpecWithBases(&type_spec_AppNotificationButton_Static, AppNotificationButton_Static_bases.get())};
    if (!type_AppNotificationButton_Static)
    {
        return nullptr;
    }

    py::pytype_handle AppNotificationButton_type{py::register_python_type(module.get(), &type_spec_AppNotificationButton, object_bases.get(), reinterpret_cast<PyTypeObject*>(type_AppNotificationButton_Static.get()))};
    if (!AppNotificationButton_type)
    {
        return nullptr;
    }

    py::pytype_handle AppNotificationComboBox_type{py::register_python_type(module.get(), &type_spec_AppNotificationComboBox, object_bases.get(), inspectable_meta_type)};
    if (!AppNotificationComboBox_type)
    {
        return nullptr;
    }

    py::pytype_handle AppNotificationProgressBar_type{py::register_python_type(module.get(), &type_spec_AppNotificationProgressBar, object_bases.get(), inspectable_meta_type)};
    if (!AppNotificationProgressBar_type)
    {
        return nullptr;
    }

    py::pytype_handle AppNotificationTextProperties_type{py::register_python_type(module.get(), &type_spec_AppNotificationTextProperties, object_bases.get(), inspectable_meta_type)};
    if (!AppNotificationTextProperties_type)
    {
        return nullptr;
    }


    return module.detach();
}
