// WARNING: Please don't edit this file. It was generated by Python/WinRT v0.0.0

#include "py.Microsoft.UI.Xaml.Controls.Primitives.h"


namespace py::cpp::Microsoft::UI::Xaml::Controls::Primitives
{
    // ----- AppBarButtonTemplateSettings class --------------------

    static PyObject* _new_AppBarButtonTemplateSettings(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Microsoft::UI::Xaml::Controls::Primitives::AppBarButtonTemplateSettings>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Microsoft::UI::Xaml::Controls::Primitives::AppBarButtonTemplateSettings>::type_name);
        return nullptr;
    }

    static void _dealloc_AppBarButtonTemplateSettings(py::wrapper::Microsoft::UI::Xaml::Controls::Primitives::AppBarButtonTemplateSettings* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* AppBarButtonTemplateSettings_get_KeyboardAcceleratorTextMinWidth(py::wrapper::Microsoft::UI::Xaml::Controls::Primitives::AppBarButtonTemplateSettings* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.AppBarButtonTemplateSettings", L"KeyboardAcceleratorTextMinWidth"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.KeyboardAcceleratorTextMinWidth());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_AppBarButtonTemplateSettings(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Microsoft::UI::Xaml::Controls::Primitives::AppBarButtonTemplateSettings>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_AppBarButtonTemplateSettings(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Microsoft::UI::Xaml::Controls::Primitives::AppBarButtonTemplateSettings>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_AppBarButtonTemplateSettings[] = {
        { "_assign_array_", _assign_array_AppBarButtonTemplateSettings, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_AppBarButtonTemplateSettings), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_AppBarButtonTemplateSettings[] = {
        { "keyboard_accelerator_text_min_width", reinterpret_cast<getter>(AppBarButtonTemplateSettings_get_KeyboardAcceleratorTextMinWidth), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_AppBarButtonTemplateSettings[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_AppBarButtonTemplateSettings) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_AppBarButtonTemplateSettings) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_AppBarButtonTemplateSettings) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_AppBarButtonTemplateSettings) },
        { },
    };

    static PyType_Spec type_spec_AppBarButtonTemplateSettings =
    {
        "winrt._winrt_microsoft_ui_xaml_controls_primitives.AppBarButtonTemplateSettings",
        sizeof(py::wrapper::Microsoft::UI::Xaml::Controls::Primitives::AppBarButtonTemplateSettings),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_AppBarButtonTemplateSettings
    };

    // ----- AppBarTemplateSettings class --------------------

    static PyObject* _new_AppBarTemplateSettings(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Microsoft::UI::Xaml::Controls::Primitives::AppBarTemplateSettings>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Microsoft::UI::Xaml::Controls::Primitives::AppBarTemplateSettings>::type_name);
        return nullptr;
    }

    static void _dealloc_AppBarTemplateSettings(py::wrapper::Microsoft::UI::Xaml::Controls::Primitives::AppBarTemplateSettings* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* AppBarTemplateSettings_get_ClipRect(py::wrapper::Microsoft::UI::Xaml::Controls::Primitives::AppBarTemplateSettings* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.AppBarTemplateSettings", L"ClipRect"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.ClipRect());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AppBarTemplateSettings_get_CompactRootMargin(py::wrapper::Microsoft::UI::Xaml::Controls::Primitives::AppBarTemplateSettings* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.AppBarTemplateSettings", L"CompactRootMargin"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.CompactRootMargin());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AppBarTemplateSettings_get_CompactVerticalDelta(py::wrapper::Microsoft::UI::Xaml::Controls::Primitives::AppBarTemplateSettings* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.AppBarTemplateSettings", L"CompactVerticalDelta"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.CompactVerticalDelta());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AppBarTemplateSettings_get_HiddenRootMargin(py::wrapper::Microsoft::UI::Xaml::Controls::Primitives::AppBarTemplateSettings* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.AppBarTemplateSettings", L"HiddenRootMargin"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.HiddenRootMargin());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AppBarTemplateSettings_get_HiddenVerticalDelta(py::wrapper::Microsoft::UI::Xaml::Controls::Primitives::AppBarTemplateSettings* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.AppBarTemplateSettings", L"HiddenVerticalDelta"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.HiddenVerticalDelta());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AppBarTemplateSettings_get_MinimalRootMargin(py::wrapper::Microsoft::UI::Xaml::Controls::Primitives::AppBarTemplateSettings* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.AppBarTemplateSettings", L"MinimalRootMargin"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.MinimalRootMargin());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AppBarTemplateSettings_get_MinimalVerticalDelta(py::wrapper::Microsoft::UI::Xaml::Controls::Primitives::AppBarTemplateSettings* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.AppBarTemplateSettings", L"MinimalVerticalDelta"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.MinimalVerticalDelta());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AppBarTemplateSettings_get_NegativeCompactVerticalDelta(py::wrapper::Microsoft::UI::Xaml::Controls::Primitives::AppBarTemplateSettings* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.AppBarTemplateSettings", L"NegativeCompactVerticalDelta"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.NegativeCompactVerticalDelta());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AppBarTemplateSettings_get_NegativeHiddenVerticalDelta(py::wrapper::Microsoft::UI::Xaml::Controls::Primitives::AppBarTemplateSettings* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.AppBarTemplateSettings", L"NegativeHiddenVerticalDelta"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.NegativeHiddenVerticalDelta());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AppBarTemplateSettings_get_NegativeMinimalVerticalDelta(py::wrapper::Microsoft::UI::Xaml::Controls::Primitives::AppBarTemplateSettings* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.AppBarTemplateSettings", L"NegativeMinimalVerticalDelta"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.NegativeMinimalVerticalDelta());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_AppBarTemplateSettings(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Microsoft::UI::Xaml::Controls::Primitives::AppBarTemplateSettings>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_AppBarTemplateSettings(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Microsoft::UI::Xaml::Controls::Primitives::AppBarTemplateSettings>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_AppBarTemplateSettings[] = {
        { "_assign_array_", _assign_array_AppBarTemplateSettings, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_AppBarTemplateSettings), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_AppBarTemplateSettings[] = {
        { "clip_rect", reinterpret_cast<getter>(AppBarTemplateSettings_get_ClipRect), nullptr, nullptr, nullptr },
        { "compact_root_margin", reinterpret_cast<getter>(AppBarTemplateSettings_get_CompactRootMargin), nullptr, nullptr, nullptr },
        { "compact_vertical_delta", reinterpret_cast<getter>(AppBarTemplateSettings_get_CompactVerticalDelta), nullptr, nullptr, nullptr },
        { "hidden_root_margin", reinterpret_cast<getter>(AppBarTemplateSettings_get_HiddenRootMargin), nullptr, nullptr, nullptr },
        { "hidden_vertical_delta", reinterpret_cast<getter>(AppBarTemplateSettings_get_HiddenVerticalDelta), nullptr, nullptr, nullptr },
        { "minimal_root_margin", reinterpret_cast<getter>(AppBarTemplateSettings_get_MinimalRootMargin), nullptr, nullptr, nullptr },
        { "minimal_vertical_delta", reinterpret_cast<getter>(AppBarTemplateSettings_get_MinimalVerticalDelta), nullptr, nullptr, nullptr },
        { "negative_compact_vertical_delta", reinterpret_cast<getter>(AppBarTemplateSettings_get_NegativeCompactVerticalDelta), nullptr, nullptr, nullptr },
        { "negative_hidden_vertical_delta", reinterpret_cast<getter>(AppBarTemplateSettings_get_NegativeHiddenVerticalDelta), nullptr, nullptr, nullptr },
        { "negative_minimal_vertical_delta", reinterpret_cast<getter>(AppBarTemplateSettings_get_NegativeMinimalVerticalDelta), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_AppBarTemplateSettings[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_AppBarTemplateSettings) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_AppBarTemplateSettings) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_AppBarTemplateSettings) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_AppBarTemplateSettings) },
        { },
    };

    static PyType_Spec type_spec_AppBarTemplateSettings =
    {
        "winrt._winrt_microsoft_ui_xaml_controls_primitives.AppBarTemplateSettings",
        sizeof(py::wrapper::Microsoft::UI::Xaml::Controls::Primitives::AppBarTemplateSettings),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_AppBarTemplateSettings
    };

    // ----- AppBarToggleButtonTemplateSettings class --------------------

    static PyObject* _new_AppBarToggleButtonTemplateSettings(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Microsoft::UI::Xaml::Controls::Primitives::AppBarToggleButtonTemplateSettings>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Microsoft::UI::Xaml::Controls::Primitives::AppBarToggleButtonTemplateSettings>::type_name);
        return nullptr;
    }

    static void _dealloc_AppBarToggleButtonTemplateSettings(py::wrapper::Microsoft::UI::Xaml::Controls::Primitives::AppBarToggleButtonTemplateSettings* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* AppBarToggleButtonTemplateSettings_get_KeyboardAcceleratorTextMinWidth(py::wrapper::Microsoft::UI::Xaml::Controls::Primitives::AppBarToggleButtonTemplateSettings* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.AppBarToggleButtonTemplateSettings", L"KeyboardAcceleratorTextMinWidth"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.KeyboardAcceleratorTextMinWidth());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_AppBarToggleButtonTemplateSettings(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Microsoft::UI::Xaml::Controls::Primitives::AppBarToggleButtonTemplateSettings>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_AppBarToggleButtonTemplateSettings(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Microsoft::UI::Xaml::Controls::Primitives::AppBarToggleButtonTemplateSettings>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_AppBarToggleButtonTemplateSettings[] = {
        { "_assign_array_", _assign_array_AppBarToggleButtonTemplateSettings, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_AppBarToggleButtonTemplateSettings), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_AppBarToggleButtonTemplateSettings[] = {
        { "keyboard_accelerator_text_min_width", reinterpret_cast<getter>(AppBarToggleButtonTemplateSettings_get_KeyboardAcceleratorTextMinWidth), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_AppBarToggleButtonTemplateSettings[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_AppBarToggleButtonTemplateSettings) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_AppBarToggleButtonTemplateSettings) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_AppBarToggleButtonTemplateSettings) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_AppBarToggleButtonTemplateSettings) },
        { },
    };

    static PyType_Spec type_spec_AppBarToggleButtonTemplateSettings =
    {
        "winrt._winrt_microsoft_ui_xaml_controls_primitives.AppBarToggleButtonTemplateSettings",
        sizeof(py::wrapper::Microsoft::UI::Xaml::Controls::Primitives::AppBarToggleButtonTemplateSettings),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_AppBarToggleButtonTemplateSettings
    };

    // ----- AutoSuggestBoxHelper class --------------------

    static PyObject* _new_AutoSuggestBoxHelper(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Microsoft::UI::Xaml::Controls::Primitives::AutoSuggestBoxHelper>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Microsoft::UI::Xaml::Controls::Primitives::AutoSuggestBoxHelper>::type_name);
        return nullptr;
    }

    static void _dealloc_AutoSuggestBoxHelper(py::wrapper::Microsoft::UI::Xaml::Controls::Primitives::AutoSuggestBoxHelper* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* AutoSuggestBoxHelper_GetKeepInteriorCornersSquare(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Xaml.Controls.Primitives.AutoSuggestBoxHelper", L"GetKeepInteriorCornersSquare", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Microsoft::UI::Xaml::Controls::AutoSuggestBox>(args, 0);

                return py::convert(winrt::Microsoft::UI::Xaml::Controls::Primitives::AutoSuggestBoxHelper::GetKeepInteriorCornersSquare(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AutoSuggestBoxHelper_SetKeepInteriorCornersSquare(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Xaml.Controls.Primitives.AutoSuggestBoxHelper", L"SetKeepInteriorCornersSquare", 2))
            {
                py::set_arg_count_version_error(2);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Microsoft::UI::Xaml::Controls::AutoSuggestBox>(args, 0);
                auto param1 = py::convert_to<bool>(args, 1);

                winrt::Microsoft::UI::Xaml::Controls::Primitives::AutoSuggestBoxHelper::SetKeepInteriorCornersSquare(param0, param1);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AutoSuggestBoxHelper_get_KeepInteriorCornersSquareProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.AutoSuggestBoxHelper", L"KeepInteriorCornersSquareProperty"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Microsoft::UI::Xaml::Controls::Primitives::AutoSuggestBoxHelper::KeepInteriorCornersSquareProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_AutoSuggestBoxHelper(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Microsoft::UI::Xaml::Controls::Primitives::AutoSuggestBoxHelper>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_AutoSuggestBoxHelper(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Microsoft::UI::Xaml::Controls::Primitives::AutoSuggestBoxHelper>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_AutoSuggestBoxHelper[] = {
        { "_assign_array_", _assign_array_AutoSuggestBoxHelper, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_AutoSuggestBoxHelper), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_AutoSuggestBoxHelper[] = {
        { }
    };

    static PyType_Slot _type_slots_AutoSuggestBoxHelper[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_AutoSuggestBoxHelper) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_AutoSuggestBoxHelper) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_AutoSuggestBoxHelper) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_AutoSuggestBoxHelper) },
        { },
    };

    static PyType_Spec type_spec_AutoSuggestBoxHelper =
    {
        "winrt._winrt_microsoft_ui_xaml_controls_primitives.AutoSuggestBoxHelper",
        sizeof(py::wrapper::Microsoft::UI::Xaml::Controls::Primitives::AutoSuggestBoxHelper),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_AutoSuggestBoxHelper
    };

    static PyGetSetDef getset_AutoSuggestBoxHelper_Static[] = {
        { "keep_interior_corners_square_property", reinterpret_cast<getter>(AutoSuggestBoxHelper_get_KeepInteriorCornersSquareProperty), nullptr, nullptr, nullptr },
        { }
    };

    static PyMethodDef methods_AutoSuggestBoxHelper_Static[] = {
        { "get_keep_interior_corners_square", reinterpret_cast<PyCFunction>(AutoSuggestBoxHelper_GetKeepInteriorCornersSquare), METH_VARARGS, nullptr },
        { "set_keep_interior_corners_square", reinterpret_cast<PyCFunction>(AutoSuggestBoxHelper_SetKeepInteriorCornersSquare), METH_VARARGS, nullptr },
        { }
    };

    static PyType_Slot type_slots_AutoSuggestBoxHelper_Static[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_AutoSuggestBoxHelper_Static) },
        { Py_tp_methods, reinterpret_cast<void*>(methods_AutoSuggestBoxHelper_Static) },
        { }
    };

    static PyType_Spec type_spec_AutoSuggestBoxHelper_Static =
    {
        "winrt._winrt_microsoft_ui_xaml_controls_primitives.AutoSuggestBoxHelper_Static",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT,
        type_slots_AutoSuggestBoxHelper_Static
    };

    // ----- ButtonBase class --------------------

    static PyObject* _new_ButtonBase(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Microsoft::UI::Xaml::Controls::Primitives::ButtonBase>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Microsoft::UI::Xaml::Controls::Primitives::ButtonBase>::type_name);
        return nullptr;
    }

    static void _dealloc_ButtonBase(py::wrapper::Microsoft::UI::Xaml::Controls::Primitives::ButtonBase* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* ButtonBase_get_CommandParameter(py::wrapper::Microsoft::UI::Xaml::Controls::Primitives::ButtonBase* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.ButtonBase", L"CommandParameter"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.CommandParameter());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ButtonBase_put_CommandParameter(py::wrapper::Microsoft::UI::Xaml::Controls::Primitives::ButtonBase* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.ButtonBase", L"CommandParameter"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);

            self->obj.CommandParameter(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ButtonBase_get_Command(py::wrapper::Microsoft::UI::Xaml::Controls::Primitives::ButtonBase* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.ButtonBase", L"Command"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Command());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ButtonBase_put_Command(py::wrapper::Microsoft::UI::Xaml::Controls::Primitives::ButtonBase* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.ButtonBase", L"Command"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Microsoft::UI::Xaml::Input::ICommand>(arg);

            self->obj.Command(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ButtonBase_get_ClickMode(py::wrapper::Microsoft::UI::Xaml::Controls::Primitives::ButtonBase* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.ButtonBase", L"ClickMode"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.ClickMode());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ButtonBase_put_ClickMode(py::wrapper::Microsoft::UI::Xaml::Controls::Primitives::ButtonBase* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.ButtonBase", L"ClickMode"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Microsoft::UI::Xaml::Controls::ClickMode>(arg);

            self->obj.ClickMode(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ButtonBase_get_IsPointerOver(py::wrapper::Microsoft::UI::Xaml::Controls::Primitives::ButtonBase* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.ButtonBase", L"IsPointerOver"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.IsPointerOver());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ButtonBase_get_IsPressed(py::wrapper::Microsoft::UI::Xaml::Controls::Primitives::ButtonBase* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.ButtonBase", L"IsPressed"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.IsPressed());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ButtonBase_get_ClickModeProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.ButtonBase", L"ClickModeProperty"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Microsoft::UI::Xaml::Controls::Primitives::ButtonBase::ClickModeProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ButtonBase_get_CommandParameterProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.ButtonBase", L"CommandParameterProperty"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Microsoft::UI::Xaml::Controls::Primitives::ButtonBase::CommandParameterProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ButtonBase_get_CommandProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.ButtonBase", L"CommandProperty"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Microsoft::UI::Xaml::Controls::Primitives::ButtonBase::CommandProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ButtonBase_get_IsPointerOverProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.ButtonBase", L"IsPointerOverProperty"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Microsoft::UI::Xaml::Controls::Primitives::ButtonBase::IsPointerOverProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ButtonBase_get_IsPressedProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.ButtonBase", L"IsPressedProperty"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Microsoft::UI::Xaml::Controls::Primitives::ButtonBase::IsPressedProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ButtonBase_add_Click(py::wrapper::Microsoft::UI::Xaml::Controls::Primitives::ButtonBase* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Microsoft.UI.Xaml.Controls.Primitives.ButtonBase", L"Click"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Microsoft::UI::Xaml::RoutedEventHandler>(arg);

            return py::convert(self->obj.Click(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ButtonBase_remove_Click(py::wrapper::Microsoft::UI::Xaml::Controls::Primitives::ButtonBase* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Microsoft.UI.Xaml.Controls.Primitives.ButtonBase", L"Click"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.Click(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_ButtonBase(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Microsoft::UI::Xaml::Controls::Primitives::ButtonBase>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_ButtonBase(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Microsoft::UI::Xaml::Controls::Primitives::ButtonBase>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_ButtonBase[] = {
        { "add_click", reinterpret_cast<PyCFunction>(ButtonBase_add_Click), METH_O, nullptr },
        { "remove_click", reinterpret_cast<PyCFunction>(ButtonBase_remove_Click), METH_O, nullptr },
        { "_assign_array_", _assign_array_ButtonBase, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_ButtonBase), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_ButtonBase[] = {
        { "command_parameter", reinterpret_cast<getter>(ButtonBase_get_CommandParameter), reinterpret_cast<setter>(ButtonBase_put_CommandParameter), nullptr, nullptr },
        { "command", reinterpret_cast<getter>(ButtonBase_get_Command), reinterpret_cast<setter>(ButtonBase_put_Command), nullptr, nullptr },
        { "click_mode", reinterpret_cast<getter>(ButtonBase_get_ClickMode), reinterpret_cast<setter>(ButtonBase_put_ClickMode), nullptr, nullptr },
        { "is_pointer_over", reinterpret_cast<getter>(ButtonBase_get_IsPointerOver), nullptr, nullptr, nullptr },
        { "is_pressed", reinterpret_cast<getter>(ButtonBase_get_IsPressed), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_ButtonBase[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_ButtonBase) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_ButtonBase) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_ButtonBase) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_ButtonBase) },
        { },
    };

    static PyType_Spec type_spec_ButtonBase =
    {
        "winrt._winrt_microsoft_ui_xaml_controls_primitives.ButtonBase",
        sizeof(py::wrapper::Microsoft::UI::Xaml::Controls::Primitives::ButtonBase),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_ButtonBase
    };

    static PyGetSetDef getset_ButtonBase_Static[] = {
        { "click_mode_property", reinterpret_cast<getter>(ButtonBase_get_ClickModeProperty), nullptr, nullptr, nullptr },
        { "command_parameter_property", reinterpret_cast<getter>(ButtonBase_get_CommandParameterProperty), nullptr, nullptr, nullptr },
        { "command_property", reinterpret_cast<getter>(ButtonBase_get_CommandProperty), nullptr, nullptr, nullptr },
        { "is_pointer_over_property", reinterpret_cast<getter>(ButtonBase_get_IsPointerOverProperty), nullptr, nullptr, nullptr },
        { "is_pressed_property", reinterpret_cast<getter>(ButtonBase_get_IsPressedProperty), nullptr, nullptr, nullptr },
        { }
    };

    static PyMethodDef methods_ButtonBase_Static[] = {
        { }
    };

    static PyType_Slot type_slots_ButtonBase_Static[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_ButtonBase_Static) },
        { Py_tp_methods, reinterpret_cast<void*>(methods_ButtonBase_Static) },
        { }
    };

    static PyType_Spec type_spec_ButtonBase_Static =
    {
        "winrt._winrt_microsoft_ui_xaml_controls_primitives.ButtonBase_Static",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT,
        type_slots_ButtonBase_Static
    };

    // ----- CalendarPanel class --------------------

    static PyObject* _new_CalendarPanel(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 0)
        {
            try
            {
                winrt::Microsoft::UI::Xaml::Controls::Primitives::CalendarPanel instance{  };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_CalendarPanel(py::wrapper::Microsoft::UI::Xaml::Controls::Primitives::CalendarPanel* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* _assign_array_CalendarPanel(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Microsoft::UI::Xaml::Controls::Primitives::CalendarPanel>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_CalendarPanel(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Microsoft::UI::Xaml::Controls::Primitives::CalendarPanel>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_CalendarPanel[] = {
        { "_assign_array_", _assign_array_CalendarPanel, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_CalendarPanel), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_CalendarPanel[] = {
        { }
    };

    static PyType_Slot _type_slots_CalendarPanel[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_CalendarPanel) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_CalendarPanel) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_CalendarPanel) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_CalendarPanel) },
        { },
    };

    static PyType_Spec type_spec_CalendarPanel =
    {
        "winrt._winrt_microsoft_ui_xaml_controls_primitives.CalendarPanel",
        sizeof(py::wrapper::Microsoft::UI::Xaml::Controls::Primitives::CalendarPanel),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_CalendarPanel
    };

    // ----- CalendarViewTemplateSettings class --------------------

    static PyObject* _new_CalendarViewTemplateSettings(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Microsoft::UI::Xaml::Controls::Primitives::CalendarViewTemplateSettings>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Microsoft::UI::Xaml::Controls::Primitives::CalendarViewTemplateSettings>::type_name);
        return nullptr;
    }

    static void _dealloc_CalendarViewTemplateSettings(py::wrapper::Microsoft::UI::Xaml::Controls::Primitives::CalendarViewTemplateSettings* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* CalendarViewTemplateSettings_get_CenterX(py::wrapper::Microsoft::UI::Xaml::Controls::Primitives::CalendarViewTemplateSettings* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.CalendarViewTemplateSettings", L"CenterX"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.CenterX());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CalendarViewTemplateSettings_get_CenterY(py::wrapper::Microsoft::UI::Xaml::Controls::Primitives::CalendarViewTemplateSettings* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.CalendarViewTemplateSettings", L"CenterY"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.CenterY());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CalendarViewTemplateSettings_get_ClipRect(py::wrapper::Microsoft::UI::Xaml::Controls::Primitives::CalendarViewTemplateSettings* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.CalendarViewTemplateSettings", L"ClipRect"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.ClipRect());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CalendarViewTemplateSettings_get_HasMoreContentAfter(py::wrapper::Microsoft::UI::Xaml::Controls::Primitives::CalendarViewTemplateSettings* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.CalendarViewTemplateSettings", L"HasMoreContentAfter"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.HasMoreContentAfter());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CalendarViewTemplateSettings_get_HasMoreContentBefore(py::wrapper::Microsoft::UI::Xaml::Controls::Primitives::CalendarViewTemplateSettings* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.CalendarViewTemplateSettings", L"HasMoreContentBefore"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.HasMoreContentBefore());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CalendarViewTemplateSettings_get_HasMoreViews(py::wrapper::Microsoft::UI::Xaml::Controls::Primitives::CalendarViewTemplateSettings* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.CalendarViewTemplateSettings", L"HasMoreViews"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.HasMoreViews());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CalendarViewTemplateSettings_get_HeaderText(py::wrapper::Microsoft::UI::Xaml::Controls::Primitives::CalendarViewTemplateSettings* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.CalendarViewTemplateSettings", L"HeaderText"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.HeaderText());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CalendarViewTemplateSettings_get_MinViewWidth(py::wrapper::Microsoft::UI::Xaml::Controls::Primitives::CalendarViewTemplateSettings* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.CalendarViewTemplateSettings", L"MinViewWidth"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.MinViewWidth());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CalendarViewTemplateSettings_get_WeekDay1(py::wrapper::Microsoft::UI::Xaml::Controls::Primitives::CalendarViewTemplateSettings* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.CalendarViewTemplateSettings", L"WeekDay1"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.WeekDay1());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CalendarViewTemplateSettings_get_WeekDay2(py::wrapper::Microsoft::UI::Xaml::Controls::Primitives::CalendarViewTemplateSettings* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.CalendarViewTemplateSettings", L"WeekDay2"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.WeekDay2());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CalendarViewTemplateSettings_get_WeekDay3(py::wrapper::Microsoft::UI::Xaml::Controls::Primitives::CalendarViewTemplateSettings* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.CalendarViewTemplateSettings", L"WeekDay3"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.WeekDay3());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CalendarViewTemplateSettings_get_WeekDay4(py::wrapper::Microsoft::UI::Xaml::Controls::Primitives::CalendarViewTemplateSettings* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.CalendarViewTemplateSettings", L"WeekDay4"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.WeekDay4());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CalendarViewTemplateSettings_get_WeekDay5(py::wrapper::Microsoft::UI::Xaml::Controls::Primitives::CalendarViewTemplateSettings* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.CalendarViewTemplateSettings", L"WeekDay5"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.WeekDay5());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CalendarViewTemplateSettings_get_WeekDay6(py::wrapper::Microsoft::UI::Xaml::Controls::Primitives::CalendarViewTemplateSettings* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.CalendarViewTemplateSettings", L"WeekDay6"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.WeekDay6());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CalendarViewTemplateSettings_get_WeekDay7(py::wrapper::Microsoft::UI::Xaml::Controls::Primitives::CalendarViewTemplateSettings* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.CalendarViewTemplateSettings", L"WeekDay7"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.WeekDay7());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_CalendarViewTemplateSettings(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Microsoft::UI::Xaml::Controls::Primitives::CalendarViewTemplateSettings>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_CalendarViewTemplateSettings(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Microsoft::UI::Xaml::Controls::Primitives::CalendarViewTemplateSettings>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_CalendarViewTemplateSettings[] = {
        { "_assign_array_", _assign_array_CalendarViewTemplateSettings, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_CalendarViewTemplateSettings), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_CalendarViewTemplateSettings[] = {
        { "center_x", reinterpret_cast<getter>(CalendarViewTemplateSettings_get_CenterX), nullptr, nullptr, nullptr },
        { "center_y", reinterpret_cast<getter>(CalendarViewTemplateSettings_get_CenterY), nullptr, nullptr, nullptr },
        { "clip_rect", reinterpret_cast<getter>(CalendarViewTemplateSettings_get_ClipRect), nullptr, nullptr, nullptr },
        { "has_more_content_after", reinterpret_cast<getter>(CalendarViewTemplateSettings_get_HasMoreContentAfter), nullptr, nullptr, nullptr },
        { "has_more_content_before", reinterpret_cast<getter>(CalendarViewTemplateSettings_get_HasMoreContentBefore), nullptr, nullptr, nullptr },
        { "has_more_views", reinterpret_cast<getter>(CalendarViewTemplateSettings_get_HasMoreViews), nullptr, nullptr, nullptr },
        { "header_text", reinterpret_cast<getter>(CalendarViewTemplateSettings_get_HeaderText), nullptr, nullptr, nullptr },
        { "min_view_width", reinterpret_cast<getter>(CalendarViewTemplateSettings_get_MinViewWidth), nullptr, nullptr, nullptr },
        { "week_day1", reinterpret_cast<getter>(CalendarViewTemplateSettings_get_WeekDay1), nullptr, nullptr, nullptr },
        { "week_day2", reinterpret_cast<getter>(CalendarViewTemplateSettings_get_WeekDay2), nullptr, nullptr, nullptr },
        { "week_day3", reinterpret_cast<getter>(CalendarViewTemplateSettings_get_WeekDay3), nullptr, nullptr, nullptr },
        { "week_day4", reinterpret_cast<getter>(CalendarViewTemplateSettings_get_WeekDay4), nullptr, nullptr, nullptr },
        { "week_day5", reinterpret_cast<getter>(CalendarViewTemplateSettings_get_WeekDay5), nullptr, nullptr, nullptr },
        { "week_day6", reinterpret_cast<getter>(CalendarViewTemplateSettings_get_WeekDay6), nullptr, nullptr, nullptr },
        { "week_day7", reinterpret_cast<getter>(CalendarViewTemplateSettings_get_WeekDay7), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_CalendarViewTemplateSettings[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_CalendarViewTemplateSettings) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_CalendarViewTemplateSettings) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_CalendarViewTemplateSettings) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_CalendarViewTemplateSettings) },
        { },
    };

    static PyType_Spec type_spec_CalendarViewTemplateSettings =
    {
        "winrt._winrt_microsoft_ui_xaml_controls_primitives.CalendarViewTemplateSettings",
        sizeof(py::wrapper::Microsoft::UI::Xaml::Controls::Primitives::CalendarViewTemplateSettings),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_CalendarViewTemplateSettings
    };

    // ----- CarouselPanel class --------------------

    static PyObject* _new_CarouselPanel(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 0)
        {
            try
            {
                winrt::Microsoft::UI::Xaml::Controls::Primitives::CarouselPanel instance{  };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_CarouselPanel(py::wrapper::Microsoft::UI::Xaml::Controls::Primitives::CarouselPanel* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* CarouselPanel_GetIrregularSnapPoints(py::wrapper::Microsoft::UI::Xaml::Controls::Primitives::CarouselPanel* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Xaml.Controls.Primitives.CarouselPanel", L"GetIrregularSnapPoints", 2))
            {
                py::set_arg_count_version_error(2);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Microsoft::UI::Xaml::Controls::Orientation>(args, 0);
                auto param1 = py::convert_to<winrt::Microsoft::UI::Xaml::Controls::Primitives::SnapPointsAlignment>(args, 1);

                return py::convert(self->obj.GetIrregularSnapPoints(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* CarouselPanel_GetRegularSnapPoints(py::wrapper::Microsoft::UI::Xaml::Controls::Primitives::CarouselPanel* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Xaml.Controls.Primitives.CarouselPanel", L"GetRegularSnapPoints", 2))
            {
                py::set_arg_count_version_error(2);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Microsoft::UI::Xaml::Controls::Orientation>(args, 0);
                auto param1 = py::convert_to<winrt::Microsoft::UI::Xaml::Controls::Primitives::SnapPointsAlignment>(args, 1);
                float param2 {  };

                auto return_value = self->obj.GetRegularSnapPoints(param0, param1, param2);

                py::pyobj_handle out_return_value{ py::convert(return_value) };
                if (!out_return_value)
                {
                    return nullptr;
                }
                py::pyobj_handle out2{ py::convert(param2) };
                if (!out2)
                {
                    return nullptr;
                }
                return PyTuple_Pack(2, out_return_value.get(), out2.get());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* CarouselPanel_LineDown(py::wrapper::Microsoft::UI::Xaml::Controls::Primitives::CarouselPanel* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Xaml.Controls.Primitives.CarouselPanel", L"LineDown", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                self->obj.LineDown();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* CarouselPanel_LineLeft(py::wrapper::Microsoft::UI::Xaml::Controls::Primitives::CarouselPanel* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Xaml.Controls.Primitives.CarouselPanel", L"LineLeft", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                self->obj.LineLeft();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* CarouselPanel_LineRight(py::wrapper::Microsoft::UI::Xaml::Controls::Primitives::CarouselPanel* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Xaml.Controls.Primitives.CarouselPanel", L"LineRight", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                self->obj.LineRight();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* CarouselPanel_LineUp(py::wrapper::Microsoft::UI::Xaml::Controls::Primitives::CarouselPanel* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Xaml.Controls.Primitives.CarouselPanel", L"LineUp", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                self->obj.LineUp();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* CarouselPanel_MakeVisible(py::wrapper::Microsoft::UI::Xaml::Controls::Primitives::CarouselPanel* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Xaml.Controls.Primitives.CarouselPanel", L"MakeVisible", 2))
            {
                py::set_arg_count_version_error(2);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Microsoft::UI::Xaml::UIElement>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Foundation::Rect>(args, 1);

                return py::convert(self->obj.MakeVisible(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* CarouselPanel_MouseWheelDown(py::wrapper::Microsoft::UI::Xaml::Controls::Primitives::CarouselPanel* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Xaml.Controls.Primitives.CarouselPanel", L"MouseWheelDown", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                self->obj.MouseWheelDown();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* CarouselPanel_MouseWheelLeft(py::wrapper::Microsoft::UI::Xaml::Controls::Primitives::CarouselPanel* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Xaml.Controls.Primitives.CarouselPanel", L"MouseWheelLeft", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                self->obj.MouseWheelLeft();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* CarouselPanel_MouseWheelRight(py::wrapper::Microsoft::UI::Xaml::Controls::Primitives::CarouselPanel* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Xaml.Controls.Primitives.CarouselPanel", L"MouseWheelRight", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                self->obj.MouseWheelRight();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* CarouselPanel_MouseWheelUp(py::wrapper::Microsoft::UI::Xaml::Controls::Primitives::CarouselPanel* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Xaml.Controls.Primitives.CarouselPanel", L"MouseWheelUp", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                self->obj.MouseWheelUp();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* CarouselPanel_PageDown(py::wrapper::Microsoft::UI::Xaml::Controls::Primitives::CarouselPanel* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Xaml.Controls.Primitives.CarouselPanel", L"PageDown", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                self->obj.PageDown();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* CarouselPanel_PageLeft(py::wrapper::Microsoft::UI::Xaml::Controls::Primitives::CarouselPanel* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Xaml.Controls.Primitives.CarouselPanel", L"PageLeft", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                self->obj.PageLeft();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* CarouselPanel_PageRight(py::wrapper::Microsoft::UI::Xaml::Controls::Primitives::CarouselPanel* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Xaml.Controls.Primitives.CarouselPanel", L"PageRight", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                self->obj.PageRight();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* CarouselPanel_PageUp(py::wrapper::Microsoft::UI::Xaml::Controls::Primitives::CarouselPanel* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Xaml.Controls.Primitives.CarouselPanel", L"PageUp", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                self->obj.PageUp();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* CarouselPanel_SetHorizontalOffset(py::wrapper::Microsoft::UI::Xaml::Controls::Primitives::CarouselPanel* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Xaml.Controls.Primitives.CarouselPanel", L"SetHorizontalOffset", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<double>(args, 0);

                self->obj.SetHorizontalOffset(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* CarouselPanel_SetVerticalOffset(py::wrapper::Microsoft::UI::Xaml::Controls::Primitives::CarouselPanel* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Xaml.Controls.Primitives.CarouselPanel", L"SetVerticalOffset", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<double>(args, 0);

                self->obj.SetVerticalOffset(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* CarouselPanel_get_ScrollOwner(py::wrapper::Microsoft::UI::Xaml::Controls::Primitives::CarouselPanel* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.CarouselPanel", L"ScrollOwner"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.ScrollOwner());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int CarouselPanel_put_ScrollOwner(py::wrapper::Microsoft::UI::Xaml::Controls::Primitives::CarouselPanel* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.CarouselPanel", L"ScrollOwner"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);

            self->obj.ScrollOwner(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* CarouselPanel_get_CanVerticallyScroll(py::wrapper::Microsoft::UI::Xaml::Controls::Primitives::CarouselPanel* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.CarouselPanel", L"CanVerticallyScroll"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.CanVerticallyScroll());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int CarouselPanel_put_CanVerticallyScroll(py::wrapper::Microsoft::UI::Xaml::Controls::Primitives::CarouselPanel* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.CarouselPanel", L"CanVerticallyScroll"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<bool>(arg);

            self->obj.CanVerticallyScroll(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* CarouselPanel_get_CanHorizontallyScroll(py::wrapper::Microsoft::UI::Xaml::Controls::Primitives::CarouselPanel* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.CarouselPanel", L"CanHorizontallyScroll"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.CanHorizontallyScroll());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int CarouselPanel_put_CanHorizontallyScroll(py::wrapper::Microsoft::UI::Xaml::Controls::Primitives::CarouselPanel* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.CarouselPanel", L"CanHorizontallyScroll"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<bool>(arg);

            self->obj.CanHorizontallyScroll(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* CarouselPanel_get_ExtentHeight(py::wrapper::Microsoft::UI::Xaml::Controls::Primitives::CarouselPanel* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.CarouselPanel", L"ExtentHeight"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.ExtentHeight());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CarouselPanel_get_ExtentWidth(py::wrapper::Microsoft::UI::Xaml::Controls::Primitives::CarouselPanel* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.CarouselPanel", L"ExtentWidth"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.ExtentWidth());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CarouselPanel_get_HorizontalOffset(py::wrapper::Microsoft::UI::Xaml::Controls::Primitives::CarouselPanel* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.CarouselPanel", L"HorizontalOffset"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.HorizontalOffset());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CarouselPanel_get_VerticalOffset(py::wrapper::Microsoft::UI::Xaml::Controls::Primitives::CarouselPanel* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.CarouselPanel", L"VerticalOffset"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.VerticalOffset());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CarouselPanel_get_ViewportHeight(py::wrapper::Microsoft::UI::Xaml::Controls::Primitives::CarouselPanel* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.CarouselPanel", L"ViewportHeight"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.ViewportHeight());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CarouselPanel_get_ViewportWidth(py::wrapper::Microsoft::UI::Xaml::Controls::Primitives::CarouselPanel* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.CarouselPanel", L"ViewportWidth"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.ViewportWidth());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CarouselPanel_get_AreHorizontalSnapPointsRegular(py::wrapper::Microsoft::UI::Xaml::Controls::Primitives::CarouselPanel* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.CarouselPanel", L"AreHorizontalSnapPointsRegular"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.AreHorizontalSnapPointsRegular());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CarouselPanel_get_AreVerticalSnapPointsRegular(py::wrapper::Microsoft::UI::Xaml::Controls::Primitives::CarouselPanel* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.CarouselPanel", L"AreVerticalSnapPointsRegular"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.AreVerticalSnapPointsRegular());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CarouselPanel_add_HorizontalSnapPointsChanged(py::wrapper::Microsoft::UI::Xaml::Controls::Primitives::CarouselPanel* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Microsoft.UI.Xaml.Controls.Primitives.CarouselPanel", L"HorizontalSnapPointsChanged"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::EventHandler<winrt::Windows::Foundation::IInspectable>>(arg);

            return py::convert(self->obj.HorizontalSnapPointsChanged(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CarouselPanel_remove_HorizontalSnapPointsChanged(py::wrapper::Microsoft::UI::Xaml::Controls::Primitives::CarouselPanel* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Microsoft.UI.Xaml.Controls.Primitives.CarouselPanel", L"HorizontalSnapPointsChanged"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.HorizontalSnapPointsChanged(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CarouselPanel_add_VerticalSnapPointsChanged(py::wrapper::Microsoft::UI::Xaml::Controls::Primitives::CarouselPanel* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Microsoft.UI.Xaml.Controls.Primitives.CarouselPanel", L"VerticalSnapPointsChanged"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::EventHandler<winrt::Windows::Foundation::IInspectable>>(arg);

            return py::convert(self->obj.VerticalSnapPointsChanged(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CarouselPanel_remove_VerticalSnapPointsChanged(py::wrapper::Microsoft::UI::Xaml::Controls::Primitives::CarouselPanel* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Microsoft.UI.Xaml.Controls.Primitives.CarouselPanel", L"VerticalSnapPointsChanged"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.VerticalSnapPointsChanged(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_CarouselPanel(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Microsoft::UI::Xaml::Controls::Primitives::CarouselPanel>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_CarouselPanel(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Microsoft::UI::Xaml::Controls::Primitives::CarouselPanel>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_CarouselPanel[] = {
        { "get_irregular_snap_points", reinterpret_cast<PyCFunction>(CarouselPanel_GetIrregularSnapPoints), METH_VARARGS, nullptr },
        { "get_regular_snap_points", reinterpret_cast<PyCFunction>(CarouselPanel_GetRegularSnapPoints), METH_VARARGS, nullptr },
        { "line_down", reinterpret_cast<PyCFunction>(CarouselPanel_LineDown), METH_VARARGS, nullptr },
        { "line_left", reinterpret_cast<PyCFunction>(CarouselPanel_LineLeft), METH_VARARGS, nullptr },
        { "line_right", reinterpret_cast<PyCFunction>(CarouselPanel_LineRight), METH_VARARGS, nullptr },
        { "line_up", reinterpret_cast<PyCFunction>(CarouselPanel_LineUp), METH_VARARGS, nullptr },
        { "make_visible", reinterpret_cast<PyCFunction>(CarouselPanel_MakeVisible), METH_VARARGS, nullptr },
        { "mouse_wheel_down", reinterpret_cast<PyCFunction>(CarouselPanel_MouseWheelDown), METH_VARARGS, nullptr },
        { "mouse_wheel_left", reinterpret_cast<PyCFunction>(CarouselPanel_MouseWheelLeft), METH_VARARGS, nullptr },
        { "mouse_wheel_right", reinterpret_cast<PyCFunction>(CarouselPanel_MouseWheelRight), METH_VARARGS, nullptr },
        { "mouse_wheel_up", reinterpret_cast<PyCFunction>(CarouselPanel_MouseWheelUp), METH_VARARGS, nullptr },
        { "page_down", reinterpret_cast<PyCFunction>(CarouselPanel_PageDown), METH_VARARGS, nullptr },
        { "page_left", reinterpret_cast<PyCFunction>(CarouselPanel_PageLeft), METH_VARARGS, nullptr },
        { "page_right", reinterpret_cast<PyCFunction>(CarouselPanel_PageRight), METH_VARARGS, nullptr },
        { "page_up", reinterpret_cast<PyCFunction>(CarouselPanel_PageUp), METH_VARARGS, nullptr },
        { "set_horizontal_offset", reinterpret_cast<PyCFunction>(CarouselPanel_SetHorizontalOffset), METH_VARARGS, nullptr },
        { "set_vertical_offset", reinterpret_cast<PyCFunction>(CarouselPanel_SetVerticalOffset), METH_VARARGS, nullptr },
        { "add_horizontal_snap_points_changed", reinterpret_cast<PyCFunction>(CarouselPanel_add_HorizontalSnapPointsChanged), METH_O, nullptr },
        { "remove_horizontal_snap_points_changed", reinterpret_cast<PyCFunction>(CarouselPanel_remove_HorizontalSnapPointsChanged), METH_O, nullptr },
        { "add_vertical_snap_points_changed", reinterpret_cast<PyCFunction>(CarouselPanel_add_VerticalSnapPointsChanged), METH_O, nullptr },
        { "remove_vertical_snap_points_changed", reinterpret_cast<PyCFunction>(CarouselPanel_remove_VerticalSnapPointsChanged), METH_O, nullptr },
        { "_assign_array_", _assign_array_CarouselPanel, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_CarouselPanel), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_CarouselPanel[] = {
        { "scroll_owner", reinterpret_cast<getter>(CarouselPanel_get_ScrollOwner), reinterpret_cast<setter>(CarouselPanel_put_ScrollOwner), nullptr, nullptr },
        { "can_vertically_scroll", reinterpret_cast<getter>(CarouselPanel_get_CanVerticallyScroll), reinterpret_cast<setter>(CarouselPanel_put_CanVerticallyScroll), nullptr, nullptr },
        { "can_horizontally_scroll", reinterpret_cast<getter>(CarouselPanel_get_CanHorizontallyScroll), reinterpret_cast<setter>(CarouselPanel_put_CanHorizontallyScroll), nullptr, nullptr },
        { "extent_height", reinterpret_cast<getter>(CarouselPanel_get_ExtentHeight), nullptr, nullptr, nullptr },
        { "extent_width", reinterpret_cast<getter>(CarouselPanel_get_ExtentWidth), nullptr, nullptr, nullptr },
        { "horizontal_offset", reinterpret_cast<getter>(CarouselPanel_get_HorizontalOffset), nullptr, nullptr, nullptr },
        { "vertical_offset", reinterpret_cast<getter>(CarouselPanel_get_VerticalOffset), nullptr, nullptr, nullptr },
        { "viewport_height", reinterpret_cast<getter>(CarouselPanel_get_ViewportHeight), nullptr, nullptr, nullptr },
        { "viewport_width", reinterpret_cast<getter>(CarouselPanel_get_ViewportWidth), nullptr, nullptr, nullptr },
        { "are_horizontal_snap_points_regular", reinterpret_cast<getter>(CarouselPanel_get_AreHorizontalSnapPointsRegular), nullptr, nullptr, nullptr },
        { "are_vertical_snap_points_regular", reinterpret_cast<getter>(CarouselPanel_get_AreVerticalSnapPointsRegular), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_CarouselPanel[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_CarouselPanel) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_CarouselPanel) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_CarouselPanel) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_CarouselPanel) },
        { },
    };

    static PyType_Spec type_spec_CarouselPanel =
    {
        "winrt._winrt_microsoft_ui_xaml_controls_primitives.CarouselPanel",
        sizeof(py::wrapper::Microsoft::UI::Xaml::Controls::Primitives::CarouselPanel),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_CarouselPanel
    };

    // ----- ColorPickerSlider class --------------------

    static PyObject* _new_ColorPickerSlider(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 0)
        {
            try
            {
                winrt::Microsoft::UI::Xaml::Controls::Primitives::ColorPickerSlider instance{  };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_ColorPickerSlider(py::wrapper::Microsoft::UI::Xaml::Controls::Primitives::ColorPickerSlider* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* ColorPickerSlider_get_ColorChannel(py::wrapper::Microsoft::UI::Xaml::Controls::Primitives::ColorPickerSlider* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.ColorPickerSlider", L"ColorChannel"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.ColorChannel());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ColorPickerSlider_put_ColorChannel(py::wrapper::Microsoft::UI::Xaml::Controls::Primitives::ColorPickerSlider* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.ColorPickerSlider", L"ColorChannel"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Microsoft::UI::Xaml::Controls::ColorPickerHsvChannel>(arg);

            self->obj.ColorChannel(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ColorPickerSlider_get_ColorChannelProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.ColorPickerSlider", L"ColorChannelProperty"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Microsoft::UI::Xaml::Controls::Primitives::ColorPickerSlider::ColorChannelProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_ColorPickerSlider(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Microsoft::UI::Xaml::Controls::Primitives::ColorPickerSlider>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_ColorPickerSlider(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Microsoft::UI::Xaml::Controls::Primitives::ColorPickerSlider>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_ColorPickerSlider[] = {
        { "_assign_array_", _assign_array_ColorPickerSlider, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_ColorPickerSlider), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_ColorPickerSlider[] = {
        { "color_channel", reinterpret_cast<getter>(ColorPickerSlider_get_ColorChannel), reinterpret_cast<setter>(ColorPickerSlider_put_ColorChannel), nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_ColorPickerSlider[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_ColorPickerSlider) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_ColorPickerSlider) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_ColorPickerSlider) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_ColorPickerSlider) },
        { },
    };

    static PyType_Spec type_spec_ColorPickerSlider =
    {
        "winrt._winrt_microsoft_ui_xaml_controls_primitives.ColorPickerSlider",
        sizeof(py::wrapper::Microsoft::UI::Xaml::Controls::Primitives::ColorPickerSlider),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_ColorPickerSlider
    };

    static PyGetSetDef getset_ColorPickerSlider_Static[] = {
        { "color_channel_property", reinterpret_cast<getter>(ColorPickerSlider_get_ColorChannelProperty), nullptr, nullptr, nullptr },
        { }
    };

    static PyMethodDef methods_ColorPickerSlider_Static[] = {
        { }
    };

    static PyType_Slot type_slots_ColorPickerSlider_Static[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_ColorPickerSlider_Static) },
        { Py_tp_methods, reinterpret_cast<void*>(methods_ColorPickerSlider_Static) },
        { }
    };

    static PyType_Spec type_spec_ColorPickerSlider_Static =
    {
        "winrt._winrt_microsoft_ui_xaml_controls_primitives.ColorPickerSlider_Static",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT,
        type_slots_ColorPickerSlider_Static
    };

    // ----- ColorSpectrum class --------------------

    static PyObject* _new_ColorSpectrum(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 0)
        {
            try
            {
                winrt::Microsoft::UI::Xaml::Controls::Primitives::ColorSpectrum instance{  };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_ColorSpectrum(py::wrapper::Microsoft::UI::Xaml::Controls::Primitives::ColorSpectrum* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* ColorSpectrum_get_Shape(py::wrapper::Microsoft::UI::Xaml::Controls::Primitives::ColorSpectrum* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.ColorSpectrum", L"Shape"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Shape());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ColorSpectrum_put_Shape(py::wrapper::Microsoft::UI::Xaml::Controls::Primitives::ColorSpectrum* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.ColorSpectrum", L"Shape"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Microsoft::UI::Xaml::Controls::ColorSpectrumShape>(arg);

            self->obj.Shape(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ColorSpectrum_get_MinValue(py::wrapper::Microsoft::UI::Xaml::Controls::Primitives::ColorSpectrum* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.ColorSpectrum", L"MinValue"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.MinValue());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ColorSpectrum_put_MinValue(py::wrapper::Microsoft::UI::Xaml::Controls::Primitives::ColorSpectrum* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.ColorSpectrum", L"MinValue"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<int32_t>(arg);

            self->obj.MinValue(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ColorSpectrum_get_MinSaturation(py::wrapper::Microsoft::UI::Xaml::Controls::Primitives::ColorSpectrum* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.ColorSpectrum", L"MinSaturation"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.MinSaturation());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ColorSpectrum_put_MinSaturation(py::wrapper::Microsoft::UI::Xaml::Controls::Primitives::ColorSpectrum* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.ColorSpectrum", L"MinSaturation"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<int32_t>(arg);

            self->obj.MinSaturation(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ColorSpectrum_get_MinHue(py::wrapper::Microsoft::UI::Xaml::Controls::Primitives::ColorSpectrum* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.ColorSpectrum", L"MinHue"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.MinHue());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ColorSpectrum_put_MinHue(py::wrapper::Microsoft::UI::Xaml::Controls::Primitives::ColorSpectrum* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.ColorSpectrum", L"MinHue"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<int32_t>(arg);

            self->obj.MinHue(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ColorSpectrum_get_MaxValue(py::wrapper::Microsoft::UI::Xaml::Controls::Primitives::ColorSpectrum* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.ColorSpectrum", L"MaxValue"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.MaxValue());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ColorSpectrum_put_MaxValue(py::wrapper::Microsoft::UI::Xaml::Controls::Primitives::ColorSpectrum* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.ColorSpectrum", L"MaxValue"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<int32_t>(arg);

            self->obj.MaxValue(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ColorSpectrum_get_MaxSaturation(py::wrapper::Microsoft::UI::Xaml::Controls::Primitives::ColorSpectrum* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.ColorSpectrum", L"MaxSaturation"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.MaxSaturation());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ColorSpectrum_put_MaxSaturation(py::wrapper::Microsoft::UI::Xaml::Controls::Primitives::ColorSpectrum* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.ColorSpectrum", L"MaxSaturation"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<int32_t>(arg);

            self->obj.MaxSaturation(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ColorSpectrum_get_MaxHue(py::wrapper::Microsoft::UI::Xaml::Controls::Primitives::ColorSpectrum* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.ColorSpectrum", L"MaxHue"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.MaxHue());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ColorSpectrum_put_MaxHue(py::wrapper::Microsoft::UI::Xaml::Controls::Primitives::ColorSpectrum* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.ColorSpectrum", L"MaxHue"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<int32_t>(arg);

            self->obj.MaxHue(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ColorSpectrum_get_HsvColor(py::wrapper::Microsoft::UI::Xaml::Controls::Primitives::ColorSpectrum* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.ColorSpectrum", L"HsvColor"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.HsvColor());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ColorSpectrum_put_HsvColor(py::wrapper::Microsoft::UI::Xaml::Controls::Primitives::ColorSpectrum* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.ColorSpectrum", L"HsvColor"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::Numerics::float4>(arg);

            self->obj.HsvColor(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ColorSpectrum_get_Components(py::wrapper::Microsoft::UI::Xaml::Controls::Primitives::ColorSpectrum* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.ColorSpectrum", L"Components"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Components());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ColorSpectrum_put_Components(py::wrapper::Microsoft::UI::Xaml::Controls::Primitives::ColorSpectrum* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.ColorSpectrum", L"Components"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Microsoft::UI::Xaml::Controls::ColorSpectrumComponents>(arg);

            self->obj.Components(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ColorSpectrum_get_Color(py::wrapper::Microsoft::UI::Xaml::Controls::Primitives::ColorSpectrum* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.ColorSpectrum", L"Color"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Color());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ColorSpectrum_put_Color(py::wrapper::Microsoft::UI::Xaml::Controls::Primitives::ColorSpectrum* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.ColorSpectrum", L"Color"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::UI::Color>(arg);

            self->obj.Color(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ColorSpectrum_get_ColorProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.ColorSpectrum", L"ColorProperty"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Microsoft::UI::Xaml::Controls::Primitives::ColorSpectrum::ColorProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ColorSpectrum_get_ComponentsProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.ColorSpectrum", L"ComponentsProperty"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Microsoft::UI::Xaml::Controls::Primitives::ColorSpectrum::ComponentsProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ColorSpectrum_get_HsvColorProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.ColorSpectrum", L"HsvColorProperty"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Microsoft::UI::Xaml::Controls::Primitives::ColorSpectrum::HsvColorProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ColorSpectrum_get_MaxHueProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.ColorSpectrum", L"MaxHueProperty"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Microsoft::UI::Xaml::Controls::Primitives::ColorSpectrum::MaxHueProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ColorSpectrum_get_MaxSaturationProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.ColorSpectrum", L"MaxSaturationProperty"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Microsoft::UI::Xaml::Controls::Primitives::ColorSpectrum::MaxSaturationProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ColorSpectrum_get_MaxValueProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.ColorSpectrum", L"MaxValueProperty"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Microsoft::UI::Xaml::Controls::Primitives::ColorSpectrum::MaxValueProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ColorSpectrum_get_MinHueProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.ColorSpectrum", L"MinHueProperty"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Microsoft::UI::Xaml::Controls::Primitives::ColorSpectrum::MinHueProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ColorSpectrum_get_MinSaturationProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.ColorSpectrum", L"MinSaturationProperty"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Microsoft::UI::Xaml::Controls::Primitives::ColorSpectrum::MinSaturationProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ColorSpectrum_get_MinValueProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.ColorSpectrum", L"MinValueProperty"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Microsoft::UI::Xaml::Controls::Primitives::ColorSpectrum::MinValueProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ColorSpectrum_get_ShapeProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.ColorSpectrum", L"ShapeProperty"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Microsoft::UI::Xaml::Controls::Primitives::ColorSpectrum::ShapeProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ColorSpectrum_add_ColorChanged(py::wrapper::Microsoft::UI::Xaml::Controls::Primitives::ColorSpectrum* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Microsoft.UI.Xaml.Controls.Primitives.ColorSpectrum", L"ColorChanged"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Microsoft::UI::Xaml::Controls::Primitives::ColorSpectrum, winrt::Microsoft::UI::Xaml::Controls::ColorChangedEventArgs>>(arg);

            return py::convert(self->obj.ColorChanged(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ColorSpectrum_remove_ColorChanged(py::wrapper::Microsoft::UI::Xaml::Controls::Primitives::ColorSpectrum* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Microsoft.UI.Xaml.Controls.Primitives.ColorSpectrum", L"ColorChanged"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.ColorChanged(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_ColorSpectrum(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Microsoft::UI::Xaml::Controls::Primitives::ColorSpectrum>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_ColorSpectrum(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Microsoft::UI::Xaml::Controls::Primitives::ColorSpectrum>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_ColorSpectrum[] = {
        { "add_color_changed", reinterpret_cast<PyCFunction>(ColorSpectrum_add_ColorChanged), METH_O, nullptr },
        { "remove_color_changed", reinterpret_cast<PyCFunction>(ColorSpectrum_remove_ColorChanged), METH_O, nullptr },
        { "_assign_array_", _assign_array_ColorSpectrum, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_ColorSpectrum), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_ColorSpectrum[] = {
        { "shape", reinterpret_cast<getter>(ColorSpectrum_get_Shape), reinterpret_cast<setter>(ColorSpectrum_put_Shape), nullptr, nullptr },
        { "min_value", reinterpret_cast<getter>(ColorSpectrum_get_MinValue), reinterpret_cast<setter>(ColorSpectrum_put_MinValue), nullptr, nullptr },
        { "min_saturation", reinterpret_cast<getter>(ColorSpectrum_get_MinSaturation), reinterpret_cast<setter>(ColorSpectrum_put_MinSaturation), nullptr, nullptr },
        { "min_hue", reinterpret_cast<getter>(ColorSpectrum_get_MinHue), reinterpret_cast<setter>(ColorSpectrum_put_MinHue), nullptr, nullptr },
        { "max_value", reinterpret_cast<getter>(ColorSpectrum_get_MaxValue), reinterpret_cast<setter>(ColorSpectrum_put_MaxValue), nullptr, nullptr },
        { "max_saturation", reinterpret_cast<getter>(ColorSpectrum_get_MaxSaturation), reinterpret_cast<setter>(ColorSpectrum_put_MaxSaturation), nullptr, nullptr },
        { "max_hue", reinterpret_cast<getter>(ColorSpectrum_get_MaxHue), reinterpret_cast<setter>(ColorSpectrum_put_MaxHue), nullptr, nullptr },
        { "hsv_color", reinterpret_cast<getter>(ColorSpectrum_get_HsvColor), reinterpret_cast<setter>(ColorSpectrum_put_HsvColor), nullptr, nullptr },
        { "components", reinterpret_cast<getter>(ColorSpectrum_get_Components), reinterpret_cast<setter>(ColorSpectrum_put_Components), nullptr, nullptr },
        { "color", reinterpret_cast<getter>(ColorSpectrum_get_Color), reinterpret_cast<setter>(ColorSpectrum_put_Color), nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_ColorSpectrum[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_ColorSpectrum) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_ColorSpectrum) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_ColorSpectrum) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_ColorSpectrum) },
        { },
    };

    static PyType_Spec type_spec_ColorSpectrum =
    {
        "winrt._winrt_microsoft_ui_xaml_controls_primitives.ColorSpectrum",
        sizeof(py::wrapper::Microsoft::UI::Xaml::Controls::Primitives::ColorSpectrum),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_ColorSpectrum
    };

    static PyGetSetDef getset_ColorSpectrum_Static[] = {
        { "color_property", reinterpret_cast<getter>(ColorSpectrum_get_ColorProperty), nullptr, nullptr, nullptr },
        { "components_property", reinterpret_cast<getter>(ColorSpectrum_get_ComponentsProperty), nullptr, nullptr, nullptr },
        { "hsv_color_property", reinterpret_cast<getter>(ColorSpectrum_get_HsvColorProperty), nullptr, nullptr, nullptr },
        { "max_hue_property", reinterpret_cast<getter>(ColorSpectrum_get_MaxHueProperty), nullptr, nullptr, nullptr },
        { "max_saturation_property", reinterpret_cast<getter>(ColorSpectrum_get_MaxSaturationProperty), nullptr, nullptr, nullptr },
        { "max_value_property", reinterpret_cast<getter>(ColorSpectrum_get_MaxValueProperty), nullptr, nullptr, nullptr },
        { "min_hue_property", reinterpret_cast<getter>(ColorSpectrum_get_MinHueProperty), nullptr, nullptr, nullptr },
        { "min_saturation_property", reinterpret_cast<getter>(ColorSpectrum_get_MinSaturationProperty), nullptr, nullptr, nullptr },
        { "min_value_property", reinterpret_cast<getter>(ColorSpectrum_get_MinValueProperty), nullptr, nullptr, nullptr },
        { "shape_property", reinterpret_cast<getter>(ColorSpectrum_get_ShapeProperty), nullptr, nullptr, nullptr },
        { }
    };

    static PyMethodDef methods_ColorSpectrum_Static[] = {
        { }
    };

    static PyType_Slot type_slots_ColorSpectrum_Static[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_ColorSpectrum_Static) },
        { Py_tp_methods, reinterpret_cast<void*>(methods_ColorSpectrum_Static) },
        { }
    };

    static PyType_Spec type_spec_ColorSpectrum_Static =
    {
        "winrt._winrt_microsoft_ui_xaml_controls_primitives.ColorSpectrum_Static",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT,
        type_slots_ColorSpectrum_Static
    };

    // ----- ColumnMajorUniformToLargestGridLayout class --------------------

    static PyObject* _new_ColumnMajorUniformToLargestGridLayout(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 0)
        {
            try
            {
                winrt::Microsoft::UI::Xaml::Controls::Primitives::ColumnMajorUniformToLargestGridLayout instance{  };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_ColumnMajorUniformToLargestGridLayout(py::wrapper::Microsoft::UI::Xaml::Controls::Primitives::ColumnMajorUniformToLargestGridLayout* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* ColumnMajorUniformToLargestGridLayout_get_RowSpacing(py::wrapper::Microsoft::UI::Xaml::Controls::Primitives::ColumnMajorUniformToLargestGridLayout* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.ColumnMajorUniformToLargestGridLayout", L"RowSpacing"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.RowSpacing());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ColumnMajorUniformToLargestGridLayout_put_RowSpacing(py::wrapper::Microsoft::UI::Xaml::Controls::Primitives::ColumnMajorUniformToLargestGridLayout* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.ColumnMajorUniformToLargestGridLayout", L"RowSpacing"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<double>(arg);

            self->obj.RowSpacing(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ColumnMajorUniformToLargestGridLayout_get_MaxColumns(py::wrapper::Microsoft::UI::Xaml::Controls::Primitives::ColumnMajorUniformToLargestGridLayout* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.ColumnMajorUniformToLargestGridLayout", L"MaxColumns"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.MaxColumns());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ColumnMajorUniformToLargestGridLayout_put_MaxColumns(py::wrapper::Microsoft::UI::Xaml::Controls::Primitives::ColumnMajorUniformToLargestGridLayout* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.ColumnMajorUniformToLargestGridLayout", L"MaxColumns"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<int32_t>(arg);

            self->obj.MaxColumns(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ColumnMajorUniformToLargestGridLayout_get_ColumnSpacing(py::wrapper::Microsoft::UI::Xaml::Controls::Primitives::ColumnMajorUniformToLargestGridLayout* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.ColumnMajorUniformToLargestGridLayout", L"ColumnSpacing"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.ColumnSpacing());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ColumnMajorUniformToLargestGridLayout_put_ColumnSpacing(py::wrapper::Microsoft::UI::Xaml::Controls::Primitives::ColumnMajorUniformToLargestGridLayout* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.ColumnMajorUniformToLargestGridLayout", L"ColumnSpacing"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<double>(arg);

            self->obj.ColumnSpacing(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ColumnMajorUniformToLargestGridLayout_get_ColumnSpacingProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.ColumnMajorUniformToLargestGridLayout", L"ColumnSpacingProperty"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Microsoft::UI::Xaml::Controls::Primitives::ColumnMajorUniformToLargestGridLayout::ColumnSpacingProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ColumnMajorUniformToLargestGridLayout_get_MaxColumnsProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.ColumnMajorUniformToLargestGridLayout", L"MaxColumnsProperty"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Microsoft::UI::Xaml::Controls::Primitives::ColumnMajorUniformToLargestGridLayout::MaxColumnsProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ColumnMajorUniformToLargestGridLayout_get_RowSpacingProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.ColumnMajorUniformToLargestGridLayout", L"RowSpacingProperty"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Microsoft::UI::Xaml::Controls::Primitives::ColumnMajorUniformToLargestGridLayout::RowSpacingProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_ColumnMajorUniformToLargestGridLayout(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Microsoft::UI::Xaml::Controls::Primitives::ColumnMajorUniformToLargestGridLayout>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_ColumnMajorUniformToLargestGridLayout(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Microsoft::UI::Xaml::Controls::Primitives::ColumnMajorUniformToLargestGridLayout>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_ColumnMajorUniformToLargestGridLayout[] = {
        { "_assign_array_", _assign_array_ColumnMajorUniformToLargestGridLayout, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_ColumnMajorUniformToLargestGridLayout), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_ColumnMajorUniformToLargestGridLayout[] = {
        { "row_spacing", reinterpret_cast<getter>(ColumnMajorUniformToLargestGridLayout_get_RowSpacing), reinterpret_cast<setter>(ColumnMajorUniformToLargestGridLayout_put_RowSpacing), nullptr, nullptr },
        { "max_columns", reinterpret_cast<getter>(ColumnMajorUniformToLargestGridLayout_get_MaxColumns), reinterpret_cast<setter>(ColumnMajorUniformToLargestGridLayout_put_MaxColumns), nullptr, nullptr },
        { "column_spacing", reinterpret_cast<getter>(ColumnMajorUniformToLargestGridLayout_get_ColumnSpacing), reinterpret_cast<setter>(ColumnMajorUniformToLargestGridLayout_put_ColumnSpacing), nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_ColumnMajorUniformToLargestGridLayout[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_ColumnMajorUniformToLargestGridLayout) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_ColumnMajorUniformToLargestGridLayout) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_ColumnMajorUniformToLargestGridLayout) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_ColumnMajorUniformToLargestGridLayout) },
        { },
    };

    static PyType_Spec type_spec_ColumnMajorUniformToLargestGridLayout =
    {
        "winrt._winrt_microsoft_ui_xaml_controls_primitives.ColumnMajorUniformToLargestGridLayout",
        sizeof(py::wrapper::Microsoft::UI::Xaml::Controls::Primitives::ColumnMajorUniformToLargestGridLayout),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_ColumnMajorUniformToLargestGridLayout
    };

    static PyGetSetDef getset_ColumnMajorUniformToLargestGridLayout_Static[] = {
        { "column_spacing_property", reinterpret_cast<getter>(ColumnMajorUniformToLargestGridLayout_get_ColumnSpacingProperty), nullptr, nullptr, nullptr },
        { "max_columns_property", reinterpret_cast<getter>(ColumnMajorUniformToLargestGridLayout_get_MaxColumnsProperty), nullptr, nullptr, nullptr },
        { "row_spacing_property", reinterpret_cast<getter>(ColumnMajorUniformToLargestGridLayout_get_RowSpacingProperty), nullptr, nullptr, nullptr },
        { }
    };

    static PyMethodDef methods_ColumnMajorUniformToLargestGridLayout_Static[] = {
        { }
    };

    static PyType_Slot type_slots_ColumnMajorUniformToLargestGridLayout_Static[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_ColumnMajorUniformToLargestGridLayout_Static) },
        { Py_tp_methods, reinterpret_cast<void*>(methods_ColumnMajorUniformToLargestGridLayout_Static) },
        { }
    };

    static PyType_Spec type_spec_ColumnMajorUniformToLargestGridLayout_Static =
    {
        "winrt._winrt_microsoft_ui_xaml_controls_primitives.ColumnMajorUniformToLargestGridLayout_Static",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT,
        type_slots_ColumnMajorUniformToLargestGridLayout_Static
    };

    // ----- ComboBoxHelper class --------------------

    static PyObject* _new_ComboBoxHelper(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Microsoft::UI::Xaml::Controls::Primitives::ComboBoxHelper>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Microsoft::UI::Xaml::Controls::Primitives::ComboBoxHelper>::type_name);
        return nullptr;
    }

    static void _dealloc_ComboBoxHelper(py::wrapper::Microsoft::UI::Xaml::Controls::Primitives::ComboBoxHelper* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* ComboBoxHelper_GetKeepInteriorCornersSquare(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Xaml.Controls.Primitives.ComboBoxHelper", L"GetKeepInteriorCornersSquare", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Microsoft::UI::Xaml::Controls::ComboBox>(args, 0);

                return py::convert(winrt::Microsoft::UI::Xaml::Controls::Primitives::ComboBoxHelper::GetKeepInteriorCornersSquare(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ComboBoxHelper_SetKeepInteriorCornersSquare(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Xaml.Controls.Primitives.ComboBoxHelper", L"SetKeepInteriorCornersSquare", 2))
            {
                py::set_arg_count_version_error(2);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Microsoft::UI::Xaml::Controls::ComboBox>(args, 0);
                auto param1 = py::convert_to<bool>(args, 1);

                winrt::Microsoft::UI::Xaml::Controls::Primitives::ComboBoxHelper::SetKeepInteriorCornersSquare(param0, param1);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ComboBoxHelper_get_KeepInteriorCornersSquareProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.ComboBoxHelper", L"KeepInteriorCornersSquareProperty"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Microsoft::UI::Xaml::Controls::Primitives::ComboBoxHelper::KeepInteriorCornersSquareProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_ComboBoxHelper(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Microsoft::UI::Xaml::Controls::Primitives::ComboBoxHelper>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_ComboBoxHelper(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Microsoft::UI::Xaml::Controls::Primitives::ComboBoxHelper>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_ComboBoxHelper[] = {
        { "_assign_array_", _assign_array_ComboBoxHelper, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_ComboBoxHelper), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_ComboBoxHelper[] = {
        { }
    };

    static PyType_Slot _type_slots_ComboBoxHelper[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_ComboBoxHelper) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_ComboBoxHelper) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_ComboBoxHelper) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_ComboBoxHelper) },
        { },
    };

    static PyType_Spec type_spec_ComboBoxHelper =
    {
        "winrt._winrt_microsoft_ui_xaml_controls_primitives.ComboBoxHelper",
        sizeof(py::wrapper::Microsoft::UI::Xaml::Controls::Primitives::ComboBoxHelper),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_ComboBoxHelper
    };

    static PyGetSetDef getset_ComboBoxHelper_Static[] = {
        { "keep_interior_corners_square_property", reinterpret_cast<getter>(ComboBoxHelper_get_KeepInteriorCornersSquareProperty), nullptr, nullptr, nullptr },
        { }
    };

    static PyMethodDef methods_ComboBoxHelper_Static[] = {
        { "get_keep_interior_corners_square", reinterpret_cast<PyCFunction>(ComboBoxHelper_GetKeepInteriorCornersSquare), METH_VARARGS, nullptr },
        { "set_keep_interior_corners_square", reinterpret_cast<PyCFunction>(ComboBoxHelper_SetKeepInteriorCornersSquare), METH_VARARGS, nullptr },
        { }
    };

    static PyType_Slot type_slots_ComboBoxHelper_Static[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_ComboBoxHelper_Static) },
        { Py_tp_methods, reinterpret_cast<void*>(methods_ComboBoxHelper_Static) },
        { }
    };

    static PyType_Spec type_spec_ComboBoxHelper_Static =
    {
        "winrt._winrt_microsoft_ui_xaml_controls_primitives.ComboBoxHelper_Static",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT,
        type_slots_ComboBoxHelper_Static
    };

    // ----- ComboBoxTemplateSettings class --------------------

    static PyObject* _new_ComboBoxTemplateSettings(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Microsoft::UI::Xaml::Controls::Primitives::ComboBoxTemplateSettings>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Microsoft::UI::Xaml::Controls::Primitives::ComboBoxTemplateSettings>::type_name);
        return nullptr;
    }

    static void _dealloc_ComboBoxTemplateSettings(py::wrapper::Microsoft::UI::Xaml::Controls::Primitives::ComboBoxTemplateSettings* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* ComboBoxTemplateSettings_get_DropDownClosedHeight(py::wrapper::Microsoft::UI::Xaml::Controls::Primitives::ComboBoxTemplateSettings* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.ComboBoxTemplateSettings", L"DropDownClosedHeight"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.DropDownClosedHeight());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ComboBoxTemplateSettings_get_DropDownContentMinWidth(py::wrapper::Microsoft::UI::Xaml::Controls::Primitives::ComboBoxTemplateSettings* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.ComboBoxTemplateSettings", L"DropDownContentMinWidth"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.DropDownContentMinWidth());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ComboBoxTemplateSettings_get_DropDownOffset(py::wrapper::Microsoft::UI::Xaml::Controls::Primitives::ComboBoxTemplateSettings* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.ComboBoxTemplateSettings", L"DropDownOffset"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.DropDownOffset());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ComboBoxTemplateSettings_get_DropDownOpenedHeight(py::wrapper::Microsoft::UI::Xaml::Controls::Primitives::ComboBoxTemplateSettings* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.ComboBoxTemplateSettings", L"DropDownOpenedHeight"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.DropDownOpenedHeight());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ComboBoxTemplateSettings_get_SelectedItemDirection(py::wrapper::Microsoft::UI::Xaml::Controls::Primitives::ComboBoxTemplateSettings* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.ComboBoxTemplateSettings", L"SelectedItemDirection"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.SelectedItemDirection());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_ComboBoxTemplateSettings(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Microsoft::UI::Xaml::Controls::Primitives::ComboBoxTemplateSettings>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_ComboBoxTemplateSettings(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Microsoft::UI::Xaml::Controls::Primitives::ComboBoxTemplateSettings>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_ComboBoxTemplateSettings[] = {
        { "_assign_array_", _assign_array_ComboBoxTemplateSettings, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_ComboBoxTemplateSettings), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_ComboBoxTemplateSettings[] = {
        { "drop_down_closed_height", reinterpret_cast<getter>(ComboBoxTemplateSettings_get_DropDownClosedHeight), nullptr, nullptr, nullptr },
        { "drop_down_content_min_width", reinterpret_cast<getter>(ComboBoxTemplateSettings_get_DropDownContentMinWidth), nullptr, nullptr, nullptr },
        { "drop_down_offset", reinterpret_cast<getter>(ComboBoxTemplateSettings_get_DropDownOffset), nullptr, nullptr, nullptr },
        { "drop_down_opened_height", reinterpret_cast<getter>(ComboBoxTemplateSettings_get_DropDownOpenedHeight), nullptr, nullptr, nullptr },
        { "selected_item_direction", reinterpret_cast<getter>(ComboBoxTemplateSettings_get_SelectedItemDirection), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_ComboBoxTemplateSettings[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_ComboBoxTemplateSettings) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_ComboBoxTemplateSettings) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_ComboBoxTemplateSettings) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_ComboBoxTemplateSettings) },
        { },
    };

    static PyType_Spec type_spec_ComboBoxTemplateSettings =
    {
        "winrt._winrt_microsoft_ui_xaml_controls_primitives.ComboBoxTemplateSettings",
        sizeof(py::wrapper::Microsoft::UI::Xaml::Controls::Primitives::ComboBoxTemplateSettings),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_ComboBoxTemplateSettings
    };

    // ----- CommandBarFlyoutCommandBar class --------------------

    static PyObject* _new_CommandBarFlyoutCommandBar(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 0)
        {
            try
            {
                winrt::Microsoft::UI::Xaml::Controls::Primitives::CommandBarFlyoutCommandBar instance{  };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_CommandBarFlyoutCommandBar(py::wrapper::Microsoft::UI::Xaml::Controls::Primitives::CommandBarFlyoutCommandBar* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* CommandBarFlyoutCommandBar_get_FlyoutTemplateSettings(py::wrapper::Microsoft::UI::Xaml::Controls::Primitives::CommandBarFlyoutCommandBar* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.CommandBarFlyoutCommandBar", L"FlyoutTemplateSettings"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.FlyoutTemplateSettings());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CommandBarFlyoutCommandBar_get_SystemBackdrop(py::wrapper::Microsoft::UI::Xaml::Controls::Primitives::CommandBarFlyoutCommandBar* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.CommandBarFlyoutCommandBar", L"SystemBackdrop"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.SystemBackdrop());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int CommandBarFlyoutCommandBar_put_SystemBackdrop(py::wrapper::Microsoft::UI::Xaml::Controls::Primitives::CommandBarFlyoutCommandBar* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.CommandBarFlyoutCommandBar", L"SystemBackdrop"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Microsoft::UI::Xaml::Media::SystemBackdrop>(arg);

            self->obj.SystemBackdrop(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* CommandBarFlyoutCommandBar_get_SystemBackdropProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.CommandBarFlyoutCommandBar", L"SystemBackdropProperty"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Microsoft::UI::Xaml::Controls::Primitives::CommandBarFlyoutCommandBar::SystemBackdropProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_CommandBarFlyoutCommandBar(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Microsoft::UI::Xaml::Controls::Primitives::CommandBarFlyoutCommandBar>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_CommandBarFlyoutCommandBar(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Microsoft::UI::Xaml::Controls::Primitives::CommandBarFlyoutCommandBar>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_CommandBarFlyoutCommandBar[] = {
        { "_assign_array_", _assign_array_CommandBarFlyoutCommandBar, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_CommandBarFlyoutCommandBar), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_CommandBarFlyoutCommandBar[] = {
        { "flyout_template_settings", reinterpret_cast<getter>(CommandBarFlyoutCommandBar_get_FlyoutTemplateSettings), nullptr, nullptr, nullptr },
        { "system_backdrop", reinterpret_cast<getter>(CommandBarFlyoutCommandBar_get_SystemBackdrop), reinterpret_cast<setter>(CommandBarFlyoutCommandBar_put_SystemBackdrop), nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_CommandBarFlyoutCommandBar[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_CommandBarFlyoutCommandBar) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_CommandBarFlyoutCommandBar) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_CommandBarFlyoutCommandBar) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_CommandBarFlyoutCommandBar) },
        { },
    };

    static PyType_Spec type_spec_CommandBarFlyoutCommandBar =
    {
        "winrt._winrt_microsoft_ui_xaml_controls_primitives.CommandBarFlyoutCommandBar",
        sizeof(py::wrapper::Microsoft::UI::Xaml::Controls::Primitives::CommandBarFlyoutCommandBar),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_CommandBarFlyoutCommandBar
    };

    static PyGetSetDef getset_CommandBarFlyoutCommandBar_Static[] = {
        { "system_backdrop_property", reinterpret_cast<getter>(CommandBarFlyoutCommandBar_get_SystemBackdropProperty), nullptr, nullptr, nullptr },
        { }
    };

    static PyMethodDef methods_CommandBarFlyoutCommandBar_Static[] = {
        { }
    };

    static PyType_Slot type_slots_CommandBarFlyoutCommandBar_Static[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_CommandBarFlyoutCommandBar_Static) },
        { Py_tp_methods, reinterpret_cast<void*>(methods_CommandBarFlyoutCommandBar_Static) },
        { }
    };

    static PyType_Spec type_spec_CommandBarFlyoutCommandBar_Static =
    {
        "winrt._winrt_microsoft_ui_xaml_controls_primitives.CommandBarFlyoutCommandBar_Static",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT,
        type_slots_CommandBarFlyoutCommandBar_Static
    };

    // ----- CommandBarFlyoutCommandBarAutomationProperties class --------------------

    static PyObject* _new_CommandBarFlyoutCommandBarAutomationProperties(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Microsoft::UI::Xaml::Controls::Primitives::CommandBarFlyoutCommandBarAutomationProperties>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Microsoft::UI::Xaml::Controls::Primitives::CommandBarFlyoutCommandBarAutomationProperties>::type_name);
        return nullptr;
    }

    static PyObject* CommandBarFlyoutCommandBarAutomationProperties_GetControlType(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Xaml.Controls.Primitives.CommandBarFlyoutCommandBarAutomationProperties", L"GetControlType", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Microsoft::UI::Xaml::UIElement>(args, 0);

                return py::convert(winrt::Microsoft::UI::Xaml::Controls::Primitives::CommandBarFlyoutCommandBarAutomationProperties::GetControlType(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* CommandBarFlyoutCommandBarAutomationProperties_SetControlType(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Xaml.Controls.Primitives.CommandBarFlyoutCommandBarAutomationProperties", L"SetControlType", 2))
            {
                py::set_arg_count_version_error(2);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Microsoft::UI::Xaml::UIElement>(args, 0);
                auto param1 = py::convert_to<winrt::Microsoft::UI::Xaml::Automation::Peers::AutomationControlType>(args, 1);

                winrt::Microsoft::UI::Xaml::Controls::Primitives::CommandBarFlyoutCommandBarAutomationProperties::SetControlType(param0, param1);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* CommandBarFlyoutCommandBarAutomationProperties_get_ControlTypeProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.CommandBarFlyoutCommandBarAutomationProperties", L"ControlTypeProperty"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Microsoft::UI::Xaml::Controls::Primitives::CommandBarFlyoutCommandBarAutomationProperties::ControlTypeProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_CommandBarFlyoutCommandBarAutomationProperties[] = {
        { }
    };

    static PyGetSetDef _getset_CommandBarFlyoutCommandBarAutomationProperties[] = {
        { }
    };

    static PyType_Slot _type_slots_CommandBarFlyoutCommandBarAutomationProperties[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_CommandBarFlyoutCommandBarAutomationProperties) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_CommandBarFlyoutCommandBarAutomationProperties) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_CommandBarFlyoutCommandBarAutomationProperties) },
        { },
    };

    static PyType_Spec type_spec_CommandBarFlyoutCommandBarAutomationProperties =
    {
        "winrt._winrt_microsoft_ui_xaml_controls_primitives.CommandBarFlyoutCommandBarAutomationProperties",
        0,
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_CommandBarFlyoutCommandBarAutomationProperties
    };

    static PyGetSetDef getset_CommandBarFlyoutCommandBarAutomationProperties_Static[] = {
        { "control_type_property", reinterpret_cast<getter>(CommandBarFlyoutCommandBarAutomationProperties_get_ControlTypeProperty), nullptr, nullptr, nullptr },
        { }
    };

    static PyMethodDef methods_CommandBarFlyoutCommandBarAutomationProperties_Static[] = {
        { "get_control_type", reinterpret_cast<PyCFunction>(CommandBarFlyoutCommandBarAutomationProperties_GetControlType), METH_VARARGS, nullptr },
        { "set_control_type", reinterpret_cast<PyCFunction>(CommandBarFlyoutCommandBarAutomationProperties_SetControlType), METH_VARARGS, nullptr },
        { }
    };

    static PyType_Slot type_slots_CommandBarFlyoutCommandBarAutomationProperties_Static[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_CommandBarFlyoutCommandBarAutomationProperties_Static) },
        { Py_tp_methods, reinterpret_cast<void*>(methods_CommandBarFlyoutCommandBarAutomationProperties_Static) },
        { }
    };

    static PyType_Spec type_spec_CommandBarFlyoutCommandBarAutomationProperties_Static =
    {
        "winrt._winrt_microsoft_ui_xaml_controls_primitives.CommandBarFlyoutCommandBarAutomationProperties_Static",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT,
        type_slots_CommandBarFlyoutCommandBarAutomationProperties_Static
    };

    // ----- CommandBarFlyoutCommandBarTemplateSettings class --------------------

    static PyObject* _new_CommandBarFlyoutCommandBarTemplateSettings(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Microsoft::UI::Xaml::Controls::Primitives::CommandBarFlyoutCommandBarTemplateSettings>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Microsoft::UI::Xaml::Controls::Primitives::CommandBarFlyoutCommandBarTemplateSettings>::type_name);
        return nullptr;
    }

    static void _dealloc_CommandBarFlyoutCommandBarTemplateSettings(py::wrapper::Microsoft::UI::Xaml::Controls::Primitives::CommandBarFlyoutCommandBarTemplateSettings* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* CommandBarFlyoutCommandBarTemplateSettings_get_CloseAnimationEndPosition(py::wrapper::Microsoft::UI::Xaml::Controls::Primitives::CommandBarFlyoutCommandBarTemplateSettings* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.CommandBarFlyoutCommandBarTemplateSettings", L"CloseAnimationEndPosition"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.CloseAnimationEndPosition());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CommandBarFlyoutCommandBarTemplateSettings_get_ContentClipRect(py::wrapper::Microsoft::UI::Xaml::Controls::Primitives::CommandBarFlyoutCommandBarTemplateSettings* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.CommandBarFlyoutCommandBarTemplateSettings", L"ContentClipRect"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.ContentClipRect());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CommandBarFlyoutCommandBarTemplateSettings_get_CurrentWidth(py::wrapper::Microsoft::UI::Xaml::Controls::Primitives::CommandBarFlyoutCommandBarTemplateSettings* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.CommandBarFlyoutCommandBarTemplateSettings", L"CurrentWidth"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.CurrentWidth());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CommandBarFlyoutCommandBarTemplateSettings_get_ExpandDownAnimationEndPosition(py::wrapper::Microsoft::UI::Xaml::Controls::Primitives::CommandBarFlyoutCommandBarTemplateSettings* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.CommandBarFlyoutCommandBarTemplateSettings", L"ExpandDownAnimationEndPosition"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.ExpandDownAnimationEndPosition());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CommandBarFlyoutCommandBarTemplateSettings_get_ExpandDownAnimationHoldPosition(py::wrapper::Microsoft::UI::Xaml::Controls::Primitives::CommandBarFlyoutCommandBarTemplateSettings* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.CommandBarFlyoutCommandBarTemplateSettings", L"ExpandDownAnimationHoldPosition"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.ExpandDownAnimationHoldPosition());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CommandBarFlyoutCommandBarTemplateSettings_get_ExpandDownAnimationStartPosition(py::wrapper::Microsoft::UI::Xaml::Controls::Primitives::CommandBarFlyoutCommandBarTemplateSettings* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.CommandBarFlyoutCommandBarTemplateSettings", L"ExpandDownAnimationStartPosition"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.ExpandDownAnimationStartPosition());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CommandBarFlyoutCommandBarTemplateSettings_get_ExpandDownOverflowVerticalPosition(py::wrapper::Microsoft::UI::Xaml::Controls::Primitives::CommandBarFlyoutCommandBarTemplateSettings* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.CommandBarFlyoutCommandBarTemplateSettings", L"ExpandDownOverflowVerticalPosition"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.ExpandDownOverflowVerticalPosition());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CommandBarFlyoutCommandBarTemplateSettings_get_ExpandUpAnimationEndPosition(py::wrapper::Microsoft::UI::Xaml::Controls::Primitives::CommandBarFlyoutCommandBarTemplateSettings* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.CommandBarFlyoutCommandBarTemplateSettings", L"ExpandUpAnimationEndPosition"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.ExpandUpAnimationEndPosition());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CommandBarFlyoutCommandBarTemplateSettings_get_ExpandUpAnimationHoldPosition(py::wrapper::Microsoft::UI::Xaml::Controls::Primitives::CommandBarFlyoutCommandBarTemplateSettings* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.CommandBarFlyoutCommandBarTemplateSettings", L"ExpandUpAnimationHoldPosition"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.ExpandUpAnimationHoldPosition());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CommandBarFlyoutCommandBarTemplateSettings_get_ExpandUpAnimationStartPosition(py::wrapper::Microsoft::UI::Xaml::Controls::Primitives::CommandBarFlyoutCommandBarTemplateSettings* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.CommandBarFlyoutCommandBarTemplateSettings", L"ExpandUpAnimationStartPosition"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.ExpandUpAnimationStartPosition());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CommandBarFlyoutCommandBarTemplateSettings_get_ExpandUpOverflowVerticalPosition(py::wrapper::Microsoft::UI::Xaml::Controls::Primitives::CommandBarFlyoutCommandBarTemplateSettings* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.CommandBarFlyoutCommandBarTemplateSettings", L"ExpandUpOverflowVerticalPosition"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.ExpandUpOverflowVerticalPosition());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CommandBarFlyoutCommandBarTemplateSettings_get_ExpandedWidth(py::wrapper::Microsoft::UI::Xaml::Controls::Primitives::CommandBarFlyoutCommandBarTemplateSettings* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.CommandBarFlyoutCommandBarTemplateSettings", L"ExpandedWidth"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.ExpandedWidth());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CommandBarFlyoutCommandBarTemplateSettings_get_OpenAnimationEndPosition(py::wrapper::Microsoft::UI::Xaml::Controls::Primitives::CommandBarFlyoutCommandBarTemplateSettings* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.CommandBarFlyoutCommandBarTemplateSettings", L"OpenAnimationEndPosition"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.OpenAnimationEndPosition());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CommandBarFlyoutCommandBarTemplateSettings_get_OpenAnimationStartPosition(py::wrapper::Microsoft::UI::Xaml::Controls::Primitives::CommandBarFlyoutCommandBarTemplateSettings* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.CommandBarFlyoutCommandBarTemplateSettings", L"OpenAnimationStartPosition"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.OpenAnimationStartPosition());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CommandBarFlyoutCommandBarTemplateSettings_get_OverflowContentClipRect(py::wrapper::Microsoft::UI::Xaml::Controls::Primitives::CommandBarFlyoutCommandBarTemplateSettings* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.CommandBarFlyoutCommandBarTemplateSettings", L"OverflowContentClipRect"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.OverflowContentClipRect());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CommandBarFlyoutCommandBarTemplateSettings_get_WidthExpansionAnimationEndPosition(py::wrapper::Microsoft::UI::Xaml::Controls::Primitives::CommandBarFlyoutCommandBarTemplateSettings* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.CommandBarFlyoutCommandBarTemplateSettings", L"WidthExpansionAnimationEndPosition"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.WidthExpansionAnimationEndPosition());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CommandBarFlyoutCommandBarTemplateSettings_get_WidthExpansionAnimationStartPosition(py::wrapper::Microsoft::UI::Xaml::Controls::Primitives::CommandBarFlyoutCommandBarTemplateSettings* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.CommandBarFlyoutCommandBarTemplateSettings", L"WidthExpansionAnimationStartPosition"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.WidthExpansionAnimationStartPosition());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CommandBarFlyoutCommandBarTemplateSettings_get_WidthExpansionDelta(py::wrapper::Microsoft::UI::Xaml::Controls::Primitives::CommandBarFlyoutCommandBarTemplateSettings* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.CommandBarFlyoutCommandBarTemplateSettings", L"WidthExpansionDelta"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.WidthExpansionDelta());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CommandBarFlyoutCommandBarTemplateSettings_get_WidthExpansionMoreButtonAnimationEndPosition(py::wrapper::Microsoft::UI::Xaml::Controls::Primitives::CommandBarFlyoutCommandBarTemplateSettings* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.CommandBarFlyoutCommandBarTemplateSettings", L"WidthExpansionMoreButtonAnimationEndPosition"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.WidthExpansionMoreButtonAnimationEndPosition());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CommandBarFlyoutCommandBarTemplateSettings_get_WidthExpansionMoreButtonAnimationStartPosition(py::wrapper::Microsoft::UI::Xaml::Controls::Primitives::CommandBarFlyoutCommandBarTemplateSettings* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.CommandBarFlyoutCommandBarTemplateSettings", L"WidthExpansionMoreButtonAnimationStartPosition"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.WidthExpansionMoreButtonAnimationStartPosition());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_CommandBarFlyoutCommandBarTemplateSettings(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Microsoft::UI::Xaml::Controls::Primitives::CommandBarFlyoutCommandBarTemplateSettings>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_CommandBarFlyoutCommandBarTemplateSettings(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Microsoft::UI::Xaml::Controls::Primitives::CommandBarFlyoutCommandBarTemplateSettings>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_CommandBarFlyoutCommandBarTemplateSettings[] = {
        { "_assign_array_", _assign_array_CommandBarFlyoutCommandBarTemplateSettings, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_CommandBarFlyoutCommandBarTemplateSettings), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_CommandBarFlyoutCommandBarTemplateSettings[] = {
        { "close_animation_end_position", reinterpret_cast<getter>(CommandBarFlyoutCommandBarTemplateSettings_get_CloseAnimationEndPosition), nullptr, nullptr, nullptr },
        { "content_clip_rect", reinterpret_cast<getter>(CommandBarFlyoutCommandBarTemplateSettings_get_ContentClipRect), nullptr, nullptr, nullptr },
        { "current_width", reinterpret_cast<getter>(CommandBarFlyoutCommandBarTemplateSettings_get_CurrentWidth), nullptr, nullptr, nullptr },
        { "expand_down_animation_end_position", reinterpret_cast<getter>(CommandBarFlyoutCommandBarTemplateSettings_get_ExpandDownAnimationEndPosition), nullptr, nullptr, nullptr },
        { "expand_down_animation_hold_position", reinterpret_cast<getter>(CommandBarFlyoutCommandBarTemplateSettings_get_ExpandDownAnimationHoldPosition), nullptr, nullptr, nullptr },
        { "expand_down_animation_start_position", reinterpret_cast<getter>(CommandBarFlyoutCommandBarTemplateSettings_get_ExpandDownAnimationStartPosition), nullptr, nullptr, nullptr },
        { "expand_down_overflow_vertical_position", reinterpret_cast<getter>(CommandBarFlyoutCommandBarTemplateSettings_get_ExpandDownOverflowVerticalPosition), nullptr, nullptr, nullptr },
        { "expand_up_animation_end_position", reinterpret_cast<getter>(CommandBarFlyoutCommandBarTemplateSettings_get_ExpandUpAnimationEndPosition), nullptr, nullptr, nullptr },
        { "expand_up_animation_hold_position", reinterpret_cast<getter>(CommandBarFlyoutCommandBarTemplateSettings_get_ExpandUpAnimationHoldPosition), nullptr, nullptr, nullptr },
        { "expand_up_animation_start_position", reinterpret_cast<getter>(CommandBarFlyoutCommandBarTemplateSettings_get_ExpandUpAnimationStartPosition), nullptr, nullptr, nullptr },
        { "expand_up_overflow_vertical_position", reinterpret_cast<getter>(CommandBarFlyoutCommandBarTemplateSettings_get_ExpandUpOverflowVerticalPosition), nullptr, nullptr, nullptr },
        { "expanded_width", reinterpret_cast<getter>(CommandBarFlyoutCommandBarTemplateSettings_get_ExpandedWidth), nullptr, nullptr, nullptr },
        { "open_animation_end_position", reinterpret_cast<getter>(CommandBarFlyoutCommandBarTemplateSettings_get_OpenAnimationEndPosition), nullptr, nullptr, nullptr },
        { "open_animation_start_position", reinterpret_cast<getter>(CommandBarFlyoutCommandBarTemplateSettings_get_OpenAnimationStartPosition), nullptr, nullptr, nullptr },
        { "overflow_content_clip_rect", reinterpret_cast<getter>(CommandBarFlyoutCommandBarTemplateSettings_get_OverflowContentClipRect), nullptr, nullptr, nullptr },
        { "width_expansion_animation_end_position", reinterpret_cast<getter>(CommandBarFlyoutCommandBarTemplateSettings_get_WidthExpansionAnimationEndPosition), nullptr, nullptr, nullptr },
        { "width_expansion_animation_start_position", reinterpret_cast<getter>(CommandBarFlyoutCommandBarTemplateSettings_get_WidthExpansionAnimationStartPosition), nullptr, nullptr, nullptr },
        { "width_expansion_delta", reinterpret_cast<getter>(CommandBarFlyoutCommandBarTemplateSettings_get_WidthExpansionDelta), nullptr, nullptr, nullptr },
        { "width_expansion_more_button_animation_end_position", reinterpret_cast<getter>(CommandBarFlyoutCommandBarTemplateSettings_get_WidthExpansionMoreButtonAnimationEndPosition), nullptr, nullptr, nullptr },
        { "width_expansion_more_button_animation_start_position", reinterpret_cast<getter>(CommandBarFlyoutCommandBarTemplateSettings_get_WidthExpansionMoreButtonAnimationStartPosition), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_CommandBarFlyoutCommandBarTemplateSettings[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_CommandBarFlyoutCommandBarTemplateSettings) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_CommandBarFlyoutCommandBarTemplateSettings) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_CommandBarFlyoutCommandBarTemplateSettings) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_CommandBarFlyoutCommandBarTemplateSettings) },
        { },
    };

    static PyType_Spec type_spec_CommandBarFlyoutCommandBarTemplateSettings =
    {
        "winrt._winrt_microsoft_ui_xaml_controls_primitives.CommandBarFlyoutCommandBarTemplateSettings",
        sizeof(py::wrapper::Microsoft::UI::Xaml::Controls::Primitives::CommandBarFlyoutCommandBarTemplateSettings),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_CommandBarFlyoutCommandBarTemplateSettings
    };

    // ----- CommandBarTemplateSettings class --------------------

    static PyObject* _new_CommandBarTemplateSettings(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Microsoft::UI::Xaml::Controls::Primitives::CommandBarTemplateSettings>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Microsoft::UI::Xaml::Controls::Primitives::CommandBarTemplateSettings>::type_name);
        return nullptr;
    }

    static void _dealloc_CommandBarTemplateSettings(py::wrapper::Microsoft::UI::Xaml::Controls::Primitives::CommandBarTemplateSettings* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* CommandBarTemplateSettings_get_ContentHeight(py::wrapper::Microsoft::UI::Xaml::Controls::Primitives::CommandBarTemplateSettings* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.CommandBarTemplateSettings", L"ContentHeight"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.ContentHeight());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CommandBarTemplateSettings_get_EffectiveOverflowButtonVisibility(py::wrapper::Microsoft::UI::Xaml::Controls::Primitives::CommandBarTemplateSettings* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.CommandBarTemplateSettings", L"EffectiveOverflowButtonVisibility"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.EffectiveOverflowButtonVisibility());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CommandBarTemplateSettings_get_NegativeOverflowContentHeight(py::wrapper::Microsoft::UI::Xaml::Controls::Primitives::CommandBarTemplateSettings* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.CommandBarTemplateSettings", L"NegativeOverflowContentHeight"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.NegativeOverflowContentHeight());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CommandBarTemplateSettings_get_OverflowContentClipRect(py::wrapper::Microsoft::UI::Xaml::Controls::Primitives::CommandBarTemplateSettings* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.CommandBarTemplateSettings", L"OverflowContentClipRect"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.OverflowContentClipRect());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CommandBarTemplateSettings_get_OverflowContentCompactYTranslation(py::wrapper::Microsoft::UI::Xaml::Controls::Primitives::CommandBarTemplateSettings* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.CommandBarTemplateSettings", L"OverflowContentCompactYTranslation"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.OverflowContentCompactYTranslation());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CommandBarTemplateSettings_get_OverflowContentHeight(py::wrapper::Microsoft::UI::Xaml::Controls::Primitives::CommandBarTemplateSettings* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.CommandBarTemplateSettings", L"OverflowContentHeight"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.OverflowContentHeight());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CommandBarTemplateSettings_get_OverflowContentHiddenYTranslation(py::wrapper::Microsoft::UI::Xaml::Controls::Primitives::CommandBarTemplateSettings* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.CommandBarTemplateSettings", L"OverflowContentHiddenYTranslation"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.OverflowContentHiddenYTranslation());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CommandBarTemplateSettings_get_OverflowContentHorizontalOffset(py::wrapper::Microsoft::UI::Xaml::Controls::Primitives::CommandBarTemplateSettings* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.CommandBarTemplateSettings", L"OverflowContentHorizontalOffset"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.OverflowContentHorizontalOffset());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CommandBarTemplateSettings_get_OverflowContentMaxHeight(py::wrapper::Microsoft::UI::Xaml::Controls::Primitives::CommandBarTemplateSettings* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.CommandBarTemplateSettings", L"OverflowContentMaxHeight"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.OverflowContentMaxHeight());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CommandBarTemplateSettings_get_OverflowContentMaxWidth(py::wrapper::Microsoft::UI::Xaml::Controls::Primitives::CommandBarTemplateSettings* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.CommandBarTemplateSettings", L"OverflowContentMaxWidth"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.OverflowContentMaxWidth());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CommandBarTemplateSettings_get_OverflowContentMinWidth(py::wrapper::Microsoft::UI::Xaml::Controls::Primitives::CommandBarTemplateSettings* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.CommandBarTemplateSettings", L"OverflowContentMinWidth"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.OverflowContentMinWidth());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CommandBarTemplateSettings_get_OverflowContentMinimalYTranslation(py::wrapper::Microsoft::UI::Xaml::Controls::Primitives::CommandBarTemplateSettings* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.CommandBarTemplateSettings", L"OverflowContentMinimalYTranslation"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.OverflowContentMinimalYTranslation());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_CommandBarTemplateSettings(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Microsoft::UI::Xaml::Controls::Primitives::CommandBarTemplateSettings>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_CommandBarTemplateSettings(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Microsoft::UI::Xaml::Controls::Primitives::CommandBarTemplateSettings>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_CommandBarTemplateSettings[] = {
        { "_assign_array_", _assign_array_CommandBarTemplateSettings, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_CommandBarTemplateSettings), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_CommandBarTemplateSettings[] = {
        { "content_height", reinterpret_cast<getter>(CommandBarTemplateSettings_get_ContentHeight), nullptr, nullptr, nullptr },
        { "effective_overflow_button_visibility", reinterpret_cast<getter>(CommandBarTemplateSettings_get_EffectiveOverflowButtonVisibility), nullptr, nullptr, nullptr },
        { "negative_overflow_content_height", reinterpret_cast<getter>(CommandBarTemplateSettings_get_NegativeOverflowContentHeight), nullptr, nullptr, nullptr },
        { "overflow_content_clip_rect", reinterpret_cast<getter>(CommandBarTemplateSettings_get_OverflowContentClipRect), nullptr, nullptr, nullptr },
        { "overflow_content_compact_y_translation", reinterpret_cast<getter>(CommandBarTemplateSettings_get_OverflowContentCompactYTranslation), nullptr, nullptr, nullptr },
        { "overflow_content_height", reinterpret_cast<getter>(CommandBarTemplateSettings_get_OverflowContentHeight), nullptr, nullptr, nullptr },
        { "overflow_content_hidden_y_translation", reinterpret_cast<getter>(CommandBarTemplateSettings_get_OverflowContentHiddenYTranslation), nullptr, nullptr, nullptr },
        { "overflow_content_horizontal_offset", reinterpret_cast<getter>(CommandBarTemplateSettings_get_OverflowContentHorizontalOffset), nullptr, nullptr, nullptr },
        { "overflow_content_max_height", reinterpret_cast<getter>(CommandBarTemplateSettings_get_OverflowContentMaxHeight), nullptr, nullptr, nullptr },
        { "overflow_content_max_width", reinterpret_cast<getter>(CommandBarTemplateSettings_get_OverflowContentMaxWidth), nullptr, nullptr, nullptr },
        { "overflow_content_min_width", reinterpret_cast<getter>(CommandBarTemplateSettings_get_OverflowContentMinWidth), nullptr, nullptr, nullptr },
        { "overflow_content_minimal_y_translation", reinterpret_cast<getter>(CommandBarTemplateSettings_get_OverflowContentMinimalYTranslation), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_CommandBarTemplateSettings[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_CommandBarTemplateSettings) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_CommandBarTemplateSettings) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_CommandBarTemplateSettings) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_CommandBarTemplateSettings) },
        { },
    };

    static PyType_Spec type_spec_CommandBarTemplateSettings =
    {
        "winrt._winrt_microsoft_ui_xaml_controls_primitives.CommandBarTemplateSettings",
        sizeof(py::wrapper::Microsoft::UI::Xaml::Controls::Primitives::CommandBarTemplateSettings),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_CommandBarTemplateSettings
    };

    // ----- CornerRadiusFilterConverter class --------------------

    static PyObject* _new_CornerRadiusFilterConverter(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 0)
        {
            try
            {
                winrt::Microsoft::UI::Xaml::Controls::Primitives::CornerRadiusFilterConverter instance{  };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_CornerRadiusFilterConverter(py::wrapper::Microsoft::UI::Xaml::Controls::Primitives::CornerRadiusFilterConverter* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* CornerRadiusFilterConverter_Convert(py::wrapper::Microsoft::UI::Xaml::Controls::Primitives::CornerRadiusFilterConverter* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 4)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Xaml.Controls.Primitives.CornerRadiusFilterConverter", L"Convert", 4))
            {
                py::set_arg_count_version_error(4);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::Foundation::IInspectable>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::UI::Xaml::Interop::TypeName>(args, 1);
                auto param2 = py::convert_to<winrt::Windows::Foundation::IInspectable>(args, 2);
                auto param3 = py::convert_to<winrt::hstring>(args, 3);

                return py::convert(self->obj.Convert(param0, param1, param2, param3));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* CornerRadiusFilterConverter_ConvertBack(py::wrapper::Microsoft::UI::Xaml::Controls::Primitives::CornerRadiusFilterConverter* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 4)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Xaml.Controls.Primitives.CornerRadiusFilterConverter", L"ConvertBack", 4))
            {
                py::set_arg_count_version_error(4);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::Foundation::IInspectable>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::UI::Xaml::Interop::TypeName>(args, 1);
                auto param2 = py::convert_to<winrt::Windows::Foundation::IInspectable>(args, 2);
                auto param3 = py::convert_to<winrt::hstring>(args, 3);

                return py::convert(self->obj.ConvertBack(param0, param1, param2, param3));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* CornerRadiusFilterConverter_get_Scale(py::wrapper::Microsoft::UI::Xaml::Controls::Primitives::CornerRadiusFilterConverter* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.CornerRadiusFilterConverter", L"Scale"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Scale());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int CornerRadiusFilterConverter_put_Scale(py::wrapper::Microsoft::UI::Xaml::Controls::Primitives::CornerRadiusFilterConverter* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.CornerRadiusFilterConverter", L"Scale"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<double>(arg);

            self->obj.Scale(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* CornerRadiusFilterConverter_get_Filter(py::wrapper::Microsoft::UI::Xaml::Controls::Primitives::CornerRadiusFilterConverter* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.CornerRadiusFilterConverter", L"Filter"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Filter());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int CornerRadiusFilterConverter_put_Filter(py::wrapper::Microsoft::UI::Xaml::Controls::Primitives::CornerRadiusFilterConverter* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.CornerRadiusFilterConverter", L"Filter"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Microsoft::UI::Xaml::Controls::Primitives::CornerRadiusFilterKind>(arg);

            self->obj.Filter(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* CornerRadiusFilterConverter_get_FilterProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.CornerRadiusFilterConverter", L"FilterProperty"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Microsoft::UI::Xaml::Controls::Primitives::CornerRadiusFilterConverter::FilterProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CornerRadiusFilterConverter_get_ScaleProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.CornerRadiusFilterConverter", L"ScaleProperty"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Microsoft::UI::Xaml::Controls::Primitives::CornerRadiusFilterConverter::ScaleProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_CornerRadiusFilterConverter(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Microsoft::UI::Xaml::Controls::Primitives::CornerRadiusFilterConverter>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_CornerRadiusFilterConverter(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Microsoft::UI::Xaml::Controls::Primitives::CornerRadiusFilterConverter>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_CornerRadiusFilterConverter[] = {
        { "convert", reinterpret_cast<PyCFunction>(CornerRadiusFilterConverter_Convert), METH_VARARGS, nullptr },
        { "convert_back", reinterpret_cast<PyCFunction>(CornerRadiusFilterConverter_ConvertBack), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_CornerRadiusFilterConverter, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_CornerRadiusFilterConverter), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_CornerRadiusFilterConverter[] = {
        { "scale", reinterpret_cast<getter>(CornerRadiusFilterConverter_get_Scale), reinterpret_cast<setter>(CornerRadiusFilterConverter_put_Scale), nullptr, nullptr },
        { "filter", reinterpret_cast<getter>(CornerRadiusFilterConverter_get_Filter), reinterpret_cast<setter>(CornerRadiusFilterConverter_put_Filter), nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_CornerRadiusFilterConverter[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_CornerRadiusFilterConverter) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_CornerRadiusFilterConverter) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_CornerRadiusFilterConverter) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_CornerRadiusFilterConverter) },
        { },
    };

    static PyType_Spec type_spec_CornerRadiusFilterConverter =
    {
        "winrt._winrt_microsoft_ui_xaml_controls_primitives.CornerRadiusFilterConverter",
        sizeof(py::wrapper::Microsoft::UI::Xaml::Controls::Primitives::CornerRadiusFilterConverter),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_CornerRadiusFilterConverter
    };

    static PyGetSetDef getset_CornerRadiusFilterConverter_Static[] = {
        { "filter_property", reinterpret_cast<getter>(CornerRadiusFilterConverter_get_FilterProperty), nullptr, nullptr, nullptr },
        { "scale_property", reinterpret_cast<getter>(CornerRadiusFilterConverter_get_ScaleProperty), nullptr, nullptr, nullptr },
        { }
    };

    static PyMethodDef methods_CornerRadiusFilterConverter_Static[] = {
        { }
    };

    static PyType_Slot type_slots_CornerRadiusFilterConverter_Static[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_CornerRadiusFilterConverter_Static) },
        { Py_tp_methods, reinterpret_cast<void*>(methods_CornerRadiusFilterConverter_Static) },
        { }
    };

    static PyType_Spec type_spec_CornerRadiusFilterConverter_Static =
    {
        "winrt._winrt_microsoft_ui_xaml_controls_primitives.CornerRadiusFilterConverter_Static",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT,
        type_slots_CornerRadiusFilterConverter_Static
    };

    // ----- CornerRadiusToThicknessConverter class --------------------

    static PyObject* _new_CornerRadiusToThicknessConverter(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 0)
        {
            try
            {
                winrt::Microsoft::UI::Xaml::Controls::Primitives::CornerRadiusToThicknessConverter instance{  };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_CornerRadiusToThicknessConverter(py::wrapper::Microsoft::UI::Xaml::Controls::Primitives::CornerRadiusToThicknessConverter* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* CornerRadiusToThicknessConverter_Convert(py::wrapper::Microsoft::UI::Xaml::Controls::Primitives::CornerRadiusToThicknessConverter* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 4)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Xaml.Controls.Primitives.CornerRadiusToThicknessConverter", L"Convert", 4))
            {
                py::set_arg_count_version_error(4);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::Foundation::IInspectable>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::UI::Xaml::Interop::TypeName>(args, 1);
                auto param2 = py::convert_to<winrt::Windows::Foundation::IInspectable>(args, 2);
                auto param3 = py::convert_to<winrt::hstring>(args, 3);

                return py::convert(self->obj.Convert(param0, param1, param2, param3));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* CornerRadiusToThicknessConverter_ConvertBack(py::wrapper::Microsoft::UI::Xaml::Controls::Primitives::CornerRadiusToThicknessConverter* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 4)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Xaml.Controls.Primitives.CornerRadiusToThicknessConverter", L"ConvertBack", 4))
            {
                py::set_arg_count_version_error(4);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::Foundation::IInspectable>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::UI::Xaml::Interop::TypeName>(args, 1);
                auto param2 = py::convert_to<winrt::Windows::Foundation::IInspectable>(args, 2);
                auto param3 = py::convert_to<winrt::hstring>(args, 3);

                return py::convert(self->obj.ConvertBack(param0, param1, param2, param3));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* CornerRadiusToThicknessConverter_get_Multiplier(py::wrapper::Microsoft::UI::Xaml::Controls::Primitives::CornerRadiusToThicknessConverter* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.CornerRadiusToThicknessConverter", L"Multiplier"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Multiplier());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int CornerRadiusToThicknessConverter_put_Multiplier(py::wrapper::Microsoft::UI::Xaml::Controls::Primitives::CornerRadiusToThicknessConverter* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.CornerRadiusToThicknessConverter", L"Multiplier"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<double>(arg);

            self->obj.Multiplier(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* CornerRadiusToThicknessConverter_get_ConversionKind(py::wrapper::Microsoft::UI::Xaml::Controls::Primitives::CornerRadiusToThicknessConverter* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.CornerRadiusToThicknessConverter", L"ConversionKind"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.ConversionKind());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int CornerRadiusToThicknessConverter_put_ConversionKind(py::wrapper::Microsoft::UI::Xaml::Controls::Primitives::CornerRadiusToThicknessConverter* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.CornerRadiusToThicknessConverter", L"ConversionKind"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Microsoft::UI::Xaml::Controls::Primitives::CornerRadiusToThicknessConverterKind>(arg);

            self->obj.ConversionKind(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* CornerRadiusToThicknessConverter_get_ConversionKindProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.CornerRadiusToThicknessConverter", L"ConversionKindProperty"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Microsoft::UI::Xaml::Controls::Primitives::CornerRadiusToThicknessConverter::ConversionKindProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CornerRadiusToThicknessConverter_get_MultiplierProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.CornerRadiusToThicknessConverter", L"MultiplierProperty"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Microsoft::UI::Xaml::Controls::Primitives::CornerRadiusToThicknessConverter::MultiplierProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_CornerRadiusToThicknessConverter(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Microsoft::UI::Xaml::Controls::Primitives::CornerRadiusToThicknessConverter>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_CornerRadiusToThicknessConverter(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Microsoft::UI::Xaml::Controls::Primitives::CornerRadiusToThicknessConverter>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_CornerRadiusToThicknessConverter[] = {
        { "convert", reinterpret_cast<PyCFunction>(CornerRadiusToThicknessConverter_Convert), METH_VARARGS, nullptr },
        { "convert_back", reinterpret_cast<PyCFunction>(CornerRadiusToThicknessConverter_ConvertBack), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_CornerRadiusToThicknessConverter, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_CornerRadiusToThicknessConverter), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_CornerRadiusToThicknessConverter[] = {
        { "multiplier", reinterpret_cast<getter>(CornerRadiusToThicknessConverter_get_Multiplier), reinterpret_cast<setter>(CornerRadiusToThicknessConverter_put_Multiplier), nullptr, nullptr },
        { "conversion_kind", reinterpret_cast<getter>(CornerRadiusToThicknessConverter_get_ConversionKind), reinterpret_cast<setter>(CornerRadiusToThicknessConverter_put_ConversionKind), nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_CornerRadiusToThicknessConverter[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_CornerRadiusToThicknessConverter) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_CornerRadiusToThicknessConverter) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_CornerRadiusToThicknessConverter) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_CornerRadiusToThicknessConverter) },
        { },
    };

    static PyType_Spec type_spec_CornerRadiusToThicknessConverter =
    {
        "winrt._winrt_microsoft_ui_xaml_controls_primitives.CornerRadiusToThicknessConverter",
        sizeof(py::wrapper::Microsoft::UI::Xaml::Controls::Primitives::CornerRadiusToThicknessConverter),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_CornerRadiusToThicknessConverter
    };

    static PyGetSetDef getset_CornerRadiusToThicknessConverter_Static[] = {
        { "conversion_kind_property", reinterpret_cast<getter>(CornerRadiusToThicknessConverter_get_ConversionKindProperty), nullptr, nullptr, nullptr },
        { "multiplier_property", reinterpret_cast<getter>(CornerRadiusToThicknessConverter_get_MultiplierProperty), nullptr, nullptr, nullptr },
        { }
    };

    static PyMethodDef methods_CornerRadiusToThicknessConverter_Static[] = {
        { }
    };

    static PyType_Slot type_slots_CornerRadiusToThicknessConverter_Static[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_CornerRadiusToThicknessConverter_Static) },
        { Py_tp_methods, reinterpret_cast<void*>(methods_CornerRadiusToThicknessConverter_Static) },
        { }
    };

    static PyType_Spec type_spec_CornerRadiusToThicknessConverter_Static =
    {
        "winrt._winrt_microsoft_ui_xaml_controls_primitives.CornerRadiusToThicknessConverter_Static",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT,
        type_slots_CornerRadiusToThicknessConverter_Static
    };

    // ----- DragCompletedEventArgs class --------------------

    static PyObject* _new_DragCompletedEventArgs(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 3)
        {
            try
            {
                auto param0 = py::convert_to<double>(args, 0);
                auto param1 = py::convert_to<double>(args, 1);
                auto param2 = py::convert_to<bool>(args, 2);

                winrt::Microsoft::UI::Xaml::Controls::Primitives::DragCompletedEventArgs instance{ param0, param1, param2 };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_DragCompletedEventArgs(py::wrapper::Microsoft::UI::Xaml::Controls::Primitives::DragCompletedEventArgs* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* DragCompletedEventArgs_get_Canceled(py::wrapper::Microsoft::UI::Xaml::Controls::Primitives::DragCompletedEventArgs* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.DragCompletedEventArgs", L"Canceled"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Canceled());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* DragCompletedEventArgs_get_HorizontalChange(py::wrapper::Microsoft::UI::Xaml::Controls::Primitives::DragCompletedEventArgs* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.DragCompletedEventArgs", L"HorizontalChange"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.HorizontalChange());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* DragCompletedEventArgs_get_VerticalChange(py::wrapper::Microsoft::UI::Xaml::Controls::Primitives::DragCompletedEventArgs* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.DragCompletedEventArgs", L"VerticalChange"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.VerticalChange());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_DragCompletedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Microsoft::UI::Xaml::Controls::Primitives::DragCompletedEventArgs>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_DragCompletedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Microsoft::UI::Xaml::Controls::Primitives::DragCompletedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_DragCompletedEventArgs[] = {
        { "_assign_array_", _assign_array_DragCompletedEventArgs, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_DragCompletedEventArgs), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_DragCompletedEventArgs[] = {
        { "canceled", reinterpret_cast<getter>(DragCompletedEventArgs_get_Canceled), nullptr, nullptr, nullptr },
        { "horizontal_change", reinterpret_cast<getter>(DragCompletedEventArgs_get_HorizontalChange), nullptr, nullptr, nullptr },
        { "vertical_change", reinterpret_cast<getter>(DragCompletedEventArgs_get_VerticalChange), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_DragCompletedEventArgs[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_DragCompletedEventArgs) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_DragCompletedEventArgs) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_DragCompletedEventArgs) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_DragCompletedEventArgs) },
        { },
    };

    static PyType_Spec type_spec_DragCompletedEventArgs =
    {
        "winrt._winrt_microsoft_ui_xaml_controls_primitives.DragCompletedEventArgs",
        sizeof(py::wrapper::Microsoft::UI::Xaml::Controls::Primitives::DragCompletedEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_DragCompletedEventArgs
    };

    // ----- DragDeltaEventArgs class --------------------

    static PyObject* _new_DragDeltaEventArgs(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<double>(args, 0);
                auto param1 = py::convert_to<double>(args, 1);

                winrt::Microsoft::UI::Xaml::Controls::Primitives::DragDeltaEventArgs instance{ param0, param1 };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_DragDeltaEventArgs(py::wrapper::Microsoft::UI::Xaml::Controls::Primitives::DragDeltaEventArgs* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* DragDeltaEventArgs_get_HorizontalChange(py::wrapper::Microsoft::UI::Xaml::Controls::Primitives::DragDeltaEventArgs* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.DragDeltaEventArgs", L"HorizontalChange"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.HorizontalChange());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* DragDeltaEventArgs_get_VerticalChange(py::wrapper::Microsoft::UI::Xaml::Controls::Primitives::DragDeltaEventArgs* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.DragDeltaEventArgs", L"VerticalChange"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.VerticalChange());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_DragDeltaEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Microsoft::UI::Xaml::Controls::Primitives::DragDeltaEventArgs>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_DragDeltaEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Microsoft::UI::Xaml::Controls::Primitives::DragDeltaEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_DragDeltaEventArgs[] = {
        { "_assign_array_", _assign_array_DragDeltaEventArgs, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_DragDeltaEventArgs), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_DragDeltaEventArgs[] = {
        { "horizontal_change", reinterpret_cast<getter>(DragDeltaEventArgs_get_HorizontalChange), nullptr, nullptr, nullptr },
        { "vertical_change", reinterpret_cast<getter>(DragDeltaEventArgs_get_VerticalChange), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_DragDeltaEventArgs[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_DragDeltaEventArgs) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_DragDeltaEventArgs) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_DragDeltaEventArgs) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_DragDeltaEventArgs) },
        { },
    };

    static PyType_Spec type_spec_DragDeltaEventArgs =
    {
        "winrt._winrt_microsoft_ui_xaml_controls_primitives.DragDeltaEventArgs",
        sizeof(py::wrapper::Microsoft::UI::Xaml::Controls::Primitives::DragDeltaEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_DragDeltaEventArgs
    };

    // ----- DragStartedEventArgs class --------------------

    static PyObject* _new_DragStartedEventArgs(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<double>(args, 0);
                auto param1 = py::convert_to<double>(args, 1);

                winrt::Microsoft::UI::Xaml::Controls::Primitives::DragStartedEventArgs instance{ param0, param1 };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_DragStartedEventArgs(py::wrapper::Microsoft::UI::Xaml::Controls::Primitives::DragStartedEventArgs* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* DragStartedEventArgs_get_HorizontalOffset(py::wrapper::Microsoft::UI::Xaml::Controls::Primitives::DragStartedEventArgs* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.DragStartedEventArgs", L"HorizontalOffset"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.HorizontalOffset());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* DragStartedEventArgs_get_VerticalOffset(py::wrapper::Microsoft::UI::Xaml::Controls::Primitives::DragStartedEventArgs* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.DragStartedEventArgs", L"VerticalOffset"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.VerticalOffset());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_DragStartedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Microsoft::UI::Xaml::Controls::Primitives::DragStartedEventArgs>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_DragStartedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Microsoft::UI::Xaml::Controls::Primitives::DragStartedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_DragStartedEventArgs[] = {
        { "_assign_array_", _assign_array_DragStartedEventArgs, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_DragStartedEventArgs), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_DragStartedEventArgs[] = {
        { "horizontal_offset", reinterpret_cast<getter>(DragStartedEventArgs_get_HorizontalOffset), nullptr, nullptr, nullptr },
        { "vertical_offset", reinterpret_cast<getter>(DragStartedEventArgs_get_VerticalOffset), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_DragStartedEventArgs[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_DragStartedEventArgs) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_DragStartedEventArgs) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_DragStartedEventArgs) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_DragStartedEventArgs) },
        { },
    };

    static PyType_Spec type_spec_DragStartedEventArgs =
    {
        "winrt._winrt_microsoft_ui_xaml_controls_primitives.DragStartedEventArgs",
        sizeof(py::wrapper::Microsoft::UI::Xaml::Controls::Primitives::DragStartedEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_DragStartedEventArgs
    };

    // ----- FlyoutBase class --------------------

    static PyObject* _new_FlyoutBase(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Microsoft::UI::Xaml::Controls::Primitives::FlyoutBase>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Microsoft::UI::Xaml::Controls::Primitives::FlyoutBase>::type_name);
        return nullptr;
    }

    static void _dealloc_FlyoutBase(py::wrapper::Microsoft::UI::Xaml::Controls::Primitives::FlyoutBase* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* FlyoutBase_CreatePresenter(py::wrapper::Microsoft::UI::Xaml::Controls::Primitives::FlyoutBase* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Xaml.Controls.Primitives.FlyoutBase", L"CreatePresenter", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(self->obj.CreatePresenter());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* FlyoutBase_GetAttachedFlyout(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Xaml.Controls.Primitives.FlyoutBase", L"GetAttachedFlyout", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Microsoft::UI::Xaml::FrameworkElement>(args, 0);

                return py::convert(winrt::Microsoft::UI::Xaml::Controls::Primitives::FlyoutBase::GetAttachedFlyout(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* FlyoutBase_Hide(py::wrapper::Microsoft::UI::Xaml::Controls::Primitives::FlyoutBase* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Xaml.Controls.Primitives.FlyoutBase", L"Hide", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                self->obj.Hide();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* FlyoutBase_OnProcessKeyboardAccelerators(py::wrapper::Microsoft::UI::Xaml::Controls::Primitives::FlyoutBase* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Xaml.Controls.Primitives.FlyoutBase", L"OnProcessKeyboardAccelerators", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Microsoft::UI::Xaml::Input::ProcessKeyboardAcceleratorEventArgs>(args, 0);

                self->obj.OnProcessKeyboardAccelerators(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* FlyoutBase_SetAttachedFlyout(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Xaml.Controls.Primitives.FlyoutBase", L"SetAttachedFlyout", 2))
            {
                py::set_arg_count_version_error(2);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Microsoft::UI::Xaml::FrameworkElement>(args, 0);
                auto param1 = py::convert_to<winrt::Microsoft::UI::Xaml::Controls::Primitives::FlyoutBase>(args, 1);

                winrt::Microsoft::UI::Xaml::Controls::Primitives::FlyoutBase::SetAttachedFlyout(param0, param1);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* FlyoutBase_ShowAt(py::wrapper::Microsoft::UI::Xaml::Controls::Primitives::FlyoutBase* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Xaml.Controls.Primitives.FlyoutBase", L"ShowAt", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Microsoft::UI::Xaml::FrameworkElement>(args, 0);

                self->obj.ShowAt(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 2)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Xaml.Controls.Primitives.FlyoutBase", L"ShowAt", 2))
            {
                py::set_arg_count_version_error(2);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Microsoft::UI::Xaml::DependencyObject>(args, 0);
                auto param1 = py::convert_to<winrt::Microsoft::UI::Xaml::Controls::Primitives::FlyoutShowOptions>(args, 1);

                self->obj.ShowAt(param0, param1);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* FlyoutBase_ShowAttachedFlyout(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Xaml.Controls.Primitives.FlyoutBase", L"ShowAttachedFlyout", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Microsoft::UI::Xaml::FrameworkElement>(args, 0);

                winrt::Microsoft::UI::Xaml::Controls::Primitives::FlyoutBase::ShowAttachedFlyout(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* FlyoutBase_TryInvokeKeyboardAccelerator(py::wrapper::Microsoft::UI::Xaml::Controls::Primitives::FlyoutBase* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Xaml.Controls.Primitives.FlyoutBase", L"TryInvokeKeyboardAccelerator", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Microsoft::UI::Xaml::Input::ProcessKeyboardAcceleratorEventArgs>(args, 0);

                self->obj.TryInvokeKeyboardAccelerator(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* FlyoutBase_get_XamlRoot(py::wrapper::Microsoft::UI::Xaml::Controls::Primitives::FlyoutBase* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.FlyoutBase", L"XamlRoot"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.XamlRoot());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int FlyoutBase_put_XamlRoot(py::wrapper::Microsoft::UI::Xaml::Controls::Primitives::FlyoutBase* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.FlyoutBase", L"XamlRoot"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Microsoft::UI::Xaml::XamlRoot>(arg);

            self->obj.XamlRoot(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* FlyoutBase_get_ShowMode(py::wrapper::Microsoft::UI::Xaml::Controls::Primitives::FlyoutBase* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.FlyoutBase", L"ShowMode"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.ShowMode());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int FlyoutBase_put_ShowMode(py::wrapper::Microsoft::UI::Xaml::Controls::Primitives::FlyoutBase* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.FlyoutBase", L"ShowMode"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Microsoft::UI::Xaml::Controls::Primitives::FlyoutShowMode>(arg);

            self->obj.ShowMode(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* FlyoutBase_get_ShouldConstrainToRootBounds(py::wrapper::Microsoft::UI::Xaml::Controls::Primitives::FlyoutBase* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.FlyoutBase", L"ShouldConstrainToRootBounds"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.ShouldConstrainToRootBounds());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int FlyoutBase_put_ShouldConstrainToRootBounds(py::wrapper::Microsoft::UI::Xaml::Controls::Primitives::FlyoutBase* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.FlyoutBase", L"ShouldConstrainToRootBounds"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<bool>(arg);

            self->obj.ShouldConstrainToRootBounds(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* FlyoutBase_get_Placement(py::wrapper::Microsoft::UI::Xaml::Controls::Primitives::FlyoutBase* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.FlyoutBase", L"Placement"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Placement());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int FlyoutBase_put_Placement(py::wrapper::Microsoft::UI::Xaml::Controls::Primitives::FlyoutBase* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.FlyoutBase", L"Placement"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Microsoft::UI::Xaml::Controls::Primitives::FlyoutPlacementMode>(arg);

            self->obj.Placement(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* FlyoutBase_get_OverlayInputPassThroughElement(py::wrapper::Microsoft::UI::Xaml::Controls::Primitives::FlyoutBase* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.FlyoutBase", L"OverlayInputPassThroughElement"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.OverlayInputPassThroughElement());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int FlyoutBase_put_OverlayInputPassThroughElement(py::wrapper::Microsoft::UI::Xaml::Controls::Primitives::FlyoutBase* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.FlyoutBase", L"OverlayInputPassThroughElement"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Microsoft::UI::Xaml::DependencyObject>(arg);

            self->obj.OverlayInputPassThroughElement(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* FlyoutBase_get_LightDismissOverlayMode(py::wrapper::Microsoft::UI::Xaml::Controls::Primitives::FlyoutBase* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.FlyoutBase", L"LightDismissOverlayMode"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.LightDismissOverlayMode());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int FlyoutBase_put_LightDismissOverlayMode(py::wrapper::Microsoft::UI::Xaml::Controls::Primitives::FlyoutBase* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.FlyoutBase", L"LightDismissOverlayMode"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Microsoft::UI::Xaml::Controls::LightDismissOverlayMode>(arg);

            self->obj.LightDismissOverlayMode(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* FlyoutBase_get_ElementSoundMode(py::wrapper::Microsoft::UI::Xaml::Controls::Primitives::FlyoutBase* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.FlyoutBase", L"ElementSoundMode"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.ElementSoundMode());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int FlyoutBase_put_ElementSoundMode(py::wrapper::Microsoft::UI::Xaml::Controls::Primitives::FlyoutBase* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.FlyoutBase", L"ElementSoundMode"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Microsoft::UI::Xaml::ElementSoundMode>(arg);

            self->obj.ElementSoundMode(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* FlyoutBase_get_AreOpenCloseAnimationsEnabled(py::wrapper::Microsoft::UI::Xaml::Controls::Primitives::FlyoutBase* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.FlyoutBase", L"AreOpenCloseAnimationsEnabled"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.AreOpenCloseAnimationsEnabled());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int FlyoutBase_put_AreOpenCloseAnimationsEnabled(py::wrapper::Microsoft::UI::Xaml::Controls::Primitives::FlyoutBase* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.FlyoutBase", L"AreOpenCloseAnimationsEnabled"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<bool>(arg);

            self->obj.AreOpenCloseAnimationsEnabled(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* FlyoutBase_get_AllowFocusWhenDisabled(py::wrapper::Microsoft::UI::Xaml::Controls::Primitives::FlyoutBase* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.FlyoutBase", L"AllowFocusWhenDisabled"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.AllowFocusWhenDisabled());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int FlyoutBase_put_AllowFocusWhenDisabled(py::wrapper::Microsoft::UI::Xaml::Controls::Primitives::FlyoutBase* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.FlyoutBase", L"AllowFocusWhenDisabled"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<bool>(arg);

            self->obj.AllowFocusWhenDisabled(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* FlyoutBase_get_AllowFocusOnInteraction(py::wrapper::Microsoft::UI::Xaml::Controls::Primitives::FlyoutBase* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.FlyoutBase", L"AllowFocusOnInteraction"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.AllowFocusOnInteraction());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int FlyoutBase_put_AllowFocusOnInteraction(py::wrapper::Microsoft::UI::Xaml::Controls::Primitives::FlyoutBase* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.FlyoutBase", L"AllowFocusOnInteraction"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<bool>(arg);

            self->obj.AllowFocusOnInteraction(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* FlyoutBase_get_InputDevicePrefersPrimaryCommands(py::wrapper::Microsoft::UI::Xaml::Controls::Primitives::FlyoutBase* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.FlyoutBase", L"InputDevicePrefersPrimaryCommands"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.InputDevicePrefersPrimaryCommands());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* FlyoutBase_get_IsConstrainedToRootBounds(py::wrapper::Microsoft::UI::Xaml::Controls::Primitives::FlyoutBase* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.FlyoutBase", L"IsConstrainedToRootBounds"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.IsConstrainedToRootBounds());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* FlyoutBase_get_IsOpen(py::wrapper::Microsoft::UI::Xaml::Controls::Primitives::FlyoutBase* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.FlyoutBase", L"IsOpen"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.IsOpen());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* FlyoutBase_get_Target(py::wrapper::Microsoft::UI::Xaml::Controls::Primitives::FlyoutBase* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.FlyoutBase", L"Target"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Target());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* FlyoutBase_get_SystemBackdrop(py::wrapper::Microsoft::UI::Xaml::Controls::Primitives::FlyoutBase* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.FlyoutBase", L"SystemBackdrop"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.SystemBackdrop());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int FlyoutBase_put_SystemBackdrop(py::wrapper::Microsoft::UI::Xaml::Controls::Primitives::FlyoutBase* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.FlyoutBase", L"SystemBackdrop"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Microsoft::UI::Xaml::Media::SystemBackdrop>(arg);

            self->obj.SystemBackdrop(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* FlyoutBase_get_AllowFocusOnInteractionProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.FlyoutBase", L"AllowFocusOnInteractionProperty"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Microsoft::UI::Xaml::Controls::Primitives::FlyoutBase::AllowFocusOnInteractionProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* FlyoutBase_get_AllowFocusWhenDisabledProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.FlyoutBase", L"AllowFocusWhenDisabledProperty"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Microsoft::UI::Xaml::Controls::Primitives::FlyoutBase::AllowFocusWhenDisabledProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* FlyoutBase_get_AreOpenCloseAnimationsEnabledProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.FlyoutBase", L"AreOpenCloseAnimationsEnabledProperty"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Microsoft::UI::Xaml::Controls::Primitives::FlyoutBase::AreOpenCloseAnimationsEnabledProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* FlyoutBase_get_AttachedFlyoutProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.FlyoutBase", L"AttachedFlyoutProperty"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Microsoft::UI::Xaml::Controls::Primitives::FlyoutBase::AttachedFlyoutProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* FlyoutBase_get_ElementSoundModeProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.FlyoutBase", L"ElementSoundModeProperty"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Microsoft::UI::Xaml::Controls::Primitives::FlyoutBase::ElementSoundModeProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* FlyoutBase_get_InputDevicePrefersPrimaryCommandsProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.FlyoutBase", L"InputDevicePrefersPrimaryCommandsProperty"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Microsoft::UI::Xaml::Controls::Primitives::FlyoutBase::InputDevicePrefersPrimaryCommandsProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* FlyoutBase_get_IsOpenProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.FlyoutBase", L"IsOpenProperty"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Microsoft::UI::Xaml::Controls::Primitives::FlyoutBase::IsOpenProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* FlyoutBase_get_LightDismissOverlayModeProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.FlyoutBase", L"LightDismissOverlayModeProperty"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Microsoft::UI::Xaml::Controls::Primitives::FlyoutBase::LightDismissOverlayModeProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* FlyoutBase_get_OverlayInputPassThroughElementProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.FlyoutBase", L"OverlayInputPassThroughElementProperty"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Microsoft::UI::Xaml::Controls::Primitives::FlyoutBase::OverlayInputPassThroughElementProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* FlyoutBase_get_PlacementProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.FlyoutBase", L"PlacementProperty"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Microsoft::UI::Xaml::Controls::Primitives::FlyoutBase::PlacementProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* FlyoutBase_get_ShouldConstrainToRootBoundsProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.FlyoutBase", L"ShouldConstrainToRootBoundsProperty"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Microsoft::UI::Xaml::Controls::Primitives::FlyoutBase::ShouldConstrainToRootBoundsProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* FlyoutBase_get_ShowModeProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.FlyoutBase", L"ShowModeProperty"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Microsoft::UI::Xaml::Controls::Primitives::FlyoutBase::ShowModeProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* FlyoutBase_get_TargetProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.FlyoutBase", L"TargetProperty"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Microsoft::UI::Xaml::Controls::Primitives::FlyoutBase::TargetProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* FlyoutBase_get_SystemBackdropProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.FlyoutBase", L"SystemBackdropProperty"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Microsoft::UI::Xaml::Controls::Primitives::FlyoutBase::SystemBackdropProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* FlyoutBase_add_Closed(py::wrapper::Microsoft::UI::Xaml::Controls::Primitives::FlyoutBase* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Microsoft.UI.Xaml.Controls.Primitives.FlyoutBase", L"Closed"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::EventHandler<winrt::Windows::Foundation::IInspectable>>(arg);

            return py::convert(self->obj.Closed(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* FlyoutBase_remove_Closed(py::wrapper::Microsoft::UI::Xaml::Controls::Primitives::FlyoutBase* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Microsoft.UI.Xaml.Controls.Primitives.FlyoutBase", L"Closed"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.Closed(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* FlyoutBase_add_Closing(py::wrapper::Microsoft::UI::Xaml::Controls::Primitives::FlyoutBase* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Microsoft.UI.Xaml.Controls.Primitives.FlyoutBase", L"Closing"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Microsoft::UI::Xaml::Controls::Primitives::FlyoutBase, winrt::Microsoft::UI::Xaml::Controls::Primitives::FlyoutBaseClosingEventArgs>>(arg);

            return py::convert(self->obj.Closing(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* FlyoutBase_remove_Closing(py::wrapper::Microsoft::UI::Xaml::Controls::Primitives::FlyoutBase* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Microsoft.UI.Xaml.Controls.Primitives.FlyoutBase", L"Closing"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.Closing(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* FlyoutBase_add_Opened(py::wrapper::Microsoft::UI::Xaml::Controls::Primitives::FlyoutBase* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Microsoft.UI.Xaml.Controls.Primitives.FlyoutBase", L"Opened"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::EventHandler<winrt::Windows::Foundation::IInspectable>>(arg);

            return py::convert(self->obj.Opened(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* FlyoutBase_remove_Opened(py::wrapper::Microsoft::UI::Xaml::Controls::Primitives::FlyoutBase* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Microsoft.UI.Xaml.Controls.Primitives.FlyoutBase", L"Opened"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.Opened(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* FlyoutBase_add_Opening(py::wrapper::Microsoft::UI::Xaml::Controls::Primitives::FlyoutBase* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Microsoft.UI.Xaml.Controls.Primitives.FlyoutBase", L"Opening"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::EventHandler<winrt::Windows::Foundation::IInspectable>>(arg);

            return py::convert(self->obj.Opening(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* FlyoutBase_remove_Opening(py::wrapper::Microsoft::UI::Xaml::Controls::Primitives::FlyoutBase* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Microsoft.UI.Xaml.Controls.Primitives.FlyoutBase", L"Opening"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.Opening(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_FlyoutBase(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Microsoft::UI::Xaml::Controls::Primitives::FlyoutBase>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_FlyoutBase(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Microsoft::UI::Xaml::Controls::Primitives::FlyoutBase>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_FlyoutBase[] = {
        { "create_presenter", reinterpret_cast<PyCFunction>(FlyoutBase_CreatePresenter), METH_VARARGS, nullptr },
        { "hide", reinterpret_cast<PyCFunction>(FlyoutBase_Hide), METH_VARARGS, nullptr },
        { "on_process_keyboard_accelerators", reinterpret_cast<PyCFunction>(FlyoutBase_OnProcessKeyboardAccelerators), METH_VARARGS, nullptr },
        { "show_at", reinterpret_cast<PyCFunction>(FlyoutBase_ShowAt), METH_VARARGS, nullptr },
        { "try_invoke_keyboard_accelerator", reinterpret_cast<PyCFunction>(FlyoutBase_TryInvokeKeyboardAccelerator), METH_VARARGS, nullptr },
        { "add_closed", reinterpret_cast<PyCFunction>(FlyoutBase_add_Closed), METH_O, nullptr },
        { "remove_closed", reinterpret_cast<PyCFunction>(FlyoutBase_remove_Closed), METH_O, nullptr },
        { "add_closing", reinterpret_cast<PyCFunction>(FlyoutBase_add_Closing), METH_O, nullptr },
        { "remove_closing", reinterpret_cast<PyCFunction>(FlyoutBase_remove_Closing), METH_O, nullptr },
        { "add_opened", reinterpret_cast<PyCFunction>(FlyoutBase_add_Opened), METH_O, nullptr },
        { "remove_opened", reinterpret_cast<PyCFunction>(FlyoutBase_remove_Opened), METH_O, nullptr },
        { "add_opening", reinterpret_cast<PyCFunction>(FlyoutBase_add_Opening), METH_O, nullptr },
        { "remove_opening", reinterpret_cast<PyCFunction>(FlyoutBase_remove_Opening), METH_O, nullptr },
        { "_assign_array_", _assign_array_FlyoutBase, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_FlyoutBase), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_FlyoutBase[] = {
        { "xaml_root", reinterpret_cast<getter>(FlyoutBase_get_XamlRoot), reinterpret_cast<setter>(FlyoutBase_put_XamlRoot), nullptr, nullptr },
        { "show_mode", reinterpret_cast<getter>(FlyoutBase_get_ShowMode), reinterpret_cast<setter>(FlyoutBase_put_ShowMode), nullptr, nullptr },
        { "should_constrain_to_root_bounds", reinterpret_cast<getter>(FlyoutBase_get_ShouldConstrainToRootBounds), reinterpret_cast<setter>(FlyoutBase_put_ShouldConstrainToRootBounds), nullptr, nullptr },
        { "placement", reinterpret_cast<getter>(FlyoutBase_get_Placement), reinterpret_cast<setter>(FlyoutBase_put_Placement), nullptr, nullptr },
        { "overlay_input_pass_through_element", reinterpret_cast<getter>(FlyoutBase_get_OverlayInputPassThroughElement), reinterpret_cast<setter>(FlyoutBase_put_OverlayInputPassThroughElement), nullptr, nullptr },
        { "light_dismiss_overlay_mode", reinterpret_cast<getter>(FlyoutBase_get_LightDismissOverlayMode), reinterpret_cast<setter>(FlyoutBase_put_LightDismissOverlayMode), nullptr, nullptr },
        { "element_sound_mode", reinterpret_cast<getter>(FlyoutBase_get_ElementSoundMode), reinterpret_cast<setter>(FlyoutBase_put_ElementSoundMode), nullptr, nullptr },
        { "are_open_close_animations_enabled", reinterpret_cast<getter>(FlyoutBase_get_AreOpenCloseAnimationsEnabled), reinterpret_cast<setter>(FlyoutBase_put_AreOpenCloseAnimationsEnabled), nullptr, nullptr },
        { "allow_focus_when_disabled", reinterpret_cast<getter>(FlyoutBase_get_AllowFocusWhenDisabled), reinterpret_cast<setter>(FlyoutBase_put_AllowFocusWhenDisabled), nullptr, nullptr },
        { "allow_focus_on_interaction", reinterpret_cast<getter>(FlyoutBase_get_AllowFocusOnInteraction), reinterpret_cast<setter>(FlyoutBase_put_AllowFocusOnInteraction), nullptr, nullptr },
        { "input_device_prefers_primary_commands", reinterpret_cast<getter>(FlyoutBase_get_InputDevicePrefersPrimaryCommands), nullptr, nullptr, nullptr },
        { "is_constrained_to_root_bounds", reinterpret_cast<getter>(FlyoutBase_get_IsConstrainedToRootBounds), nullptr, nullptr, nullptr },
        { "is_open", reinterpret_cast<getter>(FlyoutBase_get_IsOpen), nullptr, nullptr, nullptr },
        { "target", reinterpret_cast<getter>(FlyoutBase_get_Target), nullptr, nullptr, nullptr },
        { "system_backdrop", reinterpret_cast<getter>(FlyoutBase_get_SystemBackdrop), reinterpret_cast<setter>(FlyoutBase_put_SystemBackdrop), nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_FlyoutBase[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_FlyoutBase) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_FlyoutBase) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_FlyoutBase) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_FlyoutBase) },
        { },
    };

    static PyType_Spec type_spec_FlyoutBase =
    {
        "winrt._winrt_microsoft_ui_xaml_controls_primitives.FlyoutBase",
        sizeof(py::wrapper::Microsoft::UI::Xaml::Controls::Primitives::FlyoutBase),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_FlyoutBase
    };

    static PyGetSetDef getset_FlyoutBase_Static[] = {
        { "allow_focus_on_interaction_property", reinterpret_cast<getter>(FlyoutBase_get_AllowFocusOnInteractionProperty), nullptr, nullptr, nullptr },
        { "allow_focus_when_disabled_property", reinterpret_cast<getter>(FlyoutBase_get_AllowFocusWhenDisabledProperty), nullptr, nullptr, nullptr },
        { "are_open_close_animations_enabled_property", reinterpret_cast<getter>(FlyoutBase_get_AreOpenCloseAnimationsEnabledProperty), nullptr, nullptr, nullptr },
        { "attached_flyout_property", reinterpret_cast<getter>(FlyoutBase_get_AttachedFlyoutProperty), nullptr, nullptr, nullptr },
        { "element_sound_mode_property", reinterpret_cast<getter>(FlyoutBase_get_ElementSoundModeProperty), nullptr, nullptr, nullptr },
        { "input_device_prefers_primary_commands_property", reinterpret_cast<getter>(FlyoutBase_get_InputDevicePrefersPrimaryCommandsProperty), nullptr, nullptr, nullptr },
        { "is_open_property", reinterpret_cast<getter>(FlyoutBase_get_IsOpenProperty), nullptr, nullptr, nullptr },
        { "light_dismiss_overlay_mode_property", reinterpret_cast<getter>(FlyoutBase_get_LightDismissOverlayModeProperty), nullptr, nullptr, nullptr },
        { "overlay_input_pass_through_element_property", reinterpret_cast<getter>(FlyoutBase_get_OverlayInputPassThroughElementProperty), nullptr, nullptr, nullptr },
        { "placement_property", reinterpret_cast<getter>(FlyoutBase_get_PlacementProperty), nullptr, nullptr, nullptr },
        { "should_constrain_to_root_bounds_property", reinterpret_cast<getter>(FlyoutBase_get_ShouldConstrainToRootBoundsProperty), nullptr, nullptr, nullptr },
        { "show_mode_property", reinterpret_cast<getter>(FlyoutBase_get_ShowModeProperty), nullptr, nullptr, nullptr },
        { "target_property", reinterpret_cast<getter>(FlyoutBase_get_TargetProperty), nullptr, nullptr, nullptr },
        { "system_backdrop_property", reinterpret_cast<getter>(FlyoutBase_get_SystemBackdropProperty), nullptr, nullptr, nullptr },
        { }
    };

    static PyMethodDef methods_FlyoutBase_Static[] = {
        { "get_attached_flyout", reinterpret_cast<PyCFunction>(FlyoutBase_GetAttachedFlyout), METH_VARARGS, nullptr },
        { "set_attached_flyout", reinterpret_cast<PyCFunction>(FlyoutBase_SetAttachedFlyout), METH_VARARGS, nullptr },
        { "show_attached_flyout", reinterpret_cast<PyCFunction>(FlyoutBase_ShowAttachedFlyout), METH_VARARGS, nullptr },
        { }
    };

    static PyType_Slot type_slots_FlyoutBase_Static[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_FlyoutBase_Static) },
        { Py_tp_methods, reinterpret_cast<void*>(methods_FlyoutBase_Static) },
        { }
    };

    static PyType_Spec type_spec_FlyoutBase_Static =
    {
        "winrt._winrt_microsoft_ui_xaml_controls_primitives.FlyoutBase_Static",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT,
        type_slots_FlyoutBase_Static
    };

    // ----- FlyoutBaseClosingEventArgs class --------------------

    static PyObject* _new_FlyoutBaseClosingEventArgs(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Microsoft::UI::Xaml::Controls::Primitives::FlyoutBaseClosingEventArgs>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Microsoft::UI::Xaml::Controls::Primitives::FlyoutBaseClosingEventArgs>::type_name);
        return nullptr;
    }

    static void _dealloc_FlyoutBaseClosingEventArgs(py::wrapper::Microsoft::UI::Xaml::Controls::Primitives::FlyoutBaseClosingEventArgs* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* FlyoutBaseClosingEventArgs_get_Cancel(py::wrapper::Microsoft::UI::Xaml::Controls::Primitives::FlyoutBaseClosingEventArgs* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.FlyoutBaseClosingEventArgs", L"Cancel"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Cancel());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int FlyoutBaseClosingEventArgs_put_Cancel(py::wrapper::Microsoft::UI::Xaml::Controls::Primitives::FlyoutBaseClosingEventArgs* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.FlyoutBaseClosingEventArgs", L"Cancel"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<bool>(arg);

            self->obj.Cancel(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* _assign_array_FlyoutBaseClosingEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Microsoft::UI::Xaml::Controls::Primitives::FlyoutBaseClosingEventArgs>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_FlyoutBaseClosingEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Microsoft::UI::Xaml::Controls::Primitives::FlyoutBaseClosingEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_FlyoutBaseClosingEventArgs[] = {
        { "_assign_array_", _assign_array_FlyoutBaseClosingEventArgs, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_FlyoutBaseClosingEventArgs), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_FlyoutBaseClosingEventArgs[] = {
        { "cancel", reinterpret_cast<getter>(FlyoutBaseClosingEventArgs_get_Cancel), reinterpret_cast<setter>(FlyoutBaseClosingEventArgs_put_Cancel), nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_FlyoutBaseClosingEventArgs[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_FlyoutBaseClosingEventArgs) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_FlyoutBaseClosingEventArgs) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_FlyoutBaseClosingEventArgs) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_FlyoutBaseClosingEventArgs) },
        { },
    };

    static PyType_Spec type_spec_FlyoutBaseClosingEventArgs =
    {
        "winrt._winrt_microsoft_ui_xaml_controls_primitives.FlyoutBaseClosingEventArgs",
        sizeof(py::wrapper::Microsoft::UI::Xaml::Controls::Primitives::FlyoutBaseClosingEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_FlyoutBaseClosingEventArgs
    };

    // ----- FlyoutShowOptions class --------------------

    static PyObject* _new_FlyoutShowOptions(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 0)
        {
            try
            {
                winrt::Microsoft::UI::Xaml::Controls::Primitives::FlyoutShowOptions instance{  };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_FlyoutShowOptions(py::wrapper::Microsoft::UI::Xaml::Controls::Primitives::FlyoutShowOptions* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* FlyoutShowOptions_get_ShowMode(py::wrapper::Microsoft::UI::Xaml::Controls::Primitives::FlyoutShowOptions* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.FlyoutShowOptions", L"ShowMode"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.ShowMode());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int FlyoutShowOptions_put_ShowMode(py::wrapper::Microsoft::UI::Xaml::Controls::Primitives::FlyoutShowOptions* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.FlyoutShowOptions", L"ShowMode"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Microsoft::UI::Xaml::Controls::Primitives::FlyoutShowMode>(arg);

            self->obj.ShowMode(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* FlyoutShowOptions_get_Position(py::wrapper::Microsoft::UI::Xaml::Controls::Primitives::FlyoutShowOptions* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.FlyoutShowOptions", L"Position"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Position());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int FlyoutShowOptions_put_Position(py::wrapper::Microsoft::UI::Xaml::Controls::Primitives::FlyoutShowOptions* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.FlyoutShowOptions", L"Position"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::IReference<winrt::Windows::Foundation::Point>>(arg);

            self->obj.Position(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* FlyoutShowOptions_get_Placement(py::wrapper::Microsoft::UI::Xaml::Controls::Primitives::FlyoutShowOptions* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.FlyoutShowOptions", L"Placement"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Placement());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int FlyoutShowOptions_put_Placement(py::wrapper::Microsoft::UI::Xaml::Controls::Primitives::FlyoutShowOptions* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.FlyoutShowOptions", L"Placement"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Microsoft::UI::Xaml::Controls::Primitives::FlyoutPlacementMode>(arg);

            self->obj.Placement(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* FlyoutShowOptions_get_ExclusionRect(py::wrapper::Microsoft::UI::Xaml::Controls::Primitives::FlyoutShowOptions* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.FlyoutShowOptions", L"ExclusionRect"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.ExclusionRect());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int FlyoutShowOptions_put_ExclusionRect(py::wrapper::Microsoft::UI::Xaml::Controls::Primitives::FlyoutShowOptions* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.FlyoutShowOptions", L"ExclusionRect"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::IReference<winrt::Windows::Foundation::Rect>>(arg);

            self->obj.ExclusionRect(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* _assign_array_FlyoutShowOptions(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Microsoft::UI::Xaml::Controls::Primitives::FlyoutShowOptions>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_FlyoutShowOptions(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Microsoft::UI::Xaml::Controls::Primitives::FlyoutShowOptions>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_FlyoutShowOptions[] = {
        { "_assign_array_", _assign_array_FlyoutShowOptions, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_FlyoutShowOptions), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_FlyoutShowOptions[] = {
        { "show_mode", reinterpret_cast<getter>(FlyoutShowOptions_get_ShowMode), reinterpret_cast<setter>(FlyoutShowOptions_put_ShowMode), nullptr, nullptr },
        { "position", reinterpret_cast<getter>(FlyoutShowOptions_get_Position), reinterpret_cast<setter>(FlyoutShowOptions_put_Position), nullptr, nullptr },
        { "placement", reinterpret_cast<getter>(FlyoutShowOptions_get_Placement), reinterpret_cast<setter>(FlyoutShowOptions_put_Placement), nullptr, nullptr },
        { "exclusion_rect", reinterpret_cast<getter>(FlyoutShowOptions_get_ExclusionRect), reinterpret_cast<setter>(FlyoutShowOptions_put_ExclusionRect), nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_FlyoutShowOptions[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_FlyoutShowOptions) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_FlyoutShowOptions) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_FlyoutShowOptions) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_FlyoutShowOptions) },
        { },
    };

    static PyType_Spec type_spec_FlyoutShowOptions =
    {
        "winrt._winrt_microsoft_ui_xaml_controls_primitives.FlyoutShowOptions",
        sizeof(py::wrapper::Microsoft::UI::Xaml::Controls::Primitives::FlyoutShowOptions),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_FlyoutShowOptions
    };

    // ----- GeneratorPositionHelper class --------------------

    static PyObject* _new_GeneratorPositionHelper(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Microsoft::UI::Xaml::Controls::Primitives::GeneratorPositionHelper>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Microsoft::UI::Xaml::Controls::Primitives::GeneratorPositionHelper>::type_name);
        return nullptr;
    }

    static void _dealloc_GeneratorPositionHelper(py::wrapper::Microsoft::UI::Xaml::Controls::Primitives::GeneratorPositionHelper* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* GeneratorPositionHelper_FromIndexAndOffset(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Xaml.Controls.Primitives.GeneratorPositionHelper", L"FromIndexAndOffset", 2))
            {
                py::set_arg_count_version_error(2);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<int32_t>(args, 0);
                auto param1 = py::convert_to<int32_t>(args, 1);

                return py::convert(winrt::Microsoft::UI::Xaml::Controls::Primitives::GeneratorPositionHelper::FromIndexAndOffset(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* _assign_array_GeneratorPositionHelper(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Microsoft::UI::Xaml::Controls::Primitives::GeneratorPositionHelper>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_GeneratorPositionHelper(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Microsoft::UI::Xaml::Controls::Primitives::GeneratorPositionHelper>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_GeneratorPositionHelper[] = {
        { "_assign_array_", _assign_array_GeneratorPositionHelper, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_GeneratorPositionHelper), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_GeneratorPositionHelper[] = {
        { }
    };

    static PyType_Slot _type_slots_GeneratorPositionHelper[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_GeneratorPositionHelper) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_GeneratorPositionHelper) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_GeneratorPositionHelper) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_GeneratorPositionHelper) },
        { },
    };

    static PyType_Spec type_spec_GeneratorPositionHelper =
    {
        "winrt._winrt_microsoft_ui_xaml_controls_primitives.GeneratorPositionHelper",
        sizeof(py::wrapper::Microsoft::UI::Xaml::Controls::Primitives::GeneratorPositionHelper),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_GeneratorPositionHelper
    };

    static PyGetSetDef getset_GeneratorPositionHelper_Static[] = {
        { }
    };

    static PyMethodDef methods_GeneratorPositionHelper_Static[] = {
        { "from_index_and_offset", reinterpret_cast<PyCFunction>(GeneratorPositionHelper_FromIndexAndOffset), METH_VARARGS, nullptr },
        { }
    };

    static PyType_Slot type_slots_GeneratorPositionHelper_Static[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_GeneratorPositionHelper_Static) },
        { Py_tp_methods, reinterpret_cast<void*>(methods_GeneratorPositionHelper_Static) },
        { }
    };

    static PyType_Spec type_spec_GeneratorPositionHelper_Static =
    {
        "winrt._winrt_microsoft_ui_xaml_controls_primitives.GeneratorPositionHelper_Static",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT,
        type_slots_GeneratorPositionHelper_Static
    };

    // ----- GridViewItemPresenter class --------------------

    static PyObject* _new_GridViewItemPresenter(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 0)
        {
            try
            {
                winrt::Microsoft::UI::Xaml::Controls::Primitives::GridViewItemPresenter instance{  };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_GridViewItemPresenter(py::wrapper::Microsoft::UI::Xaml::Controls::Primitives::GridViewItemPresenter* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* GridViewItemPresenter_get_SelectionCheckMarkVisualEnabled(py::wrapper::Microsoft::UI::Xaml::Controls::Primitives::GridViewItemPresenter* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.GridViewItemPresenter", L"SelectionCheckMarkVisualEnabled"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.SelectionCheckMarkVisualEnabled());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int GridViewItemPresenter_put_SelectionCheckMarkVisualEnabled(py::wrapper::Microsoft::UI::Xaml::Controls::Primitives::GridViewItemPresenter* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.GridViewItemPresenter", L"SelectionCheckMarkVisualEnabled"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<bool>(arg);

            self->obj.SelectionCheckMarkVisualEnabled(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* GridViewItemPresenter_get_SelectedPointerOverBorderBrush(py::wrapper::Microsoft::UI::Xaml::Controls::Primitives::GridViewItemPresenter* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.GridViewItemPresenter", L"SelectedPointerOverBorderBrush"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.SelectedPointerOverBorderBrush());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int GridViewItemPresenter_put_SelectedPointerOverBorderBrush(py::wrapper::Microsoft::UI::Xaml::Controls::Primitives::GridViewItemPresenter* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.GridViewItemPresenter", L"SelectedPointerOverBorderBrush"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Microsoft::UI::Xaml::Media::Brush>(arg);

            self->obj.SelectedPointerOverBorderBrush(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* GridViewItemPresenter_get_SelectedPointerOverBackground(py::wrapper::Microsoft::UI::Xaml::Controls::Primitives::GridViewItemPresenter* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.GridViewItemPresenter", L"SelectedPointerOverBackground"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.SelectedPointerOverBackground());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int GridViewItemPresenter_put_SelectedPointerOverBackground(py::wrapper::Microsoft::UI::Xaml::Controls::Primitives::GridViewItemPresenter* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.GridViewItemPresenter", L"SelectedPointerOverBackground"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Microsoft::UI::Xaml::Media::Brush>(arg);

            self->obj.SelectedPointerOverBackground(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* GridViewItemPresenter_get_SelectedForeground(py::wrapper::Microsoft::UI::Xaml::Controls::Primitives::GridViewItemPresenter* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.GridViewItemPresenter", L"SelectedForeground"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.SelectedForeground());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int GridViewItemPresenter_put_SelectedForeground(py::wrapper::Microsoft::UI::Xaml::Controls::Primitives::GridViewItemPresenter* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.GridViewItemPresenter", L"SelectedForeground"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Microsoft::UI::Xaml::Media::Brush>(arg);

            self->obj.SelectedForeground(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* GridViewItemPresenter_get_SelectedBorderThickness(py::wrapper::Microsoft::UI::Xaml::Controls::Primitives::GridViewItemPresenter* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.GridViewItemPresenter", L"SelectedBorderThickness"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.SelectedBorderThickness());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int GridViewItemPresenter_put_SelectedBorderThickness(py::wrapper::Microsoft::UI::Xaml::Controls::Primitives::GridViewItemPresenter* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.GridViewItemPresenter", L"SelectedBorderThickness"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Microsoft::UI::Xaml::Thickness>(arg);

            self->obj.SelectedBorderThickness(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* GridViewItemPresenter_get_SelectedBackground(py::wrapper::Microsoft::UI::Xaml::Controls::Primitives::GridViewItemPresenter* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.GridViewItemPresenter", L"SelectedBackground"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.SelectedBackground());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int GridViewItemPresenter_put_SelectedBackground(py::wrapper::Microsoft::UI::Xaml::Controls::Primitives::GridViewItemPresenter* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.GridViewItemPresenter", L"SelectedBackground"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Microsoft::UI::Xaml::Media::Brush>(arg);

            self->obj.SelectedBackground(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* GridViewItemPresenter_get_ReorderHintOffset(py::wrapper::Microsoft::UI::Xaml::Controls::Primitives::GridViewItemPresenter* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.GridViewItemPresenter", L"ReorderHintOffset"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.ReorderHintOffset());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int GridViewItemPresenter_put_ReorderHintOffset(py::wrapper::Microsoft::UI::Xaml::Controls::Primitives::GridViewItemPresenter* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.GridViewItemPresenter", L"ReorderHintOffset"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<double>(arg);

            self->obj.ReorderHintOffset(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* GridViewItemPresenter_get_PointerOverBackgroundMargin(py::wrapper::Microsoft::UI::Xaml::Controls::Primitives::GridViewItemPresenter* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.GridViewItemPresenter", L"PointerOverBackgroundMargin"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.PointerOverBackgroundMargin());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int GridViewItemPresenter_put_PointerOverBackgroundMargin(py::wrapper::Microsoft::UI::Xaml::Controls::Primitives::GridViewItemPresenter* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.GridViewItemPresenter", L"PointerOverBackgroundMargin"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Microsoft::UI::Xaml::Thickness>(arg);

            self->obj.PointerOverBackgroundMargin(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* GridViewItemPresenter_get_PointerOverBackground(py::wrapper::Microsoft::UI::Xaml::Controls::Primitives::GridViewItemPresenter* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.GridViewItemPresenter", L"PointerOverBackground"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.PointerOverBackground());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int GridViewItemPresenter_put_PointerOverBackground(py::wrapper::Microsoft::UI::Xaml::Controls::Primitives::GridViewItemPresenter* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.GridViewItemPresenter", L"PointerOverBackground"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Microsoft::UI::Xaml::Media::Brush>(arg);

            self->obj.PointerOverBackground(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* GridViewItemPresenter_get_PlaceholderBackground(py::wrapper::Microsoft::UI::Xaml::Controls::Primitives::GridViewItemPresenter* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.GridViewItemPresenter", L"PlaceholderBackground"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.PlaceholderBackground());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int GridViewItemPresenter_put_PlaceholderBackground(py::wrapper::Microsoft::UI::Xaml::Controls::Primitives::GridViewItemPresenter* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.GridViewItemPresenter", L"PlaceholderBackground"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Microsoft::UI::Xaml::Media::Brush>(arg);

            self->obj.PlaceholderBackground(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* GridViewItemPresenter_get_GridViewItemPresenterVerticalContentAlignment(py::wrapper::Microsoft::UI::Xaml::Controls::Primitives::GridViewItemPresenter* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.GridViewItemPresenter", L"GridViewItemPresenterVerticalContentAlignment"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.GridViewItemPresenterVerticalContentAlignment());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int GridViewItemPresenter_put_GridViewItemPresenterVerticalContentAlignment(py::wrapper::Microsoft::UI::Xaml::Controls::Primitives::GridViewItemPresenter* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.GridViewItemPresenter", L"GridViewItemPresenterVerticalContentAlignment"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Microsoft::UI::Xaml::VerticalAlignment>(arg);

            self->obj.GridViewItemPresenterVerticalContentAlignment(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* GridViewItemPresenter_get_GridViewItemPresenterPadding(py::wrapper::Microsoft::UI::Xaml::Controls::Primitives::GridViewItemPresenter* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.GridViewItemPresenter", L"GridViewItemPresenterPadding"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.GridViewItemPresenterPadding());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int GridViewItemPresenter_put_GridViewItemPresenterPadding(py::wrapper::Microsoft::UI::Xaml::Controls::Primitives::GridViewItemPresenter* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.GridViewItemPresenter", L"GridViewItemPresenterPadding"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Microsoft::UI::Xaml::Thickness>(arg);

            self->obj.GridViewItemPresenterPadding(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* GridViewItemPresenter_get_GridViewItemPresenterHorizontalContentAlignment(py::wrapper::Microsoft::UI::Xaml::Controls::Primitives::GridViewItemPresenter* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.GridViewItemPresenter", L"GridViewItemPresenterHorizontalContentAlignment"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.GridViewItemPresenterHorizontalContentAlignment());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int GridViewItemPresenter_put_GridViewItemPresenterHorizontalContentAlignment(py::wrapper::Microsoft::UI::Xaml::Controls::Primitives::GridViewItemPresenter* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.GridViewItemPresenter", L"GridViewItemPresenterHorizontalContentAlignment"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Microsoft::UI::Xaml::HorizontalAlignment>(arg);

            self->obj.GridViewItemPresenterHorizontalContentAlignment(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* GridViewItemPresenter_get_FocusBorderBrush(py::wrapper::Microsoft::UI::Xaml::Controls::Primitives::GridViewItemPresenter* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.GridViewItemPresenter", L"FocusBorderBrush"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.FocusBorderBrush());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int GridViewItemPresenter_put_FocusBorderBrush(py::wrapper::Microsoft::UI::Xaml::Controls::Primitives::GridViewItemPresenter* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.GridViewItemPresenter", L"FocusBorderBrush"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Microsoft::UI::Xaml::Media::Brush>(arg);

            self->obj.FocusBorderBrush(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* GridViewItemPresenter_get_DragOpacity(py::wrapper::Microsoft::UI::Xaml::Controls::Primitives::GridViewItemPresenter* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.GridViewItemPresenter", L"DragOpacity"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.DragOpacity());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int GridViewItemPresenter_put_DragOpacity(py::wrapper::Microsoft::UI::Xaml::Controls::Primitives::GridViewItemPresenter* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.GridViewItemPresenter", L"DragOpacity"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<double>(arg);

            self->obj.DragOpacity(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* GridViewItemPresenter_get_DragForeground(py::wrapper::Microsoft::UI::Xaml::Controls::Primitives::GridViewItemPresenter* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.GridViewItemPresenter", L"DragForeground"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.DragForeground());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int GridViewItemPresenter_put_DragForeground(py::wrapper::Microsoft::UI::Xaml::Controls::Primitives::GridViewItemPresenter* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.GridViewItemPresenter", L"DragForeground"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Microsoft::UI::Xaml::Media::Brush>(arg);

            self->obj.DragForeground(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* GridViewItemPresenter_get_DragBackground(py::wrapper::Microsoft::UI::Xaml::Controls::Primitives::GridViewItemPresenter* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.GridViewItemPresenter", L"DragBackground"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.DragBackground());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int GridViewItemPresenter_put_DragBackground(py::wrapper::Microsoft::UI::Xaml::Controls::Primitives::GridViewItemPresenter* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.GridViewItemPresenter", L"DragBackground"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Microsoft::UI::Xaml::Media::Brush>(arg);

            self->obj.DragBackground(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* GridViewItemPresenter_get_DisabledOpacity(py::wrapper::Microsoft::UI::Xaml::Controls::Primitives::GridViewItemPresenter* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.GridViewItemPresenter", L"DisabledOpacity"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.DisabledOpacity());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int GridViewItemPresenter_put_DisabledOpacity(py::wrapper::Microsoft::UI::Xaml::Controls::Primitives::GridViewItemPresenter* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.GridViewItemPresenter", L"DisabledOpacity"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<double>(arg);

            self->obj.DisabledOpacity(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* GridViewItemPresenter_get_ContentMargin(py::wrapper::Microsoft::UI::Xaml::Controls::Primitives::GridViewItemPresenter* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.GridViewItemPresenter", L"ContentMargin"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.ContentMargin());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int GridViewItemPresenter_put_ContentMargin(py::wrapper::Microsoft::UI::Xaml::Controls::Primitives::GridViewItemPresenter* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.GridViewItemPresenter", L"ContentMargin"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Microsoft::UI::Xaml::Thickness>(arg);

            self->obj.ContentMargin(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* GridViewItemPresenter_get_CheckSelectingBrush(py::wrapper::Microsoft::UI::Xaml::Controls::Primitives::GridViewItemPresenter* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.GridViewItemPresenter", L"CheckSelectingBrush"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.CheckSelectingBrush());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int GridViewItemPresenter_put_CheckSelectingBrush(py::wrapper::Microsoft::UI::Xaml::Controls::Primitives::GridViewItemPresenter* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.GridViewItemPresenter", L"CheckSelectingBrush"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Microsoft::UI::Xaml::Media::Brush>(arg);

            self->obj.CheckSelectingBrush(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* GridViewItemPresenter_get_CheckHintBrush(py::wrapper::Microsoft::UI::Xaml::Controls::Primitives::GridViewItemPresenter* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.GridViewItemPresenter", L"CheckHintBrush"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.CheckHintBrush());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int GridViewItemPresenter_put_CheckHintBrush(py::wrapper::Microsoft::UI::Xaml::Controls::Primitives::GridViewItemPresenter* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.GridViewItemPresenter", L"CheckHintBrush"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Microsoft::UI::Xaml::Media::Brush>(arg);

            self->obj.CheckHintBrush(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* GridViewItemPresenter_get_CheckBrush(py::wrapper::Microsoft::UI::Xaml::Controls::Primitives::GridViewItemPresenter* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.GridViewItemPresenter", L"CheckBrush"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.CheckBrush());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int GridViewItemPresenter_put_CheckBrush(py::wrapper::Microsoft::UI::Xaml::Controls::Primitives::GridViewItemPresenter* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.GridViewItemPresenter", L"CheckBrush"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Microsoft::UI::Xaml::Media::Brush>(arg);

            self->obj.CheckBrush(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* GridViewItemPresenter_get_CheckBrushProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.GridViewItemPresenter", L"CheckBrushProperty"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Microsoft::UI::Xaml::Controls::Primitives::GridViewItemPresenter::CheckBrushProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* GridViewItemPresenter_get_CheckHintBrushProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.GridViewItemPresenter", L"CheckHintBrushProperty"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Microsoft::UI::Xaml::Controls::Primitives::GridViewItemPresenter::CheckHintBrushProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* GridViewItemPresenter_get_CheckSelectingBrushProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.GridViewItemPresenter", L"CheckSelectingBrushProperty"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Microsoft::UI::Xaml::Controls::Primitives::GridViewItemPresenter::CheckSelectingBrushProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* GridViewItemPresenter_get_ContentMarginProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.GridViewItemPresenter", L"ContentMarginProperty"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Microsoft::UI::Xaml::Controls::Primitives::GridViewItemPresenter::ContentMarginProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* GridViewItemPresenter_get_DisabledOpacityProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.GridViewItemPresenter", L"DisabledOpacityProperty"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Microsoft::UI::Xaml::Controls::Primitives::GridViewItemPresenter::DisabledOpacityProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* GridViewItemPresenter_get_DragBackgroundProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.GridViewItemPresenter", L"DragBackgroundProperty"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Microsoft::UI::Xaml::Controls::Primitives::GridViewItemPresenter::DragBackgroundProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* GridViewItemPresenter_get_DragForegroundProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.GridViewItemPresenter", L"DragForegroundProperty"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Microsoft::UI::Xaml::Controls::Primitives::GridViewItemPresenter::DragForegroundProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* GridViewItemPresenter_get_DragOpacityProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.GridViewItemPresenter", L"DragOpacityProperty"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Microsoft::UI::Xaml::Controls::Primitives::GridViewItemPresenter::DragOpacityProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* GridViewItemPresenter_get_FocusBorderBrushProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.GridViewItemPresenter", L"FocusBorderBrushProperty"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Microsoft::UI::Xaml::Controls::Primitives::GridViewItemPresenter::FocusBorderBrushProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* GridViewItemPresenter_get_GridViewItemPresenterHorizontalContentAlignmentProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.GridViewItemPresenter", L"GridViewItemPresenterHorizontalContentAlignmentProperty"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Microsoft::UI::Xaml::Controls::Primitives::GridViewItemPresenter::GridViewItemPresenterHorizontalContentAlignmentProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* GridViewItemPresenter_get_GridViewItemPresenterPaddingProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.GridViewItemPresenter", L"GridViewItemPresenterPaddingProperty"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Microsoft::UI::Xaml::Controls::Primitives::GridViewItemPresenter::GridViewItemPresenterPaddingProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* GridViewItemPresenter_get_GridViewItemPresenterVerticalContentAlignmentProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.GridViewItemPresenter", L"GridViewItemPresenterVerticalContentAlignmentProperty"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Microsoft::UI::Xaml::Controls::Primitives::GridViewItemPresenter::GridViewItemPresenterVerticalContentAlignmentProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* GridViewItemPresenter_get_PlaceholderBackgroundProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.GridViewItemPresenter", L"PlaceholderBackgroundProperty"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Microsoft::UI::Xaml::Controls::Primitives::GridViewItemPresenter::PlaceholderBackgroundProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* GridViewItemPresenter_get_PointerOverBackgroundMarginProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.GridViewItemPresenter", L"PointerOverBackgroundMarginProperty"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Microsoft::UI::Xaml::Controls::Primitives::GridViewItemPresenter::PointerOverBackgroundMarginProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* GridViewItemPresenter_get_PointerOverBackgroundProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.GridViewItemPresenter", L"PointerOverBackgroundProperty"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Microsoft::UI::Xaml::Controls::Primitives::GridViewItemPresenter::PointerOverBackgroundProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* GridViewItemPresenter_get_ReorderHintOffsetProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.GridViewItemPresenter", L"ReorderHintOffsetProperty"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Microsoft::UI::Xaml::Controls::Primitives::GridViewItemPresenter::ReorderHintOffsetProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* GridViewItemPresenter_get_SelectedBackgroundProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.GridViewItemPresenter", L"SelectedBackgroundProperty"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Microsoft::UI::Xaml::Controls::Primitives::GridViewItemPresenter::SelectedBackgroundProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* GridViewItemPresenter_get_SelectedBorderThicknessProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.GridViewItemPresenter", L"SelectedBorderThicknessProperty"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Microsoft::UI::Xaml::Controls::Primitives::GridViewItemPresenter::SelectedBorderThicknessProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* GridViewItemPresenter_get_SelectedForegroundProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.GridViewItemPresenter", L"SelectedForegroundProperty"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Microsoft::UI::Xaml::Controls::Primitives::GridViewItemPresenter::SelectedForegroundProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* GridViewItemPresenter_get_SelectedPointerOverBackgroundProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.GridViewItemPresenter", L"SelectedPointerOverBackgroundProperty"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Microsoft::UI::Xaml::Controls::Primitives::GridViewItemPresenter::SelectedPointerOverBackgroundProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* GridViewItemPresenter_get_SelectedPointerOverBorderBrushProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.GridViewItemPresenter", L"SelectedPointerOverBorderBrushProperty"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Microsoft::UI::Xaml::Controls::Primitives::GridViewItemPresenter::SelectedPointerOverBorderBrushProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* GridViewItemPresenter_get_SelectionCheckMarkVisualEnabledProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.GridViewItemPresenter", L"SelectionCheckMarkVisualEnabledProperty"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Microsoft::UI::Xaml::Controls::Primitives::GridViewItemPresenter::SelectionCheckMarkVisualEnabledProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_GridViewItemPresenter(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Microsoft::UI::Xaml::Controls::Primitives::GridViewItemPresenter>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_GridViewItemPresenter(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Microsoft::UI::Xaml::Controls::Primitives::GridViewItemPresenter>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_GridViewItemPresenter[] = {
        { "_assign_array_", _assign_array_GridViewItemPresenter, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_GridViewItemPresenter), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_GridViewItemPresenter[] = {
        { "selection_check_mark_visual_enabled", reinterpret_cast<getter>(GridViewItemPresenter_get_SelectionCheckMarkVisualEnabled), reinterpret_cast<setter>(GridViewItemPresenter_put_SelectionCheckMarkVisualEnabled), nullptr, nullptr },
        { "selected_pointer_over_border_brush", reinterpret_cast<getter>(GridViewItemPresenter_get_SelectedPointerOverBorderBrush), reinterpret_cast<setter>(GridViewItemPresenter_put_SelectedPointerOverBorderBrush), nullptr, nullptr },
        { "selected_pointer_over_background", reinterpret_cast<getter>(GridViewItemPresenter_get_SelectedPointerOverBackground), reinterpret_cast<setter>(GridViewItemPresenter_put_SelectedPointerOverBackground), nullptr, nullptr },
        { "selected_foreground", reinterpret_cast<getter>(GridViewItemPresenter_get_SelectedForeground), reinterpret_cast<setter>(GridViewItemPresenter_put_SelectedForeground), nullptr, nullptr },
        { "selected_border_thickness", reinterpret_cast<getter>(GridViewItemPresenter_get_SelectedBorderThickness), reinterpret_cast<setter>(GridViewItemPresenter_put_SelectedBorderThickness), nullptr, nullptr },
        { "selected_background", reinterpret_cast<getter>(GridViewItemPresenter_get_SelectedBackground), reinterpret_cast<setter>(GridViewItemPresenter_put_SelectedBackground), nullptr, nullptr },
        { "reorder_hint_offset", reinterpret_cast<getter>(GridViewItemPresenter_get_ReorderHintOffset), reinterpret_cast<setter>(GridViewItemPresenter_put_ReorderHintOffset), nullptr, nullptr },
        { "pointer_over_background_margin", reinterpret_cast<getter>(GridViewItemPresenter_get_PointerOverBackgroundMargin), reinterpret_cast<setter>(GridViewItemPresenter_put_PointerOverBackgroundMargin), nullptr, nullptr },
        { "pointer_over_background", reinterpret_cast<getter>(GridViewItemPresenter_get_PointerOverBackground), reinterpret_cast<setter>(GridViewItemPresenter_put_PointerOverBackground), nullptr, nullptr },
        { "placeholder_background", reinterpret_cast<getter>(GridViewItemPresenter_get_PlaceholderBackground), reinterpret_cast<setter>(GridViewItemPresenter_put_PlaceholderBackground), nullptr, nullptr },
        { "grid_view_item_presenter_vertical_content_alignment", reinterpret_cast<getter>(GridViewItemPresenter_get_GridViewItemPresenterVerticalContentAlignment), reinterpret_cast<setter>(GridViewItemPresenter_put_GridViewItemPresenterVerticalContentAlignment), nullptr, nullptr },
        { "grid_view_item_presenter_padding", reinterpret_cast<getter>(GridViewItemPresenter_get_GridViewItemPresenterPadding), reinterpret_cast<setter>(GridViewItemPresenter_put_GridViewItemPresenterPadding), nullptr, nullptr },
        { "grid_view_item_presenter_horizontal_content_alignment", reinterpret_cast<getter>(GridViewItemPresenter_get_GridViewItemPresenterHorizontalContentAlignment), reinterpret_cast<setter>(GridViewItemPresenter_put_GridViewItemPresenterHorizontalContentAlignment), nullptr, nullptr },
        { "focus_border_brush", reinterpret_cast<getter>(GridViewItemPresenter_get_FocusBorderBrush), reinterpret_cast<setter>(GridViewItemPresenter_put_FocusBorderBrush), nullptr, nullptr },
        { "drag_opacity", reinterpret_cast<getter>(GridViewItemPresenter_get_DragOpacity), reinterpret_cast<setter>(GridViewItemPresenter_put_DragOpacity), nullptr, nullptr },
        { "drag_foreground", reinterpret_cast<getter>(GridViewItemPresenter_get_DragForeground), reinterpret_cast<setter>(GridViewItemPresenter_put_DragForeground), nullptr, nullptr },
        { "drag_background", reinterpret_cast<getter>(GridViewItemPresenter_get_DragBackground), reinterpret_cast<setter>(GridViewItemPresenter_put_DragBackground), nullptr, nullptr },
        { "disabled_opacity", reinterpret_cast<getter>(GridViewItemPresenter_get_DisabledOpacity), reinterpret_cast<setter>(GridViewItemPresenter_put_DisabledOpacity), nullptr, nullptr },
        { "content_margin", reinterpret_cast<getter>(GridViewItemPresenter_get_ContentMargin), reinterpret_cast<setter>(GridViewItemPresenter_put_ContentMargin), nullptr, nullptr },
        { "check_selecting_brush", reinterpret_cast<getter>(GridViewItemPresenter_get_CheckSelectingBrush), reinterpret_cast<setter>(GridViewItemPresenter_put_CheckSelectingBrush), nullptr, nullptr },
        { "check_hint_brush", reinterpret_cast<getter>(GridViewItemPresenter_get_CheckHintBrush), reinterpret_cast<setter>(GridViewItemPresenter_put_CheckHintBrush), nullptr, nullptr },
        { "check_brush", reinterpret_cast<getter>(GridViewItemPresenter_get_CheckBrush), reinterpret_cast<setter>(GridViewItemPresenter_put_CheckBrush), nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_GridViewItemPresenter[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_GridViewItemPresenter) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_GridViewItemPresenter) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_GridViewItemPresenter) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_GridViewItemPresenter) },
        { },
    };

    static PyType_Spec type_spec_GridViewItemPresenter =
    {
        "winrt._winrt_microsoft_ui_xaml_controls_primitives.GridViewItemPresenter",
        sizeof(py::wrapper::Microsoft::UI::Xaml::Controls::Primitives::GridViewItemPresenter),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_GridViewItemPresenter
    };

    static PyGetSetDef getset_GridViewItemPresenter_Static[] = {
        { "check_brush_property", reinterpret_cast<getter>(GridViewItemPresenter_get_CheckBrushProperty), nullptr, nullptr, nullptr },
        { "check_hint_brush_property", reinterpret_cast<getter>(GridViewItemPresenter_get_CheckHintBrushProperty), nullptr, nullptr, nullptr },
        { "check_selecting_brush_property", reinterpret_cast<getter>(GridViewItemPresenter_get_CheckSelectingBrushProperty), nullptr, nullptr, nullptr },
        { "content_margin_property", reinterpret_cast<getter>(GridViewItemPresenter_get_ContentMarginProperty), nullptr, nullptr, nullptr },
        { "disabled_opacity_property", reinterpret_cast<getter>(GridViewItemPresenter_get_DisabledOpacityProperty), nullptr, nullptr, nullptr },
        { "drag_background_property", reinterpret_cast<getter>(GridViewItemPresenter_get_DragBackgroundProperty), nullptr, nullptr, nullptr },
        { "drag_foreground_property", reinterpret_cast<getter>(GridViewItemPresenter_get_DragForegroundProperty), nullptr, nullptr, nullptr },
        { "drag_opacity_property", reinterpret_cast<getter>(GridViewItemPresenter_get_DragOpacityProperty), nullptr, nullptr, nullptr },
        { "focus_border_brush_property", reinterpret_cast<getter>(GridViewItemPresenter_get_FocusBorderBrushProperty), nullptr, nullptr, nullptr },
        { "grid_view_item_presenter_horizontal_content_alignment_property", reinterpret_cast<getter>(GridViewItemPresenter_get_GridViewItemPresenterHorizontalContentAlignmentProperty), nullptr, nullptr, nullptr },
        { "grid_view_item_presenter_padding_property", reinterpret_cast<getter>(GridViewItemPresenter_get_GridViewItemPresenterPaddingProperty), nullptr, nullptr, nullptr },
        { "grid_view_item_presenter_vertical_content_alignment_property", reinterpret_cast<getter>(GridViewItemPresenter_get_GridViewItemPresenterVerticalContentAlignmentProperty), nullptr, nullptr, nullptr },
        { "placeholder_background_property", reinterpret_cast<getter>(GridViewItemPresenter_get_PlaceholderBackgroundProperty), nullptr, nullptr, nullptr },
        { "pointer_over_background_margin_property", reinterpret_cast<getter>(GridViewItemPresenter_get_PointerOverBackgroundMarginProperty), nullptr, nullptr, nullptr },
        { "pointer_over_background_property", reinterpret_cast<getter>(GridViewItemPresenter_get_PointerOverBackgroundProperty), nullptr, nullptr, nullptr },
        { "reorder_hint_offset_property", reinterpret_cast<getter>(GridViewItemPresenter_get_ReorderHintOffsetProperty), nullptr, nullptr, nullptr },
        { "selected_background_property", reinterpret_cast<getter>(GridViewItemPresenter_get_SelectedBackgroundProperty), nullptr, nullptr, nullptr },
        { "selected_border_thickness_property", reinterpret_cast<getter>(GridViewItemPresenter_get_SelectedBorderThicknessProperty), nullptr, nullptr, nullptr },
        { "selected_foreground_property", reinterpret_cast<getter>(GridViewItemPresenter_get_SelectedForegroundProperty), nullptr, nullptr, nullptr },
        { "selected_pointer_over_background_property", reinterpret_cast<getter>(GridViewItemPresenter_get_SelectedPointerOverBackgroundProperty), nullptr, nullptr, nullptr },
        { "selected_pointer_over_border_brush_property", reinterpret_cast<getter>(GridViewItemPresenter_get_SelectedPointerOverBorderBrushProperty), nullptr, nullptr, nullptr },
        { "selection_check_mark_visual_enabled_property", reinterpret_cast<getter>(GridViewItemPresenter_get_SelectionCheckMarkVisualEnabledProperty), nullptr, nullptr, nullptr },
        { }
    };

    static PyMethodDef methods_GridViewItemPresenter_Static[] = {
        { }
    };

    static PyType_Slot type_slots_GridViewItemPresenter_Static[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_GridViewItemPresenter_Static) },
        { Py_tp_methods, reinterpret_cast<void*>(methods_GridViewItemPresenter_Static) },
        { }
    };

    static PyType_Spec type_spec_GridViewItemPresenter_Static =
    {
        "winrt._winrt_microsoft_ui_xaml_controls_primitives.GridViewItemPresenter_Static",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT,
        type_slots_GridViewItemPresenter_Static
    };

    // ----- GridViewItemTemplateSettings class --------------------

    static PyObject* _new_GridViewItemTemplateSettings(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Microsoft::UI::Xaml::Controls::Primitives::GridViewItemTemplateSettings>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Microsoft::UI::Xaml::Controls::Primitives::GridViewItemTemplateSettings>::type_name);
        return nullptr;
    }

    static void _dealloc_GridViewItemTemplateSettings(py::wrapper::Microsoft::UI::Xaml::Controls::Primitives::GridViewItemTemplateSettings* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* GridViewItemTemplateSettings_get_DragItemsCount(py::wrapper::Microsoft::UI::Xaml::Controls::Primitives::GridViewItemTemplateSettings* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.GridViewItemTemplateSettings", L"DragItemsCount"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.DragItemsCount());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_GridViewItemTemplateSettings(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Microsoft::UI::Xaml::Controls::Primitives::GridViewItemTemplateSettings>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_GridViewItemTemplateSettings(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Microsoft::UI::Xaml::Controls::Primitives::GridViewItemTemplateSettings>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_GridViewItemTemplateSettings[] = {
        { "_assign_array_", _assign_array_GridViewItemTemplateSettings, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_GridViewItemTemplateSettings), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_GridViewItemTemplateSettings[] = {
        { "drag_items_count", reinterpret_cast<getter>(GridViewItemTemplateSettings_get_DragItemsCount), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_GridViewItemTemplateSettings[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_GridViewItemTemplateSettings) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_GridViewItemTemplateSettings) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_GridViewItemTemplateSettings) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_GridViewItemTemplateSettings) },
        { },
    };

    static PyType_Spec type_spec_GridViewItemTemplateSettings =
    {
        "winrt._winrt_microsoft_ui_xaml_controls_primitives.GridViewItemTemplateSettings",
        sizeof(py::wrapper::Microsoft::UI::Xaml::Controls::Primitives::GridViewItemTemplateSettings),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_GridViewItemTemplateSettings
    };

    // ----- InfoBarPanel class --------------------

    static PyObject* _new_InfoBarPanel(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 0)
        {
            try
            {
                winrt::Microsoft::UI::Xaml::Controls::Primitives::InfoBarPanel instance{  };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_InfoBarPanel(py::wrapper::Microsoft::UI::Xaml::Controls::Primitives::InfoBarPanel* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* InfoBarPanel_GetHorizontalOrientationMargin(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Xaml.Controls.Primitives.InfoBarPanel", L"GetHorizontalOrientationMargin", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Microsoft::UI::Xaml::DependencyObject>(args, 0);

                return py::convert(winrt::Microsoft::UI::Xaml::Controls::Primitives::InfoBarPanel::GetHorizontalOrientationMargin(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* InfoBarPanel_GetVerticalOrientationMargin(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Xaml.Controls.Primitives.InfoBarPanel", L"GetVerticalOrientationMargin", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Microsoft::UI::Xaml::DependencyObject>(args, 0);

                return py::convert(winrt::Microsoft::UI::Xaml::Controls::Primitives::InfoBarPanel::GetVerticalOrientationMargin(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* InfoBarPanel_SetHorizontalOrientationMargin(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Xaml.Controls.Primitives.InfoBarPanel", L"SetHorizontalOrientationMargin", 2))
            {
                py::set_arg_count_version_error(2);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Microsoft::UI::Xaml::DependencyObject>(args, 0);
                auto param1 = py::convert_to<winrt::Microsoft::UI::Xaml::Thickness>(args, 1);

                winrt::Microsoft::UI::Xaml::Controls::Primitives::InfoBarPanel::SetHorizontalOrientationMargin(param0, param1);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* InfoBarPanel_SetVerticalOrientationMargin(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Xaml.Controls.Primitives.InfoBarPanel", L"SetVerticalOrientationMargin", 2))
            {
                py::set_arg_count_version_error(2);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Microsoft::UI::Xaml::DependencyObject>(args, 0);
                auto param1 = py::convert_to<winrt::Microsoft::UI::Xaml::Thickness>(args, 1);

                winrt::Microsoft::UI::Xaml::Controls::Primitives::InfoBarPanel::SetVerticalOrientationMargin(param0, param1);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* InfoBarPanel_get_VerticalOrientationPadding(py::wrapper::Microsoft::UI::Xaml::Controls::Primitives::InfoBarPanel* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.InfoBarPanel", L"VerticalOrientationPadding"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.VerticalOrientationPadding());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int InfoBarPanel_put_VerticalOrientationPadding(py::wrapper::Microsoft::UI::Xaml::Controls::Primitives::InfoBarPanel* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.InfoBarPanel", L"VerticalOrientationPadding"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Microsoft::UI::Xaml::Thickness>(arg);

            self->obj.VerticalOrientationPadding(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* InfoBarPanel_get_HorizontalOrientationPadding(py::wrapper::Microsoft::UI::Xaml::Controls::Primitives::InfoBarPanel* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.InfoBarPanel", L"HorizontalOrientationPadding"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.HorizontalOrientationPadding());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int InfoBarPanel_put_HorizontalOrientationPadding(py::wrapper::Microsoft::UI::Xaml::Controls::Primitives::InfoBarPanel* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.InfoBarPanel", L"HorizontalOrientationPadding"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Microsoft::UI::Xaml::Thickness>(arg);

            self->obj.HorizontalOrientationPadding(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* InfoBarPanel_get_HorizontalOrientationMarginProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.InfoBarPanel", L"HorizontalOrientationMarginProperty"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Microsoft::UI::Xaml::Controls::Primitives::InfoBarPanel::HorizontalOrientationMarginProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* InfoBarPanel_get_HorizontalOrientationPaddingProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.InfoBarPanel", L"HorizontalOrientationPaddingProperty"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Microsoft::UI::Xaml::Controls::Primitives::InfoBarPanel::HorizontalOrientationPaddingProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* InfoBarPanel_get_VerticalOrientationMarginProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.InfoBarPanel", L"VerticalOrientationMarginProperty"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Microsoft::UI::Xaml::Controls::Primitives::InfoBarPanel::VerticalOrientationMarginProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* InfoBarPanel_get_VerticalOrientationPaddingProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.InfoBarPanel", L"VerticalOrientationPaddingProperty"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Microsoft::UI::Xaml::Controls::Primitives::InfoBarPanel::VerticalOrientationPaddingProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_InfoBarPanel(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Microsoft::UI::Xaml::Controls::Primitives::InfoBarPanel>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_InfoBarPanel(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Microsoft::UI::Xaml::Controls::Primitives::InfoBarPanel>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_InfoBarPanel[] = {
        { "_assign_array_", _assign_array_InfoBarPanel, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_InfoBarPanel), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_InfoBarPanel[] = {
        { "vertical_orientation_padding", reinterpret_cast<getter>(InfoBarPanel_get_VerticalOrientationPadding), reinterpret_cast<setter>(InfoBarPanel_put_VerticalOrientationPadding), nullptr, nullptr },
        { "horizontal_orientation_padding", reinterpret_cast<getter>(InfoBarPanel_get_HorizontalOrientationPadding), reinterpret_cast<setter>(InfoBarPanel_put_HorizontalOrientationPadding), nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_InfoBarPanel[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_InfoBarPanel) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_InfoBarPanel) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_InfoBarPanel) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_InfoBarPanel) },
        { },
    };

    static PyType_Spec type_spec_InfoBarPanel =
    {
        "winrt._winrt_microsoft_ui_xaml_controls_primitives.InfoBarPanel",
        sizeof(py::wrapper::Microsoft::UI::Xaml::Controls::Primitives::InfoBarPanel),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_InfoBarPanel
    };

    static PyGetSetDef getset_InfoBarPanel_Static[] = {
        { "horizontal_orientation_margin_property", reinterpret_cast<getter>(InfoBarPanel_get_HorizontalOrientationMarginProperty), nullptr, nullptr, nullptr },
        { "horizontal_orientation_padding_property", reinterpret_cast<getter>(InfoBarPanel_get_HorizontalOrientationPaddingProperty), nullptr, nullptr, nullptr },
        { "vertical_orientation_margin_property", reinterpret_cast<getter>(InfoBarPanel_get_VerticalOrientationMarginProperty), nullptr, nullptr, nullptr },
        { "vertical_orientation_padding_property", reinterpret_cast<getter>(InfoBarPanel_get_VerticalOrientationPaddingProperty), nullptr, nullptr, nullptr },
        { }
    };

    static PyMethodDef methods_InfoBarPanel_Static[] = {
        { "get_horizontal_orientation_margin", reinterpret_cast<PyCFunction>(InfoBarPanel_GetHorizontalOrientationMargin), METH_VARARGS, nullptr },
        { "get_vertical_orientation_margin", reinterpret_cast<PyCFunction>(InfoBarPanel_GetVerticalOrientationMargin), METH_VARARGS, nullptr },
        { "set_horizontal_orientation_margin", reinterpret_cast<PyCFunction>(InfoBarPanel_SetHorizontalOrientationMargin), METH_VARARGS, nullptr },
        { "set_vertical_orientation_margin", reinterpret_cast<PyCFunction>(InfoBarPanel_SetVerticalOrientationMargin), METH_VARARGS, nullptr },
        { }
    };

    static PyType_Slot type_slots_InfoBarPanel_Static[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_InfoBarPanel_Static) },
        { Py_tp_methods, reinterpret_cast<void*>(methods_InfoBarPanel_Static) },
        { }
    };

    static PyType_Spec type_spec_InfoBarPanel_Static =
    {
        "winrt._winrt_microsoft_ui_xaml_controls_primitives.InfoBarPanel_Static",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT,
        type_slots_InfoBarPanel_Static
    };

    // ----- ItemsChangedEventArgs class --------------------

    static PyObject* _new_ItemsChangedEventArgs(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Microsoft::UI::Xaml::Controls::Primitives::ItemsChangedEventArgs>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Microsoft::UI::Xaml::Controls::Primitives::ItemsChangedEventArgs>::type_name);
        return nullptr;
    }

    static void _dealloc_ItemsChangedEventArgs(py::wrapper::Microsoft::UI::Xaml::Controls::Primitives::ItemsChangedEventArgs* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* ItemsChangedEventArgs_get_Action(py::wrapper::Microsoft::UI::Xaml::Controls::Primitives::ItemsChangedEventArgs* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.ItemsChangedEventArgs", L"Action"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Action());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ItemsChangedEventArgs_get_ItemCount(py::wrapper::Microsoft::UI::Xaml::Controls::Primitives::ItemsChangedEventArgs* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.ItemsChangedEventArgs", L"ItemCount"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.ItemCount());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ItemsChangedEventArgs_get_ItemUICount(py::wrapper::Microsoft::UI::Xaml::Controls::Primitives::ItemsChangedEventArgs* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.ItemsChangedEventArgs", L"ItemUICount"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.ItemUICount());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ItemsChangedEventArgs_get_OldPosition(py::wrapper::Microsoft::UI::Xaml::Controls::Primitives::ItemsChangedEventArgs* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.ItemsChangedEventArgs", L"OldPosition"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.OldPosition());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ItemsChangedEventArgs_get_Position(py::wrapper::Microsoft::UI::Xaml::Controls::Primitives::ItemsChangedEventArgs* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.ItemsChangedEventArgs", L"Position"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Position());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_ItemsChangedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Microsoft::UI::Xaml::Controls::Primitives::ItemsChangedEventArgs>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_ItemsChangedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Microsoft::UI::Xaml::Controls::Primitives::ItemsChangedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_ItemsChangedEventArgs[] = {
        { "_assign_array_", _assign_array_ItemsChangedEventArgs, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_ItemsChangedEventArgs), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_ItemsChangedEventArgs[] = {
        { "action", reinterpret_cast<getter>(ItemsChangedEventArgs_get_Action), nullptr, nullptr, nullptr },
        { "item_count", reinterpret_cast<getter>(ItemsChangedEventArgs_get_ItemCount), nullptr, nullptr, nullptr },
        { "item_u_i_count", reinterpret_cast<getter>(ItemsChangedEventArgs_get_ItemUICount), nullptr, nullptr, nullptr },
        { "old_position", reinterpret_cast<getter>(ItemsChangedEventArgs_get_OldPosition), nullptr, nullptr, nullptr },
        { "position", reinterpret_cast<getter>(ItemsChangedEventArgs_get_Position), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_ItemsChangedEventArgs[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_ItemsChangedEventArgs) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_ItemsChangedEventArgs) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_ItemsChangedEventArgs) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_ItemsChangedEventArgs) },
        { },
    };

    static PyType_Spec type_spec_ItemsChangedEventArgs =
    {
        "winrt._winrt_microsoft_ui_xaml_controls_primitives.ItemsChangedEventArgs",
        sizeof(py::wrapper::Microsoft::UI::Xaml::Controls::Primitives::ItemsChangedEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_ItemsChangedEventArgs
    };

    // ----- JumpListItemBackgroundConverter class --------------------

    static PyObject* _new_JumpListItemBackgroundConverter(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 0)
        {
            try
            {
                winrt::Microsoft::UI::Xaml::Controls::Primitives::JumpListItemBackgroundConverter instance{  };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_JumpListItemBackgroundConverter(py::wrapper::Microsoft::UI::Xaml::Controls::Primitives::JumpListItemBackgroundConverter* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* JumpListItemBackgroundConverter_Convert(py::wrapper::Microsoft::UI::Xaml::Controls::Primitives::JumpListItemBackgroundConverter* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 4)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Xaml.Controls.Primitives.JumpListItemBackgroundConverter", L"Convert", 4))
            {
                py::set_arg_count_version_error(4);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::Foundation::IInspectable>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::UI::Xaml::Interop::TypeName>(args, 1);
                auto param2 = py::convert_to<winrt::Windows::Foundation::IInspectable>(args, 2);
                auto param3 = py::convert_to<winrt::hstring>(args, 3);

                return py::convert(self->obj.Convert(param0, param1, param2, param3));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* JumpListItemBackgroundConverter_ConvertBack(py::wrapper::Microsoft::UI::Xaml::Controls::Primitives::JumpListItemBackgroundConverter* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 4)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Xaml.Controls.Primitives.JumpListItemBackgroundConverter", L"ConvertBack", 4))
            {
                py::set_arg_count_version_error(4);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::Foundation::IInspectable>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::UI::Xaml::Interop::TypeName>(args, 1);
                auto param2 = py::convert_to<winrt::Windows::Foundation::IInspectable>(args, 2);
                auto param3 = py::convert_to<winrt::hstring>(args, 3);

                return py::convert(self->obj.ConvertBack(param0, param1, param2, param3));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* JumpListItemBackgroundConverter_get_Enabled(py::wrapper::Microsoft::UI::Xaml::Controls::Primitives::JumpListItemBackgroundConverter* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.JumpListItemBackgroundConverter", L"Enabled"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Enabled());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int JumpListItemBackgroundConverter_put_Enabled(py::wrapper::Microsoft::UI::Xaml::Controls::Primitives::JumpListItemBackgroundConverter* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.JumpListItemBackgroundConverter", L"Enabled"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Microsoft::UI::Xaml::Media::Brush>(arg);

            self->obj.Enabled(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* JumpListItemBackgroundConverter_get_Disabled(py::wrapper::Microsoft::UI::Xaml::Controls::Primitives::JumpListItemBackgroundConverter* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.JumpListItemBackgroundConverter", L"Disabled"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Disabled());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int JumpListItemBackgroundConverter_put_Disabled(py::wrapper::Microsoft::UI::Xaml::Controls::Primitives::JumpListItemBackgroundConverter* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.JumpListItemBackgroundConverter", L"Disabled"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Microsoft::UI::Xaml::Media::Brush>(arg);

            self->obj.Disabled(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* JumpListItemBackgroundConverter_get_DisabledProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.JumpListItemBackgroundConverter", L"DisabledProperty"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Microsoft::UI::Xaml::Controls::Primitives::JumpListItemBackgroundConverter::DisabledProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* JumpListItemBackgroundConverter_get_EnabledProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.JumpListItemBackgroundConverter", L"EnabledProperty"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Microsoft::UI::Xaml::Controls::Primitives::JumpListItemBackgroundConverter::EnabledProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_JumpListItemBackgroundConverter(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Microsoft::UI::Xaml::Controls::Primitives::JumpListItemBackgroundConverter>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_JumpListItemBackgroundConverter(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Microsoft::UI::Xaml::Controls::Primitives::JumpListItemBackgroundConverter>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_JumpListItemBackgroundConverter[] = {
        { "convert", reinterpret_cast<PyCFunction>(JumpListItemBackgroundConverter_Convert), METH_VARARGS, nullptr },
        { "convert_back", reinterpret_cast<PyCFunction>(JumpListItemBackgroundConverter_ConvertBack), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_JumpListItemBackgroundConverter, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_JumpListItemBackgroundConverter), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_JumpListItemBackgroundConverter[] = {
        { "enabled", reinterpret_cast<getter>(JumpListItemBackgroundConverter_get_Enabled), reinterpret_cast<setter>(JumpListItemBackgroundConverter_put_Enabled), nullptr, nullptr },
        { "disabled", reinterpret_cast<getter>(JumpListItemBackgroundConverter_get_Disabled), reinterpret_cast<setter>(JumpListItemBackgroundConverter_put_Disabled), nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_JumpListItemBackgroundConverter[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_JumpListItemBackgroundConverter) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_JumpListItemBackgroundConverter) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_JumpListItemBackgroundConverter) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_JumpListItemBackgroundConverter) },
        { },
    };

    static PyType_Spec type_spec_JumpListItemBackgroundConverter =
    {
        "winrt._winrt_microsoft_ui_xaml_controls_primitives.JumpListItemBackgroundConverter",
        sizeof(py::wrapper::Microsoft::UI::Xaml::Controls::Primitives::JumpListItemBackgroundConverter),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_JumpListItemBackgroundConverter
    };

    static PyGetSetDef getset_JumpListItemBackgroundConverter_Static[] = {
        { "disabled_property", reinterpret_cast<getter>(JumpListItemBackgroundConverter_get_DisabledProperty), nullptr, nullptr, nullptr },
        { "enabled_property", reinterpret_cast<getter>(JumpListItemBackgroundConverter_get_EnabledProperty), nullptr, nullptr, nullptr },
        { }
    };

    static PyMethodDef methods_JumpListItemBackgroundConverter_Static[] = {
        { }
    };

    static PyType_Slot type_slots_JumpListItemBackgroundConverter_Static[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_JumpListItemBackgroundConverter_Static) },
        { Py_tp_methods, reinterpret_cast<void*>(methods_JumpListItemBackgroundConverter_Static) },
        { }
    };

    static PyType_Spec type_spec_JumpListItemBackgroundConverter_Static =
    {
        "winrt._winrt_microsoft_ui_xaml_controls_primitives.JumpListItemBackgroundConverter_Static",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT,
        type_slots_JumpListItemBackgroundConverter_Static
    };

    // ----- JumpListItemForegroundConverter class --------------------

    static PyObject* _new_JumpListItemForegroundConverter(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 0)
        {
            try
            {
                winrt::Microsoft::UI::Xaml::Controls::Primitives::JumpListItemForegroundConverter instance{  };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_JumpListItemForegroundConverter(py::wrapper::Microsoft::UI::Xaml::Controls::Primitives::JumpListItemForegroundConverter* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* JumpListItemForegroundConverter_Convert(py::wrapper::Microsoft::UI::Xaml::Controls::Primitives::JumpListItemForegroundConverter* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 4)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Xaml.Controls.Primitives.JumpListItemForegroundConverter", L"Convert", 4))
            {
                py::set_arg_count_version_error(4);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::Foundation::IInspectable>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::UI::Xaml::Interop::TypeName>(args, 1);
                auto param2 = py::convert_to<winrt::Windows::Foundation::IInspectable>(args, 2);
                auto param3 = py::convert_to<winrt::hstring>(args, 3);

                return py::convert(self->obj.Convert(param0, param1, param2, param3));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* JumpListItemForegroundConverter_ConvertBack(py::wrapper::Microsoft::UI::Xaml::Controls::Primitives::JumpListItemForegroundConverter* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 4)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Xaml.Controls.Primitives.JumpListItemForegroundConverter", L"ConvertBack", 4))
            {
                py::set_arg_count_version_error(4);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::Foundation::IInspectable>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::UI::Xaml::Interop::TypeName>(args, 1);
                auto param2 = py::convert_to<winrt::Windows::Foundation::IInspectable>(args, 2);
                auto param3 = py::convert_to<winrt::hstring>(args, 3);

                return py::convert(self->obj.ConvertBack(param0, param1, param2, param3));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* JumpListItemForegroundConverter_get_Enabled(py::wrapper::Microsoft::UI::Xaml::Controls::Primitives::JumpListItemForegroundConverter* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.JumpListItemForegroundConverter", L"Enabled"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Enabled());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int JumpListItemForegroundConverter_put_Enabled(py::wrapper::Microsoft::UI::Xaml::Controls::Primitives::JumpListItemForegroundConverter* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.JumpListItemForegroundConverter", L"Enabled"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Microsoft::UI::Xaml::Media::Brush>(arg);

            self->obj.Enabled(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* JumpListItemForegroundConverter_get_Disabled(py::wrapper::Microsoft::UI::Xaml::Controls::Primitives::JumpListItemForegroundConverter* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.JumpListItemForegroundConverter", L"Disabled"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Disabled());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int JumpListItemForegroundConverter_put_Disabled(py::wrapper::Microsoft::UI::Xaml::Controls::Primitives::JumpListItemForegroundConverter* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.JumpListItemForegroundConverter", L"Disabled"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Microsoft::UI::Xaml::Media::Brush>(arg);

            self->obj.Disabled(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* JumpListItemForegroundConverter_get_DisabledProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.JumpListItemForegroundConverter", L"DisabledProperty"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Microsoft::UI::Xaml::Controls::Primitives::JumpListItemForegroundConverter::DisabledProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* JumpListItemForegroundConverter_get_EnabledProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.JumpListItemForegroundConverter", L"EnabledProperty"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Microsoft::UI::Xaml::Controls::Primitives::JumpListItemForegroundConverter::EnabledProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_JumpListItemForegroundConverter(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Microsoft::UI::Xaml::Controls::Primitives::JumpListItemForegroundConverter>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_JumpListItemForegroundConverter(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Microsoft::UI::Xaml::Controls::Primitives::JumpListItemForegroundConverter>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_JumpListItemForegroundConverter[] = {
        { "convert", reinterpret_cast<PyCFunction>(JumpListItemForegroundConverter_Convert), METH_VARARGS, nullptr },
        { "convert_back", reinterpret_cast<PyCFunction>(JumpListItemForegroundConverter_ConvertBack), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_JumpListItemForegroundConverter, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_JumpListItemForegroundConverter), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_JumpListItemForegroundConverter[] = {
        { "enabled", reinterpret_cast<getter>(JumpListItemForegroundConverter_get_Enabled), reinterpret_cast<setter>(JumpListItemForegroundConverter_put_Enabled), nullptr, nullptr },
        { "disabled", reinterpret_cast<getter>(JumpListItemForegroundConverter_get_Disabled), reinterpret_cast<setter>(JumpListItemForegroundConverter_put_Disabled), nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_JumpListItemForegroundConverter[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_JumpListItemForegroundConverter) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_JumpListItemForegroundConverter) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_JumpListItemForegroundConverter) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_JumpListItemForegroundConverter) },
        { },
    };

    static PyType_Spec type_spec_JumpListItemForegroundConverter =
    {
        "winrt._winrt_microsoft_ui_xaml_controls_primitives.JumpListItemForegroundConverter",
        sizeof(py::wrapper::Microsoft::UI::Xaml::Controls::Primitives::JumpListItemForegroundConverter),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_JumpListItemForegroundConverter
    };

    static PyGetSetDef getset_JumpListItemForegroundConverter_Static[] = {
        { "disabled_property", reinterpret_cast<getter>(JumpListItemForegroundConverter_get_DisabledProperty), nullptr, nullptr, nullptr },
        { "enabled_property", reinterpret_cast<getter>(JumpListItemForegroundConverter_get_EnabledProperty), nullptr, nullptr, nullptr },
        { }
    };

    static PyMethodDef methods_JumpListItemForegroundConverter_Static[] = {
        { }
    };

    static PyType_Slot type_slots_JumpListItemForegroundConverter_Static[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_JumpListItemForegroundConverter_Static) },
        { Py_tp_methods, reinterpret_cast<void*>(methods_JumpListItemForegroundConverter_Static) },
        { }
    };

    static PyType_Spec type_spec_JumpListItemForegroundConverter_Static =
    {
        "winrt._winrt_microsoft_ui_xaml_controls_primitives.JumpListItemForegroundConverter_Static",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT,
        type_slots_JumpListItemForegroundConverter_Static
    };

    // ----- LayoutInformation class --------------------

    static PyObject* _new_LayoutInformation(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Microsoft::UI::Xaml::Controls::Primitives::LayoutInformation>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Microsoft::UI::Xaml::Controls::Primitives::LayoutInformation>::type_name);
        return nullptr;
    }

    static void _dealloc_LayoutInformation(py::wrapper::Microsoft::UI::Xaml::Controls::Primitives::LayoutInformation* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* LayoutInformation_GetAvailableSize(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Xaml.Controls.Primitives.LayoutInformation", L"GetAvailableSize", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Microsoft::UI::Xaml::UIElement>(args, 0);

                return py::convert(winrt::Microsoft::UI::Xaml::Controls::Primitives::LayoutInformation::GetAvailableSize(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* LayoutInformation_GetLayoutExceptionElement(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Xaml.Controls.Primitives.LayoutInformation", L"GetLayoutExceptionElement", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::Foundation::IInspectable>(args, 0);

                return py::convert(winrt::Microsoft::UI::Xaml::Controls::Primitives::LayoutInformation::GetLayoutExceptionElement(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* LayoutInformation_GetLayoutSlot(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Xaml.Controls.Primitives.LayoutInformation", L"GetLayoutSlot", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Microsoft::UI::Xaml::FrameworkElement>(args, 0);

                return py::convert(winrt::Microsoft::UI::Xaml::Controls::Primitives::LayoutInformation::GetLayoutSlot(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* _assign_array_LayoutInformation(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Microsoft::UI::Xaml::Controls::Primitives::LayoutInformation>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_LayoutInformation(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Microsoft::UI::Xaml::Controls::Primitives::LayoutInformation>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_LayoutInformation[] = {
        { "_assign_array_", _assign_array_LayoutInformation, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_LayoutInformation), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_LayoutInformation[] = {
        { }
    };

    static PyType_Slot _type_slots_LayoutInformation[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_LayoutInformation) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_LayoutInformation) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_LayoutInformation) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_LayoutInformation) },
        { },
    };

    static PyType_Spec type_spec_LayoutInformation =
    {
        "winrt._winrt_microsoft_ui_xaml_controls_primitives.LayoutInformation",
        sizeof(py::wrapper::Microsoft::UI::Xaml::Controls::Primitives::LayoutInformation),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_LayoutInformation
    };

    static PyGetSetDef getset_LayoutInformation_Static[] = {
        { }
    };

    static PyMethodDef methods_LayoutInformation_Static[] = {
        { "get_available_size", reinterpret_cast<PyCFunction>(LayoutInformation_GetAvailableSize), METH_VARARGS, nullptr },
        { "get_layout_exception_element", reinterpret_cast<PyCFunction>(LayoutInformation_GetLayoutExceptionElement), METH_VARARGS, nullptr },
        { "get_layout_slot", reinterpret_cast<PyCFunction>(LayoutInformation_GetLayoutSlot), METH_VARARGS, nullptr },
        { }
    };

    static PyType_Slot type_slots_LayoutInformation_Static[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_LayoutInformation_Static) },
        { Py_tp_methods, reinterpret_cast<void*>(methods_LayoutInformation_Static) },
        { }
    };

    static PyType_Spec type_spec_LayoutInformation_Static =
    {
        "winrt._winrt_microsoft_ui_xaml_controls_primitives.LayoutInformation_Static",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT,
        type_slots_LayoutInformation_Static
    };

    // ----- ListViewItemPresenter class --------------------

    static PyObject* _new_ListViewItemPresenter(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 0)
        {
            try
            {
                winrt::Microsoft::UI::Xaml::Controls::Primitives::ListViewItemPresenter instance{  };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_ListViewItemPresenter(py::wrapper::Microsoft::UI::Xaml::Controls::Primitives::ListViewItemPresenter* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* ListViewItemPresenter_get_ListViewItemPresenterVerticalContentAlignment(py::wrapper::Microsoft::UI::Xaml::Controls::Primitives::ListViewItemPresenter* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.ListViewItemPresenter", L"ListViewItemPresenterVerticalContentAlignment"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.ListViewItemPresenterVerticalContentAlignment());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ListViewItemPresenter_put_ListViewItemPresenterVerticalContentAlignment(py::wrapper::Microsoft::UI::Xaml::Controls::Primitives::ListViewItemPresenter* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.ListViewItemPresenter", L"ListViewItemPresenterVerticalContentAlignment"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Microsoft::UI::Xaml::VerticalAlignment>(arg);

            self->obj.ListViewItemPresenterVerticalContentAlignment(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ListViewItemPresenter_get_ListViewItemPresenterPadding(py::wrapper::Microsoft::UI::Xaml::Controls::Primitives::ListViewItemPresenter* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.ListViewItemPresenter", L"ListViewItemPresenterPadding"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.ListViewItemPresenterPadding());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ListViewItemPresenter_put_ListViewItemPresenterPadding(py::wrapper::Microsoft::UI::Xaml::Controls::Primitives::ListViewItemPresenter* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.ListViewItemPresenter", L"ListViewItemPresenterPadding"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Microsoft::UI::Xaml::Thickness>(arg);

            self->obj.ListViewItemPresenterPadding(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ListViewItemPresenter_get_ListViewItemPresenterHorizontalContentAlignment(py::wrapper::Microsoft::UI::Xaml::Controls::Primitives::ListViewItemPresenter* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.ListViewItemPresenter", L"ListViewItemPresenterHorizontalContentAlignment"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.ListViewItemPresenterHorizontalContentAlignment());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ListViewItemPresenter_put_ListViewItemPresenterHorizontalContentAlignment(py::wrapper::Microsoft::UI::Xaml::Controls::Primitives::ListViewItemPresenter* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.ListViewItemPresenter", L"ListViewItemPresenterHorizontalContentAlignment"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Microsoft::UI::Xaml::HorizontalAlignment>(arg);

            self->obj.ListViewItemPresenterHorizontalContentAlignment(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ListViewItemPresenter_get_FocusSecondaryBorderBrush(py::wrapper::Microsoft::UI::Xaml::Controls::Primitives::ListViewItemPresenter* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.ListViewItemPresenter", L"FocusSecondaryBorderBrush"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.FocusSecondaryBorderBrush());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ListViewItemPresenter_put_FocusSecondaryBorderBrush(py::wrapper::Microsoft::UI::Xaml::Controls::Primitives::ListViewItemPresenter* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.ListViewItemPresenter", L"FocusSecondaryBorderBrush"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Microsoft::UI::Xaml::Media::Brush>(arg);

            self->obj.FocusSecondaryBorderBrush(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ListViewItemPresenter_get_FocusBorderBrush(py::wrapper::Microsoft::UI::Xaml::Controls::Primitives::ListViewItemPresenter* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.ListViewItemPresenter", L"FocusBorderBrush"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.FocusBorderBrush());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ListViewItemPresenter_put_FocusBorderBrush(py::wrapper::Microsoft::UI::Xaml::Controls::Primitives::ListViewItemPresenter* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.ListViewItemPresenter", L"FocusBorderBrush"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Microsoft::UI::Xaml::Media::Brush>(arg);

            self->obj.FocusBorderBrush(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ListViewItemPresenter_get_DragOpacity(py::wrapper::Microsoft::UI::Xaml::Controls::Primitives::ListViewItemPresenter* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.ListViewItemPresenter", L"DragOpacity"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.DragOpacity());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ListViewItemPresenter_put_DragOpacity(py::wrapper::Microsoft::UI::Xaml::Controls::Primitives::ListViewItemPresenter* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.ListViewItemPresenter", L"DragOpacity"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<double>(arg);

            self->obj.DragOpacity(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ListViewItemPresenter_get_RevealBackground(py::wrapper::Microsoft::UI::Xaml::Controls::Primitives::ListViewItemPresenter* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.ListViewItemPresenter", L"RevealBackground"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.RevealBackground());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ListViewItemPresenter_put_RevealBackground(py::wrapper::Microsoft::UI::Xaml::Controls::Primitives::ListViewItemPresenter* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.ListViewItemPresenter", L"RevealBackground"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Microsoft::UI::Xaml::Media::Brush>(arg);

            self->obj.RevealBackground(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ListViewItemPresenter_get_DragBackground(py::wrapper::Microsoft::UI::Xaml::Controls::Primitives::ListViewItemPresenter* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.ListViewItemPresenter", L"DragBackground"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.DragBackground());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ListViewItemPresenter_put_DragBackground(py::wrapper::Microsoft::UI::Xaml::Controls::Primitives::ListViewItemPresenter* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.ListViewItemPresenter", L"DragBackground"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Microsoft::UI::Xaml::Media::Brush>(arg);

            self->obj.DragBackground(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ListViewItemPresenter_get_DisabledOpacity(py::wrapper::Microsoft::UI::Xaml::Controls::Primitives::ListViewItemPresenter* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.ListViewItemPresenter", L"DisabledOpacity"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.DisabledOpacity());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ListViewItemPresenter_put_DisabledOpacity(py::wrapper::Microsoft::UI::Xaml::Controls::Primitives::ListViewItemPresenter* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.ListViewItemPresenter", L"DisabledOpacity"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<double>(arg);

            self->obj.DisabledOpacity(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ListViewItemPresenter_get_ContentMargin(py::wrapper::Microsoft::UI::Xaml::Controls::Primitives::ListViewItemPresenter* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.ListViewItemPresenter", L"ContentMargin"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.ContentMargin());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ListViewItemPresenter_put_ContentMargin(py::wrapper::Microsoft::UI::Xaml::Controls::Primitives::ListViewItemPresenter* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.ListViewItemPresenter", L"ContentMargin"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Microsoft::UI::Xaml::Thickness>(arg);

            self->obj.ContentMargin(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ListViewItemPresenter_get_CheckSelectingBrush(py::wrapper::Microsoft::UI::Xaml::Controls::Primitives::ListViewItemPresenter* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.ListViewItemPresenter", L"CheckSelectingBrush"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.CheckSelectingBrush());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ListViewItemPresenter_put_CheckSelectingBrush(py::wrapper::Microsoft::UI::Xaml::Controls::Primitives::ListViewItemPresenter* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.ListViewItemPresenter", L"CheckSelectingBrush"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Microsoft::UI::Xaml::Media::Brush>(arg);

            self->obj.CheckSelectingBrush(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ListViewItemPresenter_get_CheckPressedBrush(py::wrapper::Microsoft::UI::Xaml::Controls::Primitives::ListViewItemPresenter* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.ListViewItemPresenter", L"CheckPressedBrush"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.CheckPressedBrush());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ListViewItemPresenter_put_CheckPressedBrush(py::wrapper::Microsoft::UI::Xaml::Controls::Primitives::ListViewItemPresenter* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.ListViewItemPresenter", L"CheckPressedBrush"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Microsoft::UI::Xaml::Media::Brush>(arg);

            self->obj.CheckPressedBrush(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ListViewItemPresenter_get_CheckMode(py::wrapper::Microsoft::UI::Xaml::Controls::Primitives::ListViewItemPresenter* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.ListViewItemPresenter", L"CheckMode"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.CheckMode());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ListViewItemPresenter_put_CheckMode(py::wrapper::Microsoft::UI::Xaml::Controls::Primitives::ListViewItemPresenter* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.ListViewItemPresenter", L"CheckMode"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Microsoft::UI::Xaml::Controls::Primitives::ListViewItemPresenterCheckMode>(arg);

            self->obj.CheckMode(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ListViewItemPresenter_get_CheckHintBrush(py::wrapper::Microsoft::UI::Xaml::Controls::Primitives::ListViewItemPresenter* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.ListViewItemPresenter", L"CheckHintBrush"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.CheckHintBrush());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ListViewItemPresenter_put_CheckHintBrush(py::wrapper::Microsoft::UI::Xaml::Controls::Primitives::ListViewItemPresenter* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.ListViewItemPresenter", L"CheckHintBrush"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Microsoft::UI::Xaml::Media::Brush>(arg);

            self->obj.CheckHintBrush(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ListViewItemPresenter_get_CheckBoxBorderBrush(py::wrapper::Microsoft::UI::Xaml::Controls::Primitives::ListViewItemPresenter* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.ListViewItemPresenter", L"CheckBoxBorderBrush"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.CheckBoxBorderBrush());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ListViewItemPresenter_put_CheckBoxBorderBrush(py::wrapper::Microsoft::UI::Xaml::Controls::Primitives::ListViewItemPresenter* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.ListViewItemPresenter", L"CheckBoxBorderBrush"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Microsoft::UI::Xaml::Media::Brush>(arg);

            self->obj.CheckBoxBorderBrush(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ListViewItemPresenter_get_CheckBrush(py::wrapper::Microsoft::UI::Xaml::Controls::Primitives::ListViewItemPresenter* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.ListViewItemPresenter", L"CheckBrush"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.CheckBrush());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ListViewItemPresenter_put_CheckBrush(py::wrapper::Microsoft::UI::Xaml::Controls::Primitives::ListViewItemPresenter* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.ListViewItemPresenter", L"CheckBrush"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Microsoft::UI::Xaml::Media::Brush>(arg);

            self->obj.CheckBrush(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ListViewItemPresenter_get_CheckBoxSelectedPressedBrush(py::wrapper::Microsoft::UI::Xaml::Controls::Primitives::ListViewItemPresenter* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.ListViewItemPresenter", L"CheckBoxSelectedPressedBrush"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.CheckBoxSelectedPressedBrush());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ListViewItemPresenter_put_CheckBoxSelectedPressedBrush(py::wrapper::Microsoft::UI::Xaml::Controls::Primitives::ListViewItemPresenter* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.ListViewItemPresenter", L"CheckBoxSelectedPressedBrush"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Microsoft::UI::Xaml::Media::Brush>(arg);

            self->obj.CheckBoxSelectedPressedBrush(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ListViewItemPresenter_get_CheckBoxSelectedPointerOverBrush(py::wrapper::Microsoft::UI::Xaml::Controls::Primitives::ListViewItemPresenter* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.ListViewItemPresenter", L"CheckBoxSelectedPointerOverBrush"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.CheckBoxSelectedPointerOverBrush());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ListViewItemPresenter_put_CheckBoxSelectedPointerOverBrush(py::wrapper::Microsoft::UI::Xaml::Controls::Primitives::ListViewItemPresenter* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.ListViewItemPresenter", L"CheckBoxSelectedPointerOverBrush"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Microsoft::UI::Xaml::Media::Brush>(arg);

            self->obj.CheckBoxSelectedPointerOverBrush(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ListViewItemPresenter_get_CheckBoxSelectedDisabledBrush(py::wrapper::Microsoft::UI::Xaml::Controls::Primitives::ListViewItemPresenter* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.ListViewItemPresenter", L"CheckBoxSelectedDisabledBrush"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.CheckBoxSelectedDisabledBrush());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ListViewItemPresenter_put_CheckBoxSelectedDisabledBrush(py::wrapper::Microsoft::UI::Xaml::Controls::Primitives::ListViewItemPresenter* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.ListViewItemPresenter", L"CheckBoxSelectedDisabledBrush"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Microsoft::UI::Xaml::Media::Brush>(arg);

            self->obj.CheckBoxSelectedDisabledBrush(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ListViewItemPresenter_get_CheckBoxSelectedBrush(py::wrapper::Microsoft::UI::Xaml::Controls::Primitives::ListViewItemPresenter* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.ListViewItemPresenter", L"CheckBoxSelectedBrush"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.CheckBoxSelectedBrush());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ListViewItemPresenter_put_CheckBoxSelectedBrush(py::wrapper::Microsoft::UI::Xaml::Controls::Primitives::ListViewItemPresenter* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.ListViewItemPresenter", L"CheckBoxSelectedBrush"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Microsoft::UI::Xaml::Media::Brush>(arg);

            self->obj.CheckBoxSelectedBrush(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ListViewItemPresenter_get_CheckBoxPressedBrush(py::wrapper::Microsoft::UI::Xaml::Controls::Primitives::ListViewItemPresenter* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.ListViewItemPresenter", L"CheckBoxPressedBrush"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.CheckBoxPressedBrush());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ListViewItemPresenter_put_CheckBoxPressedBrush(py::wrapper::Microsoft::UI::Xaml::Controls::Primitives::ListViewItemPresenter* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.ListViewItemPresenter", L"CheckBoxPressedBrush"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Microsoft::UI::Xaml::Media::Brush>(arg);

            self->obj.CheckBoxPressedBrush(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ListViewItemPresenter_get_SelectionCheckMarkVisualEnabled(py::wrapper::Microsoft::UI::Xaml::Controls::Primitives::ListViewItemPresenter* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.ListViewItemPresenter", L"SelectionCheckMarkVisualEnabled"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.SelectionCheckMarkVisualEnabled());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ListViewItemPresenter_put_SelectionCheckMarkVisualEnabled(py::wrapper::Microsoft::UI::Xaml::Controls::Primitives::ListViewItemPresenter* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.ListViewItemPresenter", L"SelectionCheckMarkVisualEnabled"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<bool>(arg);

            self->obj.SelectionCheckMarkVisualEnabled(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ListViewItemPresenter_get_CheckBoxPointerOverBrush(py::wrapper::Microsoft::UI::Xaml::Controls::Primitives::ListViewItemPresenter* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.ListViewItemPresenter", L"CheckBoxPointerOverBrush"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.CheckBoxPointerOverBrush());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ListViewItemPresenter_put_CheckBoxPointerOverBrush(py::wrapper::Microsoft::UI::Xaml::Controls::Primitives::ListViewItemPresenter* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.ListViewItemPresenter", L"CheckBoxPointerOverBrush"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Microsoft::UI::Xaml::Media::Brush>(arg);

            self->obj.CheckBoxPointerOverBrush(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ListViewItemPresenter_get_CheckBoxPointerOverBorderBrush(py::wrapper::Microsoft::UI::Xaml::Controls::Primitives::ListViewItemPresenter* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.ListViewItemPresenter", L"CheckBoxPointerOverBorderBrush"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.CheckBoxPointerOverBorderBrush());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ListViewItemPresenter_put_CheckBoxPointerOverBorderBrush(py::wrapper::Microsoft::UI::Xaml::Controls::Primitives::ListViewItemPresenter* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.ListViewItemPresenter", L"CheckBoxPointerOverBorderBrush"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Microsoft::UI::Xaml::Media::Brush>(arg);

            self->obj.CheckBoxPointerOverBorderBrush(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ListViewItemPresenter_get_CheckBoxDisabledBrush(py::wrapper::Microsoft::UI::Xaml::Controls::Primitives::ListViewItemPresenter* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.ListViewItemPresenter", L"CheckBoxDisabledBrush"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.CheckBoxDisabledBrush());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ListViewItemPresenter_put_CheckBoxDisabledBrush(py::wrapper::Microsoft::UI::Xaml::Controls::Primitives::ListViewItemPresenter* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.ListViewItemPresenter", L"CheckBoxDisabledBrush"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Microsoft::UI::Xaml::Media::Brush>(arg);

            self->obj.CheckBoxDisabledBrush(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ListViewItemPresenter_get_CheckBoxDisabledBorderBrush(py::wrapper::Microsoft::UI::Xaml::Controls::Primitives::ListViewItemPresenter* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.ListViewItemPresenter", L"CheckBoxDisabledBorderBrush"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.CheckBoxDisabledBorderBrush());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ListViewItemPresenter_put_CheckBoxDisabledBorderBrush(py::wrapper::Microsoft::UI::Xaml::Controls::Primitives::ListViewItemPresenter* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.ListViewItemPresenter", L"CheckBoxDisabledBorderBrush"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Microsoft::UI::Xaml::Media::Brush>(arg);

            self->obj.CheckBoxDisabledBorderBrush(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ListViewItemPresenter_get_CheckBoxCornerRadius(py::wrapper::Microsoft::UI::Xaml::Controls::Primitives::ListViewItemPresenter* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.ListViewItemPresenter", L"CheckBoxCornerRadius"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.CheckBoxCornerRadius());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ListViewItemPresenter_put_CheckBoxCornerRadius(py::wrapper::Microsoft::UI::Xaml::Controls::Primitives::ListViewItemPresenter* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.ListViewItemPresenter", L"CheckBoxCornerRadius"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Microsoft::UI::Xaml::CornerRadius>(arg);

            self->obj.CheckBoxCornerRadius(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ListViewItemPresenter_get_CheckBoxBrush(py::wrapper::Microsoft::UI::Xaml::Controls::Primitives::ListViewItemPresenter* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.ListViewItemPresenter", L"CheckBoxBrush"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.CheckBoxBrush());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ListViewItemPresenter_put_CheckBoxBrush(py::wrapper::Microsoft::UI::Xaml::Controls::Primitives::ListViewItemPresenter* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.ListViewItemPresenter", L"CheckBoxBrush"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Microsoft::UI::Xaml::Media::Brush>(arg);

            self->obj.CheckBoxBrush(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ListViewItemPresenter_get_CheckDisabledBrush(py::wrapper::Microsoft::UI::Xaml::Controls::Primitives::ListViewItemPresenter* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.ListViewItemPresenter", L"CheckDisabledBrush"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.CheckDisabledBrush());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ListViewItemPresenter_put_CheckDisabledBrush(py::wrapper::Microsoft::UI::Xaml::Controls::Primitives::ListViewItemPresenter* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.ListViewItemPresenter", L"CheckDisabledBrush"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Microsoft::UI::Xaml::Media::Brush>(arg);

            self->obj.CheckDisabledBrush(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ListViewItemPresenter_get_PlaceholderBackground(py::wrapper::Microsoft::UI::Xaml::Controls::Primitives::ListViewItemPresenter* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.ListViewItemPresenter", L"PlaceholderBackground"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.PlaceholderBackground());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ListViewItemPresenter_put_PlaceholderBackground(py::wrapper::Microsoft::UI::Xaml::Controls::Primitives::ListViewItemPresenter* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.ListViewItemPresenter", L"PlaceholderBackground"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Microsoft::UI::Xaml::Media::Brush>(arg);

            self->obj.PlaceholderBackground(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ListViewItemPresenter_get_SelectedDisabledBorderBrush(py::wrapper::Microsoft::UI::Xaml::Controls::Primitives::ListViewItemPresenter* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.ListViewItemPresenter", L"SelectedDisabledBorderBrush"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.SelectedDisabledBorderBrush());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ListViewItemPresenter_put_SelectedDisabledBorderBrush(py::wrapper::Microsoft::UI::Xaml::Controls::Primitives::ListViewItemPresenter* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.ListViewItemPresenter", L"SelectedDisabledBorderBrush"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Microsoft::UI::Xaml::Media::Brush>(arg);

            self->obj.SelectedDisabledBorderBrush(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ListViewItemPresenter_get_SelectionIndicatorPressedBrush(py::wrapper::Microsoft::UI::Xaml::Controls::Primitives::ListViewItemPresenter* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.ListViewItemPresenter", L"SelectionIndicatorPressedBrush"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.SelectionIndicatorPressedBrush());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ListViewItemPresenter_put_SelectionIndicatorPressedBrush(py::wrapper::Microsoft::UI::Xaml::Controls::Primitives::ListViewItemPresenter* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.ListViewItemPresenter", L"SelectionIndicatorPressedBrush"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Microsoft::UI::Xaml::Media::Brush>(arg);

            self->obj.SelectionIndicatorPressedBrush(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ListViewItemPresenter_get_SelectionIndicatorPointerOverBrush(py::wrapper::Microsoft::UI::Xaml::Controls::Primitives::ListViewItemPresenter* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.ListViewItemPresenter", L"SelectionIndicatorPointerOverBrush"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.SelectionIndicatorPointerOverBrush());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ListViewItemPresenter_put_SelectionIndicatorPointerOverBrush(py::wrapper::Microsoft::UI::Xaml::Controls::Primitives::ListViewItemPresenter* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.ListViewItemPresenter", L"SelectionIndicatorPointerOverBrush"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Microsoft::UI::Xaml::Media::Brush>(arg);

            self->obj.SelectionIndicatorPointerOverBrush(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ListViewItemPresenter_get_SelectionIndicatorMode(py::wrapper::Microsoft::UI::Xaml::Controls::Primitives::ListViewItemPresenter* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.ListViewItemPresenter", L"SelectionIndicatorMode"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.SelectionIndicatorMode());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ListViewItemPresenter_put_SelectionIndicatorMode(py::wrapper::Microsoft::UI::Xaml::Controls::Primitives::ListViewItemPresenter* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.ListViewItemPresenter", L"SelectionIndicatorMode"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Microsoft::UI::Xaml::Controls::Primitives::ListViewItemPresenterSelectionIndicatorMode>(arg);

            self->obj.SelectionIndicatorMode(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ListViewItemPresenter_get_SelectionIndicatorDisabledBrush(py::wrapper::Microsoft::UI::Xaml::Controls::Primitives::ListViewItemPresenter* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.ListViewItemPresenter", L"SelectionIndicatorDisabledBrush"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.SelectionIndicatorDisabledBrush());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ListViewItemPresenter_put_SelectionIndicatorDisabledBrush(py::wrapper::Microsoft::UI::Xaml::Controls::Primitives::ListViewItemPresenter* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.ListViewItemPresenter", L"SelectionIndicatorDisabledBrush"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Microsoft::UI::Xaml::Media::Brush>(arg);

            self->obj.SelectionIndicatorDisabledBrush(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ListViewItemPresenter_get_SelectionIndicatorCornerRadius(py::wrapper::Microsoft::UI::Xaml::Controls::Primitives::ListViewItemPresenter* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.ListViewItemPresenter", L"SelectionIndicatorCornerRadius"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.SelectionIndicatorCornerRadius());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ListViewItemPresenter_put_SelectionIndicatorCornerRadius(py::wrapper::Microsoft::UI::Xaml::Controls::Primitives::ListViewItemPresenter* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.ListViewItemPresenter", L"SelectionIndicatorCornerRadius"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Microsoft::UI::Xaml::CornerRadius>(arg);

            self->obj.SelectionIndicatorCornerRadius(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ListViewItemPresenter_get_SelectionIndicatorBrush(py::wrapper::Microsoft::UI::Xaml::Controls::Primitives::ListViewItemPresenter* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.ListViewItemPresenter", L"SelectionIndicatorBrush"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.SelectionIndicatorBrush());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ListViewItemPresenter_put_SelectionIndicatorBrush(py::wrapper::Microsoft::UI::Xaml::Controls::Primitives::ListViewItemPresenter* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.ListViewItemPresenter", L"SelectionIndicatorBrush"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Microsoft::UI::Xaml::Media::Brush>(arg);

            self->obj.SelectionIndicatorBrush(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ListViewItemPresenter_get_CheckBoxPressedBorderBrush(py::wrapper::Microsoft::UI::Xaml::Controls::Primitives::ListViewItemPresenter* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.ListViewItemPresenter", L"CheckBoxPressedBorderBrush"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.CheckBoxPressedBorderBrush());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ListViewItemPresenter_put_CheckBoxPressedBorderBrush(py::wrapper::Microsoft::UI::Xaml::Controls::Primitives::ListViewItemPresenter* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.ListViewItemPresenter", L"CheckBoxPressedBorderBrush"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Microsoft::UI::Xaml::Media::Brush>(arg);

            self->obj.CheckBoxPressedBorderBrush(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ListViewItemPresenter_get_SelectedPressedBorderBrush(py::wrapper::Microsoft::UI::Xaml::Controls::Primitives::ListViewItemPresenter* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.ListViewItemPresenter", L"SelectedPressedBorderBrush"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.SelectedPressedBorderBrush());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ListViewItemPresenter_put_SelectedPressedBorderBrush(py::wrapper::Microsoft::UI::Xaml::Controls::Primitives::ListViewItemPresenter* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.ListViewItemPresenter", L"SelectedPressedBorderBrush"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Microsoft::UI::Xaml::Media::Brush>(arg);

            self->obj.SelectedPressedBorderBrush(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ListViewItemPresenter_get_SelectedPressedBackground(py::wrapper::Microsoft::UI::Xaml::Controls::Primitives::ListViewItemPresenter* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.ListViewItemPresenter", L"SelectedPressedBackground"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.SelectedPressedBackground());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ListViewItemPresenter_put_SelectedPressedBackground(py::wrapper::Microsoft::UI::Xaml::Controls::Primitives::ListViewItemPresenter* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.ListViewItemPresenter", L"SelectedPressedBackground"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Microsoft::UI::Xaml::Media::Brush>(arg);

            self->obj.SelectedPressedBackground(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ListViewItemPresenter_get_SelectedPointerOverBorderBrush(py::wrapper::Microsoft::UI::Xaml::Controls::Primitives::ListViewItemPresenter* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.ListViewItemPresenter", L"SelectedPointerOverBorderBrush"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.SelectedPointerOverBorderBrush());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ListViewItemPresenter_put_SelectedPointerOverBorderBrush(py::wrapper::Microsoft::UI::Xaml::Controls::Primitives::ListViewItemPresenter* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.ListViewItemPresenter", L"SelectedPointerOverBorderBrush"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Microsoft::UI::Xaml::Media::Brush>(arg);

            self->obj.SelectedPointerOverBorderBrush(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ListViewItemPresenter_get_SelectedPointerOverBackground(py::wrapper::Microsoft::UI::Xaml::Controls::Primitives::ListViewItemPresenter* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.ListViewItemPresenter", L"SelectedPointerOverBackground"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.SelectedPointerOverBackground());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ListViewItemPresenter_put_SelectedPointerOverBackground(py::wrapper::Microsoft::UI::Xaml::Controls::Primitives::ListViewItemPresenter* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.ListViewItemPresenter", L"SelectedPointerOverBackground"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Microsoft::UI::Xaml::Media::Brush>(arg);

            self->obj.SelectedPointerOverBackground(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ListViewItemPresenter_get_SelectedInnerBorderBrush(py::wrapper::Microsoft::UI::Xaml::Controls::Primitives::ListViewItemPresenter* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.ListViewItemPresenter", L"SelectedInnerBorderBrush"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.SelectedInnerBorderBrush());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ListViewItemPresenter_put_SelectedInnerBorderBrush(py::wrapper::Microsoft::UI::Xaml::Controls::Primitives::ListViewItemPresenter* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.ListViewItemPresenter", L"SelectedInnerBorderBrush"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Microsoft::UI::Xaml::Media::Brush>(arg);

            self->obj.SelectedInnerBorderBrush(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ListViewItemPresenter_get_SelectedForeground(py::wrapper::Microsoft::UI::Xaml::Controls::Primitives::ListViewItemPresenter* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.ListViewItemPresenter", L"SelectedForeground"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.SelectedForeground());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ListViewItemPresenter_put_SelectedForeground(py::wrapper::Microsoft::UI::Xaml::Controls::Primitives::ListViewItemPresenter* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.ListViewItemPresenter", L"SelectedForeground"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Microsoft::UI::Xaml::Media::Brush>(arg);

            self->obj.SelectedForeground(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ListViewItemPresenter_get_SelectionIndicatorVisualEnabled(py::wrapper::Microsoft::UI::Xaml::Controls::Primitives::ListViewItemPresenter* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.ListViewItemPresenter", L"SelectionIndicatorVisualEnabled"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.SelectionIndicatorVisualEnabled());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ListViewItemPresenter_put_SelectionIndicatorVisualEnabled(py::wrapper::Microsoft::UI::Xaml::Controls::Primitives::ListViewItemPresenter* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.ListViewItemPresenter", L"SelectionIndicatorVisualEnabled"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<bool>(arg);

            self->obj.SelectionIndicatorVisualEnabled(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ListViewItemPresenter_get_SelectedDisabledBackground(py::wrapper::Microsoft::UI::Xaml::Controls::Primitives::ListViewItemPresenter* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.ListViewItemPresenter", L"SelectedDisabledBackground"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.SelectedDisabledBackground());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ListViewItemPresenter_put_SelectedDisabledBackground(py::wrapper::Microsoft::UI::Xaml::Controls::Primitives::ListViewItemPresenter* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.ListViewItemPresenter", L"SelectedDisabledBackground"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Microsoft::UI::Xaml::Media::Brush>(arg);

            self->obj.SelectedDisabledBackground(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ListViewItemPresenter_get_SelectedBorderThickness(py::wrapper::Microsoft::UI::Xaml::Controls::Primitives::ListViewItemPresenter* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.ListViewItemPresenter", L"SelectedBorderThickness"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.SelectedBorderThickness());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ListViewItemPresenter_put_SelectedBorderThickness(py::wrapper::Microsoft::UI::Xaml::Controls::Primitives::ListViewItemPresenter* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.ListViewItemPresenter", L"SelectedBorderThickness"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Microsoft::UI::Xaml::Thickness>(arg);

            self->obj.SelectedBorderThickness(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ListViewItemPresenter_get_SelectedBorderBrush(py::wrapper::Microsoft::UI::Xaml::Controls::Primitives::ListViewItemPresenter* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.ListViewItemPresenter", L"SelectedBorderBrush"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.SelectedBorderBrush());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ListViewItemPresenter_put_SelectedBorderBrush(py::wrapper::Microsoft::UI::Xaml::Controls::Primitives::ListViewItemPresenter* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.ListViewItemPresenter", L"SelectedBorderBrush"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Microsoft::UI::Xaml::Media::Brush>(arg);

            self->obj.SelectedBorderBrush(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ListViewItemPresenter_get_SelectedBackground(py::wrapper::Microsoft::UI::Xaml::Controls::Primitives::ListViewItemPresenter* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.ListViewItemPresenter", L"SelectedBackground"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.SelectedBackground());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ListViewItemPresenter_put_SelectedBackground(py::wrapper::Microsoft::UI::Xaml::Controls::Primitives::ListViewItemPresenter* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.ListViewItemPresenter", L"SelectedBackground"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Microsoft::UI::Xaml::Media::Brush>(arg);

            self->obj.SelectedBackground(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ListViewItemPresenter_get_RevealBorderThickness(py::wrapper::Microsoft::UI::Xaml::Controls::Primitives::ListViewItemPresenter* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.ListViewItemPresenter", L"RevealBorderThickness"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.RevealBorderThickness());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ListViewItemPresenter_put_RevealBorderThickness(py::wrapper::Microsoft::UI::Xaml::Controls::Primitives::ListViewItemPresenter* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.ListViewItemPresenter", L"RevealBorderThickness"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Microsoft::UI::Xaml::Thickness>(arg);

            self->obj.RevealBorderThickness(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ListViewItemPresenter_get_RevealBorderBrush(py::wrapper::Microsoft::UI::Xaml::Controls::Primitives::ListViewItemPresenter* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.ListViewItemPresenter", L"RevealBorderBrush"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.RevealBorderBrush());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ListViewItemPresenter_put_RevealBorderBrush(py::wrapper::Microsoft::UI::Xaml::Controls::Primitives::ListViewItemPresenter* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.ListViewItemPresenter", L"RevealBorderBrush"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Microsoft::UI::Xaml::Media::Brush>(arg);

            self->obj.RevealBorderBrush(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ListViewItemPresenter_get_RevealBackgroundShowsAboveContent(py::wrapper::Microsoft::UI::Xaml::Controls::Primitives::ListViewItemPresenter* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.ListViewItemPresenter", L"RevealBackgroundShowsAboveContent"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.RevealBackgroundShowsAboveContent());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ListViewItemPresenter_put_RevealBackgroundShowsAboveContent(py::wrapper::Microsoft::UI::Xaml::Controls::Primitives::ListViewItemPresenter* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.ListViewItemPresenter", L"RevealBackgroundShowsAboveContent"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<bool>(arg);

            self->obj.RevealBackgroundShowsAboveContent(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ListViewItemPresenter_get_DragForeground(py::wrapper::Microsoft::UI::Xaml::Controls::Primitives::ListViewItemPresenter* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.ListViewItemPresenter", L"DragForeground"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.DragForeground());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ListViewItemPresenter_put_DragForeground(py::wrapper::Microsoft::UI::Xaml::Controls::Primitives::ListViewItemPresenter* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.ListViewItemPresenter", L"DragForeground"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Microsoft::UI::Xaml::Media::Brush>(arg);

            self->obj.DragForeground(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ListViewItemPresenter_get_ReorderHintOffset(py::wrapper::Microsoft::UI::Xaml::Controls::Primitives::ListViewItemPresenter* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.ListViewItemPresenter", L"ReorderHintOffset"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.ReorderHintOffset());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ListViewItemPresenter_put_ReorderHintOffset(py::wrapper::Microsoft::UI::Xaml::Controls::Primitives::ListViewItemPresenter* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.ListViewItemPresenter", L"ReorderHintOffset"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<double>(arg);

            self->obj.ReorderHintOffset(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ListViewItemPresenter_get_PressedBackground(py::wrapper::Microsoft::UI::Xaml::Controls::Primitives::ListViewItemPresenter* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.ListViewItemPresenter", L"PressedBackground"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.PressedBackground());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ListViewItemPresenter_put_PressedBackground(py::wrapper::Microsoft::UI::Xaml::Controls::Primitives::ListViewItemPresenter* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.ListViewItemPresenter", L"PressedBackground"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Microsoft::UI::Xaml::Media::Brush>(arg);

            self->obj.PressedBackground(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ListViewItemPresenter_get_PointerOverForeground(py::wrapper::Microsoft::UI::Xaml::Controls::Primitives::ListViewItemPresenter* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.ListViewItemPresenter", L"PointerOverForeground"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.PointerOverForeground());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ListViewItemPresenter_put_PointerOverForeground(py::wrapper::Microsoft::UI::Xaml::Controls::Primitives::ListViewItemPresenter* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.ListViewItemPresenter", L"PointerOverForeground"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Microsoft::UI::Xaml::Media::Brush>(arg);

            self->obj.PointerOverForeground(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ListViewItemPresenter_get_PointerOverBorderBrush(py::wrapper::Microsoft::UI::Xaml::Controls::Primitives::ListViewItemPresenter* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.ListViewItemPresenter", L"PointerOverBorderBrush"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.PointerOverBorderBrush());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ListViewItemPresenter_put_PointerOverBorderBrush(py::wrapper::Microsoft::UI::Xaml::Controls::Primitives::ListViewItemPresenter* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.ListViewItemPresenter", L"PointerOverBorderBrush"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Microsoft::UI::Xaml::Media::Brush>(arg);

            self->obj.PointerOverBorderBrush(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ListViewItemPresenter_get_PointerOverBackgroundMargin(py::wrapper::Microsoft::UI::Xaml::Controls::Primitives::ListViewItemPresenter* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.ListViewItemPresenter", L"PointerOverBackgroundMargin"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.PointerOverBackgroundMargin());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ListViewItemPresenter_put_PointerOverBackgroundMargin(py::wrapper::Microsoft::UI::Xaml::Controls::Primitives::ListViewItemPresenter* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.ListViewItemPresenter", L"PointerOverBackgroundMargin"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Microsoft::UI::Xaml::Thickness>(arg);

            self->obj.PointerOverBackgroundMargin(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ListViewItemPresenter_get_PointerOverBackground(py::wrapper::Microsoft::UI::Xaml::Controls::Primitives::ListViewItemPresenter* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.ListViewItemPresenter", L"PointerOverBackground"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.PointerOverBackground());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ListViewItemPresenter_put_PointerOverBackground(py::wrapper::Microsoft::UI::Xaml::Controls::Primitives::ListViewItemPresenter* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.ListViewItemPresenter", L"PointerOverBackground"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Microsoft::UI::Xaml::Media::Brush>(arg);

            self->obj.PointerOverBackground(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ListViewItemPresenter_get_CheckBoxBorderBrushProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.ListViewItemPresenter", L"CheckBoxBorderBrushProperty"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Microsoft::UI::Xaml::Controls::Primitives::ListViewItemPresenter::CheckBoxBorderBrushProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ListViewItemPresenter_get_CheckBoxBrushProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.ListViewItemPresenter", L"CheckBoxBrushProperty"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Microsoft::UI::Xaml::Controls::Primitives::ListViewItemPresenter::CheckBoxBrushProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ListViewItemPresenter_get_CheckBoxCornerRadiusProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.ListViewItemPresenter", L"CheckBoxCornerRadiusProperty"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Microsoft::UI::Xaml::Controls::Primitives::ListViewItemPresenter::CheckBoxCornerRadiusProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ListViewItemPresenter_get_CheckBoxDisabledBorderBrushProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.ListViewItemPresenter", L"CheckBoxDisabledBorderBrushProperty"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Microsoft::UI::Xaml::Controls::Primitives::ListViewItemPresenter::CheckBoxDisabledBorderBrushProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ListViewItemPresenter_get_CheckBoxDisabledBrushProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.ListViewItemPresenter", L"CheckBoxDisabledBrushProperty"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Microsoft::UI::Xaml::Controls::Primitives::ListViewItemPresenter::CheckBoxDisabledBrushProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ListViewItemPresenter_get_CheckBoxPointerOverBorderBrushProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.ListViewItemPresenter", L"CheckBoxPointerOverBorderBrushProperty"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Microsoft::UI::Xaml::Controls::Primitives::ListViewItemPresenter::CheckBoxPointerOverBorderBrushProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ListViewItemPresenter_get_CheckBoxPointerOverBrushProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.ListViewItemPresenter", L"CheckBoxPointerOverBrushProperty"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Microsoft::UI::Xaml::Controls::Primitives::ListViewItemPresenter::CheckBoxPointerOverBrushProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ListViewItemPresenter_get_CheckBoxPressedBorderBrushProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.ListViewItemPresenter", L"CheckBoxPressedBorderBrushProperty"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Microsoft::UI::Xaml::Controls::Primitives::ListViewItemPresenter::CheckBoxPressedBorderBrushProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ListViewItemPresenter_get_CheckBoxPressedBrushProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.ListViewItemPresenter", L"CheckBoxPressedBrushProperty"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Microsoft::UI::Xaml::Controls::Primitives::ListViewItemPresenter::CheckBoxPressedBrushProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ListViewItemPresenter_get_CheckBoxSelectedBrushProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.ListViewItemPresenter", L"CheckBoxSelectedBrushProperty"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Microsoft::UI::Xaml::Controls::Primitives::ListViewItemPresenter::CheckBoxSelectedBrushProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ListViewItemPresenter_get_CheckBoxSelectedDisabledBrushProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.ListViewItemPresenter", L"CheckBoxSelectedDisabledBrushProperty"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Microsoft::UI::Xaml::Controls::Primitives::ListViewItemPresenter::CheckBoxSelectedDisabledBrushProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ListViewItemPresenter_get_CheckBoxSelectedPointerOverBrushProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.ListViewItemPresenter", L"CheckBoxSelectedPointerOverBrushProperty"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Microsoft::UI::Xaml::Controls::Primitives::ListViewItemPresenter::CheckBoxSelectedPointerOverBrushProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ListViewItemPresenter_get_CheckBoxSelectedPressedBrushProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.ListViewItemPresenter", L"CheckBoxSelectedPressedBrushProperty"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Microsoft::UI::Xaml::Controls::Primitives::ListViewItemPresenter::CheckBoxSelectedPressedBrushProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ListViewItemPresenter_get_CheckBrushProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.ListViewItemPresenter", L"CheckBrushProperty"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Microsoft::UI::Xaml::Controls::Primitives::ListViewItemPresenter::CheckBrushProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ListViewItemPresenter_get_CheckDisabledBrushProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.ListViewItemPresenter", L"CheckDisabledBrushProperty"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Microsoft::UI::Xaml::Controls::Primitives::ListViewItemPresenter::CheckDisabledBrushProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ListViewItemPresenter_get_CheckHintBrushProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.ListViewItemPresenter", L"CheckHintBrushProperty"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Microsoft::UI::Xaml::Controls::Primitives::ListViewItemPresenter::CheckHintBrushProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ListViewItemPresenter_get_CheckModeProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.ListViewItemPresenter", L"CheckModeProperty"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Microsoft::UI::Xaml::Controls::Primitives::ListViewItemPresenter::CheckModeProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ListViewItemPresenter_get_CheckPressedBrushProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.ListViewItemPresenter", L"CheckPressedBrushProperty"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Microsoft::UI::Xaml::Controls::Primitives::ListViewItemPresenter::CheckPressedBrushProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ListViewItemPresenter_get_CheckSelectingBrushProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.ListViewItemPresenter", L"CheckSelectingBrushProperty"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Microsoft::UI::Xaml::Controls::Primitives::ListViewItemPresenter::CheckSelectingBrushProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ListViewItemPresenter_get_ContentMarginProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.ListViewItemPresenter", L"ContentMarginProperty"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Microsoft::UI::Xaml::Controls::Primitives::ListViewItemPresenter::ContentMarginProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ListViewItemPresenter_get_DisabledOpacityProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.ListViewItemPresenter", L"DisabledOpacityProperty"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Microsoft::UI::Xaml::Controls::Primitives::ListViewItemPresenter::DisabledOpacityProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ListViewItemPresenter_get_DragBackgroundProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.ListViewItemPresenter", L"DragBackgroundProperty"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Microsoft::UI::Xaml::Controls::Primitives::ListViewItemPresenter::DragBackgroundProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ListViewItemPresenter_get_DragForegroundProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.ListViewItemPresenter", L"DragForegroundProperty"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Microsoft::UI::Xaml::Controls::Primitives::ListViewItemPresenter::DragForegroundProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ListViewItemPresenter_get_DragOpacityProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.ListViewItemPresenter", L"DragOpacityProperty"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Microsoft::UI::Xaml::Controls::Primitives::ListViewItemPresenter::DragOpacityProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ListViewItemPresenter_get_FocusBorderBrushProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.ListViewItemPresenter", L"FocusBorderBrushProperty"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Microsoft::UI::Xaml::Controls::Primitives::ListViewItemPresenter::FocusBorderBrushProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ListViewItemPresenter_get_FocusSecondaryBorderBrushProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.ListViewItemPresenter", L"FocusSecondaryBorderBrushProperty"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Microsoft::UI::Xaml::Controls::Primitives::ListViewItemPresenter::FocusSecondaryBorderBrushProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ListViewItemPresenter_get_ListViewItemPresenterHorizontalContentAlignmentProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.ListViewItemPresenter", L"ListViewItemPresenterHorizontalContentAlignmentProperty"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Microsoft::UI::Xaml::Controls::Primitives::ListViewItemPresenter::ListViewItemPresenterHorizontalContentAlignmentProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ListViewItemPresenter_get_ListViewItemPresenterPaddingProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.ListViewItemPresenter", L"ListViewItemPresenterPaddingProperty"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Microsoft::UI::Xaml::Controls::Primitives::ListViewItemPresenter::ListViewItemPresenterPaddingProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ListViewItemPresenter_get_ListViewItemPresenterVerticalContentAlignmentProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.ListViewItemPresenter", L"ListViewItemPresenterVerticalContentAlignmentProperty"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Microsoft::UI::Xaml::Controls::Primitives::ListViewItemPresenter::ListViewItemPresenterVerticalContentAlignmentProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ListViewItemPresenter_get_PlaceholderBackgroundProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.ListViewItemPresenter", L"PlaceholderBackgroundProperty"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Microsoft::UI::Xaml::Controls::Primitives::ListViewItemPresenter::PlaceholderBackgroundProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ListViewItemPresenter_get_PointerOverBackgroundMarginProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.ListViewItemPresenter", L"PointerOverBackgroundMarginProperty"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Microsoft::UI::Xaml::Controls::Primitives::ListViewItemPresenter::PointerOverBackgroundMarginProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ListViewItemPresenter_get_PointerOverBackgroundProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.ListViewItemPresenter", L"PointerOverBackgroundProperty"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Microsoft::UI::Xaml::Controls::Primitives::ListViewItemPresenter::PointerOverBackgroundProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ListViewItemPresenter_get_PointerOverBorderBrushProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.ListViewItemPresenter", L"PointerOverBorderBrushProperty"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Microsoft::UI::Xaml::Controls::Primitives::ListViewItemPresenter::PointerOverBorderBrushProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ListViewItemPresenter_get_PointerOverForegroundProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.ListViewItemPresenter", L"PointerOverForegroundProperty"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Microsoft::UI::Xaml::Controls::Primitives::ListViewItemPresenter::PointerOverForegroundProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ListViewItemPresenter_get_PressedBackgroundProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.ListViewItemPresenter", L"PressedBackgroundProperty"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Microsoft::UI::Xaml::Controls::Primitives::ListViewItemPresenter::PressedBackgroundProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ListViewItemPresenter_get_ReorderHintOffsetProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.ListViewItemPresenter", L"ReorderHintOffsetProperty"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Microsoft::UI::Xaml::Controls::Primitives::ListViewItemPresenter::ReorderHintOffsetProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ListViewItemPresenter_get_RevealBackgroundProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.ListViewItemPresenter", L"RevealBackgroundProperty"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Microsoft::UI::Xaml::Controls::Primitives::ListViewItemPresenter::RevealBackgroundProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ListViewItemPresenter_get_RevealBackgroundShowsAboveContentProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.ListViewItemPresenter", L"RevealBackgroundShowsAboveContentProperty"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Microsoft::UI::Xaml::Controls::Primitives::ListViewItemPresenter::RevealBackgroundShowsAboveContentProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ListViewItemPresenter_get_RevealBorderBrushProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.ListViewItemPresenter", L"RevealBorderBrushProperty"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Microsoft::UI::Xaml::Controls::Primitives::ListViewItemPresenter::RevealBorderBrushProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ListViewItemPresenter_get_RevealBorderThicknessProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.ListViewItemPresenter", L"RevealBorderThicknessProperty"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Microsoft::UI::Xaml::Controls::Primitives::ListViewItemPresenter::RevealBorderThicknessProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ListViewItemPresenter_get_SelectedBackgroundProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.ListViewItemPresenter", L"SelectedBackgroundProperty"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Microsoft::UI::Xaml::Controls::Primitives::ListViewItemPresenter::SelectedBackgroundProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ListViewItemPresenter_get_SelectedBorderBrushProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.ListViewItemPresenter", L"SelectedBorderBrushProperty"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Microsoft::UI::Xaml::Controls::Primitives::ListViewItemPresenter::SelectedBorderBrushProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ListViewItemPresenter_get_SelectedBorderThicknessProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.ListViewItemPresenter", L"SelectedBorderThicknessProperty"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Microsoft::UI::Xaml::Controls::Primitives::ListViewItemPresenter::SelectedBorderThicknessProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ListViewItemPresenter_get_SelectedDisabledBackgroundProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.ListViewItemPresenter", L"SelectedDisabledBackgroundProperty"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Microsoft::UI::Xaml::Controls::Primitives::ListViewItemPresenter::SelectedDisabledBackgroundProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ListViewItemPresenter_get_SelectedDisabledBorderBrushProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.ListViewItemPresenter", L"SelectedDisabledBorderBrushProperty"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Microsoft::UI::Xaml::Controls::Primitives::ListViewItemPresenter::SelectedDisabledBorderBrushProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ListViewItemPresenter_get_SelectedForegroundProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.ListViewItemPresenter", L"SelectedForegroundProperty"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Microsoft::UI::Xaml::Controls::Primitives::ListViewItemPresenter::SelectedForegroundProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ListViewItemPresenter_get_SelectedInnerBorderBrushProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.ListViewItemPresenter", L"SelectedInnerBorderBrushProperty"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Microsoft::UI::Xaml::Controls::Primitives::ListViewItemPresenter::SelectedInnerBorderBrushProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ListViewItemPresenter_get_SelectedPointerOverBackgroundProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.ListViewItemPresenter", L"SelectedPointerOverBackgroundProperty"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Microsoft::UI::Xaml::Controls::Primitives::ListViewItemPresenter::SelectedPointerOverBackgroundProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ListViewItemPresenter_get_SelectedPointerOverBorderBrushProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.ListViewItemPresenter", L"SelectedPointerOverBorderBrushProperty"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Microsoft::UI::Xaml::Controls::Primitives::ListViewItemPresenter::SelectedPointerOverBorderBrushProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ListViewItemPresenter_get_SelectedPressedBackgroundProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.ListViewItemPresenter", L"SelectedPressedBackgroundProperty"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Microsoft::UI::Xaml::Controls::Primitives::ListViewItemPresenter::SelectedPressedBackgroundProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ListViewItemPresenter_get_SelectedPressedBorderBrushProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.ListViewItemPresenter", L"SelectedPressedBorderBrushProperty"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Microsoft::UI::Xaml::Controls::Primitives::ListViewItemPresenter::SelectedPressedBorderBrushProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ListViewItemPresenter_get_SelectionCheckMarkVisualEnabledProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.ListViewItemPresenter", L"SelectionCheckMarkVisualEnabledProperty"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Microsoft::UI::Xaml::Controls::Primitives::ListViewItemPresenter::SelectionCheckMarkVisualEnabledProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ListViewItemPresenter_get_SelectionIndicatorBrushProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.ListViewItemPresenter", L"SelectionIndicatorBrushProperty"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Microsoft::UI::Xaml::Controls::Primitives::ListViewItemPresenter::SelectionIndicatorBrushProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ListViewItemPresenter_get_SelectionIndicatorCornerRadiusProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.ListViewItemPresenter", L"SelectionIndicatorCornerRadiusProperty"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Microsoft::UI::Xaml::Controls::Primitives::ListViewItemPresenter::SelectionIndicatorCornerRadiusProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ListViewItemPresenter_get_SelectionIndicatorDisabledBrushProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.ListViewItemPresenter", L"SelectionIndicatorDisabledBrushProperty"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Microsoft::UI::Xaml::Controls::Primitives::ListViewItemPresenter::SelectionIndicatorDisabledBrushProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ListViewItemPresenter_get_SelectionIndicatorModeProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.ListViewItemPresenter", L"SelectionIndicatorModeProperty"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Microsoft::UI::Xaml::Controls::Primitives::ListViewItemPresenter::SelectionIndicatorModeProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ListViewItemPresenter_get_SelectionIndicatorPointerOverBrushProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.ListViewItemPresenter", L"SelectionIndicatorPointerOverBrushProperty"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Microsoft::UI::Xaml::Controls::Primitives::ListViewItemPresenter::SelectionIndicatorPointerOverBrushProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ListViewItemPresenter_get_SelectionIndicatorPressedBrushProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.ListViewItemPresenter", L"SelectionIndicatorPressedBrushProperty"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Microsoft::UI::Xaml::Controls::Primitives::ListViewItemPresenter::SelectionIndicatorPressedBrushProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ListViewItemPresenter_get_SelectionIndicatorVisualEnabledProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.ListViewItemPresenter", L"SelectionIndicatorVisualEnabledProperty"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Microsoft::UI::Xaml::Controls::Primitives::ListViewItemPresenter::SelectionIndicatorVisualEnabledProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_ListViewItemPresenter(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Microsoft::UI::Xaml::Controls::Primitives::ListViewItemPresenter>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_ListViewItemPresenter(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Microsoft::UI::Xaml::Controls::Primitives::ListViewItemPresenter>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_ListViewItemPresenter[] = {
        { "_assign_array_", _assign_array_ListViewItemPresenter, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_ListViewItemPresenter), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_ListViewItemPresenter[] = {
        { "list_view_item_presenter_vertical_content_alignment", reinterpret_cast<getter>(ListViewItemPresenter_get_ListViewItemPresenterVerticalContentAlignment), reinterpret_cast<setter>(ListViewItemPresenter_put_ListViewItemPresenterVerticalContentAlignment), nullptr, nullptr },
        { "list_view_item_presenter_padding", reinterpret_cast<getter>(ListViewItemPresenter_get_ListViewItemPresenterPadding), reinterpret_cast<setter>(ListViewItemPresenter_put_ListViewItemPresenterPadding), nullptr, nullptr },
        { "list_view_item_presenter_horizontal_content_alignment", reinterpret_cast<getter>(ListViewItemPresenter_get_ListViewItemPresenterHorizontalContentAlignment), reinterpret_cast<setter>(ListViewItemPresenter_put_ListViewItemPresenterHorizontalContentAlignment), nullptr, nullptr },
        { "focus_secondary_border_brush", reinterpret_cast<getter>(ListViewItemPresenter_get_FocusSecondaryBorderBrush), reinterpret_cast<setter>(ListViewItemPresenter_put_FocusSecondaryBorderBrush), nullptr, nullptr },
        { "focus_border_brush", reinterpret_cast<getter>(ListViewItemPresenter_get_FocusBorderBrush), reinterpret_cast<setter>(ListViewItemPresenter_put_FocusBorderBrush), nullptr, nullptr },
        { "drag_opacity", reinterpret_cast<getter>(ListViewItemPresenter_get_DragOpacity), reinterpret_cast<setter>(ListViewItemPresenter_put_DragOpacity), nullptr, nullptr },
        { "reveal_background", reinterpret_cast<getter>(ListViewItemPresenter_get_RevealBackground), reinterpret_cast<setter>(ListViewItemPresenter_put_RevealBackground), nullptr, nullptr },
        { "drag_background", reinterpret_cast<getter>(ListViewItemPresenter_get_DragBackground), reinterpret_cast<setter>(ListViewItemPresenter_put_DragBackground), nullptr, nullptr },
        { "disabled_opacity", reinterpret_cast<getter>(ListViewItemPresenter_get_DisabledOpacity), reinterpret_cast<setter>(ListViewItemPresenter_put_DisabledOpacity), nullptr, nullptr },
        { "content_margin", reinterpret_cast<getter>(ListViewItemPresenter_get_ContentMargin), reinterpret_cast<setter>(ListViewItemPresenter_put_ContentMargin), nullptr, nullptr },
        { "check_selecting_brush", reinterpret_cast<getter>(ListViewItemPresenter_get_CheckSelectingBrush), reinterpret_cast<setter>(ListViewItemPresenter_put_CheckSelectingBrush), nullptr, nullptr },
        { "check_pressed_brush", reinterpret_cast<getter>(ListViewItemPresenter_get_CheckPressedBrush), reinterpret_cast<setter>(ListViewItemPresenter_put_CheckPressedBrush), nullptr, nullptr },
        { "check_mode", reinterpret_cast<getter>(ListViewItemPresenter_get_CheckMode), reinterpret_cast<setter>(ListViewItemPresenter_put_CheckMode), nullptr, nullptr },
        { "check_hint_brush", reinterpret_cast<getter>(ListViewItemPresenter_get_CheckHintBrush), reinterpret_cast<setter>(ListViewItemPresenter_put_CheckHintBrush), nullptr, nullptr },
        { "check_box_border_brush", reinterpret_cast<getter>(ListViewItemPresenter_get_CheckBoxBorderBrush), reinterpret_cast<setter>(ListViewItemPresenter_put_CheckBoxBorderBrush), nullptr, nullptr },
        { "check_brush", reinterpret_cast<getter>(ListViewItemPresenter_get_CheckBrush), reinterpret_cast<setter>(ListViewItemPresenter_put_CheckBrush), nullptr, nullptr },
        { "check_box_selected_pressed_brush", reinterpret_cast<getter>(ListViewItemPresenter_get_CheckBoxSelectedPressedBrush), reinterpret_cast<setter>(ListViewItemPresenter_put_CheckBoxSelectedPressedBrush), nullptr, nullptr },
        { "check_box_selected_pointer_over_brush", reinterpret_cast<getter>(ListViewItemPresenter_get_CheckBoxSelectedPointerOverBrush), reinterpret_cast<setter>(ListViewItemPresenter_put_CheckBoxSelectedPointerOverBrush), nullptr, nullptr },
        { "check_box_selected_disabled_brush", reinterpret_cast<getter>(ListViewItemPresenter_get_CheckBoxSelectedDisabledBrush), reinterpret_cast<setter>(ListViewItemPresenter_put_CheckBoxSelectedDisabledBrush), nullptr, nullptr },
        { "check_box_selected_brush", reinterpret_cast<getter>(ListViewItemPresenter_get_CheckBoxSelectedBrush), reinterpret_cast<setter>(ListViewItemPresenter_put_CheckBoxSelectedBrush), nullptr, nullptr },
        { "check_box_pressed_brush", reinterpret_cast<getter>(ListViewItemPresenter_get_CheckBoxPressedBrush), reinterpret_cast<setter>(ListViewItemPresenter_put_CheckBoxPressedBrush), nullptr, nullptr },
        { "selection_check_mark_visual_enabled", reinterpret_cast<getter>(ListViewItemPresenter_get_SelectionCheckMarkVisualEnabled), reinterpret_cast<setter>(ListViewItemPresenter_put_SelectionCheckMarkVisualEnabled), nullptr, nullptr },
        { "check_box_pointer_over_brush", reinterpret_cast<getter>(ListViewItemPresenter_get_CheckBoxPointerOverBrush), reinterpret_cast<setter>(ListViewItemPresenter_put_CheckBoxPointerOverBrush), nullptr, nullptr },
        { "check_box_pointer_over_border_brush", reinterpret_cast<getter>(ListViewItemPresenter_get_CheckBoxPointerOverBorderBrush), reinterpret_cast<setter>(ListViewItemPresenter_put_CheckBoxPointerOverBorderBrush), nullptr, nullptr },
        { "check_box_disabled_brush", reinterpret_cast<getter>(ListViewItemPresenter_get_CheckBoxDisabledBrush), reinterpret_cast<setter>(ListViewItemPresenter_put_CheckBoxDisabledBrush), nullptr, nullptr },
        { "check_box_disabled_border_brush", reinterpret_cast<getter>(ListViewItemPresenter_get_CheckBoxDisabledBorderBrush), reinterpret_cast<setter>(ListViewItemPresenter_put_CheckBoxDisabledBorderBrush), nullptr, nullptr },
        { "check_box_corner_radius", reinterpret_cast<getter>(ListViewItemPresenter_get_CheckBoxCornerRadius), reinterpret_cast<setter>(ListViewItemPresenter_put_CheckBoxCornerRadius), nullptr, nullptr },
        { "check_box_brush", reinterpret_cast<getter>(ListViewItemPresenter_get_CheckBoxBrush), reinterpret_cast<setter>(ListViewItemPresenter_put_CheckBoxBrush), nullptr, nullptr },
        { "check_disabled_brush", reinterpret_cast<getter>(ListViewItemPresenter_get_CheckDisabledBrush), reinterpret_cast<setter>(ListViewItemPresenter_put_CheckDisabledBrush), nullptr, nullptr },
        { "placeholder_background", reinterpret_cast<getter>(ListViewItemPresenter_get_PlaceholderBackground), reinterpret_cast<setter>(ListViewItemPresenter_put_PlaceholderBackground), nullptr, nullptr },
        { "selected_disabled_border_brush", reinterpret_cast<getter>(ListViewItemPresenter_get_SelectedDisabledBorderBrush), reinterpret_cast<setter>(ListViewItemPresenter_put_SelectedDisabledBorderBrush), nullptr, nullptr },
        { "selection_indicator_pressed_brush", reinterpret_cast<getter>(ListViewItemPresenter_get_SelectionIndicatorPressedBrush), reinterpret_cast<setter>(ListViewItemPresenter_put_SelectionIndicatorPressedBrush), nullptr, nullptr },
        { "selection_indicator_pointer_over_brush", reinterpret_cast<getter>(ListViewItemPresenter_get_SelectionIndicatorPointerOverBrush), reinterpret_cast<setter>(ListViewItemPresenter_put_SelectionIndicatorPointerOverBrush), nullptr, nullptr },
        { "selection_indicator_mode", reinterpret_cast<getter>(ListViewItemPresenter_get_SelectionIndicatorMode), reinterpret_cast<setter>(ListViewItemPresenter_put_SelectionIndicatorMode), nullptr, nullptr },
        { "selection_indicator_disabled_brush", reinterpret_cast<getter>(ListViewItemPresenter_get_SelectionIndicatorDisabledBrush), reinterpret_cast<setter>(ListViewItemPresenter_put_SelectionIndicatorDisabledBrush), nullptr, nullptr },
        { "selection_indicator_corner_radius", reinterpret_cast<getter>(ListViewItemPresenter_get_SelectionIndicatorCornerRadius), reinterpret_cast<setter>(ListViewItemPresenter_put_SelectionIndicatorCornerRadius), nullptr, nullptr },
        { "selection_indicator_brush", reinterpret_cast<getter>(ListViewItemPresenter_get_SelectionIndicatorBrush), reinterpret_cast<setter>(ListViewItemPresenter_put_SelectionIndicatorBrush), nullptr, nullptr },
        { "check_box_pressed_border_brush", reinterpret_cast<getter>(ListViewItemPresenter_get_CheckBoxPressedBorderBrush), reinterpret_cast<setter>(ListViewItemPresenter_put_CheckBoxPressedBorderBrush), nullptr, nullptr },
        { "selected_pressed_border_brush", reinterpret_cast<getter>(ListViewItemPresenter_get_SelectedPressedBorderBrush), reinterpret_cast<setter>(ListViewItemPresenter_put_SelectedPressedBorderBrush), nullptr, nullptr },
        { "selected_pressed_background", reinterpret_cast<getter>(ListViewItemPresenter_get_SelectedPressedBackground), reinterpret_cast<setter>(ListViewItemPresenter_put_SelectedPressedBackground), nullptr, nullptr },
        { "selected_pointer_over_border_brush", reinterpret_cast<getter>(ListViewItemPresenter_get_SelectedPointerOverBorderBrush), reinterpret_cast<setter>(ListViewItemPresenter_put_SelectedPointerOverBorderBrush), nullptr, nullptr },
        { "selected_pointer_over_background", reinterpret_cast<getter>(ListViewItemPresenter_get_SelectedPointerOverBackground), reinterpret_cast<setter>(ListViewItemPresenter_put_SelectedPointerOverBackground), nullptr, nullptr },
        { "selected_inner_border_brush", reinterpret_cast<getter>(ListViewItemPresenter_get_SelectedInnerBorderBrush), reinterpret_cast<setter>(ListViewItemPresenter_put_SelectedInnerBorderBrush), nullptr, nullptr },
        { "selected_foreground", reinterpret_cast<getter>(ListViewItemPresenter_get_SelectedForeground), reinterpret_cast<setter>(ListViewItemPresenter_put_SelectedForeground), nullptr, nullptr },
        { "selection_indicator_visual_enabled", reinterpret_cast<getter>(ListViewItemPresenter_get_SelectionIndicatorVisualEnabled), reinterpret_cast<setter>(ListViewItemPresenter_put_SelectionIndicatorVisualEnabled), nullptr, nullptr },
        { "selected_disabled_background", reinterpret_cast<getter>(ListViewItemPresenter_get_SelectedDisabledBackground), reinterpret_cast<setter>(ListViewItemPresenter_put_SelectedDisabledBackground), nullptr, nullptr },
        { "selected_border_thickness", reinterpret_cast<getter>(ListViewItemPresenter_get_SelectedBorderThickness), reinterpret_cast<setter>(ListViewItemPresenter_put_SelectedBorderThickness), nullptr, nullptr },
        { "selected_border_brush", reinterpret_cast<getter>(ListViewItemPresenter_get_SelectedBorderBrush), reinterpret_cast<setter>(ListViewItemPresenter_put_SelectedBorderBrush), nullptr, nullptr },
        { "selected_background", reinterpret_cast<getter>(ListViewItemPresenter_get_SelectedBackground), reinterpret_cast<setter>(ListViewItemPresenter_put_SelectedBackground), nullptr, nullptr },
        { "reveal_border_thickness", reinterpret_cast<getter>(ListViewItemPresenter_get_RevealBorderThickness), reinterpret_cast<setter>(ListViewItemPresenter_put_RevealBorderThickness), nullptr, nullptr },
        { "reveal_border_brush", reinterpret_cast<getter>(ListViewItemPresenter_get_RevealBorderBrush), reinterpret_cast<setter>(ListViewItemPresenter_put_RevealBorderBrush), nullptr, nullptr },
        { "reveal_background_shows_above_content", reinterpret_cast<getter>(ListViewItemPresenter_get_RevealBackgroundShowsAboveContent), reinterpret_cast<setter>(ListViewItemPresenter_put_RevealBackgroundShowsAboveContent), nullptr, nullptr },
        { "drag_foreground", reinterpret_cast<getter>(ListViewItemPresenter_get_DragForeground), reinterpret_cast<setter>(ListViewItemPresenter_put_DragForeground), nullptr, nullptr },
        { "reorder_hint_offset", reinterpret_cast<getter>(ListViewItemPresenter_get_ReorderHintOffset), reinterpret_cast<setter>(ListViewItemPresenter_put_ReorderHintOffset), nullptr, nullptr },
        { "pressed_background", reinterpret_cast<getter>(ListViewItemPresenter_get_PressedBackground), reinterpret_cast<setter>(ListViewItemPresenter_put_PressedBackground), nullptr, nullptr },
        { "pointer_over_foreground", reinterpret_cast<getter>(ListViewItemPresenter_get_PointerOverForeground), reinterpret_cast<setter>(ListViewItemPresenter_put_PointerOverForeground), nullptr, nullptr },
        { "pointer_over_border_brush", reinterpret_cast<getter>(ListViewItemPresenter_get_PointerOverBorderBrush), reinterpret_cast<setter>(ListViewItemPresenter_put_PointerOverBorderBrush), nullptr, nullptr },
        { "pointer_over_background_margin", reinterpret_cast<getter>(ListViewItemPresenter_get_PointerOverBackgroundMargin), reinterpret_cast<setter>(ListViewItemPresenter_put_PointerOverBackgroundMargin), nullptr, nullptr },
        { "pointer_over_background", reinterpret_cast<getter>(ListViewItemPresenter_get_PointerOverBackground), reinterpret_cast<setter>(ListViewItemPresenter_put_PointerOverBackground), nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_ListViewItemPresenter[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_ListViewItemPresenter) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_ListViewItemPresenter) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_ListViewItemPresenter) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_ListViewItemPresenter) },
        { },
    };

    static PyType_Spec type_spec_ListViewItemPresenter =
    {
        "winrt._winrt_microsoft_ui_xaml_controls_primitives.ListViewItemPresenter",
        sizeof(py::wrapper::Microsoft::UI::Xaml::Controls::Primitives::ListViewItemPresenter),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_ListViewItemPresenter
    };

    static PyGetSetDef getset_ListViewItemPresenter_Static[] = {
        { "check_box_border_brush_property", reinterpret_cast<getter>(ListViewItemPresenter_get_CheckBoxBorderBrushProperty), nullptr, nullptr, nullptr },
        { "check_box_brush_property", reinterpret_cast<getter>(ListViewItemPresenter_get_CheckBoxBrushProperty), nullptr, nullptr, nullptr },
        { "check_box_corner_radius_property", reinterpret_cast<getter>(ListViewItemPresenter_get_CheckBoxCornerRadiusProperty), nullptr, nullptr, nullptr },
        { "check_box_disabled_border_brush_property", reinterpret_cast<getter>(ListViewItemPresenter_get_CheckBoxDisabledBorderBrushProperty), nullptr, nullptr, nullptr },
        { "check_box_disabled_brush_property", reinterpret_cast<getter>(ListViewItemPresenter_get_CheckBoxDisabledBrushProperty), nullptr, nullptr, nullptr },
        { "check_box_pointer_over_border_brush_property", reinterpret_cast<getter>(ListViewItemPresenter_get_CheckBoxPointerOverBorderBrushProperty), nullptr, nullptr, nullptr },
        { "check_box_pointer_over_brush_property", reinterpret_cast<getter>(ListViewItemPresenter_get_CheckBoxPointerOverBrushProperty), nullptr, nullptr, nullptr },
        { "check_box_pressed_border_brush_property", reinterpret_cast<getter>(ListViewItemPresenter_get_CheckBoxPressedBorderBrushProperty), nullptr, nullptr, nullptr },
        { "check_box_pressed_brush_property", reinterpret_cast<getter>(ListViewItemPresenter_get_CheckBoxPressedBrushProperty), nullptr, nullptr, nullptr },
        { "check_box_selected_brush_property", reinterpret_cast<getter>(ListViewItemPresenter_get_CheckBoxSelectedBrushProperty), nullptr, nullptr, nullptr },
        { "check_box_selected_disabled_brush_property", reinterpret_cast<getter>(ListViewItemPresenter_get_CheckBoxSelectedDisabledBrushProperty), nullptr, nullptr, nullptr },
        { "check_box_selected_pointer_over_brush_property", reinterpret_cast<getter>(ListViewItemPresenter_get_CheckBoxSelectedPointerOverBrushProperty), nullptr, nullptr, nullptr },
        { "check_box_selected_pressed_brush_property", reinterpret_cast<getter>(ListViewItemPresenter_get_CheckBoxSelectedPressedBrushProperty), nullptr, nullptr, nullptr },
        { "check_brush_property", reinterpret_cast<getter>(ListViewItemPresenter_get_CheckBrushProperty), nullptr, nullptr, nullptr },
        { "check_disabled_brush_property", reinterpret_cast<getter>(ListViewItemPresenter_get_CheckDisabledBrushProperty), nullptr, nullptr, nullptr },
        { "check_hint_brush_property", reinterpret_cast<getter>(ListViewItemPresenter_get_CheckHintBrushProperty), nullptr, nullptr, nullptr },
        { "check_mode_property", reinterpret_cast<getter>(ListViewItemPresenter_get_CheckModeProperty), nullptr, nullptr, nullptr },
        { "check_pressed_brush_property", reinterpret_cast<getter>(ListViewItemPresenter_get_CheckPressedBrushProperty), nullptr, nullptr, nullptr },
        { "check_selecting_brush_property", reinterpret_cast<getter>(ListViewItemPresenter_get_CheckSelectingBrushProperty), nullptr, nullptr, nullptr },
        { "content_margin_property", reinterpret_cast<getter>(ListViewItemPresenter_get_ContentMarginProperty), nullptr, nullptr, nullptr },
        { "disabled_opacity_property", reinterpret_cast<getter>(ListViewItemPresenter_get_DisabledOpacityProperty), nullptr, nullptr, nullptr },
        { "drag_background_property", reinterpret_cast<getter>(ListViewItemPresenter_get_DragBackgroundProperty), nullptr, nullptr, nullptr },
        { "drag_foreground_property", reinterpret_cast<getter>(ListViewItemPresenter_get_DragForegroundProperty), nullptr, nullptr, nullptr },
        { "drag_opacity_property", reinterpret_cast<getter>(ListViewItemPresenter_get_DragOpacityProperty), nullptr, nullptr, nullptr },
        { "focus_border_brush_property", reinterpret_cast<getter>(ListViewItemPresenter_get_FocusBorderBrushProperty), nullptr, nullptr, nullptr },
        { "focus_secondary_border_brush_property", reinterpret_cast<getter>(ListViewItemPresenter_get_FocusSecondaryBorderBrushProperty), nullptr, nullptr, nullptr },
        { "list_view_item_presenter_horizontal_content_alignment_property", reinterpret_cast<getter>(ListViewItemPresenter_get_ListViewItemPresenterHorizontalContentAlignmentProperty), nullptr, nullptr, nullptr },
        { "list_view_item_presenter_padding_property", reinterpret_cast<getter>(ListViewItemPresenter_get_ListViewItemPresenterPaddingProperty), nullptr, nullptr, nullptr },
        { "list_view_item_presenter_vertical_content_alignment_property", reinterpret_cast<getter>(ListViewItemPresenter_get_ListViewItemPresenterVerticalContentAlignmentProperty), nullptr, nullptr, nullptr },
        { "placeholder_background_property", reinterpret_cast<getter>(ListViewItemPresenter_get_PlaceholderBackgroundProperty), nullptr, nullptr, nullptr },
        { "pointer_over_background_margin_property", reinterpret_cast<getter>(ListViewItemPresenter_get_PointerOverBackgroundMarginProperty), nullptr, nullptr, nullptr },
        { "pointer_over_background_property", reinterpret_cast<getter>(ListViewItemPresenter_get_PointerOverBackgroundProperty), nullptr, nullptr, nullptr },
        { "pointer_over_border_brush_property", reinterpret_cast<getter>(ListViewItemPresenter_get_PointerOverBorderBrushProperty), nullptr, nullptr, nullptr },
        { "pointer_over_foreground_property", reinterpret_cast<getter>(ListViewItemPresenter_get_PointerOverForegroundProperty), nullptr, nullptr, nullptr },
        { "pressed_background_property", reinterpret_cast<getter>(ListViewItemPresenter_get_PressedBackgroundProperty), nullptr, nullptr, nullptr },
        { "reorder_hint_offset_property", reinterpret_cast<getter>(ListViewItemPresenter_get_ReorderHintOffsetProperty), nullptr, nullptr, nullptr },
        { "reveal_background_property", reinterpret_cast<getter>(ListViewItemPresenter_get_RevealBackgroundProperty), nullptr, nullptr, nullptr },
        { "reveal_background_shows_above_content_property", reinterpret_cast<getter>(ListViewItemPresenter_get_RevealBackgroundShowsAboveContentProperty), nullptr, nullptr, nullptr },
        { "reveal_border_brush_property", reinterpret_cast<getter>(ListViewItemPresenter_get_RevealBorderBrushProperty), nullptr, nullptr, nullptr },
        { "reveal_border_thickness_property", reinterpret_cast<getter>(ListViewItemPresenter_get_RevealBorderThicknessProperty), nullptr, nullptr, nullptr },
        { "selected_background_property", reinterpret_cast<getter>(ListViewItemPresenter_get_SelectedBackgroundProperty), nullptr, nullptr, nullptr },
        { "selected_border_brush_property", reinterpret_cast<getter>(ListViewItemPresenter_get_SelectedBorderBrushProperty), nullptr, nullptr, nullptr },
        { "selected_border_thickness_property", reinterpret_cast<getter>(ListViewItemPresenter_get_SelectedBorderThicknessProperty), nullptr, nullptr, nullptr },
        { "selected_disabled_background_property", reinterpret_cast<getter>(ListViewItemPresenter_get_SelectedDisabledBackgroundProperty), nullptr, nullptr, nullptr },
        { "selected_disabled_border_brush_property", reinterpret_cast<getter>(ListViewItemPresenter_get_SelectedDisabledBorderBrushProperty), nullptr, nullptr, nullptr },
        { "selected_foreground_property", reinterpret_cast<getter>(ListViewItemPresenter_get_SelectedForegroundProperty), nullptr, nullptr, nullptr },
        { "selected_inner_border_brush_property", reinterpret_cast<getter>(ListViewItemPresenter_get_SelectedInnerBorderBrushProperty), nullptr, nullptr, nullptr },
        { "selected_pointer_over_background_property", reinterpret_cast<getter>(ListViewItemPresenter_get_SelectedPointerOverBackgroundProperty), nullptr, nullptr, nullptr },
        { "selected_pointer_over_border_brush_property", reinterpret_cast<getter>(ListViewItemPresenter_get_SelectedPointerOverBorderBrushProperty), nullptr, nullptr, nullptr },
        { "selected_pressed_background_property", reinterpret_cast<getter>(ListViewItemPresenter_get_SelectedPressedBackgroundProperty), nullptr, nullptr, nullptr },
        { "selected_pressed_border_brush_property", reinterpret_cast<getter>(ListViewItemPresenter_get_SelectedPressedBorderBrushProperty), nullptr, nullptr, nullptr },
        { "selection_check_mark_visual_enabled_property", reinterpret_cast<getter>(ListViewItemPresenter_get_SelectionCheckMarkVisualEnabledProperty), nullptr, nullptr, nullptr },
        { "selection_indicator_brush_property", reinterpret_cast<getter>(ListViewItemPresenter_get_SelectionIndicatorBrushProperty), nullptr, nullptr, nullptr },
        { "selection_indicator_corner_radius_property", reinterpret_cast<getter>(ListViewItemPresenter_get_SelectionIndicatorCornerRadiusProperty), nullptr, nullptr, nullptr },
        { "selection_indicator_disabled_brush_property", reinterpret_cast<getter>(ListViewItemPresenter_get_SelectionIndicatorDisabledBrushProperty), nullptr, nullptr, nullptr },
        { "selection_indicator_mode_property", reinterpret_cast<getter>(ListViewItemPresenter_get_SelectionIndicatorModeProperty), nullptr, nullptr, nullptr },
        { "selection_indicator_pointer_over_brush_property", reinterpret_cast<getter>(ListViewItemPresenter_get_SelectionIndicatorPointerOverBrushProperty), nullptr, nullptr, nullptr },
        { "selection_indicator_pressed_brush_property", reinterpret_cast<getter>(ListViewItemPresenter_get_SelectionIndicatorPressedBrushProperty), nullptr, nullptr, nullptr },
        { "selection_indicator_visual_enabled_property", reinterpret_cast<getter>(ListViewItemPresenter_get_SelectionIndicatorVisualEnabledProperty), nullptr, nullptr, nullptr },
        { }
    };

    static PyMethodDef methods_ListViewItemPresenter_Static[] = {
        { }
    };

    static PyType_Slot type_slots_ListViewItemPresenter_Static[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_ListViewItemPresenter_Static) },
        { Py_tp_methods, reinterpret_cast<void*>(methods_ListViewItemPresenter_Static) },
        { }
    };

    static PyType_Spec type_spec_ListViewItemPresenter_Static =
    {
        "winrt._winrt_microsoft_ui_xaml_controls_primitives.ListViewItemPresenter_Static",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT,
        type_slots_ListViewItemPresenter_Static
    };

    // ----- ListViewItemTemplateSettings class --------------------

    static PyObject* _new_ListViewItemTemplateSettings(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Microsoft::UI::Xaml::Controls::Primitives::ListViewItemTemplateSettings>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Microsoft::UI::Xaml::Controls::Primitives::ListViewItemTemplateSettings>::type_name);
        return nullptr;
    }

    static void _dealloc_ListViewItemTemplateSettings(py::wrapper::Microsoft::UI::Xaml::Controls::Primitives::ListViewItemTemplateSettings* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* ListViewItemTemplateSettings_get_DragItemsCount(py::wrapper::Microsoft::UI::Xaml::Controls::Primitives::ListViewItemTemplateSettings* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.ListViewItemTemplateSettings", L"DragItemsCount"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.DragItemsCount());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_ListViewItemTemplateSettings(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Microsoft::UI::Xaml::Controls::Primitives::ListViewItemTemplateSettings>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_ListViewItemTemplateSettings(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Microsoft::UI::Xaml::Controls::Primitives::ListViewItemTemplateSettings>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_ListViewItemTemplateSettings[] = {
        { "_assign_array_", _assign_array_ListViewItemTemplateSettings, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_ListViewItemTemplateSettings), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_ListViewItemTemplateSettings[] = {
        { "drag_items_count", reinterpret_cast<getter>(ListViewItemTemplateSettings_get_DragItemsCount), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_ListViewItemTemplateSettings[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_ListViewItemTemplateSettings) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_ListViewItemTemplateSettings) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_ListViewItemTemplateSettings) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_ListViewItemTemplateSettings) },
        { },
    };

    static PyType_Spec type_spec_ListViewItemTemplateSettings =
    {
        "winrt._winrt_microsoft_ui_xaml_controls_primitives.ListViewItemTemplateSettings",
        sizeof(py::wrapper::Microsoft::UI::Xaml::Controls::Primitives::ListViewItemTemplateSettings),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_ListViewItemTemplateSettings
    };

    // ----- LoopingSelector class --------------------

    static PyObject* _new_LoopingSelector(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Microsoft::UI::Xaml::Controls::Primitives::LoopingSelector>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Microsoft::UI::Xaml::Controls::Primitives::LoopingSelector>::type_name);
        return nullptr;
    }

    static void _dealloc_LoopingSelector(py::wrapper::Microsoft::UI::Xaml::Controls::Primitives::LoopingSelector* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* LoopingSelector_get_ShouldLoop(py::wrapper::Microsoft::UI::Xaml::Controls::Primitives::LoopingSelector* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.LoopingSelector", L"ShouldLoop"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.ShouldLoop());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int LoopingSelector_put_ShouldLoop(py::wrapper::Microsoft::UI::Xaml::Controls::Primitives::LoopingSelector* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.LoopingSelector", L"ShouldLoop"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<bool>(arg);

            self->obj.ShouldLoop(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* LoopingSelector_get_SelectedItem(py::wrapper::Microsoft::UI::Xaml::Controls::Primitives::LoopingSelector* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.LoopingSelector", L"SelectedItem"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.SelectedItem());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int LoopingSelector_put_SelectedItem(py::wrapper::Microsoft::UI::Xaml::Controls::Primitives::LoopingSelector* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.LoopingSelector", L"SelectedItem"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);

            self->obj.SelectedItem(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* LoopingSelector_get_SelectedIndex(py::wrapper::Microsoft::UI::Xaml::Controls::Primitives::LoopingSelector* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.LoopingSelector", L"SelectedIndex"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.SelectedIndex());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int LoopingSelector_put_SelectedIndex(py::wrapper::Microsoft::UI::Xaml::Controls::Primitives::LoopingSelector* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.LoopingSelector", L"SelectedIndex"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<int32_t>(arg);

            self->obj.SelectedIndex(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* LoopingSelector_get_Items(py::wrapper::Microsoft::UI::Xaml::Controls::Primitives::LoopingSelector* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.LoopingSelector", L"Items"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Items());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int LoopingSelector_put_Items(py::wrapper::Microsoft::UI::Xaml::Controls::Primitives::LoopingSelector* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.LoopingSelector", L"Items"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::Collections::IVector<winrt::Windows::Foundation::IInspectable>>(arg);

            self->obj.Items(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* LoopingSelector_get_ItemWidth(py::wrapper::Microsoft::UI::Xaml::Controls::Primitives::LoopingSelector* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.LoopingSelector", L"ItemWidth"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.ItemWidth());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int LoopingSelector_put_ItemWidth(py::wrapper::Microsoft::UI::Xaml::Controls::Primitives::LoopingSelector* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.LoopingSelector", L"ItemWidth"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<int32_t>(arg);

            self->obj.ItemWidth(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* LoopingSelector_get_ItemTemplate(py::wrapper::Microsoft::UI::Xaml::Controls::Primitives::LoopingSelector* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.LoopingSelector", L"ItemTemplate"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.ItemTemplate());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int LoopingSelector_put_ItemTemplate(py::wrapper::Microsoft::UI::Xaml::Controls::Primitives::LoopingSelector* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.LoopingSelector", L"ItemTemplate"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Microsoft::UI::Xaml::DataTemplate>(arg);

            self->obj.ItemTemplate(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* LoopingSelector_get_ItemHeight(py::wrapper::Microsoft::UI::Xaml::Controls::Primitives::LoopingSelector* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.LoopingSelector", L"ItemHeight"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.ItemHeight());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int LoopingSelector_put_ItemHeight(py::wrapper::Microsoft::UI::Xaml::Controls::Primitives::LoopingSelector* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.LoopingSelector", L"ItemHeight"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<int32_t>(arg);

            self->obj.ItemHeight(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* LoopingSelector_get_ItemHeightProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.LoopingSelector", L"ItemHeightProperty"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Microsoft::UI::Xaml::Controls::Primitives::LoopingSelector::ItemHeightProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* LoopingSelector_get_ItemTemplateProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.LoopingSelector", L"ItemTemplateProperty"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Microsoft::UI::Xaml::Controls::Primitives::LoopingSelector::ItemTemplateProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* LoopingSelector_get_ItemWidthProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.LoopingSelector", L"ItemWidthProperty"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Microsoft::UI::Xaml::Controls::Primitives::LoopingSelector::ItemWidthProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* LoopingSelector_get_ItemsProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.LoopingSelector", L"ItemsProperty"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Microsoft::UI::Xaml::Controls::Primitives::LoopingSelector::ItemsProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* LoopingSelector_get_SelectedIndexProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.LoopingSelector", L"SelectedIndexProperty"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Microsoft::UI::Xaml::Controls::Primitives::LoopingSelector::SelectedIndexProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* LoopingSelector_get_SelectedItemProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.LoopingSelector", L"SelectedItemProperty"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Microsoft::UI::Xaml::Controls::Primitives::LoopingSelector::SelectedItemProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* LoopingSelector_get_ShouldLoopProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.LoopingSelector", L"ShouldLoopProperty"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Microsoft::UI::Xaml::Controls::Primitives::LoopingSelector::ShouldLoopProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* LoopingSelector_add_SelectionChanged(py::wrapper::Microsoft::UI::Xaml::Controls::Primitives::LoopingSelector* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Microsoft.UI.Xaml.Controls.Primitives.LoopingSelector", L"SelectionChanged"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Microsoft::UI::Xaml::Controls::SelectionChangedEventHandler>(arg);

            return py::convert(self->obj.SelectionChanged(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* LoopingSelector_remove_SelectionChanged(py::wrapper::Microsoft::UI::Xaml::Controls::Primitives::LoopingSelector* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Microsoft.UI.Xaml.Controls.Primitives.LoopingSelector", L"SelectionChanged"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.SelectionChanged(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_LoopingSelector(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Microsoft::UI::Xaml::Controls::Primitives::LoopingSelector>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_LoopingSelector(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Microsoft::UI::Xaml::Controls::Primitives::LoopingSelector>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_LoopingSelector[] = {
        { "add_selection_changed", reinterpret_cast<PyCFunction>(LoopingSelector_add_SelectionChanged), METH_O, nullptr },
        { "remove_selection_changed", reinterpret_cast<PyCFunction>(LoopingSelector_remove_SelectionChanged), METH_O, nullptr },
        { "_assign_array_", _assign_array_LoopingSelector, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_LoopingSelector), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_LoopingSelector[] = {
        { "should_loop", reinterpret_cast<getter>(LoopingSelector_get_ShouldLoop), reinterpret_cast<setter>(LoopingSelector_put_ShouldLoop), nullptr, nullptr },
        { "selected_item", reinterpret_cast<getter>(LoopingSelector_get_SelectedItem), reinterpret_cast<setter>(LoopingSelector_put_SelectedItem), nullptr, nullptr },
        { "selected_index", reinterpret_cast<getter>(LoopingSelector_get_SelectedIndex), reinterpret_cast<setter>(LoopingSelector_put_SelectedIndex), nullptr, nullptr },
        { "items", reinterpret_cast<getter>(LoopingSelector_get_Items), reinterpret_cast<setter>(LoopingSelector_put_Items), nullptr, nullptr },
        { "item_width", reinterpret_cast<getter>(LoopingSelector_get_ItemWidth), reinterpret_cast<setter>(LoopingSelector_put_ItemWidth), nullptr, nullptr },
        { "item_template", reinterpret_cast<getter>(LoopingSelector_get_ItemTemplate), reinterpret_cast<setter>(LoopingSelector_put_ItemTemplate), nullptr, nullptr },
        { "item_height", reinterpret_cast<getter>(LoopingSelector_get_ItemHeight), reinterpret_cast<setter>(LoopingSelector_put_ItemHeight), nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_LoopingSelector[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_LoopingSelector) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_LoopingSelector) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_LoopingSelector) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_LoopingSelector) },
        { },
    };

    static PyType_Spec type_spec_LoopingSelector =
    {
        "winrt._winrt_microsoft_ui_xaml_controls_primitives.LoopingSelector",
        sizeof(py::wrapper::Microsoft::UI::Xaml::Controls::Primitives::LoopingSelector),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_LoopingSelector
    };

    static PyGetSetDef getset_LoopingSelector_Static[] = {
        { "item_height_property", reinterpret_cast<getter>(LoopingSelector_get_ItemHeightProperty), nullptr, nullptr, nullptr },
        { "item_template_property", reinterpret_cast<getter>(LoopingSelector_get_ItemTemplateProperty), nullptr, nullptr, nullptr },
        { "item_width_property", reinterpret_cast<getter>(LoopingSelector_get_ItemWidthProperty), nullptr, nullptr, nullptr },
        { "items_property", reinterpret_cast<getter>(LoopingSelector_get_ItemsProperty), nullptr, nullptr, nullptr },
        { "selected_index_property", reinterpret_cast<getter>(LoopingSelector_get_SelectedIndexProperty), nullptr, nullptr, nullptr },
        { "selected_item_property", reinterpret_cast<getter>(LoopingSelector_get_SelectedItemProperty), nullptr, nullptr, nullptr },
        { "should_loop_property", reinterpret_cast<getter>(LoopingSelector_get_ShouldLoopProperty), nullptr, nullptr, nullptr },
        { }
    };

    static PyMethodDef methods_LoopingSelector_Static[] = {
        { }
    };

    static PyType_Slot type_slots_LoopingSelector_Static[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_LoopingSelector_Static) },
        { Py_tp_methods, reinterpret_cast<void*>(methods_LoopingSelector_Static) },
        { }
    };

    static PyType_Spec type_spec_LoopingSelector_Static =
    {
        "winrt._winrt_microsoft_ui_xaml_controls_primitives.LoopingSelector_Static",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT,
        type_slots_LoopingSelector_Static
    };

    // ----- LoopingSelectorItem class --------------------

    static PyObject* _new_LoopingSelectorItem(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Microsoft::UI::Xaml::Controls::Primitives::LoopingSelectorItem>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Microsoft::UI::Xaml::Controls::Primitives::LoopingSelectorItem>::type_name);
        return nullptr;
    }

    static void _dealloc_LoopingSelectorItem(py::wrapper::Microsoft::UI::Xaml::Controls::Primitives::LoopingSelectorItem* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* _assign_array_LoopingSelectorItem(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Microsoft::UI::Xaml::Controls::Primitives::LoopingSelectorItem>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_LoopingSelectorItem(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Microsoft::UI::Xaml::Controls::Primitives::LoopingSelectorItem>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_LoopingSelectorItem[] = {
        { "_assign_array_", _assign_array_LoopingSelectorItem, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_LoopingSelectorItem), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_LoopingSelectorItem[] = {
        { }
    };

    static PyType_Slot _type_slots_LoopingSelectorItem[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_LoopingSelectorItem) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_LoopingSelectorItem) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_LoopingSelectorItem) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_LoopingSelectorItem) },
        { },
    };

    static PyType_Spec type_spec_LoopingSelectorItem =
    {
        "winrt._winrt_microsoft_ui_xaml_controls_primitives.LoopingSelectorItem",
        sizeof(py::wrapper::Microsoft::UI::Xaml::Controls::Primitives::LoopingSelectorItem),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_LoopingSelectorItem
    };

    // ----- LoopingSelectorPanel class --------------------

    static PyObject* _new_LoopingSelectorPanel(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Microsoft::UI::Xaml::Controls::Primitives::LoopingSelectorPanel>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Microsoft::UI::Xaml::Controls::Primitives::LoopingSelectorPanel>::type_name);
        return nullptr;
    }

    static void _dealloc_LoopingSelectorPanel(py::wrapper::Microsoft::UI::Xaml::Controls::Primitives::LoopingSelectorPanel* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* LoopingSelectorPanel_GetIrregularSnapPoints(py::wrapper::Microsoft::UI::Xaml::Controls::Primitives::LoopingSelectorPanel* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Xaml.Controls.Primitives.LoopingSelectorPanel", L"GetIrregularSnapPoints", 2))
            {
                py::set_arg_count_version_error(2);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Microsoft::UI::Xaml::Controls::Orientation>(args, 0);
                auto param1 = py::convert_to<winrt::Microsoft::UI::Xaml::Controls::Primitives::SnapPointsAlignment>(args, 1);

                return py::convert(self->obj.GetIrregularSnapPoints(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* LoopingSelectorPanel_GetRegularSnapPoints(py::wrapper::Microsoft::UI::Xaml::Controls::Primitives::LoopingSelectorPanel* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Xaml.Controls.Primitives.LoopingSelectorPanel", L"GetRegularSnapPoints", 2))
            {
                py::set_arg_count_version_error(2);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Microsoft::UI::Xaml::Controls::Orientation>(args, 0);
                auto param1 = py::convert_to<winrt::Microsoft::UI::Xaml::Controls::Primitives::SnapPointsAlignment>(args, 1);
                float param2 {  };

                auto return_value = self->obj.GetRegularSnapPoints(param0, param1, param2);

                py::pyobj_handle out_return_value{ py::convert(return_value) };
                if (!out_return_value)
                {
                    return nullptr;
                }
                py::pyobj_handle out2{ py::convert(param2) };
                if (!out2)
                {
                    return nullptr;
                }
                return PyTuple_Pack(2, out_return_value.get(), out2.get());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* LoopingSelectorPanel_get_AreHorizontalSnapPointsRegular(py::wrapper::Microsoft::UI::Xaml::Controls::Primitives::LoopingSelectorPanel* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.LoopingSelectorPanel", L"AreHorizontalSnapPointsRegular"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.AreHorizontalSnapPointsRegular());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* LoopingSelectorPanel_get_AreVerticalSnapPointsRegular(py::wrapper::Microsoft::UI::Xaml::Controls::Primitives::LoopingSelectorPanel* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.LoopingSelectorPanel", L"AreVerticalSnapPointsRegular"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.AreVerticalSnapPointsRegular());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* LoopingSelectorPanel_add_HorizontalSnapPointsChanged(py::wrapper::Microsoft::UI::Xaml::Controls::Primitives::LoopingSelectorPanel* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Microsoft.UI.Xaml.Controls.Primitives.LoopingSelectorPanel", L"HorizontalSnapPointsChanged"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::EventHandler<winrt::Windows::Foundation::IInspectable>>(arg);

            return py::convert(self->obj.HorizontalSnapPointsChanged(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* LoopingSelectorPanel_remove_HorizontalSnapPointsChanged(py::wrapper::Microsoft::UI::Xaml::Controls::Primitives::LoopingSelectorPanel* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Microsoft.UI.Xaml.Controls.Primitives.LoopingSelectorPanel", L"HorizontalSnapPointsChanged"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.HorizontalSnapPointsChanged(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* LoopingSelectorPanel_add_VerticalSnapPointsChanged(py::wrapper::Microsoft::UI::Xaml::Controls::Primitives::LoopingSelectorPanel* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Microsoft.UI.Xaml.Controls.Primitives.LoopingSelectorPanel", L"VerticalSnapPointsChanged"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::EventHandler<winrt::Windows::Foundation::IInspectable>>(arg);

            return py::convert(self->obj.VerticalSnapPointsChanged(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* LoopingSelectorPanel_remove_VerticalSnapPointsChanged(py::wrapper::Microsoft::UI::Xaml::Controls::Primitives::LoopingSelectorPanel* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Microsoft.UI.Xaml.Controls.Primitives.LoopingSelectorPanel", L"VerticalSnapPointsChanged"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.VerticalSnapPointsChanged(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_LoopingSelectorPanel(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Microsoft::UI::Xaml::Controls::Primitives::LoopingSelectorPanel>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_LoopingSelectorPanel(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Microsoft::UI::Xaml::Controls::Primitives::LoopingSelectorPanel>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_LoopingSelectorPanel[] = {
        { "get_irregular_snap_points", reinterpret_cast<PyCFunction>(LoopingSelectorPanel_GetIrregularSnapPoints), METH_VARARGS, nullptr },
        { "get_regular_snap_points", reinterpret_cast<PyCFunction>(LoopingSelectorPanel_GetRegularSnapPoints), METH_VARARGS, nullptr },
        { "add_horizontal_snap_points_changed", reinterpret_cast<PyCFunction>(LoopingSelectorPanel_add_HorizontalSnapPointsChanged), METH_O, nullptr },
        { "remove_horizontal_snap_points_changed", reinterpret_cast<PyCFunction>(LoopingSelectorPanel_remove_HorizontalSnapPointsChanged), METH_O, nullptr },
        { "add_vertical_snap_points_changed", reinterpret_cast<PyCFunction>(LoopingSelectorPanel_add_VerticalSnapPointsChanged), METH_O, nullptr },
        { "remove_vertical_snap_points_changed", reinterpret_cast<PyCFunction>(LoopingSelectorPanel_remove_VerticalSnapPointsChanged), METH_O, nullptr },
        { "_assign_array_", _assign_array_LoopingSelectorPanel, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_LoopingSelectorPanel), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_LoopingSelectorPanel[] = {
        { "are_horizontal_snap_points_regular", reinterpret_cast<getter>(LoopingSelectorPanel_get_AreHorizontalSnapPointsRegular), nullptr, nullptr, nullptr },
        { "are_vertical_snap_points_regular", reinterpret_cast<getter>(LoopingSelectorPanel_get_AreVerticalSnapPointsRegular), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_LoopingSelectorPanel[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_LoopingSelectorPanel) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_LoopingSelectorPanel) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_LoopingSelectorPanel) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_LoopingSelectorPanel) },
        { },
    };

    static PyType_Spec type_spec_LoopingSelectorPanel =
    {
        "winrt._winrt_microsoft_ui_xaml_controls_primitives.LoopingSelectorPanel",
        sizeof(py::wrapper::Microsoft::UI::Xaml::Controls::Primitives::LoopingSelectorPanel),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_LoopingSelectorPanel
    };

    // ----- MenuFlyoutItemTemplateSettings class --------------------

    static PyObject* _new_MenuFlyoutItemTemplateSettings(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Microsoft::UI::Xaml::Controls::Primitives::MenuFlyoutItemTemplateSettings>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Microsoft::UI::Xaml::Controls::Primitives::MenuFlyoutItemTemplateSettings>::type_name);
        return nullptr;
    }

    static void _dealloc_MenuFlyoutItemTemplateSettings(py::wrapper::Microsoft::UI::Xaml::Controls::Primitives::MenuFlyoutItemTemplateSettings* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* MenuFlyoutItemTemplateSettings_get_KeyboardAcceleratorTextMinWidth(py::wrapper::Microsoft::UI::Xaml::Controls::Primitives::MenuFlyoutItemTemplateSettings* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.MenuFlyoutItemTemplateSettings", L"KeyboardAcceleratorTextMinWidth"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.KeyboardAcceleratorTextMinWidth());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_MenuFlyoutItemTemplateSettings(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Microsoft::UI::Xaml::Controls::Primitives::MenuFlyoutItemTemplateSettings>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_MenuFlyoutItemTemplateSettings(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Microsoft::UI::Xaml::Controls::Primitives::MenuFlyoutItemTemplateSettings>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_MenuFlyoutItemTemplateSettings[] = {
        { "_assign_array_", _assign_array_MenuFlyoutItemTemplateSettings, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_MenuFlyoutItemTemplateSettings), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_MenuFlyoutItemTemplateSettings[] = {
        { "keyboard_accelerator_text_min_width", reinterpret_cast<getter>(MenuFlyoutItemTemplateSettings_get_KeyboardAcceleratorTextMinWidth), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_MenuFlyoutItemTemplateSettings[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_MenuFlyoutItemTemplateSettings) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_MenuFlyoutItemTemplateSettings) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_MenuFlyoutItemTemplateSettings) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_MenuFlyoutItemTemplateSettings) },
        { },
    };

    static PyType_Spec type_spec_MenuFlyoutItemTemplateSettings =
    {
        "winrt._winrt_microsoft_ui_xaml_controls_primitives.MenuFlyoutItemTemplateSettings",
        sizeof(py::wrapper::Microsoft::UI::Xaml::Controls::Primitives::MenuFlyoutItemTemplateSettings),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_MenuFlyoutItemTemplateSettings
    };

    // ----- MenuFlyoutPresenterTemplateSettings class --------------------

    static PyObject* _new_MenuFlyoutPresenterTemplateSettings(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Microsoft::UI::Xaml::Controls::Primitives::MenuFlyoutPresenterTemplateSettings>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Microsoft::UI::Xaml::Controls::Primitives::MenuFlyoutPresenterTemplateSettings>::type_name);
        return nullptr;
    }

    static void _dealloc_MenuFlyoutPresenterTemplateSettings(py::wrapper::Microsoft::UI::Xaml::Controls::Primitives::MenuFlyoutPresenterTemplateSettings* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* MenuFlyoutPresenterTemplateSettings_get_FlyoutContentMinWidth(py::wrapper::Microsoft::UI::Xaml::Controls::Primitives::MenuFlyoutPresenterTemplateSettings* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.MenuFlyoutPresenterTemplateSettings", L"FlyoutContentMinWidth"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.FlyoutContentMinWidth());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_MenuFlyoutPresenterTemplateSettings(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Microsoft::UI::Xaml::Controls::Primitives::MenuFlyoutPresenterTemplateSettings>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_MenuFlyoutPresenterTemplateSettings(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Microsoft::UI::Xaml::Controls::Primitives::MenuFlyoutPresenterTemplateSettings>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_MenuFlyoutPresenterTemplateSettings[] = {
        { "_assign_array_", _assign_array_MenuFlyoutPresenterTemplateSettings, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_MenuFlyoutPresenterTemplateSettings), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_MenuFlyoutPresenterTemplateSettings[] = {
        { "flyout_content_min_width", reinterpret_cast<getter>(MenuFlyoutPresenterTemplateSettings_get_FlyoutContentMinWidth), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_MenuFlyoutPresenterTemplateSettings[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_MenuFlyoutPresenterTemplateSettings) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_MenuFlyoutPresenterTemplateSettings) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_MenuFlyoutPresenterTemplateSettings) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_MenuFlyoutPresenterTemplateSettings) },
        { },
    };

    static PyType_Spec type_spec_MenuFlyoutPresenterTemplateSettings =
    {
        "winrt._winrt_microsoft_ui_xaml_controls_primitives.MenuFlyoutPresenterTemplateSettings",
        sizeof(py::wrapper::Microsoft::UI::Xaml::Controls::Primitives::MenuFlyoutPresenterTemplateSettings),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_MenuFlyoutPresenterTemplateSettings
    };

    // ----- MonochromaticOverlayPresenter class --------------------

    static PyObject* _new_MonochromaticOverlayPresenter(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 0)
        {
            try
            {
                winrt::Microsoft::UI::Xaml::Controls::Primitives::MonochromaticOverlayPresenter instance{  };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_MonochromaticOverlayPresenter(py::wrapper::Microsoft::UI::Xaml::Controls::Primitives::MonochromaticOverlayPresenter* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* MonochromaticOverlayPresenter_get_SourceElement(py::wrapper::Microsoft::UI::Xaml::Controls::Primitives::MonochromaticOverlayPresenter* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.MonochromaticOverlayPresenter", L"SourceElement"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.SourceElement());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int MonochromaticOverlayPresenter_put_SourceElement(py::wrapper::Microsoft::UI::Xaml::Controls::Primitives::MonochromaticOverlayPresenter* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.MonochromaticOverlayPresenter", L"SourceElement"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Microsoft::UI::Xaml::UIElement>(arg);

            self->obj.SourceElement(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* MonochromaticOverlayPresenter_get_ReplacementColor(py::wrapper::Microsoft::UI::Xaml::Controls::Primitives::MonochromaticOverlayPresenter* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.MonochromaticOverlayPresenter", L"ReplacementColor"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.ReplacementColor());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int MonochromaticOverlayPresenter_put_ReplacementColor(py::wrapper::Microsoft::UI::Xaml::Controls::Primitives::MonochromaticOverlayPresenter* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.MonochromaticOverlayPresenter", L"ReplacementColor"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::UI::Color>(arg);

            self->obj.ReplacementColor(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* MonochromaticOverlayPresenter_get_ReplacementColorProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.MonochromaticOverlayPresenter", L"ReplacementColorProperty"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Microsoft::UI::Xaml::Controls::Primitives::MonochromaticOverlayPresenter::ReplacementColorProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MonochromaticOverlayPresenter_get_SourceElementProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.MonochromaticOverlayPresenter", L"SourceElementProperty"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Microsoft::UI::Xaml::Controls::Primitives::MonochromaticOverlayPresenter::SourceElementProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_MonochromaticOverlayPresenter(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Microsoft::UI::Xaml::Controls::Primitives::MonochromaticOverlayPresenter>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_MonochromaticOverlayPresenter(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Microsoft::UI::Xaml::Controls::Primitives::MonochromaticOverlayPresenter>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_MonochromaticOverlayPresenter[] = {
        { "_assign_array_", _assign_array_MonochromaticOverlayPresenter, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_MonochromaticOverlayPresenter), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_MonochromaticOverlayPresenter[] = {
        { "source_element", reinterpret_cast<getter>(MonochromaticOverlayPresenter_get_SourceElement), reinterpret_cast<setter>(MonochromaticOverlayPresenter_put_SourceElement), nullptr, nullptr },
        { "replacement_color", reinterpret_cast<getter>(MonochromaticOverlayPresenter_get_ReplacementColor), reinterpret_cast<setter>(MonochromaticOverlayPresenter_put_ReplacementColor), nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_MonochromaticOverlayPresenter[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_MonochromaticOverlayPresenter) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_MonochromaticOverlayPresenter) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_MonochromaticOverlayPresenter) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_MonochromaticOverlayPresenter) },
        { },
    };

    static PyType_Spec type_spec_MonochromaticOverlayPresenter =
    {
        "winrt._winrt_microsoft_ui_xaml_controls_primitives.MonochromaticOverlayPresenter",
        sizeof(py::wrapper::Microsoft::UI::Xaml::Controls::Primitives::MonochromaticOverlayPresenter),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_MonochromaticOverlayPresenter
    };

    static PyGetSetDef getset_MonochromaticOverlayPresenter_Static[] = {
        { "replacement_color_property", reinterpret_cast<getter>(MonochromaticOverlayPresenter_get_ReplacementColorProperty), nullptr, nullptr, nullptr },
        { "source_element_property", reinterpret_cast<getter>(MonochromaticOverlayPresenter_get_SourceElementProperty), nullptr, nullptr, nullptr },
        { }
    };

    static PyMethodDef methods_MonochromaticOverlayPresenter_Static[] = {
        { }
    };

    static PyType_Slot type_slots_MonochromaticOverlayPresenter_Static[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_MonochromaticOverlayPresenter_Static) },
        { Py_tp_methods, reinterpret_cast<void*>(methods_MonochromaticOverlayPresenter_Static) },
        { }
    };

    static PyType_Spec type_spec_MonochromaticOverlayPresenter_Static =
    {
        "winrt._winrt_microsoft_ui_xaml_controls_primitives.MonochromaticOverlayPresenter_Static",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT,
        type_slots_MonochromaticOverlayPresenter_Static
    };

    // ----- NavigationViewItemPresenter class --------------------

    static PyObject* _new_NavigationViewItemPresenter(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 0)
        {
            try
            {
                winrt::Microsoft::UI::Xaml::Controls::Primitives::NavigationViewItemPresenter instance{  };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_NavigationViewItemPresenter(py::wrapper::Microsoft::UI::Xaml::Controls::Primitives::NavigationViewItemPresenter* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* NavigationViewItemPresenter_get_Icon(py::wrapper::Microsoft::UI::Xaml::Controls::Primitives::NavigationViewItemPresenter* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.NavigationViewItemPresenter", L"Icon"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Icon());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int NavigationViewItemPresenter_put_Icon(py::wrapper::Microsoft::UI::Xaml::Controls::Primitives::NavigationViewItemPresenter* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.NavigationViewItemPresenter", L"Icon"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Microsoft::UI::Xaml::Controls::IconElement>(arg);

            self->obj.Icon(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* NavigationViewItemPresenter_get_TemplateSettings(py::wrapper::Microsoft::UI::Xaml::Controls::Primitives::NavigationViewItemPresenter* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.NavigationViewItemPresenter", L"TemplateSettings"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.TemplateSettings());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* NavigationViewItemPresenter_get_InfoBadge(py::wrapper::Microsoft::UI::Xaml::Controls::Primitives::NavigationViewItemPresenter* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.NavigationViewItemPresenter", L"InfoBadge"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.InfoBadge());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int NavigationViewItemPresenter_put_InfoBadge(py::wrapper::Microsoft::UI::Xaml::Controls::Primitives::NavigationViewItemPresenter* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.NavigationViewItemPresenter", L"InfoBadge"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Microsoft::UI::Xaml::Controls::InfoBadge>(arg);

            self->obj.InfoBadge(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* NavigationViewItemPresenter_get_IconProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.NavigationViewItemPresenter", L"IconProperty"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Microsoft::UI::Xaml::Controls::Primitives::NavigationViewItemPresenter::IconProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* NavigationViewItemPresenter_get_TemplateSettingsProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.NavigationViewItemPresenter", L"TemplateSettingsProperty"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Microsoft::UI::Xaml::Controls::Primitives::NavigationViewItemPresenter::TemplateSettingsProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* NavigationViewItemPresenter_get_InfoBadgeProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.NavigationViewItemPresenter", L"InfoBadgeProperty"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Microsoft::UI::Xaml::Controls::Primitives::NavigationViewItemPresenter::InfoBadgeProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_NavigationViewItemPresenter(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Microsoft::UI::Xaml::Controls::Primitives::NavigationViewItemPresenter>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_NavigationViewItemPresenter(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Microsoft::UI::Xaml::Controls::Primitives::NavigationViewItemPresenter>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_NavigationViewItemPresenter[] = {
        { "_assign_array_", _assign_array_NavigationViewItemPresenter, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_NavigationViewItemPresenter), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_NavigationViewItemPresenter[] = {
        { "icon", reinterpret_cast<getter>(NavigationViewItemPresenter_get_Icon), reinterpret_cast<setter>(NavigationViewItemPresenter_put_Icon), nullptr, nullptr },
        { "template_settings", reinterpret_cast<getter>(NavigationViewItemPresenter_get_TemplateSettings), nullptr, nullptr, nullptr },
        { "info_badge", reinterpret_cast<getter>(NavigationViewItemPresenter_get_InfoBadge), reinterpret_cast<setter>(NavigationViewItemPresenter_put_InfoBadge), nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_NavigationViewItemPresenter[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_NavigationViewItemPresenter) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_NavigationViewItemPresenter) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_NavigationViewItemPresenter) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_NavigationViewItemPresenter) },
        { },
    };

    static PyType_Spec type_spec_NavigationViewItemPresenter =
    {
        "winrt._winrt_microsoft_ui_xaml_controls_primitives.NavigationViewItemPresenter",
        sizeof(py::wrapper::Microsoft::UI::Xaml::Controls::Primitives::NavigationViewItemPresenter),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_NavigationViewItemPresenter
    };

    static PyGetSetDef getset_NavigationViewItemPresenter_Static[] = {
        { "icon_property", reinterpret_cast<getter>(NavigationViewItemPresenter_get_IconProperty), nullptr, nullptr, nullptr },
        { "template_settings_property", reinterpret_cast<getter>(NavigationViewItemPresenter_get_TemplateSettingsProperty), nullptr, nullptr, nullptr },
        { "info_badge_property", reinterpret_cast<getter>(NavigationViewItemPresenter_get_InfoBadgeProperty), nullptr, nullptr, nullptr },
        { }
    };

    static PyMethodDef methods_NavigationViewItemPresenter_Static[] = {
        { }
    };

    static PyType_Slot type_slots_NavigationViewItemPresenter_Static[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_NavigationViewItemPresenter_Static) },
        { Py_tp_methods, reinterpret_cast<void*>(methods_NavigationViewItemPresenter_Static) },
        { }
    };

    static PyType_Spec type_spec_NavigationViewItemPresenter_Static =
    {
        "winrt._winrt_microsoft_ui_xaml_controls_primitives.NavigationViewItemPresenter_Static",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT,
        type_slots_NavigationViewItemPresenter_Static
    };

    // ----- NavigationViewItemPresenterTemplateSettings class --------------------

    static PyObject* _new_NavigationViewItemPresenterTemplateSettings(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 0)
        {
            try
            {
                winrt::Microsoft::UI::Xaml::Controls::Primitives::NavigationViewItemPresenterTemplateSettings instance{  };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_NavigationViewItemPresenterTemplateSettings(py::wrapper::Microsoft::UI::Xaml::Controls::Primitives::NavigationViewItemPresenterTemplateSettings* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* NavigationViewItemPresenterTemplateSettings_get_IconWidth(py::wrapper::Microsoft::UI::Xaml::Controls::Primitives::NavigationViewItemPresenterTemplateSettings* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.NavigationViewItemPresenterTemplateSettings", L"IconWidth"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.IconWidth());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* NavigationViewItemPresenterTemplateSettings_get_SmallerIconWidth(py::wrapper::Microsoft::UI::Xaml::Controls::Primitives::NavigationViewItemPresenterTemplateSettings* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.NavigationViewItemPresenterTemplateSettings", L"SmallerIconWidth"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.SmallerIconWidth());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* NavigationViewItemPresenterTemplateSettings_get_IconWidthProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.NavigationViewItemPresenterTemplateSettings", L"IconWidthProperty"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Microsoft::UI::Xaml::Controls::Primitives::NavigationViewItemPresenterTemplateSettings::IconWidthProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* NavigationViewItemPresenterTemplateSettings_get_SmallerIconWidthProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.NavigationViewItemPresenterTemplateSettings", L"SmallerIconWidthProperty"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Microsoft::UI::Xaml::Controls::Primitives::NavigationViewItemPresenterTemplateSettings::SmallerIconWidthProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_NavigationViewItemPresenterTemplateSettings(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Microsoft::UI::Xaml::Controls::Primitives::NavigationViewItemPresenterTemplateSettings>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_NavigationViewItemPresenterTemplateSettings(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Microsoft::UI::Xaml::Controls::Primitives::NavigationViewItemPresenterTemplateSettings>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_NavigationViewItemPresenterTemplateSettings[] = {
        { "_assign_array_", _assign_array_NavigationViewItemPresenterTemplateSettings, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_NavigationViewItemPresenterTemplateSettings), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_NavigationViewItemPresenterTemplateSettings[] = {
        { "icon_width", reinterpret_cast<getter>(NavigationViewItemPresenterTemplateSettings_get_IconWidth), nullptr, nullptr, nullptr },
        { "smaller_icon_width", reinterpret_cast<getter>(NavigationViewItemPresenterTemplateSettings_get_SmallerIconWidth), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_NavigationViewItemPresenterTemplateSettings[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_NavigationViewItemPresenterTemplateSettings) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_NavigationViewItemPresenterTemplateSettings) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_NavigationViewItemPresenterTemplateSettings) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_NavigationViewItemPresenterTemplateSettings) },
        { },
    };

    static PyType_Spec type_spec_NavigationViewItemPresenterTemplateSettings =
    {
        "winrt._winrt_microsoft_ui_xaml_controls_primitives.NavigationViewItemPresenterTemplateSettings",
        sizeof(py::wrapper::Microsoft::UI::Xaml::Controls::Primitives::NavigationViewItemPresenterTemplateSettings),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_NavigationViewItemPresenterTemplateSettings
    };

    static PyGetSetDef getset_NavigationViewItemPresenterTemplateSettings_Static[] = {
        { "icon_width_property", reinterpret_cast<getter>(NavigationViewItemPresenterTemplateSettings_get_IconWidthProperty), nullptr, nullptr, nullptr },
        { "smaller_icon_width_property", reinterpret_cast<getter>(NavigationViewItemPresenterTemplateSettings_get_SmallerIconWidthProperty), nullptr, nullptr, nullptr },
        { }
    };

    static PyMethodDef methods_NavigationViewItemPresenterTemplateSettings_Static[] = {
        { }
    };

    static PyType_Slot type_slots_NavigationViewItemPresenterTemplateSettings_Static[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_NavigationViewItemPresenterTemplateSettings_Static) },
        { Py_tp_methods, reinterpret_cast<void*>(methods_NavigationViewItemPresenterTemplateSettings_Static) },
        { }
    };

    static PyType_Spec type_spec_NavigationViewItemPresenterTemplateSettings_Static =
    {
        "winrt._winrt_microsoft_ui_xaml_controls_primitives.NavigationViewItemPresenterTemplateSettings_Static",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT,
        type_slots_NavigationViewItemPresenterTemplateSettings_Static
    };

    // ----- OrientedVirtualizingPanel class --------------------

    static PyObject* _new_OrientedVirtualizingPanel(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Microsoft::UI::Xaml::Controls::Primitives::OrientedVirtualizingPanel>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Microsoft::UI::Xaml::Controls::Primitives::OrientedVirtualizingPanel>::type_name);
        return nullptr;
    }

    static void _dealloc_OrientedVirtualizingPanel(py::wrapper::Microsoft::UI::Xaml::Controls::Primitives::OrientedVirtualizingPanel* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* OrientedVirtualizingPanel_GetInsertionIndexes(py::wrapper::Microsoft::UI::Xaml::Controls::Primitives::OrientedVirtualizingPanel* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Xaml.Controls.Primitives.OrientedVirtualizingPanel", L"GetInsertionIndexes", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::Foundation::Point>(args, 0);
                int32_t param1 {  };
                int32_t param2 {  };

                self->obj.GetInsertionIndexes(param0, param1, param2);

                py::pyobj_handle out1{ py::convert(param1) };
                if (!out1)
                {
                    return nullptr;
                }
                py::pyobj_handle out2{ py::convert(param2) };
                if (!out2)
                {
                    return nullptr;
                }
                return PyTuple_Pack(2, out1.get(), out2.get());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* OrientedVirtualizingPanel_GetIrregularSnapPoints(py::wrapper::Microsoft::UI::Xaml::Controls::Primitives::OrientedVirtualizingPanel* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Xaml.Controls.Primitives.OrientedVirtualizingPanel", L"GetIrregularSnapPoints", 2))
            {
                py::set_arg_count_version_error(2);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Microsoft::UI::Xaml::Controls::Orientation>(args, 0);
                auto param1 = py::convert_to<winrt::Microsoft::UI::Xaml::Controls::Primitives::SnapPointsAlignment>(args, 1);

                return py::convert(self->obj.GetIrregularSnapPoints(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* OrientedVirtualizingPanel_GetRegularSnapPoints(py::wrapper::Microsoft::UI::Xaml::Controls::Primitives::OrientedVirtualizingPanel* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Xaml.Controls.Primitives.OrientedVirtualizingPanel", L"GetRegularSnapPoints", 2))
            {
                py::set_arg_count_version_error(2);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Microsoft::UI::Xaml::Controls::Orientation>(args, 0);
                auto param1 = py::convert_to<winrt::Microsoft::UI::Xaml::Controls::Primitives::SnapPointsAlignment>(args, 1);
                float param2 {  };

                auto return_value = self->obj.GetRegularSnapPoints(param0, param1, param2);

                py::pyobj_handle out_return_value{ py::convert(return_value) };
                if (!out_return_value)
                {
                    return nullptr;
                }
                py::pyobj_handle out2{ py::convert(param2) };
                if (!out2)
                {
                    return nullptr;
                }
                return PyTuple_Pack(2, out_return_value.get(), out2.get());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* OrientedVirtualizingPanel_LineDown(py::wrapper::Microsoft::UI::Xaml::Controls::Primitives::OrientedVirtualizingPanel* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Xaml.Controls.Primitives.OrientedVirtualizingPanel", L"LineDown", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                self->obj.LineDown();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* OrientedVirtualizingPanel_LineLeft(py::wrapper::Microsoft::UI::Xaml::Controls::Primitives::OrientedVirtualizingPanel* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Xaml.Controls.Primitives.OrientedVirtualizingPanel", L"LineLeft", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                self->obj.LineLeft();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* OrientedVirtualizingPanel_LineRight(py::wrapper::Microsoft::UI::Xaml::Controls::Primitives::OrientedVirtualizingPanel* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Xaml.Controls.Primitives.OrientedVirtualizingPanel", L"LineRight", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                self->obj.LineRight();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* OrientedVirtualizingPanel_LineUp(py::wrapper::Microsoft::UI::Xaml::Controls::Primitives::OrientedVirtualizingPanel* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Xaml.Controls.Primitives.OrientedVirtualizingPanel", L"LineUp", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                self->obj.LineUp();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* OrientedVirtualizingPanel_MakeVisible(py::wrapper::Microsoft::UI::Xaml::Controls::Primitives::OrientedVirtualizingPanel* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Xaml.Controls.Primitives.OrientedVirtualizingPanel", L"MakeVisible", 2))
            {
                py::set_arg_count_version_error(2);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Microsoft::UI::Xaml::UIElement>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Foundation::Rect>(args, 1);

                return py::convert(self->obj.MakeVisible(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* OrientedVirtualizingPanel_MouseWheelDown(py::wrapper::Microsoft::UI::Xaml::Controls::Primitives::OrientedVirtualizingPanel* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Xaml.Controls.Primitives.OrientedVirtualizingPanel", L"MouseWheelDown", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                self->obj.MouseWheelDown();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* OrientedVirtualizingPanel_MouseWheelLeft(py::wrapper::Microsoft::UI::Xaml::Controls::Primitives::OrientedVirtualizingPanel* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Xaml.Controls.Primitives.OrientedVirtualizingPanel", L"MouseWheelLeft", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                self->obj.MouseWheelLeft();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* OrientedVirtualizingPanel_MouseWheelRight(py::wrapper::Microsoft::UI::Xaml::Controls::Primitives::OrientedVirtualizingPanel* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Xaml.Controls.Primitives.OrientedVirtualizingPanel", L"MouseWheelRight", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                self->obj.MouseWheelRight();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* OrientedVirtualizingPanel_MouseWheelUp(py::wrapper::Microsoft::UI::Xaml::Controls::Primitives::OrientedVirtualizingPanel* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Xaml.Controls.Primitives.OrientedVirtualizingPanel", L"MouseWheelUp", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                self->obj.MouseWheelUp();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* OrientedVirtualizingPanel_PageDown(py::wrapper::Microsoft::UI::Xaml::Controls::Primitives::OrientedVirtualizingPanel* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Xaml.Controls.Primitives.OrientedVirtualizingPanel", L"PageDown", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                self->obj.PageDown();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* OrientedVirtualizingPanel_PageLeft(py::wrapper::Microsoft::UI::Xaml::Controls::Primitives::OrientedVirtualizingPanel* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Xaml.Controls.Primitives.OrientedVirtualizingPanel", L"PageLeft", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                self->obj.PageLeft();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* OrientedVirtualizingPanel_PageRight(py::wrapper::Microsoft::UI::Xaml::Controls::Primitives::OrientedVirtualizingPanel* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Xaml.Controls.Primitives.OrientedVirtualizingPanel", L"PageRight", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                self->obj.PageRight();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* OrientedVirtualizingPanel_PageUp(py::wrapper::Microsoft::UI::Xaml::Controls::Primitives::OrientedVirtualizingPanel* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Xaml.Controls.Primitives.OrientedVirtualizingPanel", L"PageUp", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                self->obj.PageUp();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* OrientedVirtualizingPanel_SetHorizontalOffset(py::wrapper::Microsoft::UI::Xaml::Controls::Primitives::OrientedVirtualizingPanel* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Xaml.Controls.Primitives.OrientedVirtualizingPanel", L"SetHorizontalOffset", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<double>(args, 0);

                self->obj.SetHorizontalOffset(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* OrientedVirtualizingPanel_SetVerticalOffset(py::wrapper::Microsoft::UI::Xaml::Controls::Primitives::OrientedVirtualizingPanel* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Xaml.Controls.Primitives.OrientedVirtualizingPanel", L"SetVerticalOffset", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<double>(args, 0);

                self->obj.SetVerticalOffset(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* OrientedVirtualizingPanel_get_ScrollOwner(py::wrapper::Microsoft::UI::Xaml::Controls::Primitives::OrientedVirtualizingPanel* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.OrientedVirtualizingPanel", L"ScrollOwner"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.ScrollOwner());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int OrientedVirtualizingPanel_put_ScrollOwner(py::wrapper::Microsoft::UI::Xaml::Controls::Primitives::OrientedVirtualizingPanel* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.OrientedVirtualizingPanel", L"ScrollOwner"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);

            self->obj.ScrollOwner(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* OrientedVirtualizingPanel_get_CanVerticallyScroll(py::wrapper::Microsoft::UI::Xaml::Controls::Primitives::OrientedVirtualizingPanel* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.OrientedVirtualizingPanel", L"CanVerticallyScroll"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.CanVerticallyScroll());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int OrientedVirtualizingPanel_put_CanVerticallyScroll(py::wrapper::Microsoft::UI::Xaml::Controls::Primitives::OrientedVirtualizingPanel* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.OrientedVirtualizingPanel", L"CanVerticallyScroll"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<bool>(arg);

            self->obj.CanVerticallyScroll(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* OrientedVirtualizingPanel_get_CanHorizontallyScroll(py::wrapper::Microsoft::UI::Xaml::Controls::Primitives::OrientedVirtualizingPanel* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.OrientedVirtualizingPanel", L"CanHorizontallyScroll"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.CanHorizontallyScroll());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int OrientedVirtualizingPanel_put_CanHorizontallyScroll(py::wrapper::Microsoft::UI::Xaml::Controls::Primitives::OrientedVirtualizingPanel* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.OrientedVirtualizingPanel", L"CanHorizontallyScroll"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<bool>(arg);

            self->obj.CanHorizontallyScroll(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* OrientedVirtualizingPanel_get_ExtentHeight(py::wrapper::Microsoft::UI::Xaml::Controls::Primitives::OrientedVirtualizingPanel* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.OrientedVirtualizingPanel", L"ExtentHeight"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.ExtentHeight());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* OrientedVirtualizingPanel_get_ExtentWidth(py::wrapper::Microsoft::UI::Xaml::Controls::Primitives::OrientedVirtualizingPanel* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.OrientedVirtualizingPanel", L"ExtentWidth"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.ExtentWidth());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* OrientedVirtualizingPanel_get_HorizontalOffset(py::wrapper::Microsoft::UI::Xaml::Controls::Primitives::OrientedVirtualizingPanel* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.OrientedVirtualizingPanel", L"HorizontalOffset"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.HorizontalOffset());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* OrientedVirtualizingPanel_get_VerticalOffset(py::wrapper::Microsoft::UI::Xaml::Controls::Primitives::OrientedVirtualizingPanel* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.OrientedVirtualizingPanel", L"VerticalOffset"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.VerticalOffset());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* OrientedVirtualizingPanel_get_ViewportHeight(py::wrapper::Microsoft::UI::Xaml::Controls::Primitives::OrientedVirtualizingPanel* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.OrientedVirtualizingPanel", L"ViewportHeight"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.ViewportHeight());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* OrientedVirtualizingPanel_get_ViewportWidth(py::wrapper::Microsoft::UI::Xaml::Controls::Primitives::OrientedVirtualizingPanel* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.OrientedVirtualizingPanel", L"ViewportWidth"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.ViewportWidth());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* OrientedVirtualizingPanel_get_AreHorizontalSnapPointsRegular(py::wrapper::Microsoft::UI::Xaml::Controls::Primitives::OrientedVirtualizingPanel* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.OrientedVirtualizingPanel", L"AreHorizontalSnapPointsRegular"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.AreHorizontalSnapPointsRegular());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* OrientedVirtualizingPanel_get_AreVerticalSnapPointsRegular(py::wrapper::Microsoft::UI::Xaml::Controls::Primitives::OrientedVirtualizingPanel* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.OrientedVirtualizingPanel", L"AreVerticalSnapPointsRegular"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.AreVerticalSnapPointsRegular());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* OrientedVirtualizingPanel_add_HorizontalSnapPointsChanged(py::wrapper::Microsoft::UI::Xaml::Controls::Primitives::OrientedVirtualizingPanel* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Microsoft.UI.Xaml.Controls.Primitives.OrientedVirtualizingPanel", L"HorizontalSnapPointsChanged"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::EventHandler<winrt::Windows::Foundation::IInspectable>>(arg);

            return py::convert(self->obj.HorizontalSnapPointsChanged(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* OrientedVirtualizingPanel_remove_HorizontalSnapPointsChanged(py::wrapper::Microsoft::UI::Xaml::Controls::Primitives::OrientedVirtualizingPanel* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Microsoft.UI.Xaml.Controls.Primitives.OrientedVirtualizingPanel", L"HorizontalSnapPointsChanged"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.HorizontalSnapPointsChanged(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* OrientedVirtualizingPanel_add_VerticalSnapPointsChanged(py::wrapper::Microsoft::UI::Xaml::Controls::Primitives::OrientedVirtualizingPanel* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Microsoft.UI.Xaml.Controls.Primitives.OrientedVirtualizingPanel", L"VerticalSnapPointsChanged"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::EventHandler<winrt::Windows::Foundation::IInspectable>>(arg);

            return py::convert(self->obj.VerticalSnapPointsChanged(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* OrientedVirtualizingPanel_remove_VerticalSnapPointsChanged(py::wrapper::Microsoft::UI::Xaml::Controls::Primitives::OrientedVirtualizingPanel* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Microsoft.UI.Xaml.Controls.Primitives.OrientedVirtualizingPanel", L"VerticalSnapPointsChanged"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.VerticalSnapPointsChanged(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_OrientedVirtualizingPanel(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Microsoft::UI::Xaml::Controls::Primitives::OrientedVirtualizingPanel>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_OrientedVirtualizingPanel(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Microsoft::UI::Xaml::Controls::Primitives::OrientedVirtualizingPanel>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_OrientedVirtualizingPanel[] = {
        { "get_insertion_indexes", reinterpret_cast<PyCFunction>(OrientedVirtualizingPanel_GetInsertionIndexes), METH_VARARGS, nullptr },
        { "get_irregular_snap_points", reinterpret_cast<PyCFunction>(OrientedVirtualizingPanel_GetIrregularSnapPoints), METH_VARARGS, nullptr },
        { "get_regular_snap_points", reinterpret_cast<PyCFunction>(OrientedVirtualizingPanel_GetRegularSnapPoints), METH_VARARGS, nullptr },
        { "line_down", reinterpret_cast<PyCFunction>(OrientedVirtualizingPanel_LineDown), METH_VARARGS, nullptr },
        { "line_left", reinterpret_cast<PyCFunction>(OrientedVirtualizingPanel_LineLeft), METH_VARARGS, nullptr },
        { "line_right", reinterpret_cast<PyCFunction>(OrientedVirtualizingPanel_LineRight), METH_VARARGS, nullptr },
        { "line_up", reinterpret_cast<PyCFunction>(OrientedVirtualizingPanel_LineUp), METH_VARARGS, nullptr },
        { "make_visible", reinterpret_cast<PyCFunction>(OrientedVirtualizingPanel_MakeVisible), METH_VARARGS, nullptr },
        { "mouse_wheel_down", reinterpret_cast<PyCFunction>(OrientedVirtualizingPanel_MouseWheelDown), METH_VARARGS, nullptr },
        { "mouse_wheel_left", reinterpret_cast<PyCFunction>(OrientedVirtualizingPanel_MouseWheelLeft), METH_VARARGS, nullptr },
        { "mouse_wheel_right", reinterpret_cast<PyCFunction>(OrientedVirtualizingPanel_MouseWheelRight), METH_VARARGS, nullptr },
        { "mouse_wheel_up", reinterpret_cast<PyCFunction>(OrientedVirtualizingPanel_MouseWheelUp), METH_VARARGS, nullptr },
        { "page_down", reinterpret_cast<PyCFunction>(OrientedVirtualizingPanel_PageDown), METH_VARARGS, nullptr },
        { "page_left", reinterpret_cast<PyCFunction>(OrientedVirtualizingPanel_PageLeft), METH_VARARGS, nullptr },
        { "page_right", reinterpret_cast<PyCFunction>(OrientedVirtualizingPanel_PageRight), METH_VARARGS, nullptr },
        { "page_up", reinterpret_cast<PyCFunction>(OrientedVirtualizingPanel_PageUp), METH_VARARGS, nullptr },
        { "set_horizontal_offset", reinterpret_cast<PyCFunction>(OrientedVirtualizingPanel_SetHorizontalOffset), METH_VARARGS, nullptr },
        { "set_vertical_offset", reinterpret_cast<PyCFunction>(OrientedVirtualizingPanel_SetVerticalOffset), METH_VARARGS, nullptr },
        { "add_horizontal_snap_points_changed", reinterpret_cast<PyCFunction>(OrientedVirtualizingPanel_add_HorizontalSnapPointsChanged), METH_O, nullptr },
        { "remove_horizontal_snap_points_changed", reinterpret_cast<PyCFunction>(OrientedVirtualizingPanel_remove_HorizontalSnapPointsChanged), METH_O, nullptr },
        { "add_vertical_snap_points_changed", reinterpret_cast<PyCFunction>(OrientedVirtualizingPanel_add_VerticalSnapPointsChanged), METH_O, nullptr },
        { "remove_vertical_snap_points_changed", reinterpret_cast<PyCFunction>(OrientedVirtualizingPanel_remove_VerticalSnapPointsChanged), METH_O, nullptr },
        { "_assign_array_", _assign_array_OrientedVirtualizingPanel, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_OrientedVirtualizingPanel), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_OrientedVirtualizingPanel[] = {
        { "scroll_owner", reinterpret_cast<getter>(OrientedVirtualizingPanel_get_ScrollOwner), reinterpret_cast<setter>(OrientedVirtualizingPanel_put_ScrollOwner), nullptr, nullptr },
        { "can_vertically_scroll", reinterpret_cast<getter>(OrientedVirtualizingPanel_get_CanVerticallyScroll), reinterpret_cast<setter>(OrientedVirtualizingPanel_put_CanVerticallyScroll), nullptr, nullptr },
        { "can_horizontally_scroll", reinterpret_cast<getter>(OrientedVirtualizingPanel_get_CanHorizontallyScroll), reinterpret_cast<setter>(OrientedVirtualizingPanel_put_CanHorizontallyScroll), nullptr, nullptr },
        { "extent_height", reinterpret_cast<getter>(OrientedVirtualizingPanel_get_ExtentHeight), nullptr, nullptr, nullptr },
        { "extent_width", reinterpret_cast<getter>(OrientedVirtualizingPanel_get_ExtentWidth), nullptr, nullptr, nullptr },
        { "horizontal_offset", reinterpret_cast<getter>(OrientedVirtualizingPanel_get_HorizontalOffset), nullptr, nullptr, nullptr },
        { "vertical_offset", reinterpret_cast<getter>(OrientedVirtualizingPanel_get_VerticalOffset), nullptr, nullptr, nullptr },
        { "viewport_height", reinterpret_cast<getter>(OrientedVirtualizingPanel_get_ViewportHeight), nullptr, nullptr, nullptr },
        { "viewport_width", reinterpret_cast<getter>(OrientedVirtualizingPanel_get_ViewportWidth), nullptr, nullptr, nullptr },
        { "are_horizontal_snap_points_regular", reinterpret_cast<getter>(OrientedVirtualizingPanel_get_AreHorizontalSnapPointsRegular), nullptr, nullptr, nullptr },
        { "are_vertical_snap_points_regular", reinterpret_cast<getter>(OrientedVirtualizingPanel_get_AreVerticalSnapPointsRegular), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_OrientedVirtualizingPanel[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_OrientedVirtualizingPanel) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_OrientedVirtualizingPanel) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_OrientedVirtualizingPanel) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_OrientedVirtualizingPanel) },
        { },
    };

    static PyType_Spec type_spec_OrientedVirtualizingPanel =
    {
        "winrt._winrt_microsoft_ui_xaml_controls_primitives.OrientedVirtualizingPanel",
        sizeof(py::wrapper::Microsoft::UI::Xaml::Controls::Primitives::OrientedVirtualizingPanel),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_OrientedVirtualizingPanel
    };

    // ----- PickerFlyoutBase class --------------------

    static PyObject* _new_PickerFlyoutBase(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Microsoft::UI::Xaml::Controls::Primitives::PickerFlyoutBase>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Microsoft::UI::Xaml::Controls::Primitives::PickerFlyoutBase>::type_name);
        return nullptr;
    }

    static void _dealloc_PickerFlyoutBase(py::wrapper::Microsoft::UI::Xaml::Controls::Primitives::PickerFlyoutBase* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* PickerFlyoutBase_GetTitle(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Xaml.Controls.Primitives.PickerFlyoutBase", L"GetTitle", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Microsoft::UI::Xaml::DependencyObject>(args, 0);

                return py::convert(winrt::Microsoft::UI::Xaml::Controls::Primitives::PickerFlyoutBase::GetTitle(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PickerFlyoutBase_OnConfirmed(py::wrapper::Microsoft::UI::Xaml::Controls::Primitives::PickerFlyoutBase* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Xaml.Controls.Primitives.PickerFlyoutBase", L"OnConfirmed", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                self->obj.OnConfirmed();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PickerFlyoutBase_SetTitle(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Xaml.Controls.Primitives.PickerFlyoutBase", L"SetTitle", 2))
            {
                py::set_arg_count_version_error(2);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Microsoft::UI::Xaml::DependencyObject>(args, 0);
                auto param1 = py::convert_to<winrt::hstring>(args, 1);

                winrt::Microsoft::UI::Xaml::Controls::Primitives::PickerFlyoutBase::SetTitle(param0, param1);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PickerFlyoutBase_ShouldShowConfirmationButtons(py::wrapper::Microsoft::UI::Xaml::Controls::Primitives::PickerFlyoutBase* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Xaml.Controls.Primitives.PickerFlyoutBase", L"ShouldShowConfirmationButtons", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(self->obj.ShouldShowConfirmationButtons());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PickerFlyoutBase_get_TitleProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.PickerFlyoutBase", L"TitleProperty"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Microsoft::UI::Xaml::Controls::Primitives::PickerFlyoutBase::TitleProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_PickerFlyoutBase(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Microsoft::UI::Xaml::Controls::Primitives::PickerFlyoutBase>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_PickerFlyoutBase(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Microsoft::UI::Xaml::Controls::Primitives::PickerFlyoutBase>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_PickerFlyoutBase[] = {
        { "on_confirmed", reinterpret_cast<PyCFunction>(PickerFlyoutBase_OnConfirmed), METH_VARARGS, nullptr },
        { "should_show_confirmation_buttons", reinterpret_cast<PyCFunction>(PickerFlyoutBase_ShouldShowConfirmationButtons), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_PickerFlyoutBase, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_PickerFlyoutBase), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_PickerFlyoutBase[] = {
        { }
    };

    static PyType_Slot _type_slots_PickerFlyoutBase[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_PickerFlyoutBase) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_PickerFlyoutBase) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_PickerFlyoutBase) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_PickerFlyoutBase) },
        { },
    };

    static PyType_Spec type_spec_PickerFlyoutBase =
    {
        "winrt._winrt_microsoft_ui_xaml_controls_primitives.PickerFlyoutBase",
        sizeof(py::wrapper::Microsoft::UI::Xaml::Controls::Primitives::PickerFlyoutBase),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_PickerFlyoutBase
    };

    static PyGetSetDef getset_PickerFlyoutBase_Static[] = {
        { "title_property", reinterpret_cast<getter>(PickerFlyoutBase_get_TitleProperty), nullptr, nullptr, nullptr },
        { }
    };

    static PyMethodDef methods_PickerFlyoutBase_Static[] = {
        { "get_title", reinterpret_cast<PyCFunction>(PickerFlyoutBase_GetTitle), METH_VARARGS, nullptr },
        { "set_title", reinterpret_cast<PyCFunction>(PickerFlyoutBase_SetTitle), METH_VARARGS, nullptr },
        { }
    };

    static PyType_Slot type_slots_PickerFlyoutBase_Static[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_PickerFlyoutBase_Static) },
        { Py_tp_methods, reinterpret_cast<void*>(methods_PickerFlyoutBase_Static) },
        { }
    };

    static PyType_Spec type_spec_PickerFlyoutBase_Static =
    {
        "winrt._winrt_microsoft_ui_xaml_controls_primitives.PickerFlyoutBase_Static",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT,
        type_slots_PickerFlyoutBase_Static
    };

    // ----- PivotHeaderItem class --------------------

    static PyObject* _new_PivotHeaderItem(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 0)
        {
            try
            {
                winrt::Microsoft::UI::Xaml::Controls::Primitives::PivotHeaderItem instance{  };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_PivotHeaderItem(py::wrapper::Microsoft::UI::Xaml::Controls::Primitives::PivotHeaderItem* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* _assign_array_PivotHeaderItem(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Microsoft::UI::Xaml::Controls::Primitives::PivotHeaderItem>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_PivotHeaderItem(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Microsoft::UI::Xaml::Controls::Primitives::PivotHeaderItem>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_PivotHeaderItem[] = {
        { "_assign_array_", _assign_array_PivotHeaderItem, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_PivotHeaderItem), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_PivotHeaderItem[] = {
        { }
    };

    static PyType_Slot _type_slots_PivotHeaderItem[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_PivotHeaderItem) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_PivotHeaderItem) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_PivotHeaderItem) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_PivotHeaderItem) },
        { },
    };

    static PyType_Spec type_spec_PivotHeaderItem =
    {
        "winrt._winrt_microsoft_ui_xaml_controls_primitives.PivotHeaderItem",
        sizeof(py::wrapper::Microsoft::UI::Xaml::Controls::Primitives::PivotHeaderItem),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_PivotHeaderItem
    };

    // ----- PivotHeaderPanel class --------------------

    static PyObject* _new_PivotHeaderPanel(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 0)
        {
            try
            {
                winrt::Microsoft::UI::Xaml::Controls::Primitives::PivotHeaderPanel instance{  };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_PivotHeaderPanel(py::wrapper::Microsoft::UI::Xaml::Controls::Primitives::PivotHeaderPanel* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* _assign_array_PivotHeaderPanel(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Microsoft::UI::Xaml::Controls::Primitives::PivotHeaderPanel>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_PivotHeaderPanel(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Microsoft::UI::Xaml::Controls::Primitives::PivotHeaderPanel>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_PivotHeaderPanel[] = {
        { "_assign_array_", _assign_array_PivotHeaderPanel, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_PivotHeaderPanel), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_PivotHeaderPanel[] = {
        { }
    };

    static PyType_Slot _type_slots_PivotHeaderPanel[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_PivotHeaderPanel) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_PivotHeaderPanel) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_PivotHeaderPanel) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_PivotHeaderPanel) },
        { },
    };

    static PyType_Spec type_spec_PivotHeaderPanel =
    {
        "winrt._winrt_microsoft_ui_xaml_controls_primitives.PivotHeaderPanel",
        sizeof(py::wrapper::Microsoft::UI::Xaml::Controls::Primitives::PivotHeaderPanel),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_PivotHeaderPanel
    };

    // ----- PivotPanel class --------------------

    static PyObject* _new_PivotPanel(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 0)
        {
            try
            {
                winrt::Microsoft::UI::Xaml::Controls::Primitives::PivotPanel instance{  };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_PivotPanel(py::wrapper::Microsoft::UI::Xaml::Controls::Primitives::PivotPanel* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* PivotPanel_GetIrregularSnapPoints(py::wrapper::Microsoft::UI::Xaml::Controls::Primitives::PivotPanel* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Xaml.Controls.Primitives.PivotPanel", L"GetIrregularSnapPoints", 2))
            {
                py::set_arg_count_version_error(2);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Microsoft::UI::Xaml::Controls::Orientation>(args, 0);
                auto param1 = py::convert_to<winrt::Microsoft::UI::Xaml::Controls::Primitives::SnapPointsAlignment>(args, 1);

                return py::convert(self->obj.GetIrregularSnapPoints(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PivotPanel_GetRegularSnapPoints(py::wrapper::Microsoft::UI::Xaml::Controls::Primitives::PivotPanel* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Xaml.Controls.Primitives.PivotPanel", L"GetRegularSnapPoints", 2))
            {
                py::set_arg_count_version_error(2);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Microsoft::UI::Xaml::Controls::Orientation>(args, 0);
                auto param1 = py::convert_to<winrt::Microsoft::UI::Xaml::Controls::Primitives::SnapPointsAlignment>(args, 1);
                float param2 {  };

                auto return_value = self->obj.GetRegularSnapPoints(param0, param1, param2);

                py::pyobj_handle out_return_value{ py::convert(return_value) };
                if (!out_return_value)
                {
                    return nullptr;
                }
                py::pyobj_handle out2{ py::convert(param2) };
                if (!out2)
                {
                    return nullptr;
                }
                return PyTuple_Pack(2, out_return_value.get(), out2.get());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PivotPanel_get_AreHorizontalSnapPointsRegular(py::wrapper::Microsoft::UI::Xaml::Controls::Primitives::PivotPanel* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.PivotPanel", L"AreHorizontalSnapPointsRegular"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.AreHorizontalSnapPointsRegular());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PivotPanel_get_AreVerticalSnapPointsRegular(py::wrapper::Microsoft::UI::Xaml::Controls::Primitives::PivotPanel* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.PivotPanel", L"AreVerticalSnapPointsRegular"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.AreVerticalSnapPointsRegular());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PivotPanel_add_HorizontalSnapPointsChanged(py::wrapper::Microsoft::UI::Xaml::Controls::Primitives::PivotPanel* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Microsoft.UI.Xaml.Controls.Primitives.PivotPanel", L"HorizontalSnapPointsChanged"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::EventHandler<winrt::Windows::Foundation::IInspectable>>(arg);

            return py::convert(self->obj.HorizontalSnapPointsChanged(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PivotPanel_remove_HorizontalSnapPointsChanged(py::wrapper::Microsoft::UI::Xaml::Controls::Primitives::PivotPanel* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Microsoft.UI.Xaml.Controls.Primitives.PivotPanel", L"HorizontalSnapPointsChanged"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.HorizontalSnapPointsChanged(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PivotPanel_add_VerticalSnapPointsChanged(py::wrapper::Microsoft::UI::Xaml::Controls::Primitives::PivotPanel* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Microsoft.UI.Xaml.Controls.Primitives.PivotPanel", L"VerticalSnapPointsChanged"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::EventHandler<winrt::Windows::Foundation::IInspectable>>(arg);

            return py::convert(self->obj.VerticalSnapPointsChanged(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PivotPanel_remove_VerticalSnapPointsChanged(py::wrapper::Microsoft::UI::Xaml::Controls::Primitives::PivotPanel* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Microsoft.UI.Xaml.Controls.Primitives.PivotPanel", L"VerticalSnapPointsChanged"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.VerticalSnapPointsChanged(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_PivotPanel(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Microsoft::UI::Xaml::Controls::Primitives::PivotPanel>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_PivotPanel(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Microsoft::UI::Xaml::Controls::Primitives::PivotPanel>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_PivotPanel[] = {
        { "get_irregular_snap_points", reinterpret_cast<PyCFunction>(PivotPanel_GetIrregularSnapPoints), METH_VARARGS, nullptr },
        { "get_regular_snap_points", reinterpret_cast<PyCFunction>(PivotPanel_GetRegularSnapPoints), METH_VARARGS, nullptr },
        { "add_horizontal_snap_points_changed", reinterpret_cast<PyCFunction>(PivotPanel_add_HorizontalSnapPointsChanged), METH_O, nullptr },
        { "remove_horizontal_snap_points_changed", reinterpret_cast<PyCFunction>(PivotPanel_remove_HorizontalSnapPointsChanged), METH_O, nullptr },
        { "add_vertical_snap_points_changed", reinterpret_cast<PyCFunction>(PivotPanel_add_VerticalSnapPointsChanged), METH_O, nullptr },
        { "remove_vertical_snap_points_changed", reinterpret_cast<PyCFunction>(PivotPanel_remove_VerticalSnapPointsChanged), METH_O, nullptr },
        { "_assign_array_", _assign_array_PivotPanel, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_PivotPanel), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_PivotPanel[] = {
        { "are_horizontal_snap_points_regular", reinterpret_cast<getter>(PivotPanel_get_AreHorizontalSnapPointsRegular), nullptr, nullptr, nullptr },
        { "are_vertical_snap_points_regular", reinterpret_cast<getter>(PivotPanel_get_AreVerticalSnapPointsRegular), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_PivotPanel[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_PivotPanel) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_PivotPanel) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_PivotPanel) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_PivotPanel) },
        { },
    };

    static PyType_Spec type_spec_PivotPanel =
    {
        "winrt._winrt_microsoft_ui_xaml_controls_primitives.PivotPanel",
        sizeof(py::wrapper::Microsoft::UI::Xaml::Controls::Primitives::PivotPanel),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_PivotPanel
    };

    // ----- Popup class --------------------

    static PyObject* _new_Popup(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 0)
        {
            try
            {
                winrt::Microsoft::UI::Xaml::Controls::Primitives::Popup instance{  };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_Popup(py::wrapper::Microsoft::UI::Xaml::Controls::Primitives::Popup* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* Popup_get_VerticalOffset(py::wrapper::Microsoft::UI::Xaml::Controls::Primitives::Popup* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.Popup", L"VerticalOffset"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.VerticalOffset());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int Popup_put_VerticalOffset(py::wrapper::Microsoft::UI::Xaml::Controls::Primitives::Popup* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.Popup", L"VerticalOffset"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<double>(arg);

            self->obj.VerticalOffset(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* Popup_get_ShouldConstrainToRootBounds(py::wrapper::Microsoft::UI::Xaml::Controls::Primitives::Popup* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.Popup", L"ShouldConstrainToRootBounds"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.ShouldConstrainToRootBounds());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int Popup_put_ShouldConstrainToRootBounds(py::wrapper::Microsoft::UI::Xaml::Controls::Primitives::Popup* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.Popup", L"ShouldConstrainToRootBounds"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<bool>(arg);

            self->obj.ShouldConstrainToRootBounds(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* Popup_get_LightDismissOverlayMode(py::wrapper::Microsoft::UI::Xaml::Controls::Primitives::Popup* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.Popup", L"LightDismissOverlayMode"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.LightDismissOverlayMode());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int Popup_put_LightDismissOverlayMode(py::wrapper::Microsoft::UI::Xaml::Controls::Primitives::Popup* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.Popup", L"LightDismissOverlayMode"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Microsoft::UI::Xaml::Controls::LightDismissOverlayMode>(arg);

            self->obj.LightDismissOverlayMode(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* Popup_get_IsOpen(py::wrapper::Microsoft::UI::Xaml::Controls::Primitives::Popup* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.Popup", L"IsOpen"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.IsOpen());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int Popup_put_IsOpen(py::wrapper::Microsoft::UI::Xaml::Controls::Primitives::Popup* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.Popup", L"IsOpen"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<bool>(arg);

            self->obj.IsOpen(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* Popup_get_IsLightDismissEnabled(py::wrapper::Microsoft::UI::Xaml::Controls::Primitives::Popup* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.Popup", L"IsLightDismissEnabled"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.IsLightDismissEnabled());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int Popup_put_IsLightDismissEnabled(py::wrapper::Microsoft::UI::Xaml::Controls::Primitives::Popup* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.Popup", L"IsLightDismissEnabled"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<bool>(arg);

            self->obj.IsLightDismissEnabled(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* Popup_get_HorizontalOffset(py::wrapper::Microsoft::UI::Xaml::Controls::Primitives::Popup* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.Popup", L"HorizontalOffset"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.HorizontalOffset());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int Popup_put_HorizontalOffset(py::wrapper::Microsoft::UI::Xaml::Controls::Primitives::Popup* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.Popup", L"HorizontalOffset"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<double>(arg);

            self->obj.HorizontalOffset(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* Popup_get_ChildTransitions(py::wrapper::Microsoft::UI::Xaml::Controls::Primitives::Popup* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.Popup", L"ChildTransitions"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.ChildTransitions());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int Popup_put_ChildTransitions(py::wrapper::Microsoft::UI::Xaml::Controls::Primitives::Popup* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.Popup", L"ChildTransitions"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Microsoft::UI::Xaml::Media::Animation::TransitionCollection>(arg);

            self->obj.ChildTransitions(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* Popup_get_Child(py::wrapper::Microsoft::UI::Xaml::Controls::Primitives::Popup* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.Popup", L"Child"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Child());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int Popup_put_Child(py::wrapper::Microsoft::UI::Xaml::Controls::Primitives::Popup* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.Popup", L"Child"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Microsoft::UI::Xaml::UIElement>(arg);

            self->obj.Child(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* Popup_get_IsConstrainedToRootBounds(py::wrapper::Microsoft::UI::Xaml::Controls::Primitives::Popup* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.Popup", L"IsConstrainedToRootBounds"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.IsConstrainedToRootBounds());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* Popup_get_PlacementTarget(py::wrapper::Microsoft::UI::Xaml::Controls::Primitives::Popup* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.Popup", L"PlacementTarget"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.PlacementTarget());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int Popup_put_PlacementTarget(py::wrapper::Microsoft::UI::Xaml::Controls::Primitives::Popup* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.Popup", L"PlacementTarget"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Microsoft::UI::Xaml::FrameworkElement>(arg);

            self->obj.PlacementTarget(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* Popup_get_DesiredPlacement(py::wrapper::Microsoft::UI::Xaml::Controls::Primitives::Popup* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.Popup", L"DesiredPlacement"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.DesiredPlacement());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int Popup_put_DesiredPlacement(py::wrapper::Microsoft::UI::Xaml::Controls::Primitives::Popup* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.Popup", L"DesiredPlacement"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Microsoft::UI::Xaml::Controls::Primitives::PopupPlacementMode>(arg);

            self->obj.DesiredPlacement(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* Popup_get_ActualPlacement(py::wrapper::Microsoft::UI::Xaml::Controls::Primitives::Popup* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.Popup", L"ActualPlacement"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.ActualPlacement());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* Popup_get_SystemBackdrop(py::wrapper::Microsoft::UI::Xaml::Controls::Primitives::Popup* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.Popup", L"SystemBackdrop"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.SystemBackdrop());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int Popup_put_SystemBackdrop(py::wrapper::Microsoft::UI::Xaml::Controls::Primitives::Popup* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.Popup", L"SystemBackdrop"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Microsoft::UI::Xaml::Media::SystemBackdrop>(arg);

            self->obj.SystemBackdrop(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* Popup_get_ChildProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.Popup", L"ChildProperty"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Microsoft::UI::Xaml::Controls::Primitives::Popup::ChildProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* Popup_get_ChildTransitionsProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.Popup", L"ChildTransitionsProperty"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Microsoft::UI::Xaml::Controls::Primitives::Popup::ChildTransitionsProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* Popup_get_HorizontalOffsetProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.Popup", L"HorizontalOffsetProperty"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Microsoft::UI::Xaml::Controls::Primitives::Popup::HorizontalOffsetProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* Popup_get_IsLightDismissEnabledProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.Popup", L"IsLightDismissEnabledProperty"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Microsoft::UI::Xaml::Controls::Primitives::Popup::IsLightDismissEnabledProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* Popup_get_IsOpenProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.Popup", L"IsOpenProperty"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Microsoft::UI::Xaml::Controls::Primitives::Popup::IsOpenProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* Popup_get_LightDismissOverlayModeProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.Popup", L"LightDismissOverlayModeProperty"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Microsoft::UI::Xaml::Controls::Primitives::Popup::LightDismissOverlayModeProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* Popup_get_ShouldConstrainToRootBoundsProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.Popup", L"ShouldConstrainToRootBoundsProperty"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Microsoft::UI::Xaml::Controls::Primitives::Popup::ShouldConstrainToRootBoundsProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* Popup_get_VerticalOffsetProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.Popup", L"VerticalOffsetProperty"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Microsoft::UI::Xaml::Controls::Primitives::Popup::VerticalOffsetProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* Popup_get_DesiredPlacementProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.Popup", L"DesiredPlacementProperty"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Microsoft::UI::Xaml::Controls::Primitives::Popup::DesiredPlacementProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* Popup_get_PlacementTargetProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.Popup", L"PlacementTargetProperty"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Microsoft::UI::Xaml::Controls::Primitives::Popup::PlacementTargetProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* Popup_get_SystemBackdropProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.Popup", L"SystemBackdropProperty"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Microsoft::UI::Xaml::Controls::Primitives::Popup::SystemBackdropProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* Popup_add_Closed(py::wrapper::Microsoft::UI::Xaml::Controls::Primitives::Popup* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Microsoft.UI.Xaml.Controls.Primitives.Popup", L"Closed"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::EventHandler<winrt::Windows::Foundation::IInspectable>>(arg);

            return py::convert(self->obj.Closed(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* Popup_remove_Closed(py::wrapper::Microsoft::UI::Xaml::Controls::Primitives::Popup* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Microsoft.UI.Xaml.Controls.Primitives.Popup", L"Closed"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.Closed(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* Popup_add_Opened(py::wrapper::Microsoft::UI::Xaml::Controls::Primitives::Popup* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Microsoft.UI.Xaml.Controls.Primitives.Popup", L"Opened"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::EventHandler<winrt::Windows::Foundation::IInspectable>>(arg);

            return py::convert(self->obj.Opened(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* Popup_remove_Opened(py::wrapper::Microsoft::UI::Xaml::Controls::Primitives::Popup* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Microsoft.UI.Xaml.Controls.Primitives.Popup", L"Opened"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.Opened(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* Popup_add_ActualPlacementChanged(py::wrapper::Microsoft::UI::Xaml::Controls::Primitives::Popup* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Microsoft.UI.Xaml.Controls.Primitives.Popup", L"ActualPlacementChanged"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::EventHandler<winrt::Windows::Foundation::IInspectable>>(arg);

            return py::convert(self->obj.ActualPlacementChanged(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* Popup_remove_ActualPlacementChanged(py::wrapper::Microsoft::UI::Xaml::Controls::Primitives::Popup* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Microsoft.UI.Xaml.Controls.Primitives.Popup", L"ActualPlacementChanged"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.ActualPlacementChanged(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_Popup(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Microsoft::UI::Xaml::Controls::Primitives::Popup>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_Popup(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Microsoft::UI::Xaml::Controls::Primitives::Popup>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_Popup[] = {
        { "add_closed", reinterpret_cast<PyCFunction>(Popup_add_Closed), METH_O, nullptr },
        { "remove_closed", reinterpret_cast<PyCFunction>(Popup_remove_Closed), METH_O, nullptr },
        { "add_opened", reinterpret_cast<PyCFunction>(Popup_add_Opened), METH_O, nullptr },
        { "remove_opened", reinterpret_cast<PyCFunction>(Popup_remove_Opened), METH_O, nullptr },
        { "add_actual_placement_changed", reinterpret_cast<PyCFunction>(Popup_add_ActualPlacementChanged), METH_O, nullptr },
        { "remove_actual_placement_changed", reinterpret_cast<PyCFunction>(Popup_remove_ActualPlacementChanged), METH_O, nullptr },
        { "_assign_array_", _assign_array_Popup, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_Popup), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_Popup[] = {
        { "vertical_offset", reinterpret_cast<getter>(Popup_get_VerticalOffset), reinterpret_cast<setter>(Popup_put_VerticalOffset), nullptr, nullptr },
        { "should_constrain_to_root_bounds", reinterpret_cast<getter>(Popup_get_ShouldConstrainToRootBounds), reinterpret_cast<setter>(Popup_put_ShouldConstrainToRootBounds), nullptr, nullptr },
        { "light_dismiss_overlay_mode", reinterpret_cast<getter>(Popup_get_LightDismissOverlayMode), reinterpret_cast<setter>(Popup_put_LightDismissOverlayMode), nullptr, nullptr },
        { "is_open", reinterpret_cast<getter>(Popup_get_IsOpen), reinterpret_cast<setter>(Popup_put_IsOpen), nullptr, nullptr },
        { "is_light_dismiss_enabled", reinterpret_cast<getter>(Popup_get_IsLightDismissEnabled), reinterpret_cast<setter>(Popup_put_IsLightDismissEnabled), nullptr, nullptr },
        { "horizontal_offset", reinterpret_cast<getter>(Popup_get_HorizontalOffset), reinterpret_cast<setter>(Popup_put_HorizontalOffset), nullptr, nullptr },
        { "child_transitions", reinterpret_cast<getter>(Popup_get_ChildTransitions), reinterpret_cast<setter>(Popup_put_ChildTransitions), nullptr, nullptr },
        { "child", reinterpret_cast<getter>(Popup_get_Child), reinterpret_cast<setter>(Popup_put_Child), nullptr, nullptr },
        { "is_constrained_to_root_bounds", reinterpret_cast<getter>(Popup_get_IsConstrainedToRootBounds), nullptr, nullptr, nullptr },
        { "placement_target", reinterpret_cast<getter>(Popup_get_PlacementTarget), reinterpret_cast<setter>(Popup_put_PlacementTarget), nullptr, nullptr },
        { "desired_placement", reinterpret_cast<getter>(Popup_get_DesiredPlacement), reinterpret_cast<setter>(Popup_put_DesiredPlacement), nullptr, nullptr },
        { "actual_placement", reinterpret_cast<getter>(Popup_get_ActualPlacement), nullptr, nullptr, nullptr },
        { "system_backdrop", reinterpret_cast<getter>(Popup_get_SystemBackdrop), reinterpret_cast<setter>(Popup_put_SystemBackdrop), nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_Popup[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_Popup) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_Popup) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_Popup) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_Popup) },
        { },
    };

    static PyType_Spec type_spec_Popup =
    {
        "winrt._winrt_microsoft_ui_xaml_controls_primitives.Popup",
        sizeof(py::wrapper::Microsoft::UI::Xaml::Controls::Primitives::Popup),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_Popup
    };

    static PyGetSetDef getset_Popup_Static[] = {
        { "child_property", reinterpret_cast<getter>(Popup_get_ChildProperty), nullptr, nullptr, nullptr },
        { "child_transitions_property", reinterpret_cast<getter>(Popup_get_ChildTransitionsProperty), nullptr, nullptr, nullptr },
        { "horizontal_offset_property", reinterpret_cast<getter>(Popup_get_HorizontalOffsetProperty), nullptr, nullptr, nullptr },
        { "is_light_dismiss_enabled_property", reinterpret_cast<getter>(Popup_get_IsLightDismissEnabledProperty), nullptr, nullptr, nullptr },
        { "is_open_property", reinterpret_cast<getter>(Popup_get_IsOpenProperty), nullptr, nullptr, nullptr },
        { "light_dismiss_overlay_mode_property", reinterpret_cast<getter>(Popup_get_LightDismissOverlayModeProperty), nullptr, nullptr, nullptr },
        { "should_constrain_to_root_bounds_property", reinterpret_cast<getter>(Popup_get_ShouldConstrainToRootBoundsProperty), nullptr, nullptr, nullptr },
        { "vertical_offset_property", reinterpret_cast<getter>(Popup_get_VerticalOffsetProperty), nullptr, nullptr, nullptr },
        { "desired_placement_property", reinterpret_cast<getter>(Popup_get_DesiredPlacementProperty), nullptr, nullptr, nullptr },
        { "placement_target_property", reinterpret_cast<getter>(Popup_get_PlacementTargetProperty), nullptr, nullptr, nullptr },
        { "system_backdrop_property", reinterpret_cast<getter>(Popup_get_SystemBackdropProperty), nullptr, nullptr, nullptr },
        { }
    };

    static PyMethodDef methods_Popup_Static[] = {
        { }
    };

    static PyType_Slot type_slots_Popup_Static[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_Popup_Static) },
        { Py_tp_methods, reinterpret_cast<void*>(methods_Popup_Static) },
        { }
    };

    static PyType_Spec type_spec_Popup_Static =
    {
        "winrt._winrt_microsoft_ui_xaml_controls_primitives.Popup_Static",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT,
        type_slots_Popup_Static
    };

    // ----- RangeBase class --------------------

    static PyObject* _new_RangeBase(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Microsoft::UI::Xaml::Controls::Primitives::RangeBase>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Microsoft::UI::Xaml::Controls::Primitives::RangeBase>::type_name);
        return nullptr;
    }

    static void _dealloc_RangeBase(py::wrapper::Microsoft::UI::Xaml::Controls::Primitives::RangeBase* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* RangeBase_OnMaximumChanged(py::wrapper::Microsoft::UI::Xaml::Controls::Primitives::RangeBase* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Xaml.Controls.Primitives.RangeBase", L"OnMaximumChanged", 2))
            {
                py::set_arg_count_version_error(2);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<double>(args, 0);
                auto param1 = py::convert_to<double>(args, 1);

                self->obj.OnMaximumChanged(param0, param1);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* RangeBase_OnMinimumChanged(py::wrapper::Microsoft::UI::Xaml::Controls::Primitives::RangeBase* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Xaml.Controls.Primitives.RangeBase", L"OnMinimumChanged", 2))
            {
                py::set_arg_count_version_error(2);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<double>(args, 0);
                auto param1 = py::convert_to<double>(args, 1);

                self->obj.OnMinimumChanged(param0, param1);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* RangeBase_OnValueChanged(py::wrapper::Microsoft::UI::Xaml::Controls::Primitives::RangeBase* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Xaml.Controls.Primitives.RangeBase", L"OnValueChanged", 2))
            {
                py::set_arg_count_version_error(2);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<double>(args, 0);
                auto param1 = py::convert_to<double>(args, 1);

                self->obj.OnValueChanged(param0, param1);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* RangeBase_get_Value(py::wrapper::Microsoft::UI::Xaml::Controls::Primitives::RangeBase* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.RangeBase", L"Value"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Value());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int RangeBase_put_Value(py::wrapper::Microsoft::UI::Xaml::Controls::Primitives::RangeBase* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.RangeBase", L"Value"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<double>(arg);

            self->obj.Value(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* RangeBase_get_SmallChange(py::wrapper::Microsoft::UI::Xaml::Controls::Primitives::RangeBase* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.RangeBase", L"SmallChange"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.SmallChange());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int RangeBase_put_SmallChange(py::wrapper::Microsoft::UI::Xaml::Controls::Primitives::RangeBase* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.RangeBase", L"SmallChange"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<double>(arg);

            self->obj.SmallChange(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* RangeBase_get_Minimum(py::wrapper::Microsoft::UI::Xaml::Controls::Primitives::RangeBase* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.RangeBase", L"Minimum"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Minimum());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int RangeBase_put_Minimum(py::wrapper::Microsoft::UI::Xaml::Controls::Primitives::RangeBase* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.RangeBase", L"Minimum"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<double>(arg);

            self->obj.Minimum(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* RangeBase_get_Maximum(py::wrapper::Microsoft::UI::Xaml::Controls::Primitives::RangeBase* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.RangeBase", L"Maximum"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Maximum());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int RangeBase_put_Maximum(py::wrapper::Microsoft::UI::Xaml::Controls::Primitives::RangeBase* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.RangeBase", L"Maximum"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<double>(arg);

            self->obj.Maximum(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* RangeBase_get_LargeChange(py::wrapper::Microsoft::UI::Xaml::Controls::Primitives::RangeBase* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.RangeBase", L"LargeChange"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.LargeChange());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int RangeBase_put_LargeChange(py::wrapper::Microsoft::UI::Xaml::Controls::Primitives::RangeBase* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.RangeBase", L"LargeChange"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<double>(arg);

            self->obj.LargeChange(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* RangeBase_get_LargeChangeProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.RangeBase", L"LargeChangeProperty"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Microsoft::UI::Xaml::Controls::Primitives::RangeBase::LargeChangeProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* RangeBase_get_MaximumProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.RangeBase", L"MaximumProperty"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Microsoft::UI::Xaml::Controls::Primitives::RangeBase::MaximumProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* RangeBase_get_MinimumProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.RangeBase", L"MinimumProperty"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Microsoft::UI::Xaml::Controls::Primitives::RangeBase::MinimumProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* RangeBase_get_SmallChangeProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.RangeBase", L"SmallChangeProperty"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Microsoft::UI::Xaml::Controls::Primitives::RangeBase::SmallChangeProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* RangeBase_get_ValueProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.RangeBase", L"ValueProperty"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Microsoft::UI::Xaml::Controls::Primitives::RangeBase::ValueProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* RangeBase_add_ValueChanged(py::wrapper::Microsoft::UI::Xaml::Controls::Primitives::RangeBase* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Microsoft.UI.Xaml.Controls.Primitives.RangeBase", L"ValueChanged"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Microsoft::UI::Xaml::Controls::Primitives::RangeBaseValueChangedEventHandler>(arg);

            return py::convert(self->obj.ValueChanged(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* RangeBase_remove_ValueChanged(py::wrapper::Microsoft::UI::Xaml::Controls::Primitives::RangeBase* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Microsoft.UI.Xaml.Controls.Primitives.RangeBase", L"ValueChanged"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.ValueChanged(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_RangeBase(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Microsoft::UI::Xaml::Controls::Primitives::RangeBase>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_RangeBase(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Microsoft::UI::Xaml::Controls::Primitives::RangeBase>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_RangeBase[] = {
        { "on_maximum_changed", reinterpret_cast<PyCFunction>(RangeBase_OnMaximumChanged), METH_VARARGS, nullptr },
        { "on_minimum_changed", reinterpret_cast<PyCFunction>(RangeBase_OnMinimumChanged), METH_VARARGS, nullptr },
        { "on_value_changed", reinterpret_cast<PyCFunction>(RangeBase_OnValueChanged), METH_VARARGS, nullptr },
        { "add_value_changed", reinterpret_cast<PyCFunction>(RangeBase_add_ValueChanged), METH_O, nullptr },
        { "remove_value_changed", reinterpret_cast<PyCFunction>(RangeBase_remove_ValueChanged), METH_O, nullptr },
        { "_assign_array_", _assign_array_RangeBase, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_RangeBase), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_RangeBase[] = {
        { "value", reinterpret_cast<getter>(RangeBase_get_Value), reinterpret_cast<setter>(RangeBase_put_Value), nullptr, nullptr },
        { "small_change", reinterpret_cast<getter>(RangeBase_get_SmallChange), reinterpret_cast<setter>(RangeBase_put_SmallChange), nullptr, nullptr },
        { "minimum", reinterpret_cast<getter>(RangeBase_get_Minimum), reinterpret_cast<setter>(RangeBase_put_Minimum), nullptr, nullptr },
        { "maximum", reinterpret_cast<getter>(RangeBase_get_Maximum), reinterpret_cast<setter>(RangeBase_put_Maximum), nullptr, nullptr },
        { "large_change", reinterpret_cast<getter>(RangeBase_get_LargeChange), reinterpret_cast<setter>(RangeBase_put_LargeChange), nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_RangeBase[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_RangeBase) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_RangeBase) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_RangeBase) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_RangeBase) },
        { },
    };

    static PyType_Spec type_spec_RangeBase =
    {
        "winrt._winrt_microsoft_ui_xaml_controls_primitives.RangeBase",
        sizeof(py::wrapper::Microsoft::UI::Xaml::Controls::Primitives::RangeBase),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_RangeBase
    };

    static PyGetSetDef getset_RangeBase_Static[] = {
        { "large_change_property", reinterpret_cast<getter>(RangeBase_get_LargeChangeProperty), nullptr, nullptr, nullptr },
        { "maximum_property", reinterpret_cast<getter>(RangeBase_get_MaximumProperty), nullptr, nullptr, nullptr },
        { "minimum_property", reinterpret_cast<getter>(RangeBase_get_MinimumProperty), nullptr, nullptr, nullptr },
        { "small_change_property", reinterpret_cast<getter>(RangeBase_get_SmallChangeProperty), nullptr, nullptr, nullptr },
        { "value_property", reinterpret_cast<getter>(RangeBase_get_ValueProperty), nullptr, nullptr, nullptr },
        { }
    };

    static PyMethodDef methods_RangeBase_Static[] = {
        { }
    };

    static PyType_Slot type_slots_RangeBase_Static[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_RangeBase_Static) },
        { Py_tp_methods, reinterpret_cast<void*>(methods_RangeBase_Static) },
        { }
    };

    static PyType_Spec type_spec_RangeBase_Static =
    {
        "winrt._winrt_microsoft_ui_xaml_controls_primitives.RangeBase_Static",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT,
        type_slots_RangeBase_Static
    };

    // ----- RangeBaseValueChangedEventArgs class --------------------

    static PyObject* _new_RangeBaseValueChangedEventArgs(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Microsoft::UI::Xaml::Controls::Primitives::RangeBaseValueChangedEventArgs>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Microsoft::UI::Xaml::Controls::Primitives::RangeBaseValueChangedEventArgs>::type_name);
        return nullptr;
    }

    static void _dealloc_RangeBaseValueChangedEventArgs(py::wrapper::Microsoft::UI::Xaml::Controls::Primitives::RangeBaseValueChangedEventArgs* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* RangeBaseValueChangedEventArgs_get_NewValue(py::wrapper::Microsoft::UI::Xaml::Controls::Primitives::RangeBaseValueChangedEventArgs* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.RangeBaseValueChangedEventArgs", L"NewValue"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.NewValue());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* RangeBaseValueChangedEventArgs_get_OldValue(py::wrapper::Microsoft::UI::Xaml::Controls::Primitives::RangeBaseValueChangedEventArgs* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.RangeBaseValueChangedEventArgs", L"OldValue"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.OldValue());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_RangeBaseValueChangedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Microsoft::UI::Xaml::Controls::Primitives::RangeBaseValueChangedEventArgs>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_RangeBaseValueChangedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Microsoft::UI::Xaml::Controls::Primitives::RangeBaseValueChangedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_RangeBaseValueChangedEventArgs[] = {
        { "_assign_array_", _assign_array_RangeBaseValueChangedEventArgs, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_RangeBaseValueChangedEventArgs), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_RangeBaseValueChangedEventArgs[] = {
        { "new_value", reinterpret_cast<getter>(RangeBaseValueChangedEventArgs_get_NewValue), nullptr, nullptr, nullptr },
        { "old_value", reinterpret_cast<getter>(RangeBaseValueChangedEventArgs_get_OldValue), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_RangeBaseValueChangedEventArgs[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_RangeBaseValueChangedEventArgs) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_RangeBaseValueChangedEventArgs) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_RangeBaseValueChangedEventArgs) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_RangeBaseValueChangedEventArgs) },
        { },
    };

    static PyType_Spec type_spec_RangeBaseValueChangedEventArgs =
    {
        "winrt._winrt_microsoft_ui_xaml_controls_primitives.RangeBaseValueChangedEventArgs",
        sizeof(py::wrapper::Microsoft::UI::Xaml::Controls::Primitives::RangeBaseValueChangedEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_RangeBaseValueChangedEventArgs
    };

    // ----- RepeatButton class --------------------

    static PyObject* _new_RepeatButton(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 0)
        {
            try
            {
                winrt::Microsoft::UI::Xaml::Controls::Primitives::RepeatButton instance{  };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_RepeatButton(py::wrapper::Microsoft::UI::Xaml::Controls::Primitives::RepeatButton* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* RepeatButton_get_Interval(py::wrapper::Microsoft::UI::Xaml::Controls::Primitives::RepeatButton* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.RepeatButton", L"Interval"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Interval());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int RepeatButton_put_Interval(py::wrapper::Microsoft::UI::Xaml::Controls::Primitives::RepeatButton* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.RepeatButton", L"Interval"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<int32_t>(arg);

            self->obj.Interval(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* RepeatButton_get_Delay(py::wrapper::Microsoft::UI::Xaml::Controls::Primitives::RepeatButton* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.RepeatButton", L"Delay"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Delay());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int RepeatButton_put_Delay(py::wrapper::Microsoft::UI::Xaml::Controls::Primitives::RepeatButton* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.RepeatButton", L"Delay"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<int32_t>(arg);

            self->obj.Delay(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* RepeatButton_get_DelayProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.RepeatButton", L"DelayProperty"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Microsoft::UI::Xaml::Controls::Primitives::RepeatButton::DelayProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* RepeatButton_get_IntervalProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.RepeatButton", L"IntervalProperty"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Microsoft::UI::Xaml::Controls::Primitives::RepeatButton::IntervalProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_RepeatButton(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Microsoft::UI::Xaml::Controls::Primitives::RepeatButton>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_RepeatButton(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Microsoft::UI::Xaml::Controls::Primitives::RepeatButton>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_RepeatButton[] = {
        { "_assign_array_", _assign_array_RepeatButton, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_RepeatButton), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_RepeatButton[] = {
        { "interval", reinterpret_cast<getter>(RepeatButton_get_Interval), reinterpret_cast<setter>(RepeatButton_put_Interval), nullptr, nullptr },
        { "delay", reinterpret_cast<getter>(RepeatButton_get_Delay), reinterpret_cast<setter>(RepeatButton_put_Delay), nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_RepeatButton[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_RepeatButton) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_RepeatButton) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_RepeatButton) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_RepeatButton) },
        { },
    };

    static PyType_Spec type_spec_RepeatButton =
    {
        "winrt._winrt_microsoft_ui_xaml_controls_primitives.RepeatButton",
        sizeof(py::wrapper::Microsoft::UI::Xaml::Controls::Primitives::RepeatButton),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_RepeatButton
    };

    static PyGetSetDef getset_RepeatButton_Static[] = {
        { "delay_property", reinterpret_cast<getter>(RepeatButton_get_DelayProperty), nullptr, nullptr, nullptr },
        { "interval_property", reinterpret_cast<getter>(RepeatButton_get_IntervalProperty), nullptr, nullptr, nullptr },
        { }
    };

    static PyMethodDef methods_RepeatButton_Static[] = {
        { }
    };

    static PyType_Slot type_slots_RepeatButton_Static[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_RepeatButton_Static) },
        { Py_tp_methods, reinterpret_cast<void*>(methods_RepeatButton_Static) },
        { }
    };

    static PyType_Spec type_spec_RepeatButton_Static =
    {
        "winrt._winrt_microsoft_ui_xaml_controls_primitives.RepeatButton_Static",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT,
        type_slots_RepeatButton_Static
    };

    // ----- RepeatedScrollSnapPoint class --------------------

    static PyObject* _new_RepeatedScrollSnapPoint(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 5)
        {
            try
            {
                auto param0 = py::convert_to<double>(args, 0);
                auto param1 = py::convert_to<double>(args, 1);
                auto param2 = py::convert_to<double>(args, 2);
                auto param3 = py::convert_to<double>(args, 3);
                auto param4 = py::convert_to<winrt::Microsoft::UI::Xaml::Controls::Primitives::ScrollSnapPointsAlignment>(args, 4);

                winrt::Microsoft::UI::Xaml::Controls::Primitives::RepeatedScrollSnapPoint instance{ param0, param1, param2, param3, param4 };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_RepeatedScrollSnapPoint(py::wrapper::Microsoft::UI::Xaml::Controls::Primitives::RepeatedScrollSnapPoint* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* RepeatedScrollSnapPoint_get_End(py::wrapper::Microsoft::UI::Xaml::Controls::Primitives::RepeatedScrollSnapPoint* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.RepeatedScrollSnapPoint", L"End"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.End());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* RepeatedScrollSnapPoint_get_Interval(py::wrapper::Microsoft::UI::Xaml::Controls::Primitives::RepeatedScrollSnapPoint* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.RepeatedScrollSnapPoint", L"Interval"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Interval());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* RepeatedScrollSnapPoint_get_Offset(py::wrapper::Microsoft::UI::Xaml::Controls::Primitives::RepeatedScrollSnapPoint* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.RepeatedScrollSnapPoint", L"Offset"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Offset());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* RepeatedScrollSnapPoint_get_Start(py::wrapper::Microsoft::UI::Xaml::Controls::Primitives::RepeatedScrollSnapPoint* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.RepeatedScrollSnapPoint", L"Start"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Start());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_RepeatedScrollSnapPoint(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Microsoft::UI::Xaml::Controls::Primitives::RepeatedScrollSnapPoint>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_RepeatedScrollSnapPoint(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Microsoft::UI::Xaml::Controls::Primitives::RepeatedScrollSnapPoint>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_RepeatedScrollSnapPoint[] = {
        { "_assign_array_", _assign_array_RepeatedScrollSnapPoint, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_RepeatedScrollSnapPoint), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_RepeatedScrollSnapPoint[] = {
        { "end", reinterpret_cast<getter>(RepeatedScrollSnapPoint_get_End), nullptr, nullptr, nullptr },
        { "interval", reinterpret_cast<getter>(RepeatedScrollSnapPoint_get_Interval), nullptr, nullptr, nullptr },
        { "offset", reinterpret_cast<getter>(RepeatedScrollSnapPoint_get_Offset), nullptr, nullptr, nullptr },
        { "start", reinterpret_cast<getter>(RepeatedScrollSnapPoint_get_Start), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_RepeatedScrollSnapPoint[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_RepeatedScrollSnapPoint) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_RepeatedScrollSnapPoint) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_RepeatedScrollSnapPoint) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_RepeatedScrollSnapPoint) },
        { },
    };

    static PyType_Spec type_spec_RepeatedScrollSnapPoint =
    {
        "winrt._winrt_microsoft_ui_xaml_controls_primitives.RepeatedScrollSnapPoint",
        sizeof(py::wrapper::Microsoft::UI::Xaml::Controls::Primitives::RepeatedScrollSnapPoint),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_RepeatedScrollSnapPoint
    };

    // ----- RepeatedZoomSnapPoint class --------------------

    static PyObject* _new_RepeatedZoomSnapPoint(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 4)
        {
            try
            {
                auto param0 = py::convert_to<double>(args, 0);
                auto param1 = py::convert_to<double>(args, 1);
                auto param2 = py::convert_to<double>(args, 2);
                auto param3 = py::convert_to<double>(args, 3);

                winrt::Microsoft::UI::Xaml::Controls::Primitives::RepeatedZoomSnapPoint instance{ param0, param1, param2, param3 };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_RepeatedZoomSnapPoint(py::wrapper::Microsoft::UI::Xaml::Controls::Primitives::RepeatedZoomSnapPoint* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* RepeatedZoomSnapPoint_get_End(py::wrapper::Microsoft::UI::Xaml::Controls::Primitives::RepeatedZoomSnapPoint* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.RepeatedZoomSnapPoint", L"End"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.End());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* RepeatedZoomSnapPoint_get_Interval(py::wrapper::Microsoft::UI::Xaml::Controls::Primitives::RepeatedZoomSnapPoint* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.RepeatedZoomSnapPoint", L"Interval"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Interval());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* RepeatedZoomSnapPoint_get_Offset(py::wrapper::Microsoft::UI::Xaml::Controls::Primitives::RepeatedZoomSnapPoint* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.RepeatedZoomSnapPoint", L"Offset"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Offset());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* RepeatedZoomSnapPoint_get_Start(py::wrapper::Microsoft::UI::Xaml::Controls::Primitives::RepeatedZoomSnapPoint* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.RepeatedZoomSnapPoint", L"Start"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Start());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_RepeatedZoomSnapPoint(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Microsoft::UI::Xaml::Controls::Primitives::RepeatedZoomSnapPoint>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_RepeatedZoomSnapPoint(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Microsoft::UI::Xaml::Controls::Primitives::RepeatedZoomSnapPoint>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_RepeatedZoomSnapPoint[] = {
        { "_assign_array_", _assign_array_RepeatedZoomSnapPoint, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_RepeatedZoomSnapPoint), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_RepeatedZoomSnapPoint[] = {
        { "end", reinterpret_cast<getter>(RepeatedZoomSnapPoint_get_End), nullptr, nullptr, nullptr },
        { "interval", reinterpret_cast<getter>(RepeatedZoomSnapPoint_get_Interval), nullptr, nullptr, nullptr },
        { "offset", reinterpret_cast<getter>(RepeatedZoomSnapPoint_get_Offset), nullptr, nullptr, nullptr },
        { "start", reinterpret_cast<getter>(RepeatedZoomSnapPoint_get_Start), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_RepeatedZoomSnapPoint[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_RepeatedZoomSnapPoint) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_RepeatedZoomSnapPoint) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_RepeatedZoomSnapPoint) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_RepeatedZoomSnapPoint) },
        { },
    };

    static PyType_Spec type_spec_RepeatedZoomSnapPoint =
    {
        "winrt._winrt_microsoft_ui_xaml_controls_primitives.RepeatedZoomSnapPoint",
        sizeof(py::wrapper::Microsoft::UI::Xaml::Controls::Primitives::RepeatedZoomSnapPoint),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_RepeatedZoomSnapPoint
    };

    // ----- ScrollBar class --------------------

    static PyObject* _new_ScrollBar(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 0)
        {
            try
            {
                winrt::Microsoft::UI::Xaml::Controls::Primitives::ScrollBar instance{  };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_ScrollBar(py::wrapper::Microsoft::UI::Xaml::Controls::Primitives::ScrollBar* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* ScrollBar_get_ViewportSize(py::wrapper::Microsoft::UI::Xaml::Controls::Primitives::ScrollBar* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.ScrollBar", L"ViewportSize"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.ViewportSize());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ScrollBar_put_ViewportSize(py::wrapper::Microsoft::UI::Xaml::Controls::Primitives::ScrollBar* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.ScrollBar", L"ViewportSize"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<double>(arg);

            self->obj.ViewportSize(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ScrollBar_get_Orientation(py::wrapper::Microsoft::UI::Xaml::Controls::Primitives::ScrollBar* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.ScrollBar", L"Orientation"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Orientation());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ScrollBar_put_Orientation(py::wrapper::Microsoft::UI::Xaml::Controls::Primitives::ScrollBar* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.ScrollBar", L"Orientation"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Microsoft::UI::Xaml::Controls::Orientation>(arg);

            self->obj.Orientation(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ScrollBar_get_IndicatorMode(py::wrapper::Microsoft::UI::Xaml::Controls::Primitives::ScrollBar* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.ScrollBar", L"IndicatorMode"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.IndicatorMode());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ScrollBar_put_IndicatorMode(py::wrapper::Microsoft::UI::Xaml::Controls::Primitives::ScrollBar* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.ScrollBar", L"IndicatorMode"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Microsoft::UI::Xaml::Controls::Primitives::ScrollingIndicatorMode>(arg);

            self->obj.IndicatorMode(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ScrollBar_get_IndicatorModeProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.ScrollBar", L"IndicatorModeProperty"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Microsoft::UI::Xaml::Controls::Primitives::ScrollBar::IndicatorModeProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ScrollBar_get_OrientationProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.ScrollBar", L"OrientationProperty"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Microsoft::UI::Xaml::Controls::Primitives::ScrollBar::OrientationProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ScrollBar_get_ViewportSizeProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.ScrollBar", L"ViewportSizeProperty"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Microsoft::UI::Xaml::Controls::Primitives::ScrollBar::ViewportSizeProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ScrollBar_add_Scroll(py::wrapper::Microsoft::UI::Xaml::Controls::Primitives::ScrollBar* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Microsoft.UI.Xaml.Controls.Primitives.ScrollBar", L"Scroll"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Microsoft::UI::Xaml::Controls::Primitives::ScrollEventHandler>(arg);

            return py::convert(self->obj.Scroll(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ScrollBar_remove_Scroll(py::wrapper::Microsoft::UI::Xaml::Controls::Primitives::ScrollBar* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Microsoft.UI.Xaml.Controls.Primitives.ScrollBar", L"Scroll"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.Scroll(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_ScrollBar(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Microsoft::UI::Xaml::Controls::Primitives::ScrollBar>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_ScrollBar(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Microsoft::UI::Xaml::Controls::Primitives::ScrollBar>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_ScrollBar[] = {
        { "add_scroll", reinterpret_cast<PyCFunction>(ScrollBar_add_Scroll), METH_O, nullptr },
        { "remove_scroll", reinterpret_cast<PyCFunction>(ScrollBar_remove_Scroll), METH_O, nullptr },
        { "_assign_array_", _assign_array_ScrollBar, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_ScrollBar), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_ScrollBar[] = {
        { "viewport_size", reinterpret_cast<getter>(ScrollBar_get_ViewportSize), reinterpret_cast<setter>(ScrollBar_put_ViewportSize), nullptr, nullptr },
        { "orientation", reinterpret_cast<getter>(ScrollBar_get_Orientation), reinterpret_cast<setter>(ScrollBar_put_Orientation), nullptr, nullptr },
        { "indicator_mode", reinterpret_cast<getter>(ScrollBar_get_IndicatorMode), reinterpret_cast<setter>(ScrollBar_put_IndicatorMode), nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_ScrollBar[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_ScrollBar) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_ScrollBar) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_ScrollBar) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_ScrollBar) },
        { },
    };

    static PyType_Spec type_spec_ScrollBar =
    {
        "winrt._winrt_microsoft_ui_xaml_controls_primitives.ScrollBar",
        sizeof(py::wrapper::Microsoft::UI::Xaml::Controls::Primitives::ScrollBar),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_ScrollBar
    };

    static PyGetSetDef getset_ScrollBar_Static[] = {
        { "indicator_mode_property", reinterpret_cast<getter>(ScrollBar_get_IndicatorModeProperty), nullptr, nullptr, nullptr },
        { "orientation_property", reinterpret_cast<getter>(ScrollBar_get_OrientationProperty), nullptr, nullptr, nullptr },
        { "viewport_size_property", reinterpret_cast<getter>(ScrollBar_get_ViewportSizeProperty), nullptr, nullptr, nullptr },
        { }
    };

    static PyMethodDef methods_ScrollBar_Static[] = {
        { }
    };

    static PyType_Slot type_slots_ScrollBar_Static[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_ScrollBar_Static) },
        { Py_tp_methods, reinterpret_cast<void*>(methods_ScrollBar_Static) },
        { }
    };

    static PyType_Spec type_spec_ScrollBar_Static =
    {
        "winrt._winrt_microsoft_ui_xaml_controls_primitives.ScrollBar_Static",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT,
        type_slots_ScrollBar_Static
    };

    // ----- ScrollControllerAddScrollVelocityRequestedEventArgs class --------------------

    static PyObject* _new_ScrollControllerAddScrollVelocityRequestedEventArgs(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<float>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Foundation::IReference<float>>(args, 1);

                winrt::Microsoft::UI::Xaml::Controls::Primitives::ScrollControllerAddScrollVelocityRequestedEventArgs instance{ param0, param1 };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_ScrollControllerAddScrollVelocityRequestedEventArgs(py::wrapper::Microsoft::UI::Xaml::Controls::Primitives::ScrollControllerAddScrollVelocityRequestedEventArgs* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* ScrollControllerAddScrollVelocityRequestedEventArgs_get_CorrelationId(py::wrapper::Microsoft::UI::Xaml::Controls::Primitives::ScrollControllerAddScrollVelocityRequestedEventArgs* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.ScrollControllerAddScrollVelocityRequestedEventArgs", L"CorrelationId"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.CorrelationId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ScrollControllerAddScrollVelocityRequestedEventArgs_put_CorrelationId(py::wrapper::Microsoft::UI::Xaml::Controls::Primitives::ScrollControllerAddScrollVelocityRequestedEventArgs* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.ScrollControllerAddScrollVelocityRequestedEventArgs", L"CorrelationId"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<int32_t>(arg);

            self->obj.CorrelationId(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ScrollControllerAddScrollVelocityRequestedEventArgs_get_InertiaDecayRate(py::wrapper::Microsoft::UI::Xaml::Controls::Primitives::ScrollControllerAddScrollVelocityRequestedEventArgs* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.ScrollControllerAddScrollVelocityRequestedEventArgs", L"InertiaDecayRate"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.InertiaDecayRate());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ScrollControllerAddScrollVelocityRequestedEventArgs_get_OffsetVelocity(py::wrapper::Microsoft::UI::Xaml::Controls::Primitives::ScrollControllerAddScrollVelocityRequestedEventArgs* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.ScrollControllerAddScrollVelocityRequestedEventArgs", L"OffsetVelocity"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.OffsetVelocity());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_ScrollControllerAddScrollVelocityRequestedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Microsoft::UI::Xaml::Controls::Primitives::ScrollControllerAddScrollVelocityRequestedEventArgs>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_ScrollControllerAddScrollVelocityRequestedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Microsoft::UI::Xaml::Controls::Primitives::ScrollControllerAddScrollVelocityRequestedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_ScrollControllerAddScrollVelocityRequestedEventArgs[] = {
        { "_assign_array_", _assign_array_ScrollControllerAddScrollVelocityRequestedEventArgs, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_ScrollControllerAddScrollVelocityRequestedEventArgs), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_ScrollControllerAddScrollVelocityRequestedEventArgs[] = {
        { "correlation_id", reinterpret_cast<getter>(ScrollControllerAddScrollVelocityRequestedEventArgs_get_CorrelationId), reinterpret_cast<setter>(ScrollControllerAddScrollVelocityRequestedEventArgs_put_CorrelationId), nullptr, nullptr },
        { "inertia_decay_rate", reinterpret_cast<getter>(ScrollControllerAddScrollVelocityRequestedEventArgs_get_InertiaDecayRate), nullptr, nullptr, nullptr },
        { "offset_velocity", reinterpret_cast<getter>(ScrollControllerAddScrollVelocityRequestedEventArgs_get_OffsetVelocity), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_ScrollControllerAddScrollVelocityRequestedEventArgs[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_ScrollControllerAddScrollVelocityRequestedEventArgs) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_ScrollControllerAddScrollVelocityRequestedEventArgs) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_ScrollControllerAddScrollVelocityRequestedEventArgs) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_ScrollControllerAddScrollVelocityRequestedEventArgs) },
        { },
    };

    static PyType_Spec type_spec_ScrollControllerAddScrollVelocityRequestedEventArgs =
    {
        "winrt._winrt_microsoft_ui_xaml_controls_primitives.ScrollControllerAddScrollVelocityRequestedEventArgs",
        sizeof(py::wrapper::Microsoft::UI::Xaml::Controls::Primitives::ScrollControllerAddScrollVelocityRequestedEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_ScrollControllerAddScrollVelocityRequestedEventArgs
    };

    // ----- ScrollControllerPanRequestedEventArgs class --------------------

    static PyObject* _new_ScrollControllerPanRequestedEventArgs(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Microsoft::UI::Input::PointerPoint>(args, 0);

                winrt::Microsoft::UI::Xaml::Controls::Primitives::ScrollControllerPanRequestedEventArgs instance{ param0 };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_ScrollControllerPanRequestedEventArgs(py::wrapper::Microsoft::UI::Xaml::Controls::Primitives::ScrollControllerPanRequestedEventArgs* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* ScrollControllerPanRequestedEventArgs_get_Handled(py::wrapper::Microsoft::UI::Xaml::Controls::Primitives::ScrollControllerPanRequestedEventArgs* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.ScrollControllerPanRequestedEventArgs", L"Handled"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Handled());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ScrollControllerPanRequestedEventArgs_put_Handled(py::wrapper::Microsoft::UI::Xaml::Controls::Primitives::ScrollControllerPanRequestedEventArgs* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.ScrollControllerPanRequestedEventArgs", L"Handled"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<bool>(arg);

            self->obj.Handled(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ScrollControllerPanRequestedEventArgs_get_PointerPoint(py::wrapper::Microsoft::UI::Xaml::Controls::Primitives::ScrollControllerPanRequestedEventArgs* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.ScrollControllerPanRequestedEventArgs", L"PointerPoint"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.PointerPoint());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_ScrollControllerPanRequestedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Microsoft::UI::Xaml::Controls::Primitives::ScrollControllerPanRequestedEventArgs>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_ScrollControllerPanRequestedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Microsoft::UI::Xaml::Controls::Primitives::ScrollControllerPanRequestedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_ScrollControllerPanRequestedEventArgs[] = {
        { "_assign_array_", _assign_array_ScrollControllerPanRequestedEventArgs, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_ScrollControllerPanRequestedEventArgs), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_ScrollControllerPanRequestedEventArgs[] = {
        { "handled", reinterpret_cast<getter>(ScrollControllerPanRequestedEventArgs_get_Handled), reinterpret_cast<setter>(ScrollControllerPanRequestedEventArgs_put_Handled), nullptr, nullptr },
        { "pointer_point", reinterpret_cast<getter>(ScrollControllerPanRequestedEventArgs_get_PointerPoint), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_ScrollControllerPanRequestedEventArgs[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_ScrollControllerPanRequestedEventArgs) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_ScrollControllerPanRequestedEventArgs) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_ScrollControllerPanRequestedEventArgs) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_ScrollControllerPanRequestedEventArgs) },
        { },
    };

    static PyType_Spec type_spec_ScrollControllerPanRequestedEventArgs =
    {
        "winrt._winrt_microsoft_ui_xaml_controls_primitives.ScrollControllerPanRequestedEventArgs",
        sizeof(py::wrapper::Microsoft::UI::Xaml::Controls::Primitives::ScrollControllerPanRequestedEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_ScrollControllerPanRequestedEventArgs
    };

    // ----- ScrollControllerScrollByRequestedEventArgs class --------------------

    static PyObject* _new_ScrollControllerScrollByRequestedEventArgs(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<double>(args, 0);
                auto param1 = py::convert_to<winrt::Microsoft::UI::Xaml::Controls::ScrollingScrollOptions>(args, 1);

                winrt::Microsoft::UI::Xaml::Controls::Primitives::ScrollControllerScrollByRequestedEventArgs instance{ param0, param1 };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_ScrollControllerScrollByRequestedEventArgs(py::wrapper::Microsoft::UI::Xaml::Controls::Primitives::ScrollControllerScrollByRequestedEventArgs* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* ScrollControllerScrollByRequestedEventArgs_get_CorrelationId(py::wrapper::Microsoft::UI::Xaml::Controls::Primitives::ScrollControllerScrollByRequestedEventArgs* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.ScrollControllerScrollByRequestedEventArgs", L"CorrelationId"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.CorrelationId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ScrollControllerScrollByRequestedEventArgs_put_CorrelationId(py::wrapper::Microsoft::UI::Xaml::Controls::Primitives::ScrollControllerScrollByRequestedEventArgs* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.ScrollControllerScrollByRequestedEventArgs", L"CorrelationId"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<int32_t>(arg);

            self->obj.CorrelationId(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ScrollControllerScrollByRequestedEventArgs_get_OffsetDelta(py::wrapper::Microsoft::UI::Xaml::Controls::Primitives::ScrollControllerScrollByRequestedEventArgs* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.ScrollControllerScrollByRequestedEventArgs", L"OffsetDelta"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.OffsetDelta());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ScrollControllerScrollByRequestedEventArgs_get_Options(py::wrapper::Microsoft::UI::Xaml::Controls::Primitives::ScrollControllerScrollByRequestedEventArgs* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.ScrollControllerScrollByRequestedEventArgs", L"Options"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Options());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_ScrollControllerScrollByRequestedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Microsoft::UI::Xaml::Controls::Primitives::ScrollControllerScrollByRequestedEventArgs>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_ScrollControllerScrollByRequestedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Microsoft::UI::Xaml::Controls::Primitives::ScrollControllerScrollByRequestedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_ScrollControllerScrollByRequestedEventArgs[] = {
        { "_assign_array_", _assign_array_ScrollControllerScrollByRequestedEventArgs, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_ScrollControllerScrollByRequestedEventArgs), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_ScrollControllerScrollByRequestedEventArgs[] = {
        { "correlation_id", reinterpret_cast<getter>(ScrollControllerScrollByRequestedEventArgs_get_CorrelationId), reinterpret_cast<setter>(ScrollControllerScrollByRequestedEventArgs_put_CorrelationId), nullptr, nullptr },
        { "offset_delta", reinterpret_cast<getter>(ScrollControllerScrollByRequestedEventArgs_get_OffsetDelta), nullptr, nullptr, nullptr },
        { "options", reinterpret_cast<getter>(ScrollControllerScrollByRequestedEventArgs_get_Options), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_ScrollControllerScrollByRequestedEventArgs[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_ScrollControllerScrollByRequestedEventArgs) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_ScrollControllerScrollByRequestedEventArgs) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_ScrollControllerScrollByRequestedEventArgs) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_ScrollControllerScrollByRequestedEventArgs) },
        { },
    };

    static PyType_Spec type_spec_ScrollControllerScrollByRequestedEventArgs =
    {
        "winrt._winrt_microsoft_ui_xaml_controls_primitives.ScrollControllerScrollByRequestedEventArgs",
        sizeof(py::wrapper::Microsoft::UI::Xaml::Controls::Primitives::ScrollControllerScrollByRequestedEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_ScrollControllerScrollByRequestedEventArgs
    };

    // ----- ScrollControllerScrollToRequestedEventArgs class --------------------

    static PyObject* _new_ScrollControllerScrollToRequestedEventArgs(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<double>(args, 0);
                auto param1 = py::convert_to<winrt::Microsoft::UI::Xaml::Controls::ScrollingScrollOptions>(args, 1);

                winrt::Microsoft::UI::Xaml::Controls::Primitives::ScrollControllerScrollToRequestedEventArgs instance{ param0, param1 };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_ScrollControllerScrollToRequestedEventArgs(py::wrapper::Microsoft::UI::Xaml::Controls::Primitives::ScrollControllerScrollToRequestedEventArgs* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* ScrollControllerScrollToRequestedEventArgs_get_CorrelationId(py::wrapper::Microsoft::UI::Xaml::Controls::Primitives::ScrollControllerScrollToRequestedEventArgs* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.ScrollControllerScrollToRequestedEventArgs", L"CorrelationId"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.CorrelationId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ScrollControllerScrollToRequestedEventArgs_put_CorrelationId(py::wrapper::Microsoft::UI::Xaml::Controls::Primitives::ScrollControllerScrollToRequestedEventArgs* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.ScrollControllerScrollToRequestedEventArgs", L"CorrelationId"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<int32_t>(arg);

            self->obj.CorrelationId(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ScrollControllerScrollToRequestedEventArgs_get_Offset(py::wrapper::Microsoft::UI::Xaml::Controls::Primitives::ScrollControllerScrollToRequestedEventArgs* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.ScrollControllerScrollToRequestedEventArgs", L"Offset"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Offset());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ScrollControllerScrollToRequestedEventArgs_get_Options(py::wrapper::Microsoft::UI::Xaml::Controls::Primitives::ScrollControllerScrollToRequestedEventArgs* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.ScrollControllerScrollToRequestedEventArgs", L"Options"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Options());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_ScrollControllerScrollToRequestedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Microsoft::UI::Xaml::Controls::Primitives::ScrollControllerScrollToRequestedEventArgs>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_ScrollControllerScrollToRequestedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Microsoft::UI::Xaml::Controls::Primitives::ScrollControllerScrollToRequestedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_ScrollControllerScrollToRequestedEventArgs[] = {
        { "_assign_array_", _assign_array_ScrollControllerScrollToRequestedEventArgs, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_ScrollControllerScrollToRequestedEventArgs), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_ScrollControllerScrollToRequestedEventArgs[] = {
        { "correlation_id", reinterpret_cast<getter>(ScrollControllerScrollToRequestedEventArgs_get_CorrelationId), reinterpret_cast<setter>(ScrollControllerScrollToRequestedEventArgs_put_CorrelationId), nullptr, nullptr },
        { "offset", reinterpret_cast<getter>(ScrollControllerScrollToRequestedEventArgs_get_Offset), nullptr, nullptr, nullptr },
        { "options", reinterpret_cast<getter>(ScrollControllerScrollToRequestedEventArgs_get_Options), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_ScrollControllerScrollToRequestedEventArgs[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_ScrollControllerScrollToRequestedEventArgs) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_ScrollControllerScrollToRequestedEventArgs) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_ScrollControllerScrollToRequestedEventArgs) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_ScrollControllerScrollToRequestedEventArgs) },
        { },
    };

    static PyType_Spec type_spec_ScrollControllerScrollToRequestedEventArgs =
    {
        "winrt._winrt_microsoft_ui_xaml_controls_primitives.ScrollControllerScrollToRequestedEventArgs",
        sizeof(py::wrapper::Microsoft::UI::Xaml::Controls::Primitives::ScrollControllerScrollToRequestedEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_ScrollControllerScrollToRequestedEventArgs
    };

    // ----- ScrollEventArgs class --------------------

    static PyObject* _new_ScrollEventArgs(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 0)
        {
            try
            {
                winrt::Microsoft::UI::Xaml::Controls::Primitives::ScrollEventArgs instance{  };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_ScrollEventArgs(py::wrapper::Microsoft::UI::Xaml::Controls::Primitives::ScrollEventArgs* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* ScrollEventArgs_get_NewValue(py::wrapper::Microsoft::UI::Xaml::Controls::Primitives::ScrollEventArgs* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.ScrollEventArgs", L"NewValue"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.NewValue());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ScrollEventArgs_get_ScrollEventType(py::wrapper::Microsoft::UI::Xaml::Controls::Primitives::ScrollEventArgs* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.ScrollEventArgs", L"ScrollEventType"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.ScrollEventType());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_ScrollEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Microsoft::UI::Xaml::Controls::Primitives::ScrollEventArgs>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_ScrollEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Microsoft::UI::Xaml::Controls::Primitives::ScrollEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_ScrollEventArgs[] = {
        { "_assign_array_", _assign_array_ScrollEventArgs, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_ScrollEventArgs), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_ScrollEventArgs[] = {
        { "new_value", reinterpret_cast<getter>(ScrollEventArgs_get_NewValue), nullptr, nullptr, nullptr },
        { "scroll_event_type", reinterpret_cast<getter>(ScrollEventArgs_get_ScrollEventType), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_ScrollEventArgs[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_ScrollEventArgs) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_ScrollEventArgs) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_ScrollEventArgs) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_ScrollEventArgs) },
        { },
    };

    static PyType_Spec type_spec_ScrollEventArgs =
    {
        "winrt._winrt_microsoft_ui_xaml_controls_primitives.ScrollEventArgs",
        sizeof(py::wrapper::Microsoft::UI::Xaml::Controls::Primitives::ScrollEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_ScrollEventArgs
    };

    // ----- ScrollPresenter class --------------------

    static PyObject* _new_ScrollPresenter(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 0)
        {
            try
            {
                winrt::Microsoft::UI::Xaml::Controls::Primitives::ScrollPresenter instance{  };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_ScrollPresenter(py::wrapper::Microsoft::UI::Xaml::Controls::Primitives::ScrollPresenter* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* ScrollPresenter_AddScrollVelocity(py::wrapper::Microsoft::UI::Xaml::Controls::Primitives::ScrollPresenter* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Xaml.Controls.Primitives.ScrollPresenter", L"AddScrollVelocity", 2))
            {
                py::set_arg_count_version_error(2);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::Foundation::Numerics::float2>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Foundation::IReference<winrt::Windows::Foundation::Numerics::float2>>(args, 1);

                return py::convert(self->obj.AddScrollVelocity(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ScrollPresenter_AddZoomVelocity(py::wrapper::Microsoft::UI::Xaml::Controls::Primitives::ScrollPresenter* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 3)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Xaml.Controls.Primitives.ScrollPresenter", L"AddZoomVelocity", 3))
            {
                py::set_arg_count_version_error(3);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<float>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Foundation::IReference<winrt::Windows::Foundation::Numerics::float2>>(args, 1);
                auto param2 = py::convert_to<winrt::Windows::Foundation::IReference<float>>(args, 2);

                return py::convert(self->obj.AddZoomVelocity(param0, param1, param2));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ScrollPresenter_RegisterAnchorCandidate(py::wrapper::Microsoft::UI::Xaml::Controls::Primitives::ScrollPresenter* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Xaml.Controls.Primitives.ScrollPresenter", L"RegisterAnchorCandidate", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Microsoft::UI::Xaml::UIElement>(args, 0);

                self->obj.RegisterAnchorCandidate(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ScrollPresenter_ScrollBy(py::wrapper::Microsoft::UI::Xaml::Controls::Primitives::ScrollPresenter* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Xaml.Controls.Primitives.ScrollPresenter", L"ScrollBy", 2))
            {
                py::set_arg_count_version_error(2);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<double>(args, 0);
                auto param1 = py::convert_to<double>(args, 1);

                return py::convert(self->obj.ScrollBy(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 3)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Xaml.Controls.Primitives.ScrollPresenter", L"ScrollBy", 3))
            {
                py::set_arg_count_version_error(3);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<double>(args, 0);
                auto param1 = py::convert_to<double>(args, 1);
                auto param2 = py::convert_to<winrt::Microsoft::UI::Xaml::Controls::ScrollingScrollOptions>(args, 2);

                return py::convert(self->obj.ScrollBy(param0, param1, param2));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ScrollPresenter_ScrollTo(py::wrapper::Microsoft::UI::Xaml::Controls::Primitives::ScrollPresenter* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Xaml.Controls.Primitives.ScrollPresenter", L"ScrollTo", 2))
            {
                py::set_arg_count_version_error(2);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<double>(args, 0);
                auto param1 = py::convert_to<double>(args, 1);

                return py::convert(self->obj.ScrollTo(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 3)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Xaml.Controls.Primitives.ScrollPresenter", L"ScrollTo", 3))
            {
                py::set_arg_count_version_error(3);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<double>(args, 0);
                auto param1 = py::convert_to<double>(args, 1);
                auto param2 = py::convert_to<winrt::Microsoft::UI::Xaml::Controls::ScrollingScrollOptions>(args, 2);

                return py::convert(self->obj.ScrollTo(param0, param1, param2));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ScrollPresenter_UnregisterAnchorCandidate(py::wrapper::Microsoft::UI::Xaml::Controls::Primitives::ScrollPresenter* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Xaml.Controls.Primitives.ScrollPresenter", L"UnregisterAnchorCandidate", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Microsoft::UI::Xaml::UIElement>(args, 0);

                self->obj.UnregisterAnchorCandidate(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ScrollPresenter_ZoomBy(py::wrapper::Microsoft::UI::Xaml::Controls::Primitives::ScrollPresenter* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Xaml.Controls.Primitives.ScrollPresenter", L"ZoomBy", 2))
            {
                py::set_arg_count_version_error(2);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<float>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Foundation::IReference<winrt::Windows::Foundation::Numerics::float2>>(args, 1);

                return py::convert(self->obj.ZoomBy(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 3)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Xaml.Controls.Primitives.ScrollPresenter", L"ZoomBy", 3))
            {
                py::set_arg_count_version_error(3);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<float>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Foundation::IReference<winrt::Windows::Foundation::Numerics::float2>>(args, 1);
                auto param2 = py::convert_to<winrt::Microsoft::UI::Xaml::Controls::ScrollingZoomOptions>(args, 2);

                return py::convert(self->obj.ZoomBy(param0, param1, param2));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ScrollPresenter_ZoomTo(py::wrapper::Microsoft::UI::Xaml::Controls::Primitives::ScrollPresenter* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Xaml.Controls.Primitives.ScrollPresenter", L"ZoomTo", 2))
            {
                py::set_arg_count_version_error(2);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<float>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Foundation::IReference<winrt::Windows::Foundation::Numerics::float2>>(args, 1);

                return py::convert(self->obj.ZoomTo(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 3)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Xaml.Controls.Primitives.ScrollPresenter", L"ZoomTo", 3))
            {
                py::set_arg_count_version_error(3);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<float>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Foundation::IReference<winrt::Windows::Foundation::Numerics::float2>>(args, 1);
                auto param2 = py::convert_to<winrt::Microsoft::UI::Xaml::Controls::ScrollingZoomOptions>(args, 2);

                return py::convert(self->obj.ZoomTo(param0, param1, param2));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ScrollPresenter_get_CurrentAnchor(py::wrapper::Microsoft::UI::Xaml::Controls::Primitives::ScrollPresenter* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.ScrollPresenter", L"CurrentAnchor"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.CurrentAnchor());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ScrollPresenter_get_IgnoredInputKinds(py::wrapper::Microsoft::UI::Xaml::Controls::Primitives::ScrollPresenter* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.ScrollPresenter", L"IgnoredInputKinds"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.IgnoredInputKinds());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ScrollPresenter_put_IgnoredInputKinds(py::wrapper::Microsoft::UI::Xaml::Controls::Primitives::ScrollPresenter* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.ScrollPresenter", L"IgnoredInputKinds"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Microsoft::UI::Xaml::Controls::ScrollingInputKinds>(arg);

            self->obj.IgnoredInputKinds(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ScrollPresenter_get_HorizontalAnchorRatio(py::wrapper::Microsoft::UI::Xaml::Controls::Primitives::ScrollPresenter* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.ScrollPresenter", L"HorizontalAnchorRatio"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.HorizontalAnchorRatio());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ScrollPresenter_put_HorizontalAnchorRatio(py::wrapper::Microsoft::UI::Xaml::Controls::Primitives::ScrollPresenter* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.ScrollPresenter", L"HorizontalAnchorRatio"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<double>(arg);

            self->obj.HorizontalAnchorRatio(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ScrollPresenter_get_MaxZoomFactor(py::wrapper::Microsoft::UI::Xaml::Controls::Primitives::ScrollPresenter* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.ScrollPresenter", L"MaxZoomFactor"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.MaxZoomFactor());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ScrollPresenter_put_MaxZoomFactor(py::wrapper::Microsoft::UI::Xaml::Controls::Primitives::ScrollPresenter* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.ScrollPresenter", L"MaxZoomFactor"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<double>(arg);

            self->obj.MaxZoomFactor(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ScrollPresenter_get_HorizontalScrollRailMode(py::wrapper::Microsoft::UI::Xaml::Controls::Primitives::ScrollPresenter* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.ScrollPresenter", L"HorizontalScrollRailMode"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.HorizontalScrollRailMode());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ScrollPresenter_put_HorizontalScrollRailMode(py::wrapper::Microsoft::UI::Xaml::Controls::Primitives::ScrollPresenter* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.ScrollPresenter", L"HorizontalScrollRailMode"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Microsoft::UI::Xaml::Controls::ScrollingRailMode>(arg);

            self->obj.HorizontalScrollRailMode(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ScrollPresenter_get_HorizontalScrollMode(py::wrapper::Microsoft::UI::Xaml::Controls::Primitives::ScrollPresenter* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.ScrollPresenter", L"HorizontalScrollMode"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.HorizontalScrollMode());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ScrollPresenter_put_HorizontalScrollMode(py::wrapper::Microsoft::UI::Xaml::Controls::Primitives::ScrollPresenter* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.ScrollPresenter", L"HorizontalScrollMode"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Microsoft::UI::Xaml::Controls::ScrollingScrollMode>(arg);

            self->obj.HorizontalScrollMode(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ScrollPresenter_get_ContentOrientation(py::wrapper::Microsoft::UI::Xaml::Controls::Primitives::ScrollPresenter* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.ScrollPresenter", L"ContentOrientation"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.ContentOrientation());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ScrollPresenter_put_ContentOrientation(py::wrapper::Microsoft::UI::Xaml::Controls::Primitives::ScrollPresenter* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.ScrollPresenter", L"ContentOrientation"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Microsoft::UI::Xaml::Controls::ScrollingContentOrientation>(arg);

            self->obj.ContentOrientation(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ScrollPresenter_get_Content(py::wrapper::Microsoft::UI::Xaml::Controls::Primitives::ScrollPresenter* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.ScrollPresenter", L"Content"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Content());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ScrollPresenter_put_Content(py::wrapper::Microsoft::UI::Xaml::Controls::Primitives::ScrollPresenter* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.ScrollPresenter", L"Content"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Microsoft::UI::Xaml::UIElement>(arg);

            self->obj.Content(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ScrollPresenter_get_HorizontalScrollController(py::wrapper::Microsoft::UI::Xaml::Controls::Primitives::ScrollPresenter* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.ScrollPresenter", L"HorizontalScrollController"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.HorizontalScrollController());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ScrollPresenter_put_HorizontalScrollController(py::wrapper::Microsoft::UI::Xaml::Controls::Primitives::ScrollPresenter* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.ScrollPresenter", L"HorizontalScrollController"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Microsoft::UI::Xaml::Controls::Primitives::IScrollController>(arg);

            self->obj.HorizontalScrollController(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ScrollPresenter_get_HorizontalScrollChainMode(py::wrapper::Microsoft::UI::Xaml::Controls::Primitives::ScrollPresenter* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.ScrollPresenter", L"HorizontalScrollChainMode"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.HorizontalScrollChainMode());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ScrollPresenter_put_HorizontalScrollChainMode(py::wrapper::Microsoft::UI::Xaml::Controls::Primitives::ScrollPresenter* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.ScrollPresenter", L"HorizontalScrollChainMode"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Microsoft::UI::Xaml::Controls::ScrollingChainMode>(arg);

            self->obj.HorizontalScrollChainMode(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ScrollPresenter_get_MinZoomFactor(py::wrapper::Microsoft::UI::Xaml::Controls::Primitives::ScrollPresenter* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.ScrollPresenter", L"MinZoomFactor"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.MinZoomFactor());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ScrollPresenter_put_MinZoomFactor(py::wrapper::Microsoft::UI::Xaml::Controls::Primitives::ScrollPresenter* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.ScrollPresenter", L"MinZoomFactor"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<double>(arg);

            self->obj.MinZoomFactor(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ScrollPresenter_get_Background(py::wrapper::Microsoft::UI::Xaml::Controls::Primitives::ScrollPresenter* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.ScrollPresenter", L"Background"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Background());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ScrollPresenter_put_Background(py::wrapper::Microsoft::UI::Xaml::Controls::Primitives::ScrollPresenter* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.ScrollPresenter", L"Background"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Microsoft::UI::Xaml::Media::Brush>(arg);

            self->obj.Background(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ScrollPresenter_get_ZoomMode(py::wrapper::Microsoft::UI::Xaml::Controls::Primitives::ScrollPresenter* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.ScrollPresenter", L"ZoomMode"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.ZoomMode());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ScrollPresenter_put_ZoomMode(py::wrapper::Microsoft::UI::Xaml::Controls::Primitives::ScrollPresenter* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.ScrollPresenter", L"ZoomMode"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Microsoft::UI::Xaml::Controls::ScrollingZoomMode>(arg);

            self->obj.ZoomMode(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ScrollPresenter_get_ZoomChainMode(py::wrapper::Microsoft::UI::Xaml::Controls::Primitives::ScrollPresenter* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.ScrollPresenter", L"ZoomChainMode"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.ZoomChainMode());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ScrollPresenter_put_ZoomChainMode(py::wrapper::Microsoft::UI::Xaml::Controls::Primitives::ScrollPresenter* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.ScrollPresenter", L"ZoomChainMode"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Microsoft::UI::Xaml::Controls::ScrollingChainMode>(arg);

            self->obj.ZoomChainMode(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ScrollPresenter_get_VerticalScrollRailMode(py::wrapper::Microsoft::UI::Xaml::Controls::Primitives::ScrollPresenter* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.ScrollPresenter", L"VerticalScrollRailMode"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.VerticalScrollRailMode());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ScrollPresenter_put_VerticalScrollRailMode(py::wrapper::Microsoft::UI::Xaml::Controls::Primitives::ScrollPresenter* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.ScrollPresenter", L"VerticalScrollRailMode"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Microsoft::UI::Xaml::Controls::ScrollingRailMode>(arg);

            self->obj.VerticalScrollRailMode(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ScrollPresenter_get_VerticalScrollMode(py::wrapper::Microsoft::UI::Xaml::Controls::Primitives::ScrollPresenter* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.ScrollPresenter", L"VerticalScrollMode"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.VerticalScrollMode());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ScrollPresenter_put_VerticalScrollMode(py::wrapper::Microsoft::UI::Xaml::Controls::Primitives::ScrollPresenter* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.ScrollPresenter", L"VerticalScrollMode"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Microsoft::UI::Xaml::Controls::ScrollingScrollMode>(arg);

            self->obj.VerticalScrollMode(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ScrollPresenter_get_VerticalScrollController(py::wrapper::Microsoft::UI::Xaml::Controls::Primitives::ScrollPresenter* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.ScrollPresenter", L"VerticalScrollController"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.VerticalScrollController());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ScrollPresenter_put_VerticalScrollController(py::wrapper::Microsoft::UI::Xaml::Controls::Primitives::ScrollPresenter* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.ScrollPresenter", L"VerticalScrollController"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Microsoft::UI::Xaml::Controls::Primitives::IScrollController>(arg);

            self->obj.VerticalScrollController(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ScrollPresenter_get_VerticalScrollChainMode(py::wrapper::Microsoft::UI::Xaml::Controls::Primitives::ScrollPresenter* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.ScrollPresenter", L"VerticalScrollChainMode"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.VerticalScrollChainMode());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ScrollPresenter_put_VerticalScrollChainMode(py::wrapper::Microsoft::UI::Xaml::Controls::Primitives::ScrollPresenter* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.ScrollPresenter", L"VerticalScrollChainMode"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Microsoft::UI::Xaml::Controls::ScrollingChainMode>(arg);

            self->obj.VerticalScrollChainMode(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ScrollPresenter_get_VerticalAnchorRatio(py::wrapper::Microsoft::UI::Xaml::Controls::Primitives::ScrollPresenter* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.ScrollPresenter", L"VerticalAnchorRatio"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.VerticalAnchorRatio());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ScrollPresenter_put_VerticalAnchorRatio(py::wrapper::Microsoft::UI::Xaml::Controls::Primitives::ScrollPresenter* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.ScrollPresenter", L"VerticalAnchorRatio"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<double>(arg);

            self->obj.VerticalAnchorRatio(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ScrollPresenter_get_ComputedHorizontalScrollMode(py::wrapper::Microsoft::UI::Xaml::Controls::Primitives::ScrollPresenter* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.ScrollPresenter", L"ComputedHorizontalScrollMode"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.ComputedHorizontalScrollMode());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ScrollPresenter_get_ComputedVerticalScrollMode(py::wrapper::Microsoft::UI::Xaml::Controls::Primitives::ScrollPresenter* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.ScrollPresenter", L"ComputedVerticalScrollMode"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.ComputedVerticalScrollMode());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ScrollPresenter_get_ExpressionAnimationSources(py::wrapper::Microsoft::UI::Xaml::Controls::Primitives::ScrollPresenter* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.ScrollPresenter", L"ExpressionAnimationSources"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.ExpressionAnimationSources());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ScrollPresenter_get_ExtentHeight(py::wrapper::Microsoft::UI::Xaml::Controls::Primitives::ScrollPresenter* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.ScrollPresenter", L"ExtentHeight"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.ExtentHeight());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ScrollPresenter_get_ExtentWidth(py::wrapper::Microsoft::UI::Xaml::Controls::Primitives::ScrollPresenter* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.ScrollPresenter", L"ExtentWidth"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.ExtentWidth());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ScrollPresenter_get_HorizontalOffset(py::wrapper::Microsoft::UI::Xaml::Controls::Primitives::ScrollPresenter* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.ScrollPresenter", L"HorizontalOffset"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.HorizontalOffset());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ScrollPresenter_get_HorizontalSnapPoints(py::wrapper::Microsoft::UI::Xaml::Controls::Primitives::ScrollPresenter* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.ScrollPresenter", L"HorizontalSnapPoints"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.HorizontalSnapPoints());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ScrollPresenter_get_ScrollableHeight(py::wrapper::Microsoft::UI::Xaml::Controls::Primitives::ScrollPresenter* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.ScrollPresenter", L"ScrollableHeight"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.ScrollableHeight());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ScrollPresenter_get_ScrollableWidth(py::wrapper::Microsoft::UI::Xaml::Controls::Primitives::ScrollPresenter* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.ScrollPresenter", L"ScrollableWidth"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.ScrollableWidth());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ScrollPresenter_get_State(py::wrapper::Microsoft::UI::Xaml::Controls::Primitives::ScrollPresenter* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.ScrollPresenter", L"State"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.State());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ScrollPresenter_get_VerticalOffset(py::wrapper::Microsoft::UI::Xaml::Controls::Primitives::ScrollPresenter* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.ScrollPresenter", L"VerticalOffset"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.VerticalOffset());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ScrollPresenter_get_VerticalSnapPoints(py::wrapper::Microsoft::UI::Xaml::Controls::Primitives::ScrollPresenter* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.ScrollPresenter", L"VerticalSnapPoints"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.VerticalSnapPoints());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ScrollPresenter_get_ViewportHeight(py::wrapper::Microsoft::UI::Xaml::Controls::Primitives::ScrollPresenter* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.ScrollPresenter", L"ViewportHeight"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.ViewportHeight());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ScrollPresenter_get_ViewportWidth(py::wrapper::Microsoft::UI::Xaml::Controls::Primitives::ScrollPresenter* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.ScrollPresenter", L"ViewportWidth"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.ViewportWidth());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ScrollPresenter_get_ZoomFactor(py::wrapper::Microsoft::UI::Xaml::Controls::Primitives::ScrollPresenter* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.ScrollPresenter", L"ZoomFactor"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.ZoomFactor());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ScrollPresenter_get_ZoomSnapPoints(py::wrapper::Microsoft::UI::Xaml::Controls::Primitives::ScrollPresenter* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.ScrollPresenter", L"ZoomSnapPoints"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.ZoomSnapPoints());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ScrollPresenter_get_BackgroundProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.ScrollPresenter", L"BackgroundProperty"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Microsoft::UI::Xaml::Controls::Primitives::ScrollPresenter::BackgroundProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ScrollPresenter_get_ComputedHorizontalScrollModeProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.ScrollPresenter", L"ComputedHorizontalScrollModeProperty"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Microsoft::UI::Xaml::Controls::Primitives::ScrollPresenter::ComputedHorizontalScrollModeProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ScrollPresenter_get_ComputedVerticalScrollModeProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.ScrollPresenter", L"ComputedVerticalScrollModeProperty"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Microsoft::UI::Xaml::Controls::Primitives::ScrollPresenter::ComputedVerticalScrollModeProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ScrollPresenter_get_ContentOrientationProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.ScrollPresenter", L"ContentOrientationProperty"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Microsoft::UI::Xaml::Controls::Primitives::ScrollPresenter::ContentOrientationProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ScrollPresenter_get_ContentProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.ScrollPresenter", L"ContentProperty"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Microsoft::UI::Xaml::Controls::Primitives::ScrollPresenter::ContentProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ScrollPresenter_get_HorizontalAnchorRatioProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.ScrollPresenter", L"HorizontalAnchorRatioProperty"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Microsoft::UI::Xaml::Controls::Primitives::ScrollPresenter::HorizontalAnchorRatioProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ScrollPresenter_get_HorizontalScrollChainModeProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.ScrollPresenter", L"HorizontalScrollChainModeProperty"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Microsoft::UI::Xaml::Controls::Primitives::ScrollPresenter::HorizontalScrollChainModeProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ScrollPresenter_get_HorizontalScrollModeProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.ScrollPresenter", L"HorizontalScrollModeProperty"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Microsoft::UI::Xaml::Controls::Primitives::ScrollPresenter::HorizontalScrollModeProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ScrollPresenter_get_HorizontalScrollRailModeProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.ScrollPresenter", L"HorizontalScrollRailModeProperty"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Microsoft::UI::Xaml::Controls::Primitives::ScrollPresenter::HorizontalScrollRailModeProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ScrollPresenter_get_IgnoredInputKindsProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.ScrollPresenter", L"IgnoredInputKindsProperty"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Microsoft::UI::Xaml::Controls::Primitives::ScrollPresenter::IgnoredInputKindsProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ScrollPresenter_get_MaxZoomFactorProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.ScrollPresenter", L"MaxZoomFactorProperty"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Microsoft::UI::Xaml::Controls::Primitives::ScrollPresenter::MaxZoomFactorProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ScrollPresenter_get_MinZoomFactorProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.ScrollPresenter", L"MinZoomFactorProperty"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Microsoft::UI::Xaml::Controls::Primitives::ScrollPresenter::MinZoomFactorProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ScrollPresenter_get_VerticalAnchorRatioProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.ScrollPresenter", L"VerticalAnchorRatioProperty"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Microsoft::UI::Xaml::Controls::Primitives::ScrollPresenter::VerticalAnchorRatioProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ScrollPresenter_get_VerticalScrollChainModeProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.ScrollPresenter", L"VerticalScrollChainModeProperty"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Microsoft::UI::Xaml::Controls::Primitives::ScrollPresenter::VerticalScrollChainModeProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ScrollPresenter_get_VerticalScrollModeProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.ScrollPresenter", L"VerticalScrollModeProperty"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Microsoft::UI::Xaml::Controls::Primitives::ScrollPresenter::VerticalScrollModeProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ScrollPresenter_get_VerticalScrollRailModeProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.ScrollPresenter", L"VerticalScrollRailModeProperty"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Microsoft::UI::Xaml::Controls::Primitives::ScrollPresenter::VerticalScrollRailModeProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ScrollPresenter_get_ZoomChainModeProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.ScrollPresenter", L"ZoomChainModeProperty"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Microsoft::UI::Xaml::Controls::Primitives::ScrollPresenter::ZoomChainModeProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ScrollPresenter_get_ZoomModeProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.ScrollPresenter", L"ZoomModeProperty"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Microsoft::UI::Xaml::Controls::Primitives::ScrollPresenter::ZoomModeProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ScrollPresenter_add_AnchorRequested(py::wrapper::Microsoft::UI::Xaml::Controls::Primitives::ScrollPresenter* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Microsoft.UI.Xaml.Controls.Primitives.ScrollPresenter", L"AnchorRequested"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Microsoft::UI::Xaml::Controls::Primitives::ScrollPresenter, winrt::Microsoft::UI::Xaml::Controls::ScrollingAnchorRequestedEventArgs>>(arg);

            return py::convert(self->obj.AnchorRequested(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ScrollPresenter_remove_AnchorRequested(py::wrapper::Microsoft::UI::Xaml::Controls::Primitives::ScrollPresenter* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Microsoft.UI.Xaml.Controls.Primitives.ScrollPresenter", L"AnchorRequested"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.AnchorRequested(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ScrollPresenter_add_BringingIntoView(py::wrapper::Microsoft::UI::Xaml::Controls::Primitives::ScrollPresenter* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Microsoft.UI.Xaml.Controls.Primitives.ScrollPresenter", L"BringingIntoView"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Microsoft::UI::Xaml::Controls::Primitives::ScrollPresenter, winrt::Microsoft::UI::Xaml::Controls::ScrollingBringingIntoViewEventArgs>>(arg);

            return py::convert(self->obj.BringingIntoView(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ScrollPresenter_remove_BringingIntoView(py::wrapper::Microsoft::UI::Xaml::Controls::Primitives::ScrollPresenter* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Microsoft.UI.Xaml.Controls.Primitives.ScrollPresenter", L"BringingIntoView"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.BringingIntoView(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ScrollPresenter_add_ExtentChanged(py::wrapper::Microsoft::UI::Xaml::Controls::Primitives::ScrollPresenter* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Microsoft.UI.Xaml.Controls.Primitives.ScrollPresenter", L"ExtentChanged"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Microsoft::UI::Xaml::Controls::Primitives::ScrollPresenter, winrt::Windows::Foundation::IInspectable>>(arg);

            return py::convert(self->obj.ExtentChanged(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ScrollPresenter_remove_ExtentChanged(py::wrapper::Microsoft::UI::Xaml::Controls::Primitives::ScrollPresenter* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Microsoft.UI.Xaml.Controls.Primitives.ScrollPresenter", L"ExtentChanged"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.ExtentChanged(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ScrollPresenter_add_ScrollAnimationStarting(py::wrapper::Microsoft::UI::Xaml::Controls::Primitives::ScrollPresenter* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Microsoft.UI.Xaml.Controls.Primitives.ScrollPresenter", L"ScrollAnimationStarting"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Microsoft::UI::Xaml::Controls::Primitives::ScrollPresenter, winrt::Microsoft::UI::Xaml::Controls::ScrollingScrollAnimationStartingEventArgs>>(arg);

            return py::convert(self->obj.ScrollAnimationStarting(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ScrollPresenter_remove_ScrollAnimationStarting(py::wrapper::Microsoft::UI::Xaml::Controls::Primitives::ScrollPresenter* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Microsoft.UI.Xaml.Controls.Primitives.ScrollPresenter", L"ScrollAnimationStarting"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.ScrollAnimationStarting(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ScrollPresenter_add_ScrollCompleted(py::wrapper::Microsoft::UI::Xaml::Controls::Primitives::ScrollPresenter* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Microsoft.UI.Xaml.Controls.Primitives.ScrollPresenter", L"ScrollCompleted"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Microsoft::UI::Xaml::Controls::Primitives::ScrollPresenter, winrt::Microsoft::UI::Xaml::Controls::ScrollingScrollCompletedEventArgs>>(arg);

            return py::convert(self->obj.ScrollCompleted(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ScrollPresenter_remove_ScrollCompleted(py::wrapper::Microsoft::UI::Xaml::Controls::Primitives::ScrollPresenter* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Microsoft.UI.Xaml.Controls.Primitives.ScrollPresenter", L"ScrollCompleted"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.ScrollCompleted(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ScrollPresenter_add_StateChanged(py::wrapper::Microsoft::UI::Xaml::Controls::Primitives::ScrollPresenter* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Microsoft.UI.Xaml.Controls.Primitives.ScrollPresenter", L"StateChanged"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Microsoft::UI::Xaml::Controls::Primitives::ScrollPresenter, winrt::Windows::Foundation::IInspectable>>(arg);

            return py::convert(self->obj.StateChanged(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ScrollPresenter_remove_StateChanged(py::wrapper::Microsoft::UI::Xaml::Controls::Primitives::ScrollPresenter* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Microsoft.UI.Xaml.Controls.Primitives.ScrollPresenter", L"StateChanged"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.StateChanged(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ScrollPresenter_add_ViewChanged(py::wrapper::Microsoft::UI::Xaml::Controls::Primitives::ScrollPresenter* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Microsoft.UI.Xaml.Controls.Primitives.ScrollPresenter", L"ViewChanged"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Microsoft::UI::Xaml::Controls::Primitives::ScrollPresenter, winrt::Windows::Foundation::IInspectable>>(arg);

            return py::convert(self->obj.ViewChanged(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ScrollPresenter_remove_ViewChanged(py::wrapper::Microsoft::UI::Xaml::Controls::Primitives::ScrollPresenter* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Microsoft.UI.Xaml.Controls.Primitives.ScrollPresenter", L"ViewChanged"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.ViewChanged(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ScrollPresenter_add_ZoomAnimationStarting(py::wrapper::Microsoft::UI::Xaml::Controls::Primitives::ScrollPresenter* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Microsoft.UI.Xaml.Controls.Primitives.ScrollPresenter", L"ZoomAnimationStarting"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Microsoft::UI::Xaml::Controls::Primitives::ScrollPresenter, winrt::Microsoft::UI::Xaml::Controls::ScrollingZoomAnimationStartingEventArgs>>(arg);

            return py::convert(self->obj.ZoomAnimationStarting(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ScrollPresenter_remove_ZoomAnimationStarting(py::wrapper::Microsoft::UI::Xaml::Controls::Primitives::ScrollPresenter* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Microsoft.UI.Xaml.Controls.Primitives.ScrollPresenter", L"ZoomAnimationStarting"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.ZoomAnimationStarting(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ScrollPresenter_add_ZoomCompleted(py::wrapper::Microsoft::UI::Xaml::Controls::Primitives::ScrollPresenter* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Microsoft.UI.Xaml.Controls.Primitives.ScrollPresenter", L"ZoomCompleted"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Microsoft::UI::Xaml::Controls::Primitives::ScrollPresenter, winrt::Microsoft::UI::Xaml::Controls::ScrollingZoomCompletedEventArgs>>(arg);

            return py::convert(self->obj.ZoomCompleted(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ScrollPresenter_remove_ZoomCompleted(py::wrapper::Microsoft::UI::Xaml::Controls::Primitives::ScrollPresenter* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Microsoft.UI.Xaml.Controls.Primitives.ScrollPresenter", L"ZoomCompleted"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.ZoomCompleted(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_ScrollPresenter(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Microsoft::UI::Xaml::Controls::Primitives::ScrollPresenter>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_ScrollPresenter(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Microsoft::UI::Xaml::Controls::Primitives::ScrollPresenter>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_ScrollPresenter[] = {
        { "add_scroll_velocity", reinterpret_cast<PyCFunction>(ScrollPresenter_AddScrollVelocity), METH_VARARGS, nullptr },
        { "add_zoom_velocity", reinterpret_cast<PyCFunction>(ScrollPresenter_AddZoomVelocity), METH_VARARGS, nullptr },
        { "register_anchor_candidate", reinterpret_cast<PyCFunction>(ScrollPresenter_RegisterAnchorCandidate), METH_VARARGS, nullptr },
        { "scroll_by", reinterpret_cast<PyCFunction>(ScrollPresenter_ScrollBy), METH_VARARGS, nullptr },
        { "scroll_to", reinterpret_cast<PyCFunction>(ScrollPresenter_ScrollTo), METH_VARARGS, nullptr },
        { "unregister_anchor_candidate", reinterpret_cast<PyCFunction>(ScrollPresenter_UnregisterAnchorCandidate), METH_VARARGS, nullptr },
        { "zoom_by", reinterpret_cast<PyCFunction>(ScrollPresenter_ZoomBy), METH_VARARGS, nullptr },
        { "zoom_to", reinterpret_cast<PyCFunction>(ScrollPresenter_ZoomTo), METH_VARARGS, nullptr },
        { "add_anchor_requested", reinterpret_cast<PyCFunction>(ScrollPresenter_add_AnchorRequested), METH_O, nullptr },
        { "remove_anchor_requested", reinterpret_cast<PyCFunction>(ScrollPresenter_remove_AnchorRequested), METH_O, nullptr },
        { "add_bringing_into_view", reinterpret_cast<PyCFunction>(ScrollPresenter_add_BringingIntoView), METH_O, nullptr },
        { "remove_bringing_into_view", reinterpret_cast<PyCFunction>(ScrollPresenter_remove_BringingIntoView), METH_O, nullptr },
        { "add_extent_changed", reinterpret_cast<PyCFunction>(ScrollPresenter_add_ExtentChanged), METH_O, nullptr },
        { "remove_extent_changed", reinterpret_cast<PyCFunction>(ScrollPresenter_remove_ExtentChanged), METH_O, nullptr },
        { "add_scroll_animation_starting", reinterpret_cast<PyCFunction>(ScrollPresenter_add_ScrollAnimationStarting), METH_O, nullptr },
        { "remove_scroll_animation_starting", reinterpret_cast<PyCFunction>(ScrollPresenter_remove_ScrollAnimationStarting), METH_O, nullptr },
        { "add_scroll_completed", reinterpret_cast<PyCFunction>(ScrollPresenter_add_ScrollCompleted), METH_O, nullptr },
        { "remove_scroll_completed", reinterpret_cast<PyCFunction>(ScrollPresenter_remove_ScrollCompleted), METH_O, nullptr },
        { "add_state_changed", reinterpret_cast<PyCFunction>(ScrollPresenter_add_StateChanged), METH_O, nullptr },
        { "remove_state_changed", reinterpret_cast<PyCFunction>(ScrollPresenter_remove_StateChanged), METH_O, nullptr },
        { "add_view_changed", reinterpret_cast<PyCFunction>(ScrollPresenter_add_ViewChanged), METH_O, nullptr },
        { "remove_view_changed", reinterpret_cast<PyCFunction>(ScrollPresenter_remove_ViewChanged), METH_O, nullptr },
        { "add_zoom_animation_starting", reinterpret_cast<PyCFunction>(ScrollPresenter_add_ZoomAnimationStarting), METH_O, nullptr },
        { "remove_zoom_animation_starting", reinterpret_cast<PyCFunction>(ScrollPresenter_remove_ZoomAnimationStarting), METH_O, nullptr },
        { "add_zoom_completed", reinterpret_cast<PyCFunction>(ScrollPresenter_add_ZoomCompleted), METH_O, nullptr },
        { "remove_zoom_completed", reinterpret_cast<PyCFunction>(ScrollPresenter_remove_ZoomCompleted), METH_O, nullptr },
        { "_assign_array_", _assign_array_ScrollPresenter, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_ScrollPresenter), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_ScrollPresenter[] = {
        { "current_anchor", reinterpret_cast<getter>(ScrollPresenter_get_CurrentAnchor), nullptr, nullptr, nullptr },
        { "ignored_input_kinds", reinterpret_cast<getter>(ScrollPresenter_get_IgnoredInputKinds), reinterpret_cast<setter>(ScrollPresenter_put_IgnoredInputKinds), nullptr, nullptr },
        { "horizontal_anchor_ratio", reinterpret_cast<getter>(ScrollPresenter_get_HorizontalAnchorRatio), reinterpret_cast<setter>(ScrollPresenter_put_HorizontalAnchorRatio), nullptr, nullptr },
        { "max_zoom_factor", reinterpret_cast<getter>(ScrollPresenter_get_MaxZoomFactor), reinterpret_cast<setter>(ScrollPresenter_put_MaxZoomFactor), nullptr, nullptr },
        { "horizontal_scroll_rail_mode", reinterpret_cast<getter>(ScrollPresenter_get_HorizontalScrollRailMode), reinterpret_cast<setter>(ScrollPresenter_put_HorizontalScrollRailMode), nullptr, nullptr },
        { "horizontal_scroll_mode", reinterpret_cast<getter>(ScrollPresenter_get_HorizontalScrollMode), reinterpret_cast<setter>(ScrollPresenter_put_HorizontalScrollMode), nullptr, nullptr },
        { "content_orientation", reinterpret_cast<getter>(ScrollPresenter_get_ContentOrientation), reinterpret_cast<setter>(ScrollPresenter_put_ContentOrientation), nullptr, nullptr },
        { "content", reinterpret_cast<getter>(ScrollPresenter_get_Content), reinterpret_cast<setter>(ScrollPresenter_put_Content), nullptr, nullptr },
        { "horizontal_scroll_controller", reinterpret_cast<getter>(ScrollPresenter_get_HorizontalScrollController), reinterpret_cast<setter>(ScrollPresenter_put_HorizontalScrollController), nullptr, nullptr },
        { "horizontal_scroll_chain_mode", reinterpret_cast<getter>(ScrollPresenter_get_HorizontalScrollChainMode), reinterpret_cast<setter>(ScrollPresenter_put_HorizontalScrollChainMode), nullptr, nullptr },
        { "min_zoom_factor", reinterpret_cast<getter>(ScrollPresenter_get_MinZoomFactor), reinterpret_cast<setter>(ScrollPresenter_put_MinZoomFactor), nullptr, nullptr },
        { "background", reinterpret_cast<getter>(ScrollPresenter_get_Background), reinterpret_cast<setter>(ScrollPresenter_put_Background), nullptr, nullptr },
        { "zoom_mode", reinterpret_cast<getter>(ScrollPresenter_get_ZoomMode), reinterpret_cast<setter>(ScrollPresenter_put_ZoomMode), nullptr, nullptr },
        { "zoom_chain_mode", reinterpret_cast<getter>(ScrollPresenter_get_ZoomChainMode), reinterpret_cast<setter>(ScrollPresenter_put_ZoomChainMode), nullptr, nullptr },
        { "vertical_scroll_rail_mode", reinterpret_cast<getter>(ScrollPresenter_get_VerticalScrollRailMode), reinterpret_cast<setter>(ScrollPresenter_put_VerticalScrollRailMode), nullptr, nullptr },
        { "vertical_scroll_mode", reinterpret_cast<getter>(ScrollPresenter_get_VerticalScrollMode), reinterpret_cast<setter>(ScrollPresenter_put_VerticalScrollMode), nullptr, nullptr },
        { "vertical_scroll_controller", reinterpret_cast<getter>(ScrollPresenter_get_VerticalScrollController), reinterpret_cast<setter>(ScrollPresenter_put_VerticalScrollController), nullptr, nullptr },
        { "vertical_scroll_chain_mode", reinterpret_cast<getter>(ScrollPresenter_get_VerticalScrollChainMode), reinterpret_cast<setter>(ScrollPresenter_put_VerticalScrollChainMode), nullptr, nullptr },
        { "vertical_anchor_ratio", reinterpret_cast<getter>(ScrollPresenter_get_VerticalAnchorRatio), reinterpret_cast<setter>(ScrollPresenter_put_VerticalAnchorRatio), nullptr, nullptr },
        { "computed_horizontal_scroll_mode", reinterpret_cast<getter>(ScrollPresenter_get_ComputedHorizontalScrollMode), nullptr, nullptr, nullptr },
        { "computed_vertical_scroll_mode", reinterpret_cast<getter>(ScrollPresenter_get_ComputedVerticalScrollMode), nullptr, nullptr, nullptr },
        { "expression_animation_sources", reinterpret_cast<getter>(ScrollPresenter_get_ExpressionAnimationSources), nullptr, nullptr, nullptr },
        { "extent_height", reinterpret_cast<getter>(ScrollPresenter_get_ExtentHeight), nullptr, nullptr, nullptr },
        { "extent_width", reinterpret_cast<getter>(ScrollPresenter_get_ExtentWidth), nullptr, nullptr, nullptr },
        { "horizontal_offset", reinterpret_cast<getter>(ScrollPresenter_get_HorizontalOffset), nullptr, nullptr, nullptr },
        { "horizontal_snap_points", reinterpret_cast<getter>(ScrollPresenter_get_HorizontalSnapPoints), nullptr, nullptr, nullptr },
        { "scrollable_height", reinterpret_cast<getter>(ScrollPresenter_get_ScrollableHeight), nullptr, nullptr, nullptr },
        { "scrollable_width", reinterpret_cast<getter>(ScrollPresenter_get_ScrollableWidth), nullptr, nullptr, nullptr },
        { "state", reinterpret_cast<getter>(ScrollPresenter_get_State), nullptr, nullptr, nullptr },
        { "vertical_offset", reinterpret_cast<getter>(ScrollPresenter_get_VerticalOffset), nullptr, nullptr, nullptr },
        { "vertical_snap_points", reinterpret_cast<getter>(ScrollPresenter_get_VerticalSnapPoints), nullptr, nullptr, nullptr },
        { "viewport_height", reinterpret_cast<getter>(ScrollPresenter_get_ViewportHeight), nullptr, nullptr, nullptr },
        { "viewport_width", reinterpret_cast<getter>(ScrollPresenter_get_ViewportWidth), nullptr, nullptr, nullptr },
        { "zoom_factor", reinterpret_cast<getter>(ScrollPresenter_get_ZoomFactor), nullptr, nullptr, nullptr },
        { "zoom_snap_points", reinterpret_cast<getter>(ScrollPresenter_get_ZoomSnapPoints), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_ScrollPresenter[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_ScrollPresenter) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_ScrollPresenter) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_ScrollPresenter) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_ScrollPresenter) },
        { },
    };

    static PyType_Spec type_spec_ScrollPresenter =
    {
        "winrt._winrt_microsoft_ui_xaml_controls_primitives.ScrollPresenter",
        sizeof(py::wrapper::Microsoft::UI::Xaml::Controls::Primitives::ScrollPresenter),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_ScrollPresenter
    };

    static PyGetSetDef getset_ScrollPresenter_Static[] = {
        { "background_property", reinterpret_cast<getter>(ScrollPresenter_get_BackgroundProperty), nullptr, nullptr, nullptr },
        { "computed_horizontal_scroll_mode_property", reinterpret_cast<getter>(ScrollPresenter_get_ComputedHorizontalScrollModeProperty), nullptr, nullptr, nullptr },
        { "computed_vertical_scroll_mode_property", reinterpret_cast<getter>(ScrollPresenter_get_ComputedVerticalScrollModeProperty), nullptr, nullptr, nullptr },
        { "content_orientation_property", reinterpret_cast<getter>(ScrollPresenter_get_ContentOrientationProperty), nullptr, nullptr, nullptr },
        { "content_property", reinterpret_cast<getter>(ScrollPresenter_get_ContentProperty), nullptr, nullptr, nullptr },
        { "horizontal_anchor_ratio_property", reinterpret_cast<getter>(ScrollPresenter_get_HorizontalAnchorRatioProperty), nullptr, nullptr, nullptr },
        { "horizontal_scroll_chain_mode_property", reinterpret_cast<getter>(ScrollPresenter_get_HorizontalScrollChainModeProperty), nullptr, nullptr, nullptr },
        { "horizontal_scroll_mode_property", reinterpret_cast<getter>(ScrollPresenter_get_HorizontalScrollModeProperty), nullptr, nullptr, nullptr },
        { "horizontal_scroll_rail_mode_property", reinterpret_cast<getter>(ScrollPresenter_get_HorizontalScrollRailModeProperty), nullptr, nullptr, nullptr },
        { "ignored_input_kinds_property", reinterpret_cast<getter>(ScrollPresenter_get_IgnoredInputKindsProperty), nullptr, nullptr, nullptr },
        { "max_zoom_factor_property", reinterpret_cast<getter>(ScrollPresenter_get_MaxZoomFactorProperty), nullptr, nullptr, nullptr },
        { "min_zoom_factor_property", reinterpret_cast<getter>(ScrollPresenter_get_MinZoomFactorProperty), nullptr, nullptr, nullptr },
        { "vertical_anchor_ratio_property", reinterpret_cast<getter>(ScrollPresenter_get_VerticalAnchorRatioProperty), nullptr, nullptr, nullptr },
        { "vertical_scroll_chain_mode_property", reinterpret_cast<getter>(ScrollPresenter_get_VerticalScrollChainModeProperty), nullptr, nullptr, nullptr },
        { "vertical_scroll_mode_property", reinterpret_cast<getter>(ScrollPresenter_get_VerticalScrollModeProperty), nullptr, nullptr, nullptr },
        { "vertical_scroll_rail_mode_property", reinterpret_cast<getter>(ScrollPresenter_get_VerticalScrollRailModeProperty), nullptr, nullptr, nullptr },
        { "zoom_chain_mode_property", reinterpret_cast<getter>(ScrollPresenter_get_ZoomChainModeProperty), nullptr, nullptr, nullptr },
        { "zoom_mode_property", reinterpret_cast<getter>(ScrollPresenter_get_ZoomModeProperty), nullptr, nullptr, nullptr },
        { }
    };

    static PyMethodDef methods_ScrollPresenter_Static[] = {
        { }
    };

    static PyType_Slot type_slots_ScrollPresenter_Static[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_ScrollPresenter_Static) },
        { Py_tp_methods, reinterpret_cast<void*>(methods_ScrollPresenter_Static) },
        { }
    };

    static PyType_Spec type_spec_ScrollPresenter_Static =
    {
        "winrt._winrt_microsoft_ui_xaml_controls_primitives.ScrollPresenter_Static",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT,
        type_slots_ScrollPresenter_Static
    };

    // ----- ScrollSnapPoint class --------------------

    static PyObject* _new_ScrollSnapPoint(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<double>(args, 0);
                auto param1 = py::convert_to<winrt::Microsoft::UI::Xaml::Controls::Primitives::ScrollSnapPointsAlignment>(args, 1);

                winrt::Microsoft::UI::Xaml::Controls::Primitives::ScrollSnapPoint instance{ param0, param1 };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_ScrollSnapPoint(py::wrapper::Microsoft::UI::Xaml::Controls::Primitives::ScrollSnapPoint* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* ScrollSnapPoint_get_Value(py::wrapper::Microsoft::UI::Xaml::Controls::Primitives::ScrollSnapPoint* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.ScrollSnapPoint", L"Value"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Value());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_ScrollSnapPoint(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Microsoft::UI::Xaml::Controls::Primitives::ScrollSnapPoint>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_ScrollSnapPoint(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Microsoft::UI::Xaml::Controls::Primitives::ScrollSnapPoint>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_ScrollSnapPoint[] = {
        { "_assign_array_", _assign_array_ScrollSnapPoint, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_ScrollSnapPoint), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_ScrollSnapPoint[] = {
        { "value", reinterpret_cast<getter>(ScrollSnapPoint_get_Value), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_ScrollSnapPoint[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_ScrollSnapPoint) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_ScrollSnapPoint) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_ScrollSnapPoint) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_ScrollSnapPoint) },
        { },
    };

    static PyType_Spec type_spec_ScrollSnapPoint =
    {
        "winrt._winrt_microsoft_ui_xaml_controls_primitives.ScrollSnapPoint",
        sizeof(py::wrapper::Microsoft::UI::Xaml::Controls::Primitives::ScrollSnapPoint),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_ScrollSnapPoint
    };

    // ----- ScrollSnapPointBase class --------------------

    static PyObject* _new_ScrollSnapPointBase(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Microsoft::UI::Xaml::Controls::Primitives::ScrollSnapPointBase>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Microsoft::UI::Xaml::Controls::Primitives::ScrollSnapPointBase>::type_name);
        return nullptr;
    }

    static void _dealloc_ScrollSnapPointBase(py::wrapper::Microsoft::UI::Xaml::Controls::Primitives::ScrollSnapPointBase* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* ScrollSnapPointBase_get_Alignment(py::wrapper::Microsoft::UI::Xaml::Controls::Primitives::ScrollSnapPointBase* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.ScrollSnapPointBase", L"Alignment"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Alignment());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_ScrollSnapPointBase(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Microsoft::UI::Xaml::Controls::Primitives::ScrollSnapPointBase>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_ScrollSnapPointBase(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Microsoft::UI::Xaml::Controls::Primitives::ScrollSnapPointBase>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_ScrollSnapPointBase[] = {
        { "_assign_array_", _assign_array_ScrollSnapPointBase, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_ScrollSnapPointBase), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_ScrollSnapPointBase[] = {
        { "alignment", reinterpret_cast<getter>(ScrollSnapPointBase_get_Alignment), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_ScrollSnapPointBase[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_ScrollSnapPointBase) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_ScrollSnapPointBase) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_ScrollSnapPointBase) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_ScrollSnapPointBase) },
        { },
    };

    static PyType_Spec type_spec_ScrollSnapPointBase =
    {
        "winrt._winrt_microsoft_ui_xaml_controls_primitives.ScrollSnapPointBase",
        sizeof(py::wrapper::Microsoft::UI::Xaml::Controls::Primitives::ScrollSnapPointBase),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_ScrollSnapPointBase
    };

    // ----- Selector class --------------------

    static PyObject* _new_Selector(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Microsoft::UI::Xaml::Controls::Primitives::Selector>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Microsoft::UI::Xaml::Controls::Primitives::Selector>::type_name);
        return nullptr;
    }

    static void _dealloc_Selector(py::wrapper::Microsoft::UI::Xaml::Controls::Primitives::Selector* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* Selector_GetIsSelectionActive(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Xaml.Controls.Primitives.Selector", L"GetIsSelectionActive", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Microsoft::UI::Xaml::DependencyObject>(args, 0);

                return py::convert(winrt::Microsoft::UI::Xaml::Controls::Primitives::Selector::GetIsSelectionActive(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* Selector_get_SelectedValuePath(py::wrapper::Microsoft::UI::Xaml::Controls::Primitives::Selector* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.Selector", L"SelectedValuePath"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.SelectedValuePath());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int Selector_put_SelectedValuePath(py::wrapper::Microsoft::UI::Xaml::Controls::Primitives::Selector* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.Selector", L"SelectedValuePath"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.SelectedValuePath(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* Selector_get_SelectedValue(py::wrapper::Microsoft::UI::Xaml::Controls::Primitives::Selector* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.Selector", L"SelectedValue"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.SelectedValue());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int Selector_put_SelectedValue(py::wrapper::Microsoft::UI::Xaml::Controls::Primitives::Selector* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.Selector", L"SelectedValue"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);

            self->obj.SelectedValue(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* Selector_get_SelectedItem(py::wrapper::Microsoft::UI::Xaml::Controls::Primitives::Selector* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.Selector", L"SelectedItem"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.SelectedItem());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int Selector_put_SelectedItem(py::wrapper::Microsoft::UI::Xaml::Controls::Primitives::Selector* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.Selector", L"SelectedItem"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);

            self->obj.SelectedItem(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* Selector_get_SelectedIndex(py::wrapper::Microsoft::UI::Xaml::Controls::Primitives::Selector* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.Selector", L"SelectedIndex"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.SelectedIndex());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int Selector_put_SelectedIndex(py::wrapper::Microsoft::UI::Xaml::Controls::Primitives::Selector* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.Selector", L"SelectedIndex"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<int32_t>(arg);

            self->obj.SelectedIndex(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* Selector_get_IsSynchronizedWithCurrentItem(py::wrapper::Microsoft::UI::Xaml::Controls::Primitives::Selector* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.Selector", L"IsSynchronizedWithCurrentItem"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.IsSynchronizedWithCurrentItem());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int Selector_put_IsSynchronizedWithCurrentItem(py::wrapper::Microsoft::UI::Xaml::Controls::Primitives::Selector* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.Selector", L"IsSynchronizedWithCurrentItem"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::IReference<bool>>(arg);

            self->obj.IsSynchronizedWithCurrentItem(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* Selector_get_IsSynchronizedWithCurrentItemProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.Selector", L"IsSynchronizedWithCurrentItemProperty"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Microsoft::UI::Xaml::Controls::Primitives::Selector::IsSynchronizedWithCurrentItemProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* Selector_get_SelectedIndexProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.Selector", L"SelectedIndexProperty"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Microsoft::UI::Xaml::Controls::Primitives::Selector::SelectedIndexProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* Selector_get_SelectedItemProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.Selector", L"SelectedItemProperty"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Microsoft::UI::Xaml::Controls::Primitives::Selector::SelectedItemProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* Selector_get_SelectedValuePathProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.Selector", L"SelectedValuePathProperty"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Microsoft::UI::Xaml::Controls::Primitives::Selector::SelectedValuePathProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* Selector_get_SelectedValueProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.Selector", L"SelectedValueProperty"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Microsoft::UI::Xaml::Controls::Primitives::Selector::SelectedValueProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* Selector_add_SelectionChanged(py::wrapper::Microsoft::UI::Xaml::Controls::Primitives::Selector* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Microsoft.UI.Xaml.Controls.Primitives.Selector", L"SelectionChanged"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Microsoft::UI::Xaml::Controls::SelectionChangedEventHandler>(arg);

            return py::convert(self->obj.SelectionChanged(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* Selector_remove_SelectionChanged(py::wrapper::Microsoft::UI::Xaml::Controls::Primitives::Selector* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Microsoft.UI.Xaml.Controls.Primitives.Selector", L"SelectionChanged"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.SelectionChanged(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_Selector(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Microsoft::UI::Xaml::Controls::Primitives::Selector>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_Selector(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Microsoft::UI::Xaml::Controls::Primitives::Selector>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_Selector[] = {
        { "add_selection_changed", reinterpret_cast<PyCFunction>(Selector_add_SelectionChanged), METH_O, nullptr },
        { "remove_selection_changed", reinterpret_cast<PyCFunction>(Selector_remove_SelectionChanged), METH_O, nullptr },
        { "_assign_array_", _assign_array_Selector, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_Selector), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_Selector[] = {
        { "selected_value_path", reinterpret_cast<getter>(Selector_get_SelectedValuePath), reinterpret_cast<setter>(Selector_put_SelectedValuePath), nullptr, nullptr },
        { "selected_value", reinterpret_cast<getter>(Selector_get_SelectedValue), reinterpret_cast<setter>(Selector_put_SelectedValue), nullptr, nullptr },
        { "selected_item", reinterpret_cast<getter>(Selector_get_SelectedItem), reinterpret_cast<setter>(Selector_put_SelectedItem), nullptr, nullptr },
        { "selected_index", reinterpret_cast<getter>(Selector_get_SelectedIndex), reinterpret_cast<setter>(Selector_put_SelectedIndex), nullptr, nullptr },
        { "is_synchronized_with_current_item", reinterpret_cast<getter>(Selector_get_IsSynchronizedWithCurrentItem), reinterpret_cast<setter>(Selector_put_IsSynchronizedWithCurrentItem), nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_Selector[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_Selector) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_Selector) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_Selector) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_Selector) },
        { },
    };

    static PyType_Spec type_spec_Selector =
    {
        "winrt._winrt_microsoft_ui_xaml_controls_primitives.Selector",
        sizeof(py::wrapper::Microsoft::UI::Xaml::Controls::Primitives::Selector),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_Selector
    };

    static PyGetSetDef getset_Selector_Static[] = {
        { "is_synchronized_with_current_item_property", reinterpret_cast<getter>(Selector_get_IsSynchronizedWithCurrentItemProperty), nullptr, nullptr, nullptr },
        { "selected_index_property", reinterpret_cast<getter>(Selector_get_SelectedIndexProperty), nullptr, nullptr, nullptr },
        { "selected_item_property", reinterpret_cast<getter>(Selector_get_SelectedItemProperty), nullptr, nullptr, nullptr },
        { "selected_value_path_property", reinterpret_cast<getter>(Selector_get_SelectedValuePathProperty), nullptr, nullptr, nullptr },
        { "selected_value_property", reinterpret_cast<getter>(Selector_get_SelectedValueProperty), nullptr, nullptr, nullptr },
        { }
    };

    static PyMethodDef methods_Selector_Static[] = {
        { "get_is_selection_active", reinterpret_cast<PyCFunction>(Selector_GetIsSelectionActive), METH_VARARGS, nullptr },
        { }
    };

    static PyType_Slot type_slots_Selector_Static[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_Selector_Static) },
        { Py_tp_methods, reinterpret_cast<void*>(methods_Selector_Static) },
        { }
    };

    static PyType_Spec type_spec_Selector_Static =
    {
        "winrt._winrt_microsoft_ui_xaml_controls_primitives.Selector_Static",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT,
        type_slots_Selector_Static
    };

    // ----- SelectorItem class --------------------

    static PyObject* _new_SelectorItem(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Microsoft::UI::Xaml::Controls::Primitives::SelectorItem>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Microsoft::UI::Xaml::Controls::Primitives::SelectorItem>::type_name);
        return nullptr;
    }

    static void _dealloc_SelectorItem(py::wrapper::Microsoft::UI::Xaml::Controls::Primitives::SelectorItem* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* SelectorItem_get_IsSelected(py::wrapper::Microsoft::UI::Xaml::Controls::Primitives::SelectorItem* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.SelectorItem", L"IsSelected"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.IsSelected());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int SelectorItem_put_IsSelected(py::wrapper::Microsoft::UI::Xaml::Controls::Primitives::SelectorItem* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.SelectorItem", L"IsSelected"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<bool>(arg);

            self->obj.IsSelected(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* SelectorItem_get_IsSelectedProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.SelectorItem", L"IsSelectedProperty"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Microsoft::UI::Xaml::Controls::Primitives::SelectorItem::IsSelectedProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_SelectorItem(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Microsoft::UI::Xaml::Controls::Primitives::SelectorItem>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_SelectorItem(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Microsoft::UI::Xaml::Controls::Primitives::SelectorItem>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_SelectorItem[] = {
        { "_assign_array_", _assign_array_SelectorItem, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_SelectorItem), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_SelectorItem[] = {
        { "is_selected", reinterpret_cast<getter>(SelectorItem_get_IsSelected), reinterpret_cast<setter>(SelectorItem_put_IsSelected), nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_SelectorItem[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_SelectorItem) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_SelectorItem) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_SelectorItem) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_SelectorItem) },
        { },
    };

    static PyType_Spec type_spec_SelectorItem =
    {
        "winrt._winrt_microsoft_ui_xaml_controls_primitives.SelectorItem",
        sizeof(py::wrapper::Microsoft::UI::Xaml::Controls::Primitives::SelectorItem),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_SelectorItem
    };

    static PyGetSetDef getset_SelectorItem_Static[] = {
        { "is_selected_property", reinterpret_cast<getter>(SelectorItem_get_IsSelectedProperty), nullptr, nullptr, nullptr },
        { }
    };

    static PyMethodDef methods_SelectorItem_Static[] = {
        { }
    };

    static PyType_Slot type_slots_SelectorItem_Static[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_SelectorItem_Static) },
        { Py_tp_methods, reinterpret_cast<void*>(methods_SelectorItem_Static) },
        { }
    };

    static PyType_Spec type_spec_SelectorItem_Static =
    {
        "winrt._winrt_microsoft_ui_xaml_controls_primitives.SelectorItem_Static",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT,
        type_slots_SelectorItem_Static
    };

    // ----- SnapPointBase class --------------------

    static PyObject* _new_SnapPointBase(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Microsoft::UI::Xaml::Controls::Primitives::SnapPointBase>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Microsoft::UI::Xaml::Controls::Primitives::SnapPointBase>::type_name);
        return nullptr;
    }

    static void _dealloc_SnapPointBase(py::wrapper::Microsoft::UI::Xaml::Controls::Primitives::SnapPointBase* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* _assign_array_SnapPointBase(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Microsoft::UI::Xaml::Controls::Primitives::SnapPointBase>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_SnapPointBase(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Microsoft::UI::Xaml::Controls::Primitives::SnapPointBase>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_SnapPointBase[] = {
        { "_assign_array_", _assign_array_SnapPointBase, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_SnapPointBase), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_SnapPointBase[] = {
        { }
    };

    static PyType_Slot _type_slots_SnapPointBase[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_SnapPointBase) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_SnapPointBase) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_SnapPointBase) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_SnapPointBase) },
        { },
    };

    static PyType_Spec type_spec_SnapPointBase =
    {
        "winrt._winrt_microsoft_ui_xaml_controls_primitives.SnapPointBase",
        sizeof(py::wrapper::Microsoft::UI::Xaml::Controls::Primitives::SnapPointBase),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_SnapPointBase
    };

    // ----- SplitViewTemplateSettings class --------------------

    static PyObject* _new_SplitViewTemplateSettings(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Microsoft::UI::Xaml::Controls::Primitives::SplitViewTemplateSettings>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Microsoft::UI::Xaml::Controls::Primitives::SplitViewTemplateSettings>::type_name);
        return nullptr;
    }

    static void _dealloc_SplitViewTemplateSettings(py::wrapper::Microsoft::UI::Xaml::Controls::Primitives::SplitViewTemplateSettings* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* SplitViewTemplateSettings_get_CompactPaneGridLength(py::wrapper::Microsoft::UI::Xaml::Controls::Primitives::SplitViewTemplateSettings* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.SplitViewTemplateSettings", L"CompactPaneGridLength"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.CompactPaneGridLength());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SplitViewTemplateSettings_get_NegativeOpenPaneLength(py::wrapper::Microsoft::UI::Xaml::Controls::Primitives::SplitViewTemplateSettings* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.SplitViewTemplateSettings", L"NegativeOpenPaneLength"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.NegativeOpenPaneLength());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SplitViewTemplateSettings_get_NegativeOpenPaneLengthMinusCompactLength(py::wrapper::Microsoft::UI::Xaml::Controls::Primitives::SplitViewTemplateSettings* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.SplitViewTemplateSettings", L"NegativeOpenPaneLengthMinusCompactLength"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.NegativeOpenPaneLengthMinusCompactLength());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SplitViewTemplateSettings_get_OpenPaneGridLength(py::wrapper::Microsoft::UI::Xaml::Controls::Primitives::SplitViewTemplateSettings* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.SplitViewTemplateSettings", L"OpenPaneGridLength"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.OpenPaneGridLength());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SplitViewTemplateSettings_get_OpenPaneLength(py::wrapper::Microsoft::UI::Xaml::Controls::Primitives::SplitViewTemplateSettings* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.SplitViewTemplateSettings", L"OpenPaneLength"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.OpenPaneLength());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SplitViewTemplateSettings_get_OpenPaneLengthMinusCompactLength(py::wrapper::Microsoft::UI::Xaml::Controls::Primitives::SplitViewTemplateSettings* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.SplitViewTemplateSettings", L"OpenPaneLengthMinusCompactLength"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.OpenPaneLengthMinusCompactLength());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_SplitViewTemplateSettings(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Microsoft::UI::Xaml::Controls::Primitives::SplitViewTemplateSettings>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_SplitViewTemplateSettings(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Microsoft::UI::Xaml::Controls::Primitives::SplitViewTemplateSettings>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_SplitViewTemplateSettings[] = {
        { "_assign_array_", _assign_array_SplitViewTemplateSettings, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_SplitViewTemplateSettings), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_SplitViewTemplateSettings[] = {
        { "compact_pane_grid_length", reinterpret_cast<getter>(SplitViewTemplateSettings_get_CompactPaneGridLength), nullptr, nullptr, nullptr },
        { "negative_open_pane_length", reinterpret_cast<getter>(SplitViewTemplateSettings_get_NegativeOpenPaneLength), nullptr, nullptr, nullptr },
        { "negative_open_pane_length_minus_compact_length", reinterpret_cast<getter>(SplitViewTemplateSettings_get_NegativeOpenPaneLengthMinusCompactLength), nullptr, nullptr, nullptr },
        { "open_pane_grid_length", reinterpret_cast<getter>(SplitViewTemplateSettings_get_OpenPaneGridLength), nullptr, nullptr, nullptr },
        { "open_pane_length", reinterpret_cast<getter>(SplitViewTemplateSettings_get_OpenPaneLength), nullptr, nullptr, nullptr },
        { "open_pane_length_minus_compact_length", reinterpret_cast<getter>(SplitViewTemplateSettings_get_OpenPaneLengthMinusCompactLength), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_SplitViewTemplateSettings[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_SplitViewTemplateSettings) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_SplitViewTemplateSettings) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_SplitViewTemplateSettings) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_SplitViewTemplateSettings) },
        { },
    };

    static PyType_Spec type_spec_SplitViewTemplateSettings =
    {
        "winrt._winrt_microsoft_ui_xaml_controls_primitives.SplitViewTemplateSettings",
        sizeof(py::wrapper::Microsoft::UI::Xaml::Controls::Primitives::SplitViewTemplateSettings),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_SplitViewTemplateSettings
    };

    // ----- TabViewListView class --------------------

    static PyObject* _new_TabViewListView(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 0)
        {
            try
            {
                winrt::Microsoft::UI::Xaml::Controls::Primitives::TabViewListView instance{  };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_TabViewListView(py::wrapper::Microsoft::UI::Xaml::Controls::Primitives::TabViewListView* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* _assign_array_TabViewListView(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Microsoft::UI::Xaml::Controls::Primitives::TabViewListView>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_TabViewListView(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Microsoft::UI::Xaml::Controls::Primitives::TabViewListView>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_TabViewListView[] = {
        { "_assign_array_", _assign_array_TabViewListView, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_TabViewListView), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_TabViewListView[] = {
        { }
    };

    static PyType_Slot _type_slots_TabViewListView[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_TabViewListView) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_TabViewListView) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_TabViewListView) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_TabViewListView) },
        { },
    };

    static PyType_Spec type_spec_TabViewListView =
    {
        "winrt._winrt_microsoft_ui_xaml_controls_primitives.TabViewListView",
        sizeof(py::wrapper::Microsoft::UI::Xaml::Controls::Primitives::TabViewListView),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_TabViewListView
    };

    // ----- Thumb class --------------------

    static PyObject* _new_Thumb(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 0)
        {
            try
            {
                winrt::Microsoft::UI::Xaml::Controls::Primitives::Thumb instance{  };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_Thumb(py::wrapper::Microsoft::UI::Xaml::Controls::Primitives::Thumb* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* Thumb_CancelDrag(py::wrapper::Microsoft::UI::Xaml::Controls::Primitives::Thumb* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Xaml.Controls.Primitives.Thumb", L"CancelDrag", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                self->obj.CancelDrag();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* Thumb_get_IsDragging(py::wrapper::Microsoft::UI::Xaml::Controls::Primitives::Thumb* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.Thumb", L"IsDragging"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.IsDragging());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* Thumb_get_IsDraggingProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.Thumb", L"IsDraggingProperty"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Microsoft::UI::Xaml::Controls::Primitives::Thumb::IsDraggingProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* Thumb_add_DragCompleted(py::wrapper::Microsoft::UI::Xaml::Controls::Primitives::Thumb* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Microsoft.UI.Xaml.Controls.Primitives.Thumb", L"DragCompleted"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Microsoft::UI::Xaml::Controls::Primitives::DragCompletedEventHandler>(arg);

            return py::convert(self->obj.DragCompleted(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* Thumb_remove_DragCompleted(py::wrapper::Microsoft::UI::Xaml::Controls::Primitives::Thumb* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Microsoft.UI.Xaml.Controls.Primitives.Thumb", L"DragCompleted"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.DragCompleted(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* Thumb_add_DragDelta(py::wrapper::Microsoft::UI::Xaml::Controls::Primitives::Thumb* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Microsoft.UI.Xaml.Controls.Primitives.Thumb", L"DragDelta"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Microsoft::UI::Xaml::Controls::Primitives::DragDeltaEventHandler>(arg);

            return py::convert(self->obj.DragDelta(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* Thumb_remove_DragDelta(py::wrapper::Microsoft::UI::Xaml::Controls::Primitives::Thumb* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Microsoft.UI.Xaml.Controls.Primitives.Thumb", L"DragDelta"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.DragDelta(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* Thumb_add_DragStarted(py::wrapper::Microsoft::UI::Xaml::Controls::Primitives::Thumb* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Microsoft.UI.Xaml.Controls.Primitives.Thumb", L"DragStarted"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Microsoft::UI::Xaml::Controls::Primitives::DragStartedEventHandler>(arg);

            return py::convert(self->obj.DragStarted(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* Thumb_remove_DragStarted(py::wrapper::Microsoft::UI::Xaml::Controls::Primitives::Thumb* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Microsoft.UI.Xaml.Controls.Primitives.Thumb", L"DragStarted"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.DragStarted(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_Thumb(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Microsoft::UI::Xaml::Controls::Primitives::Thumb>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_Thumb(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Microsoft::UI::Xaml::Controls::Primitives::Thumb>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_Thumb[] = {
        { "cancel_drag", reinterpret_cast<PyCFunction>(Thumb_CancelDrag), METH_VARARGS, nullptr },
        { "add_drag_completed", reinterpret_cast<PyCFunction>(Thumb_add_DragCompleted), METH_O, nullptr },
        { "remove_drag_completed", reinterpret_cast<PyCFunction>(Thumb_remove_DragCompleted), METH_O, nullptr },
        { "add_drag_delta", reinterpret_cast<PyCFunction>(Thumb_add_DragDelta), METH_O, nullptr },
        { "remove_drag_delta", reinterpret_cast<PyCFunction>(Thumb_remove_DragDelta), METH_O, nullptr },
        { "add_drag_started", reinterpret_cast<PyCFunction>(Thumb_add_DragStarted), METH_O, nullptr },
        { "remove_drag_started", reinterpret_cast<PyCFunction>(Thumb_remove_DragStarted), METH_O, nullptr },
        { "_assign_array_", _assign_array_Thumb, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_Thumb), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_Thumb[] = {
        { "is_dragging", reinterpret_cast<getter>(Thumb_get_IsDragging), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_Thumb[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_Thumb) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_Thumb) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_Thumb) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_Thumb) },
        { },
    };

    static PyType_Spec type_spec_Thumb =
    {
        "winrt._winrt_microsoft_ui_xaml_controls_primitives.Thumb",
        sizeof(py::wrapper::Microsoft::UI::Xaml::Controls::Primitives::Thumb),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_Thumb
    };

    static PyGetSetDef getset_Thumb_Static[] = {
        { "is_dragging_property", reinterpret_cast<getter>(Thumb_get_IsDraggingProperty), nullptr, nullptr, nullptr },
        { }
    };

    static PyMethodDef methods_Thumb_Static[] = {
        { }
    };

    static PyType_Slot type_slots_Thumb_Static[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_Thumb_Static) },
        { Py_tp_methods, reinterpret_cast<void*>(methods_Thumb_Static) },
        { }
    };

    static PyType_Spec type_spec_Thumb_Static =
    {
        "winrt._winrt_microsoft_ui_xaml_controls_primitives.Thumb_Static",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT,
        type_slots_Thumb_Static
    };

    // ----- TickBar class --------------------

    static PyObject* _new_TickBar(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 0)
        {
            try
            {
                winrt::Microsoft::UI::Xaml::Controls::Primitives::TickBar instance{  };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_TickBar(py::wrapper::Microsoft::UI::Xaml::Controls::Primitives::TickBar* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* TickBar_get_Fill(py::wrapper::Microsoft::UI::Xaml::Controls::Primitives::TickBar* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.TickBar", L"Fill"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Fill());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int TickBar_put_Fill(py::wrapper::Microsoft::UI::Xaml::Controls::Primitives::TickBar* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.TickBar", L"Fill"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Microsoft::UI::Xaml::Media::Brush>(arg);

            self->obj.Fill(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* TickBar_get_FillProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.TickBar", L"FillProperty"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Microsoft::UI::Xaml::Controls::Primitives::TickBar::FillProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_TickBar(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Microsoft::UI::Xaml::Controls::Primitives::TickBar>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_TickBar(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Microsoft::UI::Xaml::Controls::Primitives::TickBar>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_TickBar[] = {
        { "_assign_array_", _assign_array_TickBar, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_TickBar), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_TickBar[] = {
        { "fill", reinterpret_cast<getter>(TickBar_get_Fill), reinterpret_cast<setter>(TickBar_put_Fill), nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_TickBar[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_TickBar) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_TickBar) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_TickBar) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_TickBar) },
        { },
    };

    static PyType_Spec type_spec_TickBar =
    {
        "winrt._winrt_microsoft_ui_xaml_controls_primitives.TickBar",
        sizeof(py::wrapper::Microsoft::UI::Xaml::Controls::Primitives::TickBar),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_TickBar
    };

    static PyGetSetDef getset_TickBar_Static[] = {
        { "fill_property", reinterpret_cast<getter>(TickBar_get_FillProperty), nullptr, nullptr, nullptr },
        { }
    };

    static PyMethodDef methods_TickBar_Static[] = {
        { }
    };

    static PyType_Slot type_slots_TickBar_Static[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_TickBar_Static) },
        { Py_tp_methods, reinterpret_cast<void*>(methods_TickBar_Static) },
        { }
    };

    static PyType_Spec type_spec_TickBar_Static =
    {
        "winrt._winrt_microsoft_ui_xaml_controls_primitives.TickBar_Static",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT,
        type_slots_TickBar_Static
    };

    // ----- ToggleButton class --------------------

    static PyObject* _new_ToggleButton(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 0)
        {
            try
            {
                winrt::Microsoft::UI::Xaml::Controls::Primitives::ToggleButton instance{  };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_ToggleButton(py::wrapper::Microsoft::UI::Xaml::Controls::Primitives::ToggleButton* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* ToggleButton_OnToggle(py::wrapper::Microsoft::UI::Xaml::Controls::Primitives::ToggleButton* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Xaml.Controls.Primitives.ToggleButton", L"OnToggle", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                self->obj.OnToggle();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ToggleButton_get_IsThreeState(py::wrapper::Microsoft::UI::Xaml::Controls::Primitives::ToggleButton* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.ToggleButton", L"IsThreeState"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.IsThreeState());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ToggleButton_put_IsThreeState(py::wrapper::Microsoft::UI::Xaml::Controls::Primitives::ToggleButton* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.ToggleButton", L"IsThreeState"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<bool>(arg);

            self->obj.IsThreeState(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ToggleButton_get_IsChecked(py::wrapper::Microsoft::UI::Xaml::Controls::Primitives::ToggleButton* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.ToggleButton", L"IsChecked"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.IsChecked());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ToggleButton_put_IsChecked(py::wrapper::Microsoft::UI::Xaml::Controls::Primitives::ToggleButton* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.ToggleButton", L"IsChecked"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::IReference<bool>>(arg);

            self->obj.IsChecked(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ToggleButton_get_IsCheckedProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.ToggleButton", L"IsCheckedProperty"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Microsoft::UI::Xaml::Controls::Primitives::ToggleButton::IsCheckedProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ToggleButton_get_IsThreeStateProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.ToggleButton", L"IsThreeStateProperty"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Microsoft::UI::Xaml::Controls::Primitives::ToggleButton::IsThreeStateProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ToggleButton_add_Checked(py::wrapper::Microsoft::UI::Xaml::Controls::Primitives::ToggleButton* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Microsoft.UI.Xaml.Controls.Primitives.ToggleButton", L"Checked"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Microsoft::UI::Xaml::RoutedEventHandler>(arg);

            return py::convert(self->obj.Checked(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ToggleButton_remove_Checked(py::wrapper::Microsoft::UI::Xaml::Controls::Primitives::ToggleButton* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Microsoft.UI.Xaml.Controls.Primitives.ToggleButton", L"Checked"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.Checked(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ToggleButton_add_Indeterminate(py::wrapper::Microsoft::UI::Xaml::Controls::Primitives::ToggleButton* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Microsoft.UI.Xaml.Controls.Primitives.ToggleButton", L"Indeterminate"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Microsoft::UI::Xaml::RoutedEventHandler>(arg);

            return py::convert(self->obj.Indeterminate(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ToggleButton_remove_Indeterminate(py::wrapper::Microsoft::UI::Xaml::Controls::Primitives::ToggleButton* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Microsoft.UI.Xaml.Controls.Primitives.ToggleButton", L"Indeterminate"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.Indeterminate(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ToggleButton_add_Unchecked(py::wrapper::Microsoft::UI::Xaml::Controls::Primitives::ToggleButton* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Microsoft.UI.Xaml.Controls.Primitives.ToggleButton", L"Unchecked"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Microsoft::UI::Xaml::RoutedEventHandler>(arg);

            return py::convert(self->obj.Unchecked(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ToggleButton_remove_Unchecked(py::wrapper::Microsoft::UI::Xaml::Controls::Primitives::ToggleButton* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Microsoft.UI.Xaml.Controls.Primitives.ToggleButton", L"Unchecked"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.Unchecked(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_ToggleButton(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Microsoft::UI::Xaml::Controls::Primitives::ToggleButton>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_ToggleButton(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Microsoft::UI::Xaml::Controls::Primitives::ToggleButton>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_ToggleButton[] = {
        { "on_toggle", reinterpret_cast<PyCFunction>(ToggleButton_OnToggle), METH_VARARGS, nullptr },
        { "add_checked", reinterpret_cast<PyCFunction>(ToggleButton_add_Checked), METH_O, nullptr },
        { "remove_checked", reinterpret_cast<PyCFunction>(ToggleButton_remove_Checked), METH_O, nullptr },
        { "add_indeterminate", reinterpret_cast<PyCFunction>(ToggleButton_add_Indeterminate), METH_O, nullptr },
        { "remove_indeterminate", reinterpret_cast<PyCFunction>(ToggleButton_remove_Indeterminate), METH_O, nullptr },
        { "add_unchecked", reinterpret_cast<PyCFunction>(ToggleButton_add_Unchecked), METH_O, nullptr },
        { "remove_unchecked", reinterpret_cast<PyCFunction>(ToggleButton_remove_Unchecked), METH_O, nullptr },
        { "_assign_array_", _assign_array_ToggleButton, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_ToggleButton), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_ToggleButton[] = {
        { "is_three_state", reinterpret_cast<getter>(ToggleButton_get_IsThreeState), reinterpret_cast<setter>(ToggleButton_put_IsThreeState), nullptr, nullptr },
        { "is_checked", reinterpret_cast<getter>(ToggleButton_get_IsChecked), reinterpret_cast<setter>(ToggleButton_put_IsChecked), nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_ToggleButton[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_ToggleButton) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_ToggleButton) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_ToggleButton) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_ToggleButton) },
        { },
    };

    static PyType_Spec type_spec_ToggleButton =
    {
        "winrt._winrt_microsoft_ui_xaml_controls_primitives.ToggleButton",
        sizeof(py::wrapper::Microsoft::UI::Xaml::Controls::Primitives::ToggleButton),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_ToggleButton
    };

    static PyGetSetDef getset_ToggleButton_Static[] = {
        { "is_checked_property", reinterpret_cast<getter>(ToggleButton_get_IsCheckedProperty), nullptr, nullptr, nullptr },
        { "is_three_state_property", reinterpret_cast<getter>(ToggleButton_get_IsThreeStateProperty), nullptr, nullptr, nullptr },
        { }
    };

    static PyMethodDef methods_ToggleButton_Static[] = {
        { }
    };

    static PyType_Slot type_slots_ToggleButton_Static[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_ToggleButton_Static) },
        { Py_tp_methods, reinterpret_cast<void*>(methods_ToggleButton_Static) },
        { }
    };

    static PyType_Spec type_spec_ToggleButton_Static =
    {
        "winrt._winrt_microsoft_ui_xaml_controls_primitives.ToggleButton_Static",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT,
        type_slots_ToggleButton_Static
    };

    // ----- ToggleSwitchTemplateSettings class --------------------

    static PyObject* _new_ToggleSwitchTemplateSettings(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Microsoft::UI::Xaml::Controls::Primitives::ToggleSwitchTemplateSettings>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Microsoft::UI::Xaml::Controls::Primitives::ToggleSwitchTemplateSettings>::type_name);
        return nullptr;
    }

    static void _dealloc_ToggleSwitchTemplateSettings(py::wrapper::Microsoft::UI::Xaml::Controls::Primitives::ToggleSwitchTemplateSettings* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* ToggleSwitchTemplateSettings_get_CurtainCurrentToOffOffset(py::wrapper::Microsoft::UI::Xaml::Controls::Primitives::ToggleSwitchTemplateSettings* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.ToggleSwitchTemplateSettings", L"CurtainCurrentToOffOffset"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.CurtainCurrentToOffOffset());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ToggleSwitchTemplateSettings_get_CurtainCurrentToOnOffset(py::wrapper::Microsoft::UI::Xaml::Controls::Primitives::ToggleSwitchTemplateSettings* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.ToggleSwitchTemplateSettings", L"CurtainCurrentToOnOffset"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.CurtainCurrentToOnOffset());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ToggleSwitchTemplateSettings_get_CurtainOffToOnOffset(py::wrapper::Microsoft::UI::Xaml::Controls::Primitives::ToggleSwitchTemplateSettings* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.ToggleSwitchTemplateSettings", L"CurtainOffToOnOffset"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.CurtainOffToOnOffset());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ToggleSwitchTemplateSettings_get_CurtainOnToOffOffset(py::wrapper::Microsoft::UI::Xaml::Controls::Primitives::ToggleSwitchTemplateSettings* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.ToggleSwitchTemplateSettings", L"CurtainOnToOffOffset"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.CurtainOnToOffOffset());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ToggleSwitchTemplateSettings_get_KnobCurrentToOffOffset(py::wrapper::Microsoft::UI::Xaml::Controls::Primitives::ToggleSwitchTemplateSettings* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.ToggleSwitchTemplateSettings", L"KnobCurrentToOffOffset"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.KnobCurrentToOffOffset());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ToggleSwitchTemplateSettings_get_KnobCurrentToOnOffset(py::wrapper::Microsoft::UI::Xaml::Controls::Primitives::ToggleSwitchTemplateSettings* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.ToggleSwitchTemplateSettings", L"KnobCurrentToOnOffset"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.KnobCurrentToOnOffset());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ToggleSwitchTemplateSettings_get_KnobOffToOnOffset(py::wrapper::Microsoft::UI::Xaml::Controls::Primitives::ToggleSwitchTemplateSettings* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.ToggleSwitchTemplateSettings", L"KnobOffToOnOffset"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.KnobOffToOnOffset());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ToggleSwitchTemplateSettings_get_KnobOnToOffOffset(py::wrapper::Microsoft::UI::Xaml::Controls::Primitives::ToggleSwitchTemplateSettings* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.ToggleSwitchTemplateSettings", L"KnobOnToOffOffset"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.KnobOnToOffOffset());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_ToggleSwitchTemplateSettings(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Microsoft::UI::Xaml::Controls::Primitives::ToggleSwitchTemplateSettings>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_ToggleSwitchTemplateSettings(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Microsoft::UI::Xaml::Controls::Primitives::ToggleSwitchTemplateSettings>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_ToggleSwitchTemplateSettings[] = {
        { "_assign_array_", _assign_array_ToggleSwitchTemplateSettings, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_ToggleSwitchTemplateSettings), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_ToggleSwitchTemplateSettings[] = {
        { "curtain_current_to_off_offset", reinterpret_cast<getter>(ToggleSwitchTemplateSettings_get_CurtainCurrentToOffOffset), nullptr, nullptr, nullptr },
        { "curtain_current_to_on_offset", reinterpret_cast<getter>(ToggleSwitchTemplateSettings_get_CurtainCurrentToOnOffset), nullptr, nullptr, nullptr },
        { "curtain_off_to_on_offset", reinterpret_cast<getter>(ToggleSwitchTemplateSettings_get_CurtainOffToOnOffset), nullptr, nullptr, nullptr },
        { "curtain_on_to_off_offset", reinterpret_cast<getter>(ToggleSwitchTemplateSettings_get_CurtainOnToOffOffset), nullptr, nullptr, nullptr },
        { "knob_current_to_off_offset", reinterpret_cast<getter>(ToggleSwitchTemplateSettings_get_KnobCurrentToOffOffset), nullptr, nullptr, nullptr },
        { "knob_current_to_on_offset", reinterpret_cast<getter>(ToggleSwitchTemplateSettings_get_KnobCurrentToOnOffset), nullptr, nullptr, nullptr },
        { "knob_off_to_on_offset", reinterpret_cast<getter>(ToggleSwitchTemplateSettings_get_KnobOffToOnOffset), nullptr, nullptr, nullptr },
        { "knob_on_to_off_offset", reinterpret_cast<getter>(ToggleSwitchTemplateSettings_get_KnobOnToOffOffset), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_ToggleSwitchTemplateSettings[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_ToggleSwitchTemplateSettings) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_ToggleSwitchTemplateSettings) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_ToggleSwitchTemplateSettings) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_ToggleSwitchTemplateSettings) },
        { },
    };

    static PyType_Spec type_spec_ToggleSwitchTemplateSettings =
    {
        "winrt._winrt_microsoft_ui_xaml_controls_primitives.ToggleSwitchTemplateSettings",
        sizeof(py::wrapper::Microsoft::UI::Xaml::Controls::Primitives::ToggleSwitchTemplateSettings),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_ToggleSwitchTemplateSettings
    };

    // ----- ToolTipTemplateSettings class --------------------

    static PyObject* _new_ToolTipTemplateSettings(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Microsoft::UI::Xaml::Controls::Primitives::ToolTipTemplateSettings>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Microsoft::UI::Xaml::Controls::Primitives::ToolTipTemplateSettings>::type_name);
        return nullptr;
    }

    static void _dealloc_ToolTipTemplateSettings(py::wrapper::Microsoft::UI::Xaml::Controls::Primitives::ToolTipTemplateSettings* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* ToolTipTemplateSettings_get_FromHorizontalOffset(py::wrapper::Microsoft::UI::Xaml::Controls::Primitives::ToolTipTemplateSettings* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.ToolTipTemplateSettings", L"FromHorizontalOffset"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.FromHorizontalOffset());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ToolTipTemplateSettings_get_FromVerticalOffset(py::wrapper::Microsoft::UI::Xaml::Controls::Primitives::ToolTipTemplateSettings* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.ToolTipTemplateSettings", L"FromVerticalOffset"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.FromVerticalOffset());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_ToolTipTemplateSettings(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Microsoft::UI::Xaml::Controls::Primitives::ToolTipTemplateSettings>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_ToolTipTemplateSettings(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Microsoft::UI::Xaml::Controls::Primitives::ToolTipTemplateSettings>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_ToolTipTemplateSettings[] = {
        { "_assign_array_", _assign_array_ToolTipTemplateSettings, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_ToolTipTemplateSettings), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_ToolTipTemplateSettings[] = {
        { "from_horizontal_offset", reinterpret_cast<getter>(ToolTipTemplateSettings_get_FromHorizontalOffset), nullptr, nullptr, nullptr },
        { "from_vertical_offset", reinterpret_cast<getter>(ToolTipTemplateSettings_get_FromVerticalOffset), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_ToolTipTemplateSettings[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_ToolTipTemplateSettings) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_ToolTipTemplateSettings) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_ToolTipTemplateSettings) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_ToolTipTemplateSettings) },
        { },
    };

    static PyType_Spec type_spec_ToolTipTemplateSettings =
    {
        "winrt._winrt_microsoft_ui_xaml_controls_primitives.ToolTipTemplateSettings",
        sizeof(py::wrapper::Microsoft::UI::Xaml::Controls::Primitives::ToolTipTemplateSettings),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_ToolTipTemplateSettings
    };

    // ----- ZoomSnapPoint class --------------------

    static PyObject* _new_ZoomSnapPoint(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<double>(args, 0);

                winrt::Microsoft::UI::Xaml::Controls::Primitives::ZoomSnapPoint instance{ param0 };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_ZoomSnapPoint(py::wrapper::Microsoft::UI::Xaml::Controls::Primitives::ZoomSnapPoint* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* ZoomSnapPoint_get_Value(py::wrapper::Microsoft::UI::Xaml::Controls::Primitives::ZoomSnapPoint* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.ZoomSnapPoint", L"Value"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Value());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_ZoomSnapPoint(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Microsoft::UI::Xaml::Controls::Primitives::ZoomSnapPoint>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_ZoomSnapPoint(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Microsoft::UI::Xaml::Controls::Primitives::ZoomSnapPoint>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_ZoomSnapPoint[] = {
        { "_assign_array_", _assign_array_ZoomSnapPoint, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_ZoomSnapPoint), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_ZoomSnapPoint[] = {
        { "value", reinterpret_cast<getter>(ZoomSnapPoint_get_Value), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_ZoomSnapPoint[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_ZoomSnapPoint) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_ZoomSnapPoint) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_ZoomSnapPoint) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_ZoomSnapPoint) },
        { },
    };

    static PyType_Spec type_spec_ZoomSnapPoint =
    {
        "winrt._winrt_microsoft_ui_xaml_controls_primitives.ZoomSnapPoint",
        sizeof(py::wrapper::Microsoft::UI::Xaml::Controls::Primitives::ZoomSnapPoint),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_ZoomSnapPoint
    };

    // ----- ZoomSnapPointBase class --------------------

    static PyObject* _new_ZoomSnapPointBase(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Microsoft::UI::Xaml::Controls::Primitives::ZoomSnapPointBase>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Microsoft::UI::Xaml::Controls::Primitives::ZoomSnapPointBase>::type_name);
        return nullptr;
    }

    static void _dealloc_ZoomSnapPointBase(py::wrapper::Microsoft::UI::Xaml::Controls::Primitives::ZoomSnapPointBase* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* _assign_array_ZoomSnapPointBase(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Microsoft::UI::Xaml::Controls::Primitives::ZoomSnapPointBase>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_ZoomSnapPointBase(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Microsoft::UI::Xaml::Controls::Primitives::ZoomSnapPointBase>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_ZoomSnapPointBase[] = {
        { "_assign_array_", _assign_array_ZoomSnapPointBase, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_ZoomSnapPointBase), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_ZoomSnapPointBase[] = {
        { }
    };

    static PyType_Slot _type_slots_ZoomSnapPointBase[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_ZoomSnapPointBase) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_ZoomSnapPointBase) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_ZoomSnapPointBase) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_ZoomSnapPointBase) },
        { },
    };

    static PyType_Spec type_spec_ZoomSnapPointBase =
    {
        "winrt._winrt_microsoft_ui_xaml_controls_primitives.ZoomSnapPointBase",
        sizeof(py::wrapper::Microsoft::UI::Xaml::Controls::Primitives::ZoomSnapPointBase),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_ZoomSnapPointBase
    };

    // ----- IScrollController interface --------------------

    static PyObject* _new_IScrollController(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Microsoft::UI::Xaml::Controls::Primitives::IScrollController>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Microsoft::UI::Xaml::Controls::Primitives::IScrollController>::type_name);
        return nullptr;
    }

    static void _dealloc_IScrollController(py::wrapper::Microsoft::UI::Xaml::Controls::Primitives::IScrollController* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* IScrollController_GetScrollAnimation(py::wrapper::Microsoft::UI::Xaml::Controls::Primitives::IScrollController* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 4)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Xaml.Controls.Primitives.IScrollController", L"GetScrollAnimation", 4))
            {
                py::set_arg_count_version_error(4);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<int32_t>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Foundation::Numerics::float2>(args, 1);
                auto param2 = py::convert_to<winrt::Windows::Foundation::Numerics::float2>(args, 2);
                auto param3 = py::convert_to<winrt::Microsoft::UI::Composition::CompositionAnimation>(args, 3);

                return py::convert(self->obj.GetScrollAnimation(param0, param1, param2, param3));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* IScrollController_NotifyRequestedScrollCompleted(py::wrapper::Microsoft::UI::Xaml::Controls::Primitives::IScrollController* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Xaml.Controls.Primitives.IScrollController", L"NotifyRequestedScrollCompleted", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<int32_t>(args, 0);

                self->obj.NotifyRequestedScrollCompleted(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* IScrollController_SetIsScrollable(py::wrapper::Microsoft::UI::Xaml::Controls::Primitives::IScrollController* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Xaml.Controls.Primitives.IScrollController", L"SetIsScrollable", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<bool>(args, 0);

                self->obj.SetIsScrollable(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* IScrollController_SetValues(py::wrapper::Microsoft::UI::Xaml::Controls::Primitives::IScrollController* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 4)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Xaml.Controls.Primitives.IScrollController", L"SetValues", 4))
            {
                py::set_arg_count_version_error(4);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<double>(args, 0);
                auto param1 = py::convert_to<double>(args, 1);
                auto param2 = py::convert_to<double>(args, 2);
                auto param3 = py::convert_to<double>(args, 3);

                self->obj.SetValues(param0, param1, param2, param3);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* IScrollController_get_CanScroll(py::wrapper::Microsoft::UI::Xaml::Controls::Primitives::IScrollController* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.IScrollController", L"CanScroll"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.CanScroll());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IScrollController_get_IsScrollingWithMouse(py::wrapper::Microsoft::UI::Xaml::Controls::Primitives::IScrollController* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.IScrollController", L"IsScrollingWithMouse"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.IsScrollingWithMouse());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IScrollController_get_PanningInfo(py::wrapper::Microsoft::UI::Xaml::Controls::Primitives::IScrollController* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.IScrollController", L"PanningInfo"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.PanningInfo());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IScrollController_add_AddScrollVelocityRequested(py::wrapper::Microsoft::UI::Xaml::Controls::Primitives::IScrollController* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Microsoft.UI.Xaml.Controls.Primitives.IScrollController", L"AddScrollVelocityRequested"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Microsoft::UI::Xaml::Controls::Primitives::IScrollController, winrt::Microsoft::UI::Xaml::Controls::Primitives::ScrollControllerAddScrollVelocityRequestedEventArgs>>(arg);

            return py::convert(self->obj.AddScrollVelocityRequested(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IScrollController_remove_AddScrollVelocityRequested(py::wrapper::Microsoft::UI::Xaml::Controls::Primitives::IScrollController* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Microsoft.UI.Xaml.Controls.Primitives.IScrollController", L"AddScrollVelocityRequested"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.AddScrollVelocityRequested(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IScrollController_add_CanScrollChanged(py::wrapper::Microsoft::UI::Xaml::Controls::Primitives::IScrollController* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Microsoft.UI.Xaml.Controls.Primitives.IScrollController", L"CanScrollChanged"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Microsoft::UI::Xaml::Controls::Primitives::IScrollController, winrt::Windows::Foundation::IInspectable>>(arg);

            return py::convert(self->obj.CanScrollChanged(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IScrollController_remove_CanScrollChanged(py::wrapper::Microsoft::UI::Xaml::Controls::Primitives::IScrollController* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Microsoft.UI.Xaml.Controls.Primitives.IScrollController", L"CanScrollChanged"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.CanScrollChanged(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IScrollController_add_IsScrollingWithMouseChanged(py::wrapper::Microsoft::UI::Xaml::Controls::Primitives::IScrollController* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Microsoft.UI.Xaml.Controls.Primitives.IScrollController", L"IsScrollingWithMouseChanged"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Microsoft::UI::Xaml::Controls::Primitives::IScrollController, winrt::Windows::Foundation::IInspectable>>(arg);

            return py::convert(self->obj.IsScrollingWithMouseChanged(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IScrollController_remove_IsScrollingWithMouseChanged(py::wrapper::Microsoft::UI::Xaml::Controls::Primitives::IScrollController* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Microsoft.UI.Xaml.Controls.Primitives.IScrollController", L"IsScrollingWithMouseChanged"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.IsScrollingWithMouseChanged(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IScrollController_add_ScrollByRequested(py::wrapper::Microsoft::UI::Xaml::Controls::Primitives::IScrollController* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Microsoft.UI.Xaml.Controls.Primitives.IScrollController", L"ScrollByRequested"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Microsoft::UI::Xaml::Controls::Primitives::IScrollController, winrt::Microsoft::UI::Xaml::Controls::Primitives::ScrollControllerScrollByRequestedEventArgs>>(arg);

            return py::convert(self->obj.ScrollByRequested(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IScrollController_remove_ScrollByRequested(py::wrapper::Microsoft::UI::Xaml::Controls::Primitives::IScrollController* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Microsoft.UI.Xaml.Controls.Primitives.IScrollController", L"ScrollByRequested"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.ScrollByRequested(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IScrollController_add_ScrollToRequested(py::wrapper::Microsoft::UI::Xaml::Controls::Primitives::IScrollController* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Microsoft.UI.Xaml.Controls.Primitives.IScrollController", L"ScrollToRequested"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Microsoft::UI::Xaml::Controls::Primitives::IScrollController, winrt::Microsoft::UI::Xaml::Controls::Primitives::ScrollControllerScrollToRequestedEventArgs>>(arg);

            return py::convert(self->obj.ScrollToRequested(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IScrollController_remove_ScrollToRequested(py::wrapper::Microsoft::UI::Xaml::Controls::Primitives::IScrollController* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Microsoft.UI.Xaml.Controls.Primitives.IScrollController", L"ScrollToRequested"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.ScrollToRequested(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_IScrollController(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Microsoft::UI::Xaml::Controls::Primitives::IScrollController>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_IScrollController(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Microsoft::UI::Xaml::Controls::Primitives::IScrollController>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_IScrollController[] = {
        { "get_scroll_animation", reinterpret_cast<PyCFunction>(IScrollController_GetScrollAnimation), METH_VARARGS, nullptr },
        { "notify_requested_scroll_completed", reinterpret_cast<PyCFunction>(IScrollController_NotifyRequestedScrollCompleted), METH_VARARGS, nullptr },
        { "set_is_scrollable", reinterpret_cast<PyCFunction>(IScrollController_SetIsScrollable), METH_VARARGS, nullptr },
        { "set_values", reinterpret_cast<PyCFunction>(IScrollController_SetValues), METH_VARARGS, nullptr },
        { "add_add_scroll_velocity_requested", reinterpret_cast<PyCFunction>(IScrollController_add_AddScrollVelocityRequested), METH_O, nullptr },
        { "remove_add_scroll_velocity_requested", reinterpret_cast<PyCFunction>(IScrollController_remove_AddScrollVelocityRequested), METH_O, nullptr },
        { "add_can_scroll_changed", reinterpret_cast<PyCFunction>(IScrollController_add_CanScrollChanged), METH_O, nullptr },
        { "remove_can_scroll_changed", reinterpret_cast<PyCFunction>(IScrollController_remove_CanScrollChanged), METH_O, nullptr },
        { "add_is_scrolling_with_mouse_changed", reinterpret_cast<PyCFunction>(IScrollController_add_IsScrollingWithMouseChanged), METH_O, nullptr },
        { "remove_is_scrolling_with_mouse_changed", reinterpret_cast<PyCFunction>(IScrollController_remove_IsScrollingWithMouseChanged), METH_O, nullptr },
        { "add_scroll_by_requested", reinterpret_cast<PyCFunction>(IScrollController_add_ScrollByRequested), METH_O, nullptr },
        { "remove_scroll_by_requested", reinterpret_cast<PyCFunction>(IScrollController_remove_ScrollByRequested), METH_O, nullptr },
        { "add_scroll_to_requested", reinterpret_cast<PyCFunction>(IScrollController_add_ScrollToRequested), METH_O, nullptr },
        { "remove_scroll_to_requested", reinterpret_cast<PyCFunction>(IScrollController_remove_ScrollToRequested), METH_O, nullptr },
        { "_assign_array_", _assign_array_IScrollController, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_IScrollController), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_IScrollController[] = {
        { "can_scroll", reinterpret_cast<getter>(IScrollController_get_CanScroll), nullptr, nullptr, nullptr },
        { "is_scrolling_with_mouse", reinterpret_cast<getter>(IScrollController_get_IsScrollingWithMouse), nullptr, nullptr, nullptr },
        { "panning_info", reinterpret_cast<getter>(IScrollController_get_PanningInfo), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_IScrollController[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_IScrollController) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_IScrollController) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_IScrollController) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_IScrollController) },
        { },
    };

    static PyType_Spec type_spec_IScrollController =
    {
        "winrt._winrt_microsoft_ui_xaml_controls_primitives.IScrollController",
        sizeof(py::wrapper::Microsoft::UI::Xaml::Controls::Primitives::IScrollController),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_IScrollController
    };

    // ----- IScrollControllerPanningInfo interface --------------------

    static PyObject* _new_IScrollControllerPanningInfo(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Microsoft::UI::Xaml::Controls::Primitives::IScrollControllerPanningInfo>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Microsoft::UI::Xaml::Controls::Primitives::IScrollControllerPanningInfo>::type_name);
        return nullptr;
    }

    static void _dealloc_IScrollControllerPanningInfo(py::wrapper::Microsoft::UI::Xaml::Controls::Primitives::IScrollControllerPanningInfo* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* IScrollControllerPanningInfo_SetPanningElementExpressionAnimationSources(py::wrapper::Microsoft::UI::Xaml::Controls::Primitives::IScrollControllerPanningInfo* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 5)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Xaml.Controls.Primitives.IScrollControllerPanningInfo", L"SetPanningElementExpressionAnimationSources", 5))
            {
                py::set_arg_count_version_error(5);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Microsoft::UI::Composition::CompositionPropertySet>(args, 0);
                auto param1 = py::convert_to<winrt::hstring>(args, 1);
                auto param2 = py::convert_to<winrt::hstring>(args, 2);
                auto param3 = py::convert_to<winrt::hstring>(args, 3);
                auto param4 = py::convert_to<winrt::hstring>(args, 4);

                self->obj.SetPanningElementExpressionAnimationSources(param0, param1, param2, param3, param4);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* IScrollControllerPanningInfo_get_IsRailEnabled(py::wrapper::Microsoft::UI::Xaml::Controls::Primitives::IScrollControllerPanningInfo* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.IScrollControllerPanningInfo", L"IsRailEnabled"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.IsRailEnabled());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IScrollControllerPanningInfo_get_PanOrientation(py::wrapper::Microsoft::UI::Xaml::Controls::Primitives::IScrollControllerPanningInfo* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.IScrollControllerPanningInfo", L"PanOrientation"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.PanOrientation());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IScrollControllerPanningInfo_get_PanningElementAncestor(py::wrapper::Microsoft::UI::Xaml::Controls::Primitives::IScrollControllerPanningInfo* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.IScrollControllerPanningInfo", L"PanningElementAncestor"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.PanningElementAncestor());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IScrollControllerPanningInfo_add_Changed(py::wrapper::Microsoft::UI::Xaml::Controls::Primitives::IScrollControllerPanningInfo* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Microsoft.UI.Xaml.Controls.Primitives.IScrollControllerPanningInfo", L"Changed"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Microsoft::UI::Xaml::Controls::Primitives::IScrollControllerPanningInfo, winrt::Windows::Foundation::IInspectable>>(arg);

            return py::convert(self->obj.Changed(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IScrollControllerPanningInfo_remove_Changed(py::wrapper::Microsoft::UI::Xaml::Controls::Primitives::IScrollControllerPanningInfo* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Microsoft.UI.Xaml.Controls.Primitives.IScrollControllerPanningInfo", L"Changed"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.Changed(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IScrollControllerPanningInfo_add_PanRequested(py::wrapper::Microsoft::UI::Xaml::Controls::Primitives::IScrollControllerPanningInfo* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Microsoft.UI.Xaml.Controls.Primitives.IScrollControllerPanningInfo", L"PanRequested"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Microsoft::UI::Xaml::Controls::Primitives::IScrollControllerPanningInfo, winrt::Microsoft::UI::Xaml::Controls::Primitives::ScrollControllerPanRequestedEventArgs>>(arg);

            return py::convert(self->obj.PanRequested(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IScrollControllerPanningInfo_remove_PanRequested(py::wrapper::Microsoft::UI::Xaml::Controls::Primitives::IScrollControllerPanningInfo* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Microsoft.UI.Xaml.Controls.Primitives.IScrollControllerPanningInfo", L"PanRequested"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.PanRequested(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_IScrollControllerPanningInfo(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Microsoft::UI::Xaml::Controls::Primitives::IScrollControllerPanningInfo>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_IScrollControllerPanningInfo(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Microsoft::UI::Xaml::Controls::Primitives::IScrollControllerPanningInfo>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_IScrollControllerPanningInfo[] = {
        { "set_panning_element_expression_animation_sources", reinterpret_cast<PyCFunction>(IScrollControllerPanningInfo_SetPanningElementExpressionAnimationSources), METH_VARARGS, nullptr },
        { "add_changed", reinterpret_cast<PyCFunction>(IScrollControllerPanningInfo_add_Changed), METH_O, nullptr },
        { "remove_changed", reinterpret_cast<PyCFunction>(IScrollControllerPanningInfo_remove_Changed), METH_O, nullptr },
        { "add_pan_requested", reinterpret_cast<PyCFunction>(IScrollControllerPanningInfo_add_PanRequested), METH_O, nullptr },
        { "remove_pan_requested", reinterpret_cast<PyCFunction>(IScrollControllerPanningInfo_remove_PanRequested), METH_O, nullptr },
        { "_assign_array_", _assign_array_IScrollControllerPanningInfo, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_IScrollControllerPanningInfo), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_IScrollControllerPanningInfo[] = {
        { "is_rail_enabled", reinterpret_cast<getter>(IScrollControllerPanningInfo_get_IsRailEnabled), nullptr, nullptr, nullptr },
        { "pan_orientation", reinterpret_cast<getter>(IScrollControllerPanningInfo_get_PanOrientation), nullptr, nullptr, nullptr },
        { "panning_element_ancestor", reinterpret_cast<getter>(IScrollControllerPanningInfo_get_PanningElementAncestor), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_IScrollControllerPanningInfo[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_IScrollControllerPanningInfo) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_IScrollControllerPanningInfo) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_IScrollControllerPanningInfo) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_IScrollControllerPanningInfo) },
        { },
    };

    static PyType_Spec type_spec_IScrollControllerPanningInfo =
    {
        "winrt._winrt_microsoft_ui_xaml_controls_primitives.IScrollControllerPanningInfo",
        sizeof(py::wrapper::Microsoft::UI::Xaml::Controls::Primitives::IScrollControllerPanningInfo),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_IScrollControllerPanningInfo
    };

    // ----- IScrollSnapPointsInfo interface --------------------

    static PyObject* _new_IScrollSnapPointsInfo(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Microsoft::UI::Xaml::Controls::Primitives::IScrollSnapPointsInfo>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Microsoft::UI::Xaml::Controls::Primitives::IScrollSnapPointsInfo>::type_name);
        return nullptr;
    }

    static void _dealloc_IScrollSnapPointsInfo(py::wrapper::Microsoft::UI::Xaml::Controls::Primitives::IScrollSnapPointsInfo* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* IScrollSnapPointsInfo_GetIrregularSnapPoints(py::wrapper::Microsoft::UI::Xaml::Controls::Primitives::IScrollSnapPointsInfo* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Xaml.Controls.Primitives.IScrollSnapPointsInfo", L"GetIrregularSnapPoints", 2))
            {
                py::set_arg_count_version_error(2);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Microsoft::UI::Xaml::Controls::Orientation>(args, 0);
                auto param1 = py::convert_to<winrt::Microsoft::UI::Xaml::Controls::Primitives::SnapPointsAlignment>(args, 1);

                return py::convert(self->obj.GetIrregularSnapPoints(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* IScrollSnapPointsInfo_GetRegularSnapPoints(py::wrapper::Microsoft::UI::Xaml::Controls::Primitives::IScrollSnapPointsInfo* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Xaml.Controls.Primitives.IScrollSnapPointsInfo", L"GetRegularSnapPoints", 2))
            {
                py::set_arg_count_version_error(2);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Microsoft::UI::Xaml::Controls::Orientation>(args, 0);
                auto param1 = py::convert_to<winrt::Microsoft::UI::Xaml::Controls::Primitives::SnapPointsAlignment>(args, 1);
                float param2 {  };

                auto return_value = self->obj.GetRegularSnapPoints(param0, param1, param2);

                py::pyobj_handle out_return_value{ py::convert(return_value) };
                if (!out_return_value)
                {
                    return nullptr;
                }
                py::pyobj_handle out2{ py::convert(param2) };
                if (!out2)
                {
                    return nullptr;
                }
                return PyTuple_Pack(2, out_return_value.get(), out2.get());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* IScrollSnapPointsInfo_get_AreHorizontalSnapPointsRegular(py::wrapper::Microsoft::UI::Xaml::Controls::Primitives::IScrollSnapPointsInfo* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.IScrollSnapPointsInfo", L"AreHorizontalSnapPointsRegular"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.AreHorizontalSnapPointsRegular());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IScrollSnapPointsInfo_get_AreVerticalSnapPointsRegular(py::wrapper::Microsoft::UI::Xaml::Controls::Primitives::IScrollSnapPointsInfo* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.IScrollSnapPointsInfo", L"AreVerticalSnapPointsRegular"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.AreVerticalSnapPointsRegular());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IScrollSnapPointsInfo_add_HorizontalSnapPointsChanged(py::wrapper::Microsoft::UI::Xaml::Controls::Primitives::IScrollSnapPointsInfo* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Microsoft.UI.Xaml.Controls.Primitives.IScrollSnapPointsInfo", L"HorizontalSnapPointsChanged"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::EventHandler<winrt::Windows::Foundation::IInspectable>>(arg);

            return py::convert(self->obj.HorizontalSnapPointsChanged(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IScrollSnapPointsInfo_remove_HorizontalSnapPointsChanged(py::wrapper::Microsoft::UI::Xaml::Controls::Primitives::IScrollSnapPointsInfo* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Microsoft.UI.Xaml.Controls.Primitives.IScrollSnapPointsInfo", L"HorizontalSnapPointsChanged"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.HorizontalSnapPointsChanged(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IScrollSnapPointsInfo_add_VerticalSnapPointsChanged(py::wrapper::Microsoft::UI::Xaml::Controls::Primitives::IScrollSnapPointsInfo* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Microsoft.UI.Xaml.Controls.Primitives.IScrollSnapPointsInfo", L"VerticalSnapPointsChanged"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::EventHandler<winrt::Windows::Foundation::IInspectable>>(arg);

            return py::convert(self->obj.VerticalSnapPointsChanged(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IScrollSnapPointsInfo_remove_VerticalSnapPointsChanged(py::wrapper::Microsoft::UI::Xaml::Controls::Primitives::IScrollSnapPointsInfo* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Microsoft.UI.Xaml.Controls.Primitives.IScrollSnapPointsInfo", L"VerticalSnapPointsChanged"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.VerticalSnapPointsChanged(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_IScrollSnapPointsInfo(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Microsoft::UI::Xaml::Controls::Primitives::IScrollSnapPointsInfo>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_IScrollSnapPointsInfo(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Microsoft::UI::Xaml::Controls::Primitives::IScrollSnapPointsInfo>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_IScrollSnapPointsInfo[] = {
        { "get_irregular_snap_points", reinterpret_cast<PyCFunction>(IScrollSnapPointsInfo_GetIrregularSnapPoints), METH_VARARGS, nullptr },
        { "get_regular_snap_points", reinterpret_cast<PyCFunction>(IScrollSnapPointsInfo_GetRegularSnapPoints), METH_VARARGS, nullptr },
        { "add_horizontal_snap_points_changed", reinterpret_cast<PyCFunction>(IScrollSnapPointsInfo_add_HorizontalSnapPointsChanged), METH_O, nullptr },
        { "remove_horizontal_snap_points_changed", reinterpret_cast<PyCFunction>(IScrollSnapPointsInfo_remove_HorizontalSnapPointsChanged), METH_O, nullptr },
        { "add_vertical_snap_points_changed", reinterpret_cast<PyCFunction>(IScrollSnapPointsInfo_add_VerticalSnapPointsChanged), METH_O, nullptr },
        { "remove_vertical_snap_points_changed", reinterpret_cast<PyCFunction>(IScrollSnapPointsInfo_remove_VerticalSnapPointsChanged), METH_O, nullptr },
        { "_assign_array_", _assign_array_IScrollSnapPointsInfo, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_IScrollSnapPointsInfo), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_IScrollSnapPointsInfo[] = {
        { "are_horizontal_snap_points_regular", reinterpret_cast<getter>(IScrollSnapPointsInfo_get_AreHorizontalSnapPointsRegular), nullptr, nullptr, nullptr },
        { "are_vertical_snap_points_regular", reinterpret_cast<getter>(IScrollSnapPointsInfo_get_AreVerticalSnapPointsRegular), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_IScrollSnapPointsInfo[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_IScrollSnapPointsInfo) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_IScrollSnapPointsInfo) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_IScrollSnapPointsInfo) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_IScrollSnapPointsInfo) },
        { },
    };

    static PyType_Spec type_spec_IScrollSnapPointsInfo =
    {
        "winrt._winrt_microsoft_ui_xaml_controls_primitives.IScrollSnapPointsInfo",
        sizeof(py::wrapper::Microsoft::UI::Xaml::Controls::Primitives::IScrollSnapPointsInfo),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_IScrollSnapPointsInfo
    };

    // ----- GeneratorPosition struct --------------------

    winrt_struct_wrapper<winrt::Microsoft::UI::Xaml::Controls::Primitives::GeneratorPosition>* _new_GeneratorPosition(PyTypeObject* subclass, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        auto self = reinterpret_cast<winrt_struct_wrapper<winrt::Microsoft::UI::Xaml::Controls::Primitives::GeneratorPosition>*>(subclass->tp_alloc(subclass, 0));

        if (!self)
        {
            return nullptr;
        }

        std::construct_at(&self->obj);

        return self;
    }

    int _init_GeneratorPosition(winrt_struct_wrapper<winrt::Microsoft::UI::Xaml::Controls::Primitives::GeneratorPosition>* self, PyObject* args, PyObject* kwds) noexcept
    {
        auto tuple_size = PyTuple_Size(args);

        if ((tuple_size == 0) && (kwds == nullptr))
        {
            self->obj = {};
            return 0;
        }

        int32_t _Index{};
        int32_t _Offset{};

        static const char* kwlist[] = {"index", "offset", nullptr};
        if (!PyArg_ParseTupleAndKeywords(args, kwds, "ii", const_cast<char**>(kwlist), &_Index, &_Offset))
        {
            return -1;
        }

        try
        {
            self->obj = {_Index, _Offset};
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static void _dealloc_GeneratorPosition(py::wrapper::Microsoft::UI::Xaml::Controls::Primitives::GeneratorPosition* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* _assign_array_GeneratorPosition(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Microsoft::UI::Xaml::Controls::Primitives::GeneratorPosition>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyMethodDef _methods_GeneratorPosition[] = {
        { "_assign_array_", _assign_array_GeneratorPosition, METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyObject* GeneratorPosition_get_Index(py::wrapper::Microsoft::UI::Xaml::Controls::Primitives::GeneratorPosition* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Index);
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int GeneratorPosition_set_Index(py::wrapper::Microsoft::UI::Xaml::Controls::Primitives::GeneratorPosition* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            self->obj.Index = py::converter<int32_t>::convert_to(arg);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* GeneratorPosition_get_Offset(py::wrapper::Microsoft::UI::Xaml::Controls::Primitives::GeneratorPosition* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Offset);
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int GeneratorPosition_set_Offset(py::wrapper::Microsoft::UI::Xaml::Controls::Primitives::GeneratorPosition* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            self->obj.Offset = py::converter<int32_t>::convert_to(arg);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyGetSetDef _getset_GeneratorPosition[] = {
        { "index", reinterpret_cast<getter>(GeneratorPosition_get_Index), reinterpret_cast<setter>(GeneratorPosition_set_Index), nullptr, nullptr },
        { "offset", reinterpret_cast<getter>(GeneratorPosition_get_Offset), reinterpret_cast<setter>(GeneratorPosition_set_Offset), nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_GeneratorPosition[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_GeneratorPosition) },
        { Py_tp_init, reinterpret_cast<void*>(_init_GeneratorPosition) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_GeneratorPosition) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_GeneratorPosition) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_GeneratorPosition) },
        { },
    };

    static PyType_Spec type_spec_GeneratorPosition =
    {
        "winrt._winrt_microsoft_ui_xaml_controls_primitives.GeneratorPosition",
        sizeof(py::wrapper::Microsoft::UI::Xaml::Controls::Primitives::GeneratorPosition),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_GeneratorPosition
    };

    // ----- Microsoft.UI.Xaml.Controls.Primitives Initialization --------------------
    PyDoc_STRVAR(module_doc, "Microsoft::UI::Xaml::Controls::Primitives");


    static PyModuleDef module_def
        = {PyModuleDef_HEAD_INIT,
           "_winrt_microsoft_ui_xaml_controls_primitives",
           module_doc,
           0,
           nullptr,
           nullptr,
           nullptr,
           nullptr,
           nullptr};

} // py::cpp::Microsoft::UI::Xaml::Controls::Primitives

PyMODINIT_FUNC PyInit__winrt_microsoft_ui_xaml_controls_primitives(void) noexcept
{
    using namespace py::cpp::Microsoft::UI::Xaml::Controls::Primitives;

    if (py::import_winrt_runtime() == -1)
    {
        return nullptr;
    }

    py::pyobj_handle module{PyModule_Create(&module_def)};

    if (!module)
    {
        return nullptr;
    }

    auto object_type = py::get_object_type();
    if (!object_type)
    {
        return nullptr;
    }

    py::pyobj_handle object_bases{PyTuple_Pack(1, object_type)};

    if (!object_bases)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_AppBarButtonTemplateSettings, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_AppBarTemplateSettings, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_AppBarToggleButtonTemplateSettings, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    py::pyobj_handle type_AutoSuggestBoxHelper_Static{PyType_FromSpec(&type_spec_AutoSuggestBoxHelper_Static)};
    if (!type_AutoSuggestBoxHelper_Static)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_AutoSuggestBoxHelper, object_bases.get(), reinterpret_cast<PyTypeObject*>(type_AutoSuggestBoxHelper_Static.get())) == -1)
    {
        return nullptr;
    }

    py::pyobj_handle type_ButtonBase_Static{PyType_FromSpec(&type_spec_ButtonBase_Static)};
    if (!type_ButtonBase_Static)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_ButtonBase, object_bases.get(), reinterpret_cast<PyTypeObject*>(type_ButtonBase_Static.get())) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_CalendarPanel, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_CalendarViewTemplateSettings, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_CarouselPanel, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    py::pyobj_handle type_ColorPickerSlider_Static{PyType_FromSpec(&type_spec_ColorPickerSlider_Static)};
    if (!type_ColorPickerSlider_Static)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_ColorPickerSlider, object_bases.get(), reinterpret_cast<PyTypeObject*>(type_ColorPickerSlider_Static.get())) == -1)
    {
        return nullptr;
    }

    py::pyobj_handle type_ColorSpectrum_Static{PyType_FromSpec(&type_spec_ColorSpectrum_Static)};
    if (!type_ColorSpectrum_Static)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_ColorSpectrum, object_bases.get(), reinterpret_cast<PyTypeObject*>(type_ColorSpectrum_Static.get())) == -1)
    {
        return nullptr;
    }

    py::pyobj_handle type_ColumnMajorUniformToLargestGridLayout_Static{PyType_FromSpec(&type_spec_ColumnMajorUniformToLargestGridLayout_Static)};
    if (!type_ColumnMajorUniformToLargestGridLayout_Static)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_ColumnMajorUniformToLargestGridLayout, object_bases.get(), reinterpret_cast<PyTypeObject*>(type_ColumnMajorUniformToLargestGridLayout_Static.get())) == -1)
    {
        return nullptr;
    }

    py::pyobj_handle type_ComboBoxHelper_Static{PyType_FromSpec(&type_spec_ComboBoxHelper_Static)};
    if (!type_ComboBoxHelper_Static)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_ComboBoxHelper, object_bases.get(), reinterpret_cast<PyTypeObject*>(type_ComboBoxHelper_Static.get())) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_ComboBoxTemplateSettings, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    py::pyobj_handle type_CommandBarFlyoutCommandBar_Static{PyType_FromSpec(&type_spec_CommandBarFlyoutCommandBar_Static)};
    if (!type_CommandBarFlyoutCommandBar_Static)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_CommandBarFlyoutCommandBar, object_bases.get(), reinterpret_cast<PyTypeObject*>(type_CommandBarFlyoutCommandBar_Static.get())) == -1)
    {
        return nullptr;
    }

    py::pyobj_handle type_CommandBarFlyoutCommandBarAutomationProperties_Static{PyType_FromSpec(&type_spec_CommandBarFlyoutCommandBarAutomationProperties_Static)};
    if (!type_CommandBarFlyoutCommandBarAutomationProperties_Static)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_CommandBarFlyoutCommandBarAutomationProperties, object_bases.get(), reinterpret_cast<PyTypeObject*>(type_CommandBarFlyoutCommandBarAutomationProperties_Static.get())) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_CommandBarFlyoutCommandBarTemplateSettings, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_CommandBarTemplateSettings, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    py::pyobj_handle type_CornerRadiusFilterConverter_Static{PyType_FromSpec(&type_spec_CornerRadiusFilterConverter_Static)};
    if (!type_CornerRadiusFilterConverter_Static)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_CornerRadiusFilterConverter, object_bases.get(), reinterpret_cast<PyTypeObject*>(type_CornerRadiusFilterConverter_Static.get())) == -1)
    {
        return nullptr;
    }

    py::pyobj_handle type_CornerRadiusToThicknessConverter_Static{PyType_FromSpec(&type_spec_CornerRadiusToThicknessConverter_Static)};
    if (!type_CornerRadiusToThicknessConverter_Static)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_CornerRadiusToThicknessConverter, object_bases.get(), reinterpret_cast<PyTypeObject*>(type_CornerRadiusToThicknessConverter_Static.get())) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_DragCompletedEventArgs, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_DragDeltaEventArgs, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_DragStartedEventArgs, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    py::pyobj_handle type_FlyoutBase_Static{PyType_FromSpec(&type_spec_FlyoutBase_Static)};
    if (!type_FlyoutBase_Static)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_FlyoutBase, object_bases.get(), reinterpret_cast<PyTypeObject*>(type_FlyoutBase_Static.get())) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_FlyoutBaseClosingEventArgs, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_FlyoutShowOptions, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    py::pyobj_handle type_GeneratorPositionHelper_Static{PyType_FromSpec(&type_spec_GeneratorPositionHelper_Static)};
    if (!type_GeneratorPositionHelper_Static)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_GeneratorPositionHelper, object_bases.get(), reinterpret_cast<PyTypeObject*>(type_GeneratorPositionHelper_Static.get())) == -1)
    {
        return nullptr;
    }

    py::pyobj_handle type_GridViewItemPresenter_Static{PyType_FromSpec(&type_spec_GridViewItemPresenter_Static)};
    if (!type_GridViewItemPresenter_Static)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_GridViewItemPresenter, object_bases.get(), reinterpret_cast<PyTypeObject*>(type_GridViewItemPresenter_Static.get())) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_GridViewItemTemplateSettings, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    py::pyobj_handle type_InfoBarPanel_Static{PyType_FromSpec(&type_spec_InfoBarPanel_Static)};
    if (!type_InfoBarPanel_Static)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_InfoBarPanel, object_bases.get(), reinterpret_cast<PyTypeObject*>(type_InfoBarPanel_Static.get())) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_ItemsChangedEventArgs, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    py::pyobj_handle type_JumpListItemBackgroundConverter_Static{PyType_FromSpec(&type_spec_JumpListItemBackgroundConverter_Static)};
    if (!type_JumpListItemBackgroundConverter_Static)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_JumpListItemBackgroundConverter, object_bases.get(), reinterpret_cast<PyTypeObject*>(type_JumpListItemBackgroundConverter_Static.get())) == -1)
    {
        return nullptr;
    }

    py::pyobj_handle type_JumpListItemForegroundConverter_Static{PyType_FromSpec(&type_spec_JumpListItemForegroundConverter_Static)};
    if (!type_JumpListItemForegroundConverter_Static)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_JumpListItemForegroundConverter, object_bases.get(), reinterpret_cast<PyTypeObject*>(type_JumpListItemForegroundConverter_Static.get())) == -1)
    {
        return nullptr;
    }

    py::pyobj_handle type_LayoutInformation_Static{PyType_FromSpec(&type_spec_LayoutInformation_Static)};
    if (!type_LayoutInformation_Static)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_LayoutInformation, object_bases.get(), reinterpret_cast<PyTypeObject*>(type_LayoutInformation_Static.get())) == -1)
    {
        return nullptr;
    }

    py::pyobj_handle type_ListViewItemPresenter_Static{PyType_FromSpec(&type_spec_ListViewItemPresenter_Static)};
    if (!type_ListViewItemPresenter_Static)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_ListViewItemPresenter, object_bases.get(), reinterpret_cast<PyTypeObject*>(type_ListViewItemPresenter_Static.get())) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_ListViewItemTemplateSettings, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    py::pyobj_handle type_LoopingSelector_Static{PyType_FromSpec(&type_spec_LoopingSelector_Static)};
    if (!type_LoopingSelector_Static)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_LoopingSelector, object_bases.get(), reinterpret_cast<PyTypeObject*>(type_LoopingSelector_Static.get())) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_LoopingSelectorItem, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_LoopingSelectorPanel, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_MenuFlyoutItemTemplateSettings, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_MenuFlyoutPresenterTemplateSettings, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    py::pyobj_handle type_MonochromaticOverlayPresenter_Static{PyType_FromSpec(&type_spec_MonochromaticOverlayPresenter_Static)};
    if (!type_MonochromaticOverlayPresenter_Static)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_MonochromaticOverlayPresenter, object_bases.get(), reinterpret_cast<PyTypeObject*>(type_MonochromaticOverlayPresenter_Static.get())) == -1)
    {
        return nullptr;
    }

    py::pyobj_handle type_NavigationViewItemPresenter_Static{PyType_FromSpec(&type_spec_NavigationViewItemPresenter_Static)};
    if (!type_NavigationViewItemPresenter_Static)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_NavigationViewItemPresenter, object_bases.get(), reinterpret_cast<PyTypeObject*>(type_NavigationViewItemPresenter_Static.get())) == -1)
    {
        return nullptr;
    }

    py::pyobj_handle type_NavigationViewItemPresenterTemplateSettings_Static{PyType_FromSpec(&type_spec_NavigationViewItemPresenterTemplateSettings_Static)};
    if (!type_NavigationViewItemPresenterTemplateSettings_Static)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_NavigationViewItemPresenterTemplateSettings, object_bases.get(), reinterpret_cast<PyTypeObject*>(type_NavigationViewItemPresenterTemplateSettings_Static.get())) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_OrientedVirtualizingPanel, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    py::pyobj_handle type_PickerFlyoutBase_Static{PyType_FromSpec(&type_spec_PickerFlyoutBase_Static)};
    if (!type_PickerFlyoutBase_Static)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_PickerFlyoutBase, object_bases.get(), reinterpret_cast<PyTypeObject*>(type_PickerFlyoutBase_Static.get())) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_PivotHeaderItem, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_PivotHeaderPanel, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_PivotPanel, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    py::pyobj_handle type_Popup_Static{PyType_FromSpec(&type_spec_Popup_Static)};
    if (!type_Popup_Static)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_Popup, object_bases.get(), reinterpret_cast<PyTypeObject*>(type_Popup_Static.get())) == -1)
    {
        return nullptr;
    }

    py::pyobj_handle type_RangeBase_Static{PyType_FromSpec(&type_spec_RangeBase_Static)};
    if (!type_RangeBase_Static)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_RangeBase, object_bases.get(), reinterpret_cast<PyTypeObject*>(type_RangeBase_Static.get())) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_RangeBaseValueChangedEventArgs, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    py::pyobj_handle type_RepeatButton_Static{PyType_FromSpec(&type_spec_RepeatButton_Static)};
    if (!type_RepeatButton_Static)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_RepeatButton, object_bases.get(), reinterpret_cast<PyTypeObject*>(type_RepeatButton_Static.get())) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_RepeatedScrollSnapPoint, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_RepeatedZoomSnapPoint, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    py::pyobj_handle type_ScrollBar_Static{PyType_FromSpec(&type_spec_ScrollBar_Static)};
    if (!type_ScrollBar_Static)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_ScrollBar, object_bases.get(), reinterpret_cast<PyTypeObject*>(type_ScrollBar_Static.get())) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_ScrollControllerAddScrollVelocityRequestedEventArgs, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_ScrollControllerPanRequestedEventArgs, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_ScrollControllerScrollByRequestedEventArgs, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_ScrollControllerScrollToRequestedEventArgs, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_ScrollEventArgs, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    py::pyobj_handle type_ScrollPresenter_Static{PyType_FromSpec(&type_spec_ScrollPresenter_Static)};
    if (!type_ScrollPresenter_Static)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_ScrollPresenter, object_bases.get(), reinterpret_cast<PyTypeObject*>(type_ScrollPresenter_Static.get())) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_ScrollSnapPoint, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_ScrollSnapPointBase, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    py::pyobj_handle type_Selector_Static{PyType_FromSpec(&type_spec_Selector_Static)};
    if (!type_Selector_Static)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_Selector, object_bases.get(), reinterpret_cast<PyTypeObject*>(type_Selector_Static.get())) == -1)
    {
        return nullptr;
    }

    py::pyobj_handle type_SelectorItem_Static{PyType_FromSpec(&type_spec_SelectorItem_Static)};
    if (!type_SelectorItem_Static)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_SelectorItem, object_bases.get(), reinterpret_cast<PyTypeObject*>(type_SelectorItem_Static.get())) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_SnapPointBase, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_SplitViewTemplateSettings, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_TabViewListView, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    py::pyobj_handle type_Thumb_Static{PyType_FromSpec(&type_spec_Thumb_Static)};
    if (!type_Thumb_Static)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_Thumb, object_bases.get(), reinterpret_cast<PyTypeObject*>(type_Thumb_Static.get())) == -1)
    {
        return nullptr;
    }

    py::pyobj_handle type_TickBar_Static{PyType_FromSpec(&type_spec_TickBar_Static)};
    if (!type_TickBar_Static)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_TickBar, object_bases.get(), reinterpret_cast<PyTypeObject*>(type_TickBar_Static.get())) == -1)
    {
        return nullptr;
    }

    py::pyobj_handle type_ToggleButton_Static{PyType_FromSpec(&type_spec_ToggleButton_Static)};
    if (!type_ToggleButton_Static)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_ToggleButton, object_bases.get(), reinterpret_cast<PyTypeObject*>(type_ToggleButton_Static.get())) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_ToggleSwitchTemplateSettings, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_ToolTipTemplateSettings, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_ZoomSnapPoint, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_ZoomSnapPointBase, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_IScrollController, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_IScrollControllerPanningInfo, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_IScrollSnapPointsInfo, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_GeneratorPosition, nullptr, nullptr) == -1)
    {
        return nullptr;
    }


    return module.detach();
}
