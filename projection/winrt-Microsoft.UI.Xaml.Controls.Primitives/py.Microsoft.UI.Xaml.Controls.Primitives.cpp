// WARNING: Please don't edit this file. It was generated by Python/WinRT v0.0.0

#include "py.Microsoft.UI.Xaml.Controls.Primitives.h"

namespace py::cpp::Microsoft::UI::Xaml::Controls::Primitives
{
    // ----- AppBarButtonTemplateSettings class --------------------

    static PyObject* _new_AppBarButtonTemplateSettings(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Microsoft::UI::Xaml::Controls::Primitives::AppBarButtonTemplateSettings>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Microsoft::UI::Xaml::Controls::Primitives::AppBarButtonTemplateSettings>::type_name);
        return nullptr;
    }

    static void _dealloc_AppBarButtonTemplateSettings(py::wrapper::Microsoft::UI::Xaml::Controls::Primitives::AppBarButtonTemplateSettings* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* AppBarButtonTemplateSettings_get_KeyboardAcceleratorTextMinWidth(py::wrapper::Microsoft::UI::Xaml::Controls::Primitives::AppBarButtonTemplateSettings* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.AppBarButtonTemplateSettings", L"KeyboardAcceleratorTextMinWidth");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.KeyboardAcceleratorTextMinWidth();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_AppBarButtonTemplateSettings(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Microsoft::UI::Xaml::Controls::Primitives::AppBarButtonTemplateSettings>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_AppBarButtonTemplateSettings(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Microsoft::UI::Xaml::Controls::Primitives::AppBarButtonTemplateSettings>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_AppBarButtonTemplateSettings[] = {
        { "_assign_array_", _assign_array_AppBarButtonTemplateSettings, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_AppBarButtonTemplateSettings), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_AppBarButtonTemplateSettings[] = {
        { "keyboard_accelerator_text_min_width", reinterpret_cast<getter>(AppBarButtonTemplateSettings_get_KeyboardAcceleratorTextMinWidth), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_AppBarButtonTemplateSettings[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_AppBarButtonTemplateSettings) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_AppBarButtonTemplateSettings) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_AppBarButtonTemplateSettings) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_AppBarButtonTemplateSettings) },
        { }
    };

    static PyType_Spec type_spec_AppBarButtonTemplateSettings = {
        "winrt._winrt_microsoft_ui_xaml_controls_primitives.AppBarButtonTemplateSettings",
        sizeof(py::wrapper::Microsoft::UI::Xaml::Controls::Primitives::AppBarButtonTemplateSettings),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_AppBarButtonTemplateSettings};

    // ----- AppBarTemplateSettings class --------------------

    static PyObject* _new_AppBarTemplateSettings(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Microsoft::UI::Xaml::Controls::Primitives::AppBarTemplateSettings>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Microsoft::UI::Xaml::Controls::Primitives::AppBarTemplateSettings>::type_name);
        return nullptr;
    }

    static void _dealloc_AppBarTemplateSettings(py::wrapper::Microsoft::UI::Xaml::Controls::Primitives::AppBarTemplateSettings* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* AppBarTemplateSettings_get_ClipRect(py::wrapper::Microsoft::UI::Xaml::Controls::Primitives::AppBarTemplateSettings* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.AppBarTemplateSettings", L"ClipRect");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.ClipRect();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AppBarTemplateSettings_get_CompactRootMargin(py::wrapper::Microsoft::UI::Xaml::Controls::Primitives::AppBarTemplateSettings* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.AppBarTemplateSettings", L"CompactRootMargin");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.CompactRootMargin();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AppBarTemplateSettings_get_CompactVerticalDelta(py::wrapper::Microsoft::UI::Xaml::Controls::Primitives::AppBarTemplateSettings* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.AppBarTemplateSettings", L"CompactVerticalDelta");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.CompactVerticalDelta();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AppBarTemplateSettings_get_HiddenRootMargin(py::wrapper::Microsoft::UI::Xaml::Controls::Primitives::AppBarTemplateSettings* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.AppBarTemplateSettings", L"HiddenRootMargin");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.HiddenRootMargin();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AppBarTemplateSettings_get_HiddenVerticalDelta(py::wrapper::Microsoft::UI::Xaml::Controls::Primitives::AppBarTemplateSettings* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.AppBarTemplateSettings", L"HiddenVerticalDelta");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.HiddenVerticalDelta();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AppBarTemplateSettings_get_MinimalRootMargin(py::wrapper::Microsoft::UI::Xaml::Controls::Primitives::AppBarTemplateSettings* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.AppBarTemplateSettings", L"MinimalRootMargin");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.MinimalRootMargin();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AppBarTemplateSettings_get_MinimalVerticalDelta(py::wrapper::Microsoft::UI::Xaml::Controls::Primitives::AppBarTemplateSettings* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.AppBarTemplateSettings", L"MinimalVerticalDelta");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.MinimalVerticalDelta();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AppBarTemplateSettings_get_NegativeCompactVerticalDelta(py::wrapper::Microsoft::UI::Xaml::Controls::Primitives::AppBarTemplateSettings* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.AppBarTemplateSettings", L"NegativeCompactVerticalDelta");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.NegativeCompactVerticalDelta();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AppBarTemplateSettings_get_NegativeHiddenVerticalDelta(py::wrapper::Microsoft::UI::Xaml::Controls::Primitives::AppBarTemplateSettings* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.AppBarTemplateSettings", L"NegativeHiddenVerticalDelta");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.NegativeHiddenVerticalDelta();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AppBarTemplateSettings_get_NegativeMinimalVerticalDelta(py::wrapper::Microsoft::UI::Xaml::Controls::Primitives::AppBarTemplateSettings* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.AppBarTemplateSettings", L"NegativeMinimalVerticalDelta");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.NegativeMinimalVerticalDelta();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_AppBarTemplateSettings(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Microsoft::UI::Xaml::Controls::Primitives::AppBarTemplateSettings>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_AppBarTemplateSettings(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Microsoft::UI::Xaml::Controls::Primitives::AppBarTemplateSettings>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_AppBarTemplateSettings[] = {
        { "_assign_array_", _assign_array_AppBarTemplateSettings, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_AppBarTemplateSettings), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_AppBarTemplateSettings[] = {
        { "clip_rect", reinterpret_cast<getter>(AppBarTemplateSettings_get_ClipRect), nullptr, nullptr, nullptr },
        { "compact_root_margin", reinterpret_cast<getter>(AppBarTemplateSettings_get_CompactRootMargin), nullptr, nullptr, nullptr },
        { "compact_vertical_delta", reinterpret_cast<getter>(AppBarTemplateSettings_get_CompactVerticalDelta), nullptr, nullptr, nullptr },
        { "hidden_root_margin", reinterpret_cast<getter>(AppBarTemplateSettings_get_HiddenRootMargin), nullptr, nullptr, nullptr },
        { "hidden_vertical_delta", reinterpret_cast<getter>(AppBarTemplateSettings_get_HiddenVerticalDelta), nullptr, nullptr, nullptr },
        { "minimal_root_margin", reinterpret_cast<getter>(AppBarTemplateSettings_get_MinimalRootMargin), nullptr, nullptr, nullptr },
        { "minimal_vertical_delta", reinterpret_cast<getter>(AppBarTemplateSettings_get_MinimalVerticalDelta), nullptr, nullptr, nullptr },
        { "negative_compact_vertical_delta", reinterpret_cast<getter>(AppBarTemplateSettings_get_NegativeCompactVerticalDelta), nullptr, nullptr, nullptr },
        { "negative_hidden_vertical_delta", reinterpret_cast<getter>(AppBarTemplateSettings_get_NegativeHiddenVerticalDelta), nullptr, nullptr, nullptr },
        { "negative_minimal_vertical_delta", reinterpret_cast<getter>(AppBarTemplateSettings_get_NegativeMinimalVerticalDelta), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_AppBarTemplateSettings[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_AppBarTemplateSettings) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_AppBarTemplateSettings) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_AppBarTemplateSettings) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_AppBarTemplateSettings) },
        { }
    };

    static PyType_Spec type_spec_AppBarTemplateSettings = {
        "winrt._winrt_microsoft_ui_xaml_controls_primitives.AppBarTemplateSettings",
        sizeof(py::wrapper::Microsoft::UI::Xaml::Controls::Primitives::AppBarTemplateSettings),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_AppBarTemplateSettings};

    // ----- AppBarToggleButtonTemplateSettings class --------------------

    static PyObject* _new_AppBarToggleButtonTemplateSettings(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Microsoft::UI::Xaml::Controls::Primitives::AppBarToggleButtonTemplateSettings>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Microsoft::UI::Xaml::Controls::Primitives::AppBarToggleButtonTemplateSettings>::type_name);
        return nullptr;
    }

    static void _dealloc_AppBarToggleButtonTemplateSettings(py::wrapper::Microsoft::UI::Xaml::Controls::Primitives::AppBarToggleButtonTemplateSettings* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* AppBarToggleButtonTemplateSettings_get_KeyboardAcceleratorTextMinWidth(py::wrapper::Microsoft::UI::Xaml::Controls::Primitives::AppBarToggleButtonTemplateSettings* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.AppBarToggleButtonTemplateSettings", L"KeyboardAcceleratorTextMinWidth");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.KeyboardAcceleratorTextMinWidth();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_AppBarToggleButtonTemplateSettings(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Microsoft::UI::Xaml::Controls::Primitives::AppBarToggleButtonTemplateSettings>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_AppBarToggleButtonTemplateSettings(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Microsoft::UI::Xaml::Controls::Primitives::AppBarToggleButtonTemplateSettings>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_AppBarToggleButtonTemplateSettings[] = {
        { "_assign_array_", _assign_array_AppBarToggleButtonTemplateSettings, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_AppBarToggleButtonTemplateSettings), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_AppBarToggleButtonTemplateSettings[] = {
        { "keyboard_accelerator_text_min_width", reinterpret_cast<getter>(AppBarToggleButtonTemplateSettings_get_KeyboardAcceleratorTextMinWidth), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_AppBarToggleButtonTemplateSettings[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_AppBarToggleButtonTemplateSettings) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_AppBarToggleButtonTemplateSettings) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_AppBarToggleButtonTemplateSettings) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_AppBarToggleButtonTemplateSettings) },
        { }
    };

    static PyType_Spec type_spec_AppBarToggleButtonTemplateSettings = {
        "winrt._winrt_microsoft_ui_xaml_controls_primitives.AppBarToggleButtonTemplateSettings",
        sizeof(py::wrapper::Microsoft::UI::Xaml::Controls::Primitives::AppBarToggleButtonTemplateSettings),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_AppBarToggleButtonTemplateSettings};

    // ----- AutoSuggestBoxHelper class --------------------

    static PyObject* _new_AutoSuggestBoxHelper(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Microsoft::UI::Xaml::Controls::Primitives::AutoSuggestBoxHelper>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Microsoft::UI::Xaml::Controls::Primitives::AutoSuggestBoxHelper>::type_name);
        return nullptr;
    }

    static void _dealloc_AutoSuggestBoxHelper(py::wrapper::Microsoft::UI::Xaml::Controls::Primitives::AutoSuggestBoxHelper* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* AutoSuggestBoxHelper_GetKeepInteriorCornersSquare(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Xaml.Controls.Primitives.AutoSuggestBoxHelper", L"GetKeepInteriorCornersSquare", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Microsoft::UI::Xaml::Controls::AutoSuggestBox>(args, 0);

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return winrt::Microsoft::UI::Xaml::Controls::Primitives::AutoSuggestBoxHelper::GetKeepInteriorCornersSquare(param0);
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AutoSuggestBoxHelper_SetKeepInteriorCornersSquare(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Xaml.Controls.Primitives.AutoSuggestBoxHelper", L"SetKeepInteriorCornersSquare", 2);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(2);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Microsoft::UI::Xaml::Controls::AutoSuggestBox>(args, 0);
                auto param1 = py::convert_to<bool>(args, 1);

                {
                    auto _gil = release_gil();
                    winrt::Microsoft::UI::Xaml::Controls::Primitives::AutoSuggestBoxHelper::SetKeepInteriorCornersSquare(param0, param1);
                }

                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AutoSuggestBoxHelper_get_KeepInteriorCornersSquareProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.AutoSuggestBoxHelper", L"KeepInteriorCornersSquareProperty");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return winrt::Microsoft::UI::Xaml::Controls::Primitives::AutoSuggestBoxHelper::KeepInteriorCornersSquareProperty();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_AutoSuggestBoxHelper(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Microsoft::UI::Xaml::Controls::Primitives::AutoSuggestBoxHelper>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_AutoSuggestBoxHelper(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Microsoft::UI::Xaml::Controls::Primitives::AutoSuggestBoxHelper>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_AutoSuggestBoxHelper[] = {
        { "_assign_array_", _assign_array_AutoSuggestBoxHelper, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_AutoSuggestBoxHelper), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_AutoSuggestBoxHelper[] = {
        { }
    };

    static PyType_Slot _type_slots_AutoSuggestBoxHelper[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_AutoSuggestBoxHelper) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_AutoSuggestBoxHelper) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_AutoSuggestBoxHelper) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_AutoSuggestBoxHelper) },
        { }
    };

    static PyType_Spec type_spec_AutoSuggestBoxHelper = {
        "winrt._winrt_microsoft_ui_xaml_controls_primitives.AutoSuggestBoxHelper",
        sizeof(py::wrapper::Microsoft::UI::Xaml::Controls::Primitives::AutoSuggestBoxHelper),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_AutoSuggestBoxHelper};

    static PyGetSetDef getset_AutoSuggestBoxHelper_Static[] = {
        { "keep_interior_corners_square_property", reinterpret_cast<getter>(AutoSuggestBoxHelper_get_KeepInteriorCornersSquareProperty), nullptr, nullptr, nullptr },
        { }
    };

    static PyMethodDef methods_AutoSuggestBoxHelper_Static[] = {
        { "get_keep_interior_corners_square", reinterpret_cast<PyCFunction>(AutoSuggestBoxHelper_GetKeepInteriorCornersSquare), METH_VARARGS, nullptr },
        { "set_keep_interior_corners_square", reinterpret_cast<PyCFunction>(AutoSuggestBoxHelper_SetKeepInteriorCornersSquare), METH_VARARGS, nullptr },
        { }
    };

    static PyType_Slot type_slots_AutoSuggestBoxHelper_Static[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_AutoSuggestBoxHelper_Static) },
        { Py_tp_methods, reinterpret_cast<void*>(methods_AutoSuggestBoxHelper_Static) },
        { }
    };

    static PyType_Spec type_spec_AutoSuggestBoxHelper_Static =
    {
        "winrt._winrt_microsoft_ui_xaml_controls_primitives.AutoSuggestBoxHelper_Static",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT,
        type_slots_AutoSuggestBoxHelper_Static
    };

    // ----- ButtonBase class --------------------

    struct PyWinrtButtonBase;
    using BasePyWinrtButtonBase = winrt::Microsoft::UI::Xaml::Controls::Primitives::ButtonBaseT<PyWinrtButtonBase, py::IPywinrtObject>;

    struct PyWinrtButtonBase : py::py_obj_ref, BasePyWinrtButtonBase
    {

        int32_t __stdcall GetPyObject(PyObject*& obj) override
        {
            obj = py::py_obj_ref::get_py_obj();
            return 0;
        }

        int32_t __stdcall GetComposableInner(winrt::Windows::Foundation::IInspectable& inner) override
        {
            inner = m_inner;
            return winrt::impl::error_ok;
        }

        static void toggle_reference(PyWinrtButtonBase* instance, bool is_last_reference)
        {
            py::py_obj_ref::toggle_reference(instance, is_last_reference);
        }

        int32_t query_interface_tearoff(winrt::guid const& id, void** result) const noexcept override
        {
            return py::py_obj_ref::query_interface_tearoff(id, result);
        }
    };

    static PyObject* _new_ButtonBase(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Microsoft::UI::Xaml::Controls::Primitives::ButtonBase>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Microsoft::UI::Xaml::Controls::Primitives::ButtonBase>::type_name);
        return nullptr;
    }

    static void _dealloc_ButtonBase(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* ButtonBase_get_CommandParameter(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.ButtonBase", L"CommandParameter");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::Primitives::ButtonBase>().CommandParameter();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ButtonBase_put_CommandParameter(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.ButtonBase", L"CommandParameter");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);

            {
                auto _gil = release_gil();
                self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::Primitives::ButtonBase>().CommandParameter(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ButtonBase_get_Command(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.ButtonBase", L"Command");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::Primitives::ButtonBase>().Command();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ButtonBase_put_Command(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.ButtonBase", L"Command");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Microsoft::UI::Xaml::Input::ICommand>(arg);

            {
                auto _gil = release_gil();
                self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::Primitives::ButtonBase>().Command(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ButtonBase_get_ClickMode(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.ButtonBase", L"ClickMode");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::Primitives::ButtonBase>().ClickMode();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ButtonBase_put_ClickMode(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.ButtonBase", L"ClickMode");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Microsoft::UI::Xaml::Controls::ClickMode>(arg);

            {
                auto _gil = release_gil();
                self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::Primitives::ButtonBase>().ClickMode(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ButtonBase_get_IsPointerOver(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.ButtonBase", L"IsPointerOver");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::Primitives::ButtonBase>().IsPointerOver();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ButtonBase_get_IsPressed(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.ButtonBase", L"IsPressed");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::Primitives::ButtonBase>().IsPressed();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ButtonBase_get_ClickModeProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.ButtonBase", L"ClickModeProperty");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return winrt::Microsoft::UI::Xaml::Controls::Primitives::ButtonBase::ClickModeProperty();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ButtonBase_get_CommandParameterProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.ButtonBase", L"CommandParameterProperty");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return winrt::Microsoft::UI::Xaml::Controls::Primitives::ButtonBase::CommandParameterProperty();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ButtonBase_get_CommandProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.ButtonBase", L"CommandProperty");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return winrt::Microsoft::UI::Xaml::Controls::Primitives::ButtonBase::CommandProperty();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ButtonBase_get_IsPointerOverProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.ButtonBase", L"IsPointerOverProperty");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return winrt::Microsoft::UI::Xaml::Controls::Primitives::ButtonBase::IsPointerOverProperty();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ButtonBase_get_IsPressedProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.ButtonBase", L"IsPressedProperty");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return winrt::Microsoft::UI::Xaml::Controls::Primitives::ButtonBase::IsPressedProperty();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ButtonBase_add_Click(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, PyObject* arg) noexcept
    {
        try
        {
            static std::optional<bool> is_event_present{};

            if (!is_event_present.has_value())
            {
                is_event_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Microsoft.UI.Xaml.Controls.Primitives.ButtonBase", L"Click");
            }

            if (!is_event_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::Microsoft::UI::Xaml::RoutedEventHandler>(arg);

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::Primitives::ButtonBase>().Click(param0);
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ButtonBase_remove_Click(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, PyObject* arg) noexcept
    {
        try
        {
            static std::optional<bool> is_event_present{};

            if (!is_event_present.has_value())
            {
                is_event_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Microsoft.UI.Xaml.Controls.Primitives.ButtonBase", L"Click");
            }

            if (!is_event_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::event_token>(arg);

            {
                auto _gil = release_gil();
                self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::Primitives::ButtonBase>().Click(param0);
            }

            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_ButtonBase(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Microsoft::UI::Xaml::Controls::Primitives::ButtonBase>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_ButtonBase(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Microsoft::UI::Xaml::Controls::Primitives::ButtonBase>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_ButtonBase[] = {
        { "add_click", reinterpret_cast<PyCFunction>(ButtonBase_add_Click), METH_O, nullptr },
        { "remove_click", reinterpret_cast<PyCFunction>(ButtonBase_remove_Click), METH_O, nullptr },
        { "_assign_array_", _assign_array_ButtonBase, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_ButtonBase), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_ButtonBase[] = {
        { "command_parameter", reinterpret_cast<getter>(ButtonBase_get_CommandParameter), reinterpret_cast<setter>(ButtonBase_put_CommandParameter), nullptr, nullptr },
        { "command", reinterpret_cast<getter>(ButtonBase_get_Command), reinterpret_cast<setter>(ButtonBase_put_Command), nullptr, nullptr },
        { "click_mode", reinterpret_cast<getter>(ButtonBase_get_ClickMode), reinterpret_cast<setter>(ButtonBase_put_ClickMode), nullptr, nullptr },
        { "is_pointer_over", reinterpret_cast<getter>(ButtonBase_get_IsPointerOver), nullptr, nullptr, nullptr },
        { "is_pressed", reinterpret_cast<getter>(ButtonBase_get_IsPressed), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_ButtonBase[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_ButtonBase) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_ButtonBase) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_ButtonBase) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_ButtonBase) },
        { }
    };

    static PyType_Spec type_spec_ButtonBase = {
        "winrt._winrt_microsoft_ui_xaml_controls_primitives.ButtonBase",
        sizeof(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>),
        0,
        Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,
        _type_slots_ButtonBase};

    static PyGetSetDef getset_ButtonBase_Static[] = {
        { "click_mode_property", reinterpret_cast<getter>(ButtonBase_get_ClickModeProperty), nullptr, nullptr, nullptr },
        { "command_parameter_property", reinterpret_cast<getter>(ButtonBase_get_CommandParameterProperty), nullptr, nullptr, nullptr },
        { "command_property", reinterpret_cast<getter>(ButtonBase_get_CommandProperty), nullptr, nullptr, nullptr },
        { "is_pointer_over_property", reinterpret_cast<getter>(ButtonBase_get_IsPointerOverProperty), nullptr, nullptr, nullptr },
        { "is_pressed_property", reinterpret_cast<getter>(ButtonBase_get_IsPressedProperty), nullptr, nullptr, nullptr },
        { }
    };

    static PyMethodDef methods_ButtonBase_Static[] = {
        { }
    };

    static PyType_Slot type_slots_ButtonBase_Static[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_ButtonBase_Static) },
        { Py_tp_methods, reinterpret_cast<void*>(methods_ButtonBase_Static) },
        { }
    };

    static PyType_Spec type_spec_ButtonBase_Static =
    {
        "winrt._winrt_microsoft_ui_xaml_controls_primitives.ButtonBase_Static",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,
        type_slots_ButtonBase_Static
    };

    // ----- CalendarPanel class --------------------

    static PyObject* _new_CalendarPanel(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 0)
        {
            try
            {
                winrt::Microsoft::UI::Xaml::Controls::Primitives::CalendarPanel instance{};
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_CalendarPanel(py::wrapper::Microsoft::UI::Xaml::Controls::Primitives::CalendarPanel* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* _assign_array_CalendarPanel(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Microsoft::UI::Xaml::Controls::Primitives::CalendarPanel>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_CalendarPanel(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Microsoft::UI::Xaml::Controls::Primitives::CalendarPanel>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_CalendarPanel[] = {
        { "_assign_array_", _assign_array_CalendarPanel, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_CalendarPanel), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_CalendarPanel[] = {
        { }
    };

    static PyType_Slot _type_slots_CalendarPanel[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_CalendarPanel) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_CalendarPanel) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_CalendarPanel) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_CalendarPanel) },
        { }
    };

    static PyType_Spec type_spec_CalendarPanel = {
        "winrt._winrt_microsoft_ui_xaml_controls_primitives.CalendarPanel",
        sizeof(py::wrapper::Microsoft::UI::Xaml::Controls::Primitives::CalendarPanel),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_CalendarPanel};

    // ----- CalendarViewTemplateSettings class --------------------

    static PyObject* _new_CalendarViewTemplateSettings(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Microsoft::UI::Xaml::Controls::Primitives::CalendarViewTemplateSettings>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Microsoft::UI::Xaml::Controls::Primitives::CalendarViewTemplateSettings>::type_name);
        return nullptr;
    }

    static void _dealloc_CalendarViewTemplateSettings(py::wrapper::Microsoft::UI::Xaml::Controls::Primitives::CalendarViewTemplateSettings* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* CalendarViewTemplateSettings_get_CenterX(py::wrapper::Microsoft::UI::Xaml::Controls::Primitives::CalendarViewTemplateSettings* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.CalendarViewTemplateSettings", L"CenterX");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.CenterX();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CalendarViewTemplateSettings_get_CenterY(py::wrapper::Microsoft::UI::Xaml::Controls::Primitives::CalendarViewTemplateSettings* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.CalendarViewTemplateSettings", L"CenterY");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.CenterY();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CalendarViewTemplateSettings_get_ClipRect(py::wrapper::Microsoft::UI::Xaml::Controls::Primitives::CalendarViewTemplateSettings* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.CalendarViewTemplateSettings", L"ClipRect");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.ClipRect();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CalendarViewTemplateSettings_get_HasMoreContentAfter(py::wrapper::Microsoft::UI::Xaml::Controls::Primitives::CalendarViewTemplateSettings* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.CalendarViewTemplateSettings", L"HasMoreContentAfter");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.HasMoreContentAfter();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CalendarViewTemplateSettings_get_HasMoreContentBefore(py::wrapper::Microsoft::UI::Xaml::Controls::Primitives::CalendarViewTemplateSettings* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.CalendarViewTemplateSettings", L"HasMoreContentBefore");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.HasMoreContentBefore();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CalendarViewTemplateSettings_get_HasMoreViews(py::wrapper::Microsoft::UI::Xaml::Controls::Primitives::CalendarViewTemplateSettings* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.CalendarViewTemplateSettings", L"HasMoreViews");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.HasMoreViews();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CalendarViewTemplateSettings_get_HeaderText(py::wrapper::Microsoft::UI::Xaml::Controls::Primitives::CalendarViewTemplateSettings* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.CalendarViewTemplateSettings", L"HeaderText");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.HeaderText();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CalendarViewTemplateSettings_get_MinViewWidth(py::wrapper::Microsoft::UI::Xaml::Controls::Primitives::CalendarViewTemplateSettings* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.CalendarViewTemplateSettings", L"MinViewWidth");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.MinViewWidth();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CalendarViewTemplateSettings_get_WeekDay1(py::wrapper::Microsoft::UI::Xaml::Controls::Primitives::CalendarViewTemplateSettings* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.CalendarViewTemplateSettings", L"WeekDay1");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.WeekDay1();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CalendarViewTemplateSettings_get_WeekDay2(py::wrapper::Microsoft::UI::Xaml::Controls::Primitives::CalendarViewTemplateSettings* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.CalendarViewTemplateSettings", L"WeekDay2");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.WeekDay2();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CalendarViewTemplateSettings_get_WeekDay3(py::wrapper::Microsoft::UI::Xaml::Controls::Primitives::CalendarViewTemplateSettings* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.CalendarViewTemplateSettings", L"WeekDay3");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.WeekDay3();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CalendarViewTemplateSettings_get_WeekDay4(py::wrapper::Microsoft::UI::Xaml::Controls::Primitives::CalendarViewTemplateSettings* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.CalendarViewTemplateSettings", L"WeekDay4");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.WeekDay4();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CalendarViewTemplateSettings_get_WeekDay5(py::wrapper::Microsoft::UI::Xaml::Controls::Primitives::CalendarViewTemplateSettings* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.CalendarViewTemplateSettings", L"WeekDay5");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.WeekDay5();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CalendarViewTemplateSettings_get_WeekDay6(py::wrapper::Microsoft::UI::Xaml::Controls::Primitives::CalendarViewTemplateSettings* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.CalendarViewTemplateSettings", L"WeekDay6");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.WeekDay6();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CalendarViewTemplateSettings_get_WeekDay7(py::wrapper::Microsoft::UI::Xaml::Controls::Primitives::CalendarViewTemplateSettings* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.CalendarViewTemplateSettings", L"WeekDay7");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.WeekDay7();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_CalendarViewTemplateSettings(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Microsoft::UI::Xaml::Controls::Primitives::CalendarViewTemplateSettings>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_CalendarViewTemplateSettings(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Microsoft::UI::Xaml::Controls::Primitives::CalendarViewTemplateSettings>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_CalendarViewTemplateSettings[] = {
        { "_assign_array_", _assign_array_CalendarViewTemplateSettings, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_CalendarViewTemplateSettings), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_CalendarViewTemplateSettings[] = {
        { "center_x", reinterpret_cast<getter>(CalendarViewTemplateSettings_get_CenterX), nullptr, nullptr, nullptr },
        { "center_y", reinterpret_cast<getter>(CalendarViewTemplateSettings_get_CenterY), nullptr, nullptr, nullptr },
        { "clip_rect", reinterpret_cast<getter>(CalendarViewTemplateSettings_get_ClipRect), nullptr, nullptr, nullptr },
        { "has_more_content_after", reinterpret_cast<getter>(CalendarViewTemplateSettings_get_HasMoreContentAfter), nullptr, nullptr, nullptr },
        { "has_more_content_before", reinterpret_cast<getter>(CalendarViewTemplateSettings_get_HasMoreContentBefore), nullptr, nullptr, nullptr },
        { "has_more_views", reinterpret_cast<getter>(CalendarViewTemplateSettings_get_HasMoreViews), nullptr, nullptr, nullptr },
        { "header_text", reinterpret_cast<getter>(CalendarViewTemplateSettings_get_HeaderText), nullptr, nullptr, nullptr },
        { "min_view_width", reinterpret_cast<getter>(CalendarViewTemplateSettings_get_MinViewWidth), nullptr, nullptr, nullptr },
        { "week_day1", reinterpret_cast<getter>(CalendarViewTemplateSettings_get_WeekDay1), nullptr, nullptr, nullptr },
        { "week_day2", reinterpret_cast<getter>(CalendarViewTemplateSettings_get_WeekDay2), nullptr, nullptr, nullptr },
        { "week_day3", reinterpret_cast<getter>(CalendarViewTemplateSettings_get_WeekDay3), nullptr, nullptr, nullptr },
        { "week_day4", reinterpret_cast<getter>(CalendarViewTemplateSettings_get_WeekDay4), nullptr, nullptr, nullptr },
        { "week_day5", reinterpret_cast<getter>(CalendarViewTemplateSettings_get_WeekDay5), nullptr, nullptr, nullptr },
        { "week_day6", reinterpret_cast<getter>(CalendarViewTemplateSettings_get_WeekDay6), nullptr, nullptr, nullptr },
        { "week_day7", reinterpret_cast<getter>(CalendarViewTemplateSettings_get_WeekDay7), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_CalendarViewTemplateSettings[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_CalendarViewTemplateSettings) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_CalendarViewTemplateSettings) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_CalendarViewTemplateSettings) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_CalendarViewTemplateSettings) },
        { }
    };

    static PyType_Spec type_spec_CalendarViewTemplateSettings = {
        "winrt._winrt_microsoft_ui_xaml_controls_primitives.CalendarViewTemplateSettings",
        sizeof(py::wrapper::Microsoft::UI::Xaml::Controls::Primitives::CalendarViewTemplateSettings),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_CalendarViewTemplateSettings};

    // ----- CarouselPanel class --------------------

    struct PyWinrtCarouselPanel;
    using BasePyWinrtCarouselPanel = winrt::Microsoft::UI::Xaml::Controls::Primitives::CarouselPanelT<PyWinrtCarouselPanel, py::IPywinrtObject>;

    struct PyWinrtCarouselPanel : py::py_obj_ref, BasePyWinrtCarouselPanel
    {
        PyWinrtCarouselPanel(PyObject* py_obj) : py::py_obj_ref(py_obj), BasePyWinrtCarouselPanel() {}

        int32_t __stdcall GetPyObject(PyObject*& obj) override
        {
            obj = py::py_obj_ref::get_py_obj();
            return 0;
        }

        int32_t __stdcall GetComposableInner(winrt::Windows::Foundation::IInspectable& inner) override
        {
            inner = m_inner;
            return winrt::impl::error_ok;
        }

        static void toggle_reference(PyWinrtCarouselPanel* instance, bool is_last_reference)
        {
            py::py_obj_ref::toggle_reference(instance, is_last_reference);
        }

        int32_t query_interface_tearoff(winrt::guid const& id, void** result) const noexcept override
        {
            return py::py_obj_ref::query_interface_tearoff(id, result);
        }
    };

    static PyObject* _new_CarouselPanel(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);

        auto self_type = get_python_type_for<winrt::Microsoft::UI::Xaml::Controls::Primitives::CarouselPanel>();
        if (!self_type)
        {
            return nullptr;
        }

        if (arg_count == 0)
        {
            try
            {
                if (type != self_type)
                {
                    py::pyobj_handle self{type->tp_alloc(type, 0)};
                    if (!self)
                    {
                        return nullptr;
                    }

                    std::construct_at(&reinterpret_cast<py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>*>(self.get())->obj, nullptr);

                    auto obj_impl = winrt::make_self<PyWinrtCarouselPanel>(self.get());

                    auto obj = py::make_py_obj<PyWinrtCarouselPanel>(obj_impl, type, self.get());
                    if (!obj)
                    {
                        return nullptr;
                    }

                    reinterpret_cast<py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>*>(self.get())->obj = std::move(obj);

                    return self.detach();
                }

                winrt::Microsoft::UI::Xaml::Controls::Primitives::CarouselPanel instance{};
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_CarouselPanel(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* CarouselPanel_GetIrregularSnapPoints(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Xaml.Controls.Primitives.CarouselPanel", L"GetIrregularSnapPoints", 2);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(2);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Microsoft::UI::Xaml::Controls::Orientation>(args, 0);
                auto param1 = py::convert_to<winrt::Microsoft::UI::Xaml::Controls::Primitives::SnapPointsAlignment>(args, 1);

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::Primitives::CarouselPanel>().GetIrregularSnapPoints(param0, param1);
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* CarouselPanel_GetRegularSnapPoints(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Xaml.Controls.Primitives.CarouselPanel", L"GetRegularSnapPoints", 2);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(2);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Microsoft::UI::Xaml::Controls::Orientation>(args, 0);
                auto param1 = py::convert_to<winrt::Microsoft::UI::Xaml::Controls::Primitives::SnapPointsAlignment>(args, 1);
                float param2{};

                auto return_value = [&]()
                {
                    auto _gil = release_gil();
                    return self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::Primitives::CarouselPanel>().GetRegularSnapPoints(param0, param1, param2);
                }();

                py::pyobj_handle out_return_value{ py::convert(return_value) };
                if (!out_return_value)
                {
                    return nullptr;
                }
                py::pyobj_handle out2{ py::convert(param2) };
                if (!out2)
                {
                    return nullptr;
                }

                return PyTuple_Pack(2, out_return_value.get(), out2.get());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* CarouselPanel_LineDown(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Xaml.Controls.Primitives.CarouselPanel", L"LineDown", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                {
                    auto _gil = release_gil();
                    self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::Primitives::CarouselPanel>().LineDown();
                }

                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* CarouselPanel_LineLeft(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Xaml.Controls.Primitives.CarouselPanel", L"LineLeft", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                {
                    auto _gil = release_gil();
                    self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::Primitives::CarouselPanel>().LineLeft();
                }

                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* CarouselPanel_LineRight(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Xaml.Controls.Primitives.CarouselPanel", L"LineRight", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                {
                    auto _gil = release_gil();
                    self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::Primitives::CarouselPanel>().LineRight();
                }

                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* CarouselPanel_LineUp(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Xaml.Controls.Primitives.CarouselPanel", L"LineUp", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                {
                    auto _gil = release_gil();
                    self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::Primitives::CarouselPanel>().LineUp();
                }

                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* CarouselPanel_MakeVisible(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Xaml.Controls.Primitives.CarouselPanel", L"MakeVisible", 2);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(2);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Microsoft::UI::Xaml::UIElement>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Foundation::Rect>(args, 1);

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::Primitives::CarouselPanel>().MakeVisible(param0, param1);
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* CarouselPanel_MouseWheelDown(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Xaml.Controls.Primitives.CarouselPanel", L"MouseWheelDown", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                {
                    auto _gil = release_gil();
                    self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::Primitives::CarouselPanel>().MouseWheelDown();
                }

                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* CarouselPanel_MouseWheelLeft(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Xaml.Controls.Primitives.CarouselPanel", L"MouseWheelLeft", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                {
                    auto _gil = release_gil();
                    self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::Primitives::CarouselPanel>().MouseWheelLeft();
                }

                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* CarouselPanel_MouseWheelRight(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Xaml.Controls.Primitives.CarouselPanel", L"MouseWheelRight", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                {
                    auto _gil = release_gil();
                    self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::Primitives::CarouselPanel>().MouseWheelRight();
                }

                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* CarouselPanel_MouseWheelUp(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Xaml.Controls.Primitives.CarouselPanel", L"MouseWheelUp", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                {
                    auto _gil = release_gil();
                    self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::Primitives::CarouselPanel>().MouseWheelUp();
                }

                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* CarouselPanel_PageDown(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Xaml.Controls.Primitives.CarouselPanel", L"PageDown", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                {
                    auto _gil = release_gil();
                    self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::Primitives::CarouselPanel>().PageDown();
                }

                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* CarouselPanel_PageLeft(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Xaml.Controls.Primitives.CarouselPanel", L"PageLeft", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                {
                    auto _gil = release_gil();
                    self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::Primitives::CarouselPanel>().PageLeft();
                }

                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* CarouselPanel_PageRight(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Xaml.Controls.Primitives.CarouselPanel", L"PageRight", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                {
                    auto _gil = release_gil();
                    self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::Primitives::CarouselPanel>().PageRight();
                }

                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* CarouselPanel_PageUp(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Xaml.Controls.Primitives.CarouselPanel", L"PageUp", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                {
                    auto _gil = release_gil();
                    self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::Primitives::CarouselPanel>().PageUp();
                }

                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* CarouselPanel_SetHorizontalOffset(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Xaml.Controls.Primitives.CarouselPanel", L"SetHorizontalOffset", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<double>(args, 0);

                {
                    auto _gil = release_gil();
                    self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::Primitives::CarouselPanel>().SetHorizontalOffset(param0);
                }

                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* CarouselPanel_SetVerticalOffset(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Xaml.Controls.Primitives.CarouselPanel", L"SetVerticalOffset", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<double>(args, 0);

                {
                    auto _gil = release_gil();
                    self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::Primitives::CarouselPanel>().SetVerticalOffset(param0);
                }

                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* CarouselPanel_get_ScrollOwner(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.CarouselPanel", L"ScrollOwner");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::Primitives::CarouselPanel>().ScrollOwner();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int CarouselPanel_put_ScrollOwner(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.CarouselPanel", L"ScrollOwner");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);

            {
                auto _gil = release_gil();
                self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::Primitives::CarouselPanel>().ScrollOwner(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* CarouselPanel_get_CanVerticallyScroll(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.CarouselPanel", L"CanVerticallyScroll");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::Primitives::CarouselPanel>().CanVerticallyScroll();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int CarouselPanel_put_CanVerticallyScroll(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.CarouselPanel", L"CanVerticallyScroll");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<bool>(arg);

            {
                auto _gil = release_gil();
                self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::Primitives::CarouselPanel>().CanVerticallyScroll(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* CarouselPanel_get_CanHorizontallyScroll(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.CarouselPanel", L"CanHorizontallyScroll");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::Primitives::CarouselPanel>().CanHorizontallyScroll();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int CarouselPanel_put_CanHorizontallyScroll(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.CarouselPanel", L"CanHorizontallyScroll");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<bool>(arg);

            {
                auto _gil = release_gil();
                self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::Primitives::CarouselPanel>().CanHorizontallyScroll(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* CarouselPanel_get_ExtentHeight(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.CarouselPanel", L"ExtentHeight");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::Primitives::CarouselPanel>().ExtentHeight();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CarouselPanel_get_ExtentWidth(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.CarouselPanel", L"ExtentWidth");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::Primitives::CarouselPanel>().ExtentWidth();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CarouselPanel_get_HorizontalOffset(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.CarouselPanel", L"HorizontalOffset");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::Primitives::CarouselPanel>().HorizontalOffset();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CarouselPanel_get_VerticalOffset(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.CarouselPanel", L"VerticalOffset");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::Primitives::CarouselPanel>().VerticalOffset();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CarouselPanel_get_ViewportHeight(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.CarouselPanel", L"ViewportHeight");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::Primitives::CarouselPanel>().ViewportHeight();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CarouselPanel_get_ViewportWidth(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.CarouselPanel", L"ViewportWidth");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::Primitives::CarouselPanel>().ViewportWidth();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CarouselPanel_get_AreHorizontalSnapPointsRegular(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.CarouselPanel", L"AreHorizontalSnapPointsRegular");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::Primitives::CarouselPanel>().AreHorizontalSnapPointsRegular();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CarouselPanel_get_AreVerticalSnapPointsRegular(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.CarouselPanel", L"AreVerticalSnapPointsRegular");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::Primitives::CarouselPanel>().AreVerticalSnapPointsRegular();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CarouselPanel_add_HorizontalSnapPointsChanged(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, PyObject* arg) noexcept
    {
        try
        {
            static std::optional<bool> is_event_present{};

            if (!is_event_present.has_value())
            {
                is_event_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Microsoft.UI.Xaml.Controls.Primitives.CarouselPanel", L"HorizontalSnapPointsChanged");
            }

            if (!is_event_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::EventHandler<winrt::Windows::Foundation::IInspectable>>(arg);

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::Primitives::CarouselPanel>().HorizontalSnapPointsChanged(param0);
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CarouselPanel_remove_HorizontalSnapPointsChanged(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, PyObject* arg) noexcept
    {
        try
        {
            static std::optional<bool> is_event_present{};

            if (!is_event_present.has_value())
            {
                is_event_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Microsoft.UI.Xaml.Controls.Primitives.CarouselPanel", L"HorizontalSnapPointsChanged");
            }

            if (!is_event_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::event_token>(arg);

            {
                auto _gil = release_gil();
                self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::Primitives::CarouselPanel>().HorizontalSnapPointsChanged(param0);
            }

            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CarouselPanel_add_VerticalSnapPointsChanged(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, PyObject* arg) noexcept
    {
        try
        {
            static std::optional<bool> is_event_present{};

            if (!is_event_present.has_value())
            {
                is_event_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Microsoft.UI.Xaml.Controls.Primitives.CarouselPanel", L"VerticalSnapPointsChanged");
            }

            if (!is_event_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::EventHandler<winrt::Windows::Foundation::IInspectable>>(arg);

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::Primitives::CarouselPanel>().VerticalSnapPointsChanged(param0);
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CarouselPanel_remove_VerticalSnapPointsChanged(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, PyObject* arg) noexcept
    {
        try
        {
            static std::optional<bool> is_event_present{};

            if (!is_event_present.has_value())
            {
                is_event_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Microsoft.UI.Xaml.Controls.Primitives.CarouselPanel", L"VerticalSnapPointsChanged");
            }

            if (!is_event_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::event_token>(arg);

            {
                auto _gil = release_gil();
                self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::Primitives::CarouselPanel>().VerticalSnapPointsChanged(param0);
            }

            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_CarouselPanel(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Microsoft::UI::Xaml::Controls::Primitives::CarouselPanel>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_CarouselPanel(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Microsoft::UI::Xaml::Controls::Primitives::CarouselPanel>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_CarouselPanel[] = {
        { "get_irregular_snap_points", reinterpret_cast<PyCFunction>(CarouselPanel_GetIrregularSnapPoints), METH_VARARGS, nullptr },
        { "get_regular_snap_points", reinterpret_cast<PyCFunction>(CarouselPanel_GetRegularSnapPoints), METH_VARARGS, nullptr },
        { "line_down", reinterpret_cast<PyCFunction>(CarouselPanel_LineDown), METH_VARARGS, nullptr },
        { "line_left", reinterpret_cast<PyCFunction>(CarouselPanel_LineLeft), METH_VARARGS, nullptr },
        { "line_right", reinterpret_cast<PyCFunction>(CarouselPanel_LineRight), METH_VARARGS, nullptr },
        { "line_up", reinterpret_cast<PyCFunction>(CarouselPanel_LineUp), METH_VARARGS, nullptr },
        { "make_visible", reinterpret_cast<PyCFunction>(CarouselPanel_MakeVisible), METH_VARARGS, nullptr },
        { "mouse_wheel_down", reinterpret_cast<PyCFunction>(CarouselPanel_MouseWheelDown), METH_VARARGS, nullptr },
        { "mouse_wheel_left", reinterpret_cast<PyCFunction>(CarouselPanel_MouseWheelLeft), METH_VARARGS, nullptr },
        { "mouse_wheel_right", reinterpret_cast<PyCFunction>(CarouselPanel_MouseWheelRight), METH_VARARGS, nullptr },
        { "mouse_wheel_up", reinterpret_cast<PyCFunction>(CarouselPanel_MouseWheelUp), METH_VARARGS, nullptr },
        { "page_down", reinterpret_cast<PyCFunction>(CarouselPanel_PageDown), METH_VARARGS, nullptr },
        { "page_left", reinterpret_cast<PyCFunction>(CarouselPanel_PageLeft), METH_VARARGS, nullptr },
        { "page_right", reinterpret_cast<PyCFunction>(CarouselPanel_PageRight), METH_VARARGS, nullptr },
        { "page_up", reinterpret_cast<PyCFunction>(CarouselPanel_PageUp), METH_VARARGS, nullptr },
        { "set_horizontal_offset", reinterpret_cast<PyCFunction>(CarouselPanel_SetHorizontalOffset), METH_VARARGS, nullptr },
        { "set_vertical_offset", reinterpret_cast<PyCFunction>(CarouselPanel_SetVerticalOffset), METH_VARARGS, nullptr },
        { "add_horizontal_snap_points_changed", reinterpret_cast<PyCFunction>(CarouselPanel_add_HorizontalSnapPointsChanged), METH_O, nullptr },
        { "remove_horizontal_snap_points_changed", reinterpret_cast<PyCFunction>(CarouselPanel_remove_HorizontalSnapPointsChanged), METH_O, nullptr },
        { "add_vertical_snap_points_changed", reinterpret_cast<PyCFunction>(CarouselPanel_add_VerticalSnapPointsChanged), METH_O, nullptr },
        { "remove_vertical_snap_points_changed", reinterpret_cast<PyCFunction>(CarouselPanel_remove_VerticalSnapPointsChanged), METH_O, nullptr },
        { "_assign_array_", _assign_array_CarouselPanel, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_CarouselPanel), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_CarouselPanel[] = {
        { "scroll_owner", reinterpret_cast<getter>(CarouselPanel_get_ScrollOwner), reinterpret_cast<setter>(CarouselPanel_put_ScrollOwner), nullptr, nullptr },
        { "can_vertically_scroll", reinterpret_cast<getter>(CarouselPanel_get_CanVerticallyScroll), reinterpret_cast<setter>(CarouselPanel_put_CanVerticallyScroll), nullptr, nullptr },
        { "can_horizontally_scroll", reinterpret_cast<getter>(CarouselPanel_get_CanHorizontallyScroll), reinterpret_cast<setter>(CarouselPanel_put_CanHorizontallyScroll), nullptr, nullptr },
        { "extent_height", reinterpret_cast<getter>(CarouselPanel_get_ExtentHeight), nullptr, nullptr, nullptr },
        { "extent_width", reinterpret_cast<getter>(CarouselPanel_get_ExtentWidth), nullptr, nullptr, nullptr },
        { "horizontal_offset", reinterpret_cast<getter>(CarouselPanel_get_HorizontalOffset), nullptr, nullptr, nullptr },
        { "vertical_offset", reinterpret_cast<getter>(CarouselPanel_get_VerticalOffset), nullptr, nullptr, nullptr },
        { "viewport_height", reinterpret_cast<getter>(CarouselPanel_get_ViewportHeight), nullptr, nullptr, nullptr },
        { "viewport_width", reinterpret_cast<getter>(CarouselPanel_get_ViewportWidth), nullptr, nullptr, nullptr },
        { "are_horizontal_snap_points_regular", reinterpret_cast<getter>(CarouselPanel_get_AreHorizontalSnapPointsRegular), nullptr, nullptr, nullptr },
        { "are_vertical_snap_points_regular", reinterpret_cast<getter>(CarouselPanel_get_AreVerticalSnapPointsRegular), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_CarouselPanel[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_CarouselPanel) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_CarouselPanel) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_CarouselPanel) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_CarouselPanel) },
        { }
    };

    static PyType_Spec type_spec_CarouselPanel = {
        "winrt._winrt_microsoft_ui_xaml_controls_primitives.CarouselPanel",
        sizeof(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>),
        0,
        Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,
        _type_slots_CarouselPanel};

    static PyGetSetDef getset_CarouselPanel_Static[] = {
        { }
    };

    static PyMethodDef methods_CarouselPanel_Static[] = {
        { }
    };

    static PyType_Slot type_slots_CarouselPanel_Static[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_CarouselPanel_Static) },
        { Py_tp_methods, reinterpret_cast<void*>(methods_CarouselPanel_Static) },
        { }
    };

    static PyType_Spec type_spec_CarouselPanel_Static =
    {
        "winrt._winrt_microsoft_ui_xaml_controls_primitives.CarouselPanel_Static",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,
        type_slots_CarouselPanel_Static
    };

    // ----- ColorSpectrum class --------------------

    struct PyWinrtColorSpectrum;
    using BasePyWinrtColorSpectrum = winrt::Microsoft::UI::Xaml::Controls::Primitives::ColorSpectrumT<PyWinrtColorSpectrum, py::IPywinrtObject>;

    struct PyWinrtColorSpectrum : py::py_obj_ref, BasePyWinrtColorSpectrum
    {
        PyWinrtColorSpectrum(PyObject* py_obj) : py::py_obj_ref(py_obj), BasePyWinrtColorSpectrum() {}

        int32_t __stdcall GetPyObject(PyObject*& obj) override
        {
            obj = py::py_obj_ref::get_py_obj();
            return 0;
        }

        int32_t __stdcall GetComposableInner(winrt::Windows::Foundation::IInspectable& inner) override
        {
            inner = m_inner;
            return winrt::impl::error_ok;
        }

        static void toggle_reference(PyWinrtColorSpectrum* instance, bool is_last_reference)
        {
            py::py_obj_ref::toggle_reference(instance, is_last_reference);
        }

        int32_t query_interface_tearoff(winrt::guid const& id, void** result) const noexcept override
        {
            return py::py_obj_ref::query_interface_tearoff(id, result);
        }
    };

    static PyObject* _new_ColorSpectrum(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);

        auto self_type = get_python_type_for<winrt::Microsoft::UI::Xaml::Controls::Primitives::ColorSpectrum>();
        if (!self_type)
        {
            return nullptr;
        }

        if (arg_count == 0)
        {
            try
            {
                if (type != self_type)
                {
                    py::pyobj_handle self{type->tp_alloc(type, 0)};
                    if (!self)
                    {
                        return nullptr;
                    }

                    std::construct_at(&reinterpret_cast<py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>*>(self.get())->obj, nullptr);

                    auto obj_impl = winrt::make_self<PyWinrtColorSpectrum>(self.get());

                    auto obj = py::make_py_obj<PyWinrtColorSpectrum>(obj_impl, type, self.get());
                    if (!obj)
                    {
                        return nullptr;
                    }

                    reinterpret_cast<py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>*>(self.get())->obj = std::move(obj);

                    return self.detach();
                }

                winrt::Microsoft::UI::Xaml::Controls::Primitives::ColorSpectrum instance{};
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_ColorSpectrum(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* ColorSpectrum_get_Shape(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.ColorSpectrum", L"Shape");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::Primitives::ColorSpectrum>().Shape();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ColorSpectrum_put_Shape(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.ColorSpectrum", L"Shape");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Microsoft::UI::Xaml::Controls::ColorSpectrumShape>(arg);

            {
                auto _gil = release_gil();
                self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::Primitives::ColorSpectrum>().Shape(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ColorSpectrum_get_MinValue(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.ColorSpectrum", L"MinValue");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::Primitives::ColorSpectrum>().MinValue();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ColorSpectrum_put_MinValue(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.ColorSpectrum", L"MinValue");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<int32_t>(arg);

            {
                auto _gil = release_gil();
                self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::Primitives::ColorSpectrum>().MinValue(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ColorSpectrum_get_MinSaturation(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.ColorSpectrum", L"MinSaturation");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::Primitives::ColorSpectrum>().MinSaturation();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ColorSpectrum_put_MinSaturation(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.ColorSpectrum", L"MinSaturation");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<int32_t>(arg);

            {
                auto _gil = release_gil();
                self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::Primitives::ColorSpectrum>().MinSaturation(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ColorSpectrum_get_MinHue(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.ColorSpectrum", L"MinHue");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::Primitives::ColorSpectrum>().MinHue();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ColorSpectrum_put_MinHue(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.ColorSpectrum", L"MinHue");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<int32_t>(arg);

            {
                auto _gil = release_gil();
                self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::Primitives::ColorSpectrum>().MinHue(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ColorSpectrum_get_MaxValue(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.ColorSpectrum", L"MaxValue");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::Primitives::ColorSpectrum>().MaxValue();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ColorSpectrum_put_MaxValue(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.ColorSpectrum", L"MaxValue");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<int32_t>(arg);

            {
                auto _gil = release_gil();
                self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::Primitives::ColorSpectrum>().MaxValue(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ColorSpectrum_get_MaxSaturation(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.ColorSpectrum", L"MaxSaturation");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::Primitives::ColorSpectrum>().MaxSaturation();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ColorSpectrum_put_MaxSaturation(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.ColorSpectrum", L"MaxSaturation");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<int32_t>(arg);

            {
                auto _gil = release_gil();
                self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::Primitives::ColorSpectrum>().MaxSaturation(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ColorSpectrum_get_MaxHue(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.ColorSpectrum", L"MaxHue");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::Primitives::ColorSpectrum>().MaxHue();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ColorSpectrum_put_MaxHue(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.ColorSpectrum", L"MaxHue");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<int32_t>(arg);

            {
                auto _gil = release_gil();
                self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::Primitives::ColorSpectrum>().MaxHue(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ColorSpectrum_get_HsvColor(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.ColorSpectrum", L"HsvColor");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::Primitives::ColorSpectrum>().HsvColor();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ColorSpectrum_put_HsvColor(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.ColorSpectrum", L"HsvColor");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::Numerics::float4>(arg);

            {
                auto _gil = release_gil();
                self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::Primitives::ColorSpectrum>().HsvColor(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ColorSpectrum_get_Components(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.ColorSpectrum", L"Components");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::Primitives::ColorSpectrum>().Components();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ColorSpectrum_put_Components(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.ColorSpectrum", L"Components");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Microsoft::UI::Xaml::Controls::ColorSpectrumComponents>(arg);

            {
                auto _gil = release_gil();
                self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::Primitives::ColorSpectrum>().Components(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ColorSpectrum_get_Color(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.ColorSpectrum", L"Color");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::Primitives::ColorSpectrum>().Color();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ColorSpectrum_put_Color(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.ColorSpectrum", L"Color");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::UI::Color>(arg);

            {
                auto _gil = release_gil();
                self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::Primitives::ColorSpectrum>().Color(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ColorSpectrum_get_ColorProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.ColorSpectrum", L"ColorProperty");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return winrt::Microsoft::UI::Xaml::Controls::Primitives::ColorSpectrum::ColorProperty();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ColorSpectrum_get_ComponentsProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.ColorSpectrum", L"ComponentsProperty");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return winrt::Microsoft::UI::Xaml::Controls::Primitives::ColorSpectrum::ComponentsProperty();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ColorSpectrum_get_HsvColorProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.ColorSpectrum", L"HsvColorProperty");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return winrt::Microsoft::UI::Xaml::Controls::Primitives::ColorSpectrum::HsvColorProperty();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ColorSpectrum_get_MaxHueProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.ColorSpectrum", L"MaxHueProperty");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return winrt::Microsoft::UI::Xaml::Controls::Primitives::ColorSpectrum::MaxHueProperty();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ColorSpectrum_get_MaxSaturationProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.ColorSpectrum", L"MaxSaturationProperty");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return winrt::Microsoft::UI::Xaml::Controls::Primitives::ColorSpectrum::MaxSaturationProperty();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ColorSpectrum_get_MaxValueProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.ColorSpectrum", L"MaxValueProperty");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return winrt::Microsoft::UI::Xaml::Controls::Primitives::ColorSpectrum::MaxValueProperty();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ColorSpectrum_get_MinHueProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.ColorSpectrum", L"MinHueProperty");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return winrt::Microsoft::UI::Xaml::Controls::Primitives::ColorSpectrum::MinHueProperty();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ColorSpectrum_get_MinSaturationProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.ColorSpectrum", L"MinSaturationProperty");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return winrt::Microsoft::UI::Xaml::Controls::Primitives::ColorSpectrum::MinSaturationProperty();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ColorSpectrum_get_MinValueProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.ColorSpectrum", L"MinValueProperty");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return winrt::Microsoft::UI::Xaml::Controls::Primitives::ColorSpectrum::MinValueProperty();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ColorSpectrum_get_ShapeProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.ColorSpectrum", L"ShapeProperty");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return winrt::Microsoft::UI::Xaml::Controls::Primitives::ColorSpectrum::ShapeProperty();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ColorSpectrum_add_ColorChanged(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, PyObject* arg) noexcept
    {
        try
        {
            static std::optional<bool> is_event_present{};

            if (!is_event_present.has_value())
            {
                is_event_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Microsoft.UI.Xaml.Controls.Primitives.ColorSpectrum", L"ColorChanged");
            }

            if (!is_event_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Microsoft::UI::Xaml::Controls::Primitives::ColorSpectrum, winrt::Microsoft::UI::Xaml::Controls::ColorChangedEventArgs>>(arg);

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::Primitives::ColorSpectrum>().ColorChanged(param0);
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ColorSpectrum_remove_ColorChanged(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, PyObject* arg) noexcept
    {
        try
        {
            static std::optional<bool> is_event_present{};

            if (!is_event_present.has_value())
            {
                is_event_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Microsoft.UI.Xaml.Controls.Primitives.ColorSpectrum", L"ColorChanged");
            }

            if (!is_event_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::event_token>(arg);

            {
                auto _gil = release_gil();
                self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::Primitives::ColorSpectrum>().ColorChanged(param0);
            }

            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_ColorSpectrum(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Microsoft::UI::Xaml::Controls::Primitives::ColorSpectrum>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_ColorSpectrum(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Microsoft::UI::Xaml::Controls::Primitives::ColorSpectrum>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_ColorSpectrum[] = {
        { "add_color_changed", reinterpret_cast<PyCFunction>(ColorSpectrum_add_ColorChanged), METH_O, nullptr },
        { "remove_color_changed", reinterpret_cast<PyCFunction>(ColorSpectrum_remove_ColorChanged), METH_O, nullptr },
        { "_assign_array_", _assign_array_ColorSpectrum, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_ColorSpectrum), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_ColorSpectrum[] = {
        { "shape", reinterpret_cast<getter>(ColorSpectrum_get_Shape), reinterpret_cast<setter>(ColorSpectrum_put_Shape), nullptr, nullptr },
        { "min_value", reinterpret_cast<getter>(ColorSpectrum_get_MinValue), reinterpret_cast<setter>(ColorSpectrum_put_MinValue), nullptr, nullptr },
        { "min_saturation", reinterpret_cast<getter>(ColorSpectrum_get_MinSaturation), reinterpret_cast<setter>(ColorSpectrum_put_MinSaturation), nullptr, nullptr },
        { "min_hue", reinterpret_cast<getter>(ColorSpectrum_get_MinHue), reinterpret_cast<setter>(ColorSpectrum_put_MinHue), nullptr, nullptr },
        { "max_value", reinterpret_cast<getter>(ColorSpectrum_get_MaxValue), reinterpret_cast<setter>(ColorSpectrum_put_MaxValue), nullptr, nullptr },
        { "max_saturation", reinterpret_cast<getter>(ColorSpectrum_get_MaxSaturation), reinterpret_cast<setter>(ColorSpectrum_put_MaxSaturation), nullptr, nullptr },
        { "max_hue", reinterpret_cast<getter>(ColorSpectrum_get_MaxHue), reinterpret_cast<setter>(ColorSpectrum_put_MaxHue), nullptr, nullptr },
        { "hsv_color", reinterpret_cast<getter>(ColorSpectrum_get_HsvColor), reinterpret_cast<setter>(ColorSpectrum_put_HsvColor), nullptr, nullptr },
        { "components", reinterpret_cast<getter>(ColorSpectrum_get_Components), reinterpret_cast<setter>(ColorSpectrum_put_Components), nullptr, nullptr },
        { "color", reinterpret_cast<getter>(ColorSpectrum_get_Color), reinterpret_cast<setter>(ColorSpectrum_put_Color), nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_ColorSpectrum[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_ColorSpectrum) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_ColorSpectrum) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_ColorSpectrum) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_ColorSpectrum) },
        { }
    };

    static PyType_Spec type_spec_ColorSpectrum = {
        "winrt._winrt_microsoft_ui_xaml_controls_primitives.ColorSpectrum",
        sizeof(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>),
        0,
        Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,
        _type_slots_ColorSpectrum};

    static PyGetSetDef getset_ColorSpectrum_Static[] = {
        { "color_property", reinterpret_cast<getter>(ColorSpectrum_get_ColorProperty), nullptr, nullptr, nullptr },
        { "components_property", reinterpret_cast<getter>(ColorSpectrum_get_ComponentsProperty), nullptr, nullptr, nullptr },
        { "hsv_color_property", reinterpret_cast<getter>(ColorSpectrum_get_HsvColorProperty), nullptr, nullptr, nullptr },
        { "max_hue_property", reinterpret_cast<getter>(ColorSpectrum_get_MaxHueProperty), nullptr, nullptr, nullptr },
        { "max_saturation_property", reinterpret_cast<getter>(ColorSpectrum_get_MaxSaturationProperty), nullptr, nullptr, nullptr },
        { "max_value_property", reinterpret_cast<getter>(ColorSpectrum_get_MaxValueProperty), nullptr, nullptr, nullptr },
        { "min_hue_property", reinterpret_cast<getter>(ColorSpectrum_get_MinHueProperty), nullptr, nullptr, nullptr },
        { "min_saturation_property", reinterpret_cast<getter>(ColorSpectrum_get_MinSaturationProperty), nullptr, nullptr, nullptr },
        { "min_value_property", reinterpret_cast<getter>(ColorSpectrum_get_MinValueProperty), nullptr, nullptr, nullptr },
        { "shape_property", reinterpret_cast<getter>(ColorSpectrum_get_ShapeProperty), nullptr, nullptr, nullptr },
        { }
    };

    static PyMethodDef methods_ColorSpectrum_Static[] = {
        { }
    };

    static PyType_Slot type_slots_ColorSpectrum_Static[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_ColorSpectrum_Static) },
        { Py_tp_methods, reinterpret_cast<void*>(methods_ColorSpectrum_Static) },
        { }
    };

    static PyType_Spec type_spec_ColorSpectrum_Static =
    {
        "winrt._winrt_microsoft_ui_xaml_controls_primitives.ColorSpectrum_Static",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,
        type_slots_ColorSpectrum_Static
    };

    // ----- ColumnMajorUniformToLargestGridLayout class --------------------

    struct PyWinrtColumnMajorUniformToLargestGridLayout;
    using BasePyWinrtColumnMajorUniformToLargestGridLayout = winrt::Microsoft::UI::Xaml::Controls::Primitives::ColumnMajorUniformToLargestGridLayoutT<PyWinrtColumnMajorUniformToLargestGridLayout, py::IPywinrtObject>;

    struct PyWinrtColumnMajorUniformToLargestGridLayout : py::py_obj_ref, BasePyWinrtColumnMajorUniformToLargestGridLayout
    {
        PyWinrtColumnMajorUniformToLargestGridLayout(PyObject* py_obj) : py::py_obj_ref(py_obj), BasePyWinrtColumnMajorUniformToLargestGridLayout() {}

        int32_t __stdcall GetPyObject(PyObject*& obj) override
        {
            obj = py::py_obj_ref::get_py_obj();
            return 0;
        }

        int32_t __stdcall GetComposableInner(winrt::Windows::Foundation::IInspectable& inner) override
        {
            inner = m_inner;
            return winrt::impl::error_ok;
        }

        static void toggle_reference(PyWinrtColumnMajorUniformToLargestGridLayout* instance, bool is_last_reference)
        {
            py::py_obj_ref::toggle_reference(instance, is_last_reference);
        }

        int32_t query_interface_tearoff(winrt::guid const& id, void** result) const noexcept override
        {
            return py::py_obj_ref::query_interface_tearoff(id, result);
        }
    };

    static PyObject* _new_ColumnMajorUniformToLargestGridLayout(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);

        auto self_type = get_python_type_for<winrt::Microsoft::UI::Xaml::Controls::Primitives::ColumnMajorUniformToLargestGridLayout>();
        if (!self_type)
        {
            return nullptr;
        }

        if (arg_count == 0)
        {
            try
            {
                if (type != self_type)
                {
                    py::pyobj_handle self{type->tp_alloc(type, 0)};
                    if (!self)
                    {
                        return nullptr;
                    }

                    std::construct_at(&reinterpret_cast<py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>*>(self.get())->obj, nullptr);

                    auto obj_impl = winrt::make_self<PyWinrtColumnMajorUniformToLargestGridLayout>(self.get());

                    auto obj = py::make_py_obj<PyWinrtColumnMajorUniformToLargestGridLayout>(obj_impl, type, self.get());
                    if (!obj)
                    {
                        return nullptr;
                    }

                    reinterpret_cast<py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>*>(self.get())->obj = std::move(obj);

                    return self.detach();
                }

                winrt::Microsoft::UI::Xaml::Controls::Primitives::ColumnMajorUniformToLargestGridLayout instance{};
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_ColumnMajorUniformToLargestGridLayout(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* ColumnMajorUniformToLargestGridLayout_get_RowSpacing(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.ColumnMajorUniformToLargestGridLayout", L"RowSpacing");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::Primitives::ColumnMajorUniformToLargestGridLayout>().RowSpacing();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ColumnMajorUniformToLargestGridLayout_put_RowSpacing(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.ColumnMajorUniformToLargestGridLayout", L"RowSpacing");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<double>(arg);

            {
                auto _gil = release_gil();
                self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::Primitives::ColumnMajorUniformToLargestGridLayout>().RowSpacing(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ColumnMajorUniformToLargestGridLayout_get_MaxColumns(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.ColumnMajorUniformToLargestGridLayout", L"MaxColumns");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::Primitives::ColumnMajorUniformToLargestGridLayout>().MaxColumns();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ColumnMajorUniformToLargestGridLayout_put_MaxColumns(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.ColumnMajorUniformToLargestGridLayout", L"MaxColumns");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<int32_t>(arg);

            {
                auto _gil = release_gil();
                self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::Primitives::ColumnMajorUniformToLargestGridLayout>().MaxColumns(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ColumnMajorUniformToLargestGridLayout_get_ColumnSpacing(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.ColumnMajorUniformToLargestGridLayout", L"ColumnSpacing");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::Primitives::ColumnMajorUniformToLargestGridLayout>().ColumnSpacing();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ColumnMajorUniformToLargestGridLayout_put_ColumnSpacing(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.ColumnMajorUniformToLargestGridLayout", L"ColumnSpacing");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<double>(arg);

            {
                auto _gil = release_gil();
                self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::Primitives::ColumnMajorUniformToLargestGridLayout>().ColumnSpacing(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ColumnMajorUniformToLargestGridLayout_get_ColumnSpacingProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.ColumnMajorUniformToLargestGridLayout", L"ColumnSpacingProperty");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return winrt::Microsoft::UI::Xaml::Controls::Primitives::ColumnMajorUniformToLargestGridLayout::ColumnSpacingProperty();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ColumnMajorUniformToLargestGridLayout_get_MaxColumnsProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.ColumnMajorUniformToLargestGridLayout", L"MaxColumnsProperty");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return winrt::Microsoft::UI::Xaml::Controls::Primitives::ColumnMajorUniformToLargestGridLayout::MaxColumnsProperty();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ColumnMajorUniformToLargestGridLayout_get_RowSpacingProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.ColumnMajorUniformToLargestGridLayout", L"RowSpacingProperty");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return winrt::Microsoft::UI::Xaml::Controls::Primitives::ColumnMajorUniformToLargestGridLayout::RowSpacingProperty();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_ColumnMajorUniformToLargestGridLayout(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Microsoft::UI::Xaml::Controls::Primitives::ColumnMajorUniformToLargestGridLayout>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_ColumnMajorUniformToLargestGridLayout(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Microsoft::UI::Xaml::Controls::Primitives::ColumnMajorUniformToLargestGridLayout>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_ColumnMajorUniformToLargestGridLayout[] = {
        { "_assign_array_", _assign_array_ColumnMajorUniformToLargestGridLayout, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_ColumnMajorUniformToLargestGridLayout), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_ColumnMajorUniformToLargestGridLayout[] = {
        { "row_spacing", reinterpret_cast<getter>(ColumnMajorUniformToLargestGridLayout_get_RowSpacing), reinterpret_cast<setter>(ColumnMajorUniformToLargestGridLayout_put_RowSpacing), nullptr, nullptr },
        { "max_columns", reinterpret_cast<getter>(ColumnMajorUniformToLargestGridLayout_get_MaxColumns), reinterpret_cast<setter>(ColumnMajorUniformToLargestGridLayout_put_MaxColumns), nullptr, nullptr },
        { "column_spacing", reinterpret_cast<getter>(ColumnMajorUniformToLargestGridLayout_get_ColumnSpacing), reinterpret_cast<setter>(ColumnMajorUniformToLargestGridLayout_put_ColumnSpacing), nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_ColumnMajorUniformToLargestGridLayout[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_ColumnMajorUniformToLargestGridLayout) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_ColumnMajorUniformToLargestGridLayout) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_ColumnMajorUniformToLargestGridLayout) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_ColumnMajorUniformToLargestGridLayout) },
        { }
    };

    static PyType_Spec type_spec_ColumnMajorUniformToLargestGridLayout = {
        "winrt._winrt_microsoft_ui_xaml_controls_primitives.ColumnMajorUniformToLargestGridLayout",
        sizeof(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>),
        0,
        Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,
        _type_slots_ColumnMajorUniformToLargestGridLayout};

    static PyGetSetDef getset_ColumnMajorUniformToLargestGridLayout_Static[] = {
        { "column_spacing_property", reinterpret_cast<getter>(ColumnMajorUniformToLargestGridLayout_get_ColumnSpacingProperty), nullptr, nullptr, nullptr },
        { "max_columns_property", reinterpret_cast<getter>(ColumnMajorUniformToLargestGridLayout_get_MaxColumnsProperty), nullptr, nullptr, nullptr },
        { "row_spacing_property", reinterpret_cast<getter>(ColumnMajorUniformToLargestGridLayout_get_RowSpacingProperty), nullptr, nullptr, nullptr },
        { }
    };

    static PyMethodDef methods_ColumnMajorUniformToLargestGridLayout_Static[] = {
        { }
    };

    static PyType_Slot type_slots_ColumnMajorUniformToLargestGridLayout_Static[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_ColumnMajorUniformToLargestGridLayout_Static) },
        { Py_tp_methods, reinterpret_cast<void*>(methods_ColumnMajorUniformToLargestGridLayout_Static) },
        { }
    };

    static PyType_Spec type_spec_ColumnMajorUniformToLargestGridLayout_Static =
    {
        "winrt._winrt_microsoft_ui_xaml_controls_primitives.ColumnMajorUniformToLargestGridLayout_Static",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,
        type_slots_ColumnMajorUniformToLargestGridLayout_Static
    };

    // ----- ComboBoxHelper class --------------------

    static PyObject* _new_ComboBoxHelper(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Microsoft::UI::Xaml::Controls::Primitives::ComboBoxHelper>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Microsoft::UI::Xaml::Controls::Primitives::ComboBoxHelper>::type_name);
        return nullptr;
    }

    static void _dealloc_ComboBoxHelper(py::wrapper::Microsoft::UI::Xaml::Controls::Primitives::ComboBoxHelper* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* ComboBoxHelper_GetKeepInteriorCornersSquare(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Xaml.Controls.Primitives.ComboBoxHelper", L"GetKeepInteriorCornersSquare", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Microsoft::UI::Xaml::Controls::ComboBox>(args, 0);

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return winrt::Microsoft::UI::Xaml::Controls::Primitives::ComboBoxHelper::GetKeepInteriorCornersSquare(param0);
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ComboBoxHelper_SetKeepInteriorCornersSquare(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Xaml.Controls.Primitives.ComboBoxHelper", L"SetKeepInteriorCornersSquare", 2);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(2);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Microsoft::UI::Xaml::Controls::ComboBox>(args, 0);
                auto param1 = py::convert_to<bool>(args, 1);

                {
                    auto _gil = release_gil();
                    winrt::Microsoft::UI::Xaml::Controls::Primitives::ComboBoxHelper::SetKeepInteriorCornersSquare(param0, param1);
                }

                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ComboBoxHelper_get_KeepInteriorCornersSquareProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.ComboBoxHelper", L"KeepInteriorCornersSquareProperty");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return winrt::Microsoft::UI::Xaml::Controls::Primitives::ComboBoxHelper::KeepInteriorCornersSquareProperty();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_ComboBoxHelper(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Microsoft::UI::Xaml::Controls::Primitives::ComboBoxHelper>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_ComboBoxHelper(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Microsoft::UI::Xaml::Controls::Primitives::ComboBoxHelper>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_ComboBoxHelper[] = {
        { "_assign_array_", _assign_array_ComboBoxHelper, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_ComboBoxHelper), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_ComboBoxHelper[] = {
        { }
    };

    static PyType_Slot _type_slots_ComboBoxHelper[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_ComboBoxHelper) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_ComboBoxHelper) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_ComboBoxHelper) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_ComboBoxHelper) },
        { }
    };

    static PyType_Spec type_spec_ComboBoxHelper = {
        "winrt._winrt_microsoft_ui_xaml_controls_primitives.ComboBoxHelper",
        sizeof(py::wrapper::Microsoft::UI::Xaml::Controls::Primitives::ComboBoxHelper),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_ComboBoxHelper};

    static PyGetSetDef getset_ComboBoxHelper_Static[] = {
        { "keep_interior_corners_square_property", reinterpret_cast<getter>(ComboBoxHelper_get_KeepInteriorCornersSquareProperty), nullptr, nullptr, nullptr },
        { }
    };

    static PyMethodDef methods_ComboBoxHelper_Static[] = {
        { "get_keep_interior_corners_square", reinterpret_cast<PyCFunction>(ComboBoxHelper_GetKeepInteriorCornersSquare), METH_VARARGS, nullptr },
        { "set_keep_interior_corners_square", reinterpret_cast<PyCFunction>(ComboBoxHelper_SetKeepInteriorCornersSquare), METH_VARARGS, nullptr },
        { }
    };

    static PyType_Slot type_slots_ComboBoxHelper_Static[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_ComboBoxHelper_Static) },
        { Py_tp_methods, reinterpret_cast<void*>(methods_ComboBoxHelper_Static) },
        { }
    };

    static PyType_Spec type_spec_ComboBoxHelper_Static =
    {
        "winrt._winrt_microsoft_ui_xaml_controls_primitives.ComboBoxHelper_Static",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT,
        type_slots_ComboBoxHelper_Static
    };

    // ----- ComboBoxTemplateSettings class --------------------

    static PyObject* _new_ComboBoxTemplateSettings(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Microsoft::UI::Xaml::Controls::Primitives::ComboBoxTemplateSettings>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Microsoft::UI::Xaml::Controls::Primitives::ComboBoxTemplateSettings>::type_name);
        return nullptr;
    }

    static void _dealloc_ComboBoxTemplateSettings(py::wrapper::Microsoft::UI::Xaml::Controls::Primitives::ComboBoxTemplateSettings* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* ComboBoxTemplateSettings_get_DropDownClosedHeight(py::wrapper::Microsoft::UI::Xaml::Controls::Primitives::ComboBoxTemplateSettings* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.ComboBoxTemplateSettings", L"DropDownClosedHeight");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.DropDownClosedHeight();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ComboBoxTemplateSettings_get_DropDownContentMinWidth(py::wrapper::Microsoft::UI::Xaml::Controls::Primitives::ComboBoxTemplateSettings* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.ComboBoxTemplateSettings", L"DropDownContentMinWidth");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.DropDownContentMinWidth();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ComboBoxTemplateSettings_get_DropDownOffset(py::wrapper::Microsoft::UI::Xaml::Controls::Primitives::ComboBoxTemplateSettings* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.ComboBoxTemplateSettings", L"DropDownOffset");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.DropDownOffset();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ComboBoxTemplateSettings_get_DropDownOpenedHeight(py::wrapper::Microsoft::UI::Xaml::Controls::Primitives::ComboBoxTemplateSettings* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.ComboBoxTemplateSettings", L"DropDownOpenedHeight");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.DropDownOpenedHeight();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ComboBoxTemplateSettings_get_SelectedItemDirection(py::wrapper::Microsoft::UI::Xaml::Controls::Primitives::ComboBoxTemplateSettings* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.ComboBoxTemplateSettings", L"SelectedItemDirection");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.SelectedItemDirection();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_ComboBoxTemplateSettings(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Microsoft::UI::Xaml::Controls::Primitives::ComboBoxTemplateSettings>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_ComboBoxTemplateSettings(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Microsoft::UI::Xaml::Controls::Primitives::ComboBoxTemplateSettings>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_ComboBoxTemplateSettings[] = {
        { "_assign_array_", _assign_array_ComboBoxTemplateSettings, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_ComboBoxTemplateSettings), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_ComboBoxTemplateSettings[] = {
        { "drop_down_closed_height", reinterpret_cast<getter>(ComboBoxTemplateSettings_get_DropDownClosedHeight), nullptr, nullptr, nullptr },
        { "drop_down_content_min_width", reinterpret_cast<getter>(ComboBoxTemplateSettings_get_DropDownContentMinWidth), nullptr, nullptr, nullptr },
        { "drop_down_offset", reinterpret_cast<getter>(ComboBoxTemplateSettings_get_DropDownOffset), nullptr, nullptr, nullptr },
        { "drop_down_opened_height", reinterpret_cast<getter>(ComboBoxTemplateSettings_get_DropDownOpenedHeight), nullptr, nullptr, nullptr },
        { "selected_item_direction", reinterpret_cast<getter>(ComboBoxTemplateSettings_get_SelectedItemDirection), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_ComboBoxTemplateSettings[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_ComboBoxTemplateSettings) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_ComboBoxTemplateSettings) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_ComboBoxTemplateSettings) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_ComboBoxTemplateSettings) },
        { }
    };

    static PyType_Spec type_spec_ComboBoxTemplateSettings = {
        "winrt._winrt_microsoft_ui_xaml_controls_primitives.ComboBoxTemplateSettings",
        sizeof(py::wrapper::Microsoft::UI::Xaml::Controls::Primitives::ComboBoxTemplateSettings),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_ComboBoxTemplateSettings};

    // ----- CommandBarFlyoutCommandBar class --------------------

    struct PyWinrtCommandBarFlyoutCommandBar;
    using BasePyWinrtCommandBarFlyoutCommandBar = winrt::Microsoft::UI::Xaml::Controls::Primitives::CommandBarFlyoutCommandBarT<PyWinrtCommandBarFlyoutCommandBar, py::IPywinrtObject>;

    struct PyWinrtCommandBarFlyoutCommandBar : py::py_obj_ref, BasePyWinrtCommandBarFlyoutCommandBar
    {
        PyWinrtCommandBarFlyoutCommandBar(PyObject* py_obj) : py::py_obj_ref(py_obj), BasePyWinrtCommandBarFlyoutCommandBar() {}

        int32_t __stdcall GetPyObject(PyObject*& obj) override
        {
            obj = py::py_obj_ref::get_py_obj();
            return 0;
        }

        int32_t __stdcall GetComposableInner(winrt::Windows::Foundation::IInspectable& inner) override
        {
            inner = m_inner;
            return winrt::impl::error_ok;
        }

        static void toggle_reference(PyWinrtCommandBarFlyoutCommandBar* instance, bool is_last_reference)
        {
            py::py_obj_ref::toggle_reference(instance, is_last_reference);
        }

        int32_t query_interface_tearoff(winrt::guid const& id, void** result) const noexcept override
        {
            return py::py_obj_ref::query_interface_tearoff(id, result);
        }
    };

    static PyObject* _new_CommandBarFlyoutCommandBar(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);

        auto self_type = get_python_type_for<winrt::Microsoft::UI::Xaml::Controls::Primitives::CommandBarFlyoutCommandBar>();
        if (!self_type)
        {
            return nullptr;
        }

        if (arg_count == 0)
        {
            try
            {
                if (type != self_type)
                {
                    py::pyobj_handle self{type->tp_alloc(type, 0)};
                    if (!self)
                    {
                        return nullptr;
                    }

                    std::construct_at(&reinterpret_cast<py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>*>(self.get())->obj, nullptr);

                    auto obj_impl = winrt::make_self<PyWinrtCommandBarFlyoutCommandBar>(self.get());

                    auto obj = py::make_py_obj<PyWinrtCommandBarFlyoutCommandBar>(obj_impl, type, self.get());
                    if (!obj)
                    {
                        return nullptr;
                    }

                    reinterpret_cast<py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>*>(self.get())->obj = std::move(obj);

                    return self.detach();
                }

                winrt::Microsoft::UI::Xaml::Controls::Primitives::CommandBarFlyoutCommandBar instance{};
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_CommandBarFlyoutCommandBar(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* CommandBarFlyoutCommandBar_get_FlyoutTemplateSettings(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.CommandBarFlyoutCommandBar", L"FlyoutTemplateSettings");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::Primitives::CommandBarFlyoutCommandBar>().FlyoutTemplateSettings();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CommandBarFlyoutCommandBar_get_SystemBackdrop(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.CommandBarFlyoutCommandBar", L"SystemBackdrop");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::Primitives::CommandBarFlyoutCommandBar>().SystemBackdrop();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int CommandBarFlyoutCommandBar_put_SystemBackdrop(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.CommandBarFlyoutCommandBar", L"SystemBackdrop");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Microsoft::UI::Xaml::Media::SystemBackdrop>(arg);

            {
                auto _gil = release_gil();
                self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::Primitives::CommandBarFlyoutCommandBar>().SystemBackdrop(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* CommandBarFlyoutCommandBar_get_SystemBackdropProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.CommandBarFlyoutCommandBar", L"SystemBackdropProperty");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return winrt::Microsoft::UI::Xaml::Controls::Primitives::CommandBarFlyoutCommandBar::SystemBackdropProperty();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_CommandBarFlyoutCommandBar(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Microsoft::UI::Xaml::Controls::Primitives::CommandBarFlyoutCommandBar>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_CommandBarFlyoutCommandBar(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Microsoft::UI::Xaml::Controls::Primitives::CommandBarFlyoutCommandBar>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_CommandBarFlyoutCommandBar[] = {
        { "_assign_array_", _assign_array_CommandBarFlyoutCommandBar, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_CommandBarFlyoutCommandBar), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_CommandBarFlyoutCommandBar[] = {
        { "flyout_template_settings", reinterpret_cast<getter>(CommandBarFlyoutCommandBar_get_FlyoutTemplateSettings), nullptr, nullptr, nullptr },
        { "system_backdrop", reinterpret_cast<getter>(CommandBarFlyoutCommandBar_get_SystemBackdrop), reinterpret_cast<setter>(CommandBarFlyoutCommandBar_put_SystemBackdrop), nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_CommandBarFlyoutCommandBar[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_CommandBarFlyoutCommandBar) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_CommandBarFlyoutCommandBar) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_CommandBarFlyoutCommandBar) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_CommandBarFlyoutCommandBar) },
        { }
    };

    static PyType_Spec type_spec_CommandBarFlyoutCommandBar = {
        "winrt._winrt_microsoft_ui_xaml_controls_primitives.CommandBarFlyoutCommandBar",
        sizeof(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>),
        0,
        Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,
        _type_slots_CommandBarFlyoutCommandBar};

    static PyGetSetDef getset_CommandBarFlyoutCommandBar_Static[] = {
        { "system_backdrop_property", reinterpret_cast<getter>(CommandBarFlyoutCommandBar_get_SystemBackdropProperty), nullptr, nullptr, nullptr },
        { }
    };

    static PyMethodDef methods_CommandBarFlyoutCommandBar_Static[] = {
        { }
    };

    static PyType_Slot type_slots_CommandBarFlyoutCommandBar_Static[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_CommandBarFlyoutCommandBar_Static) },
        { Py_tp_methods, reinterpret_cast<void*>(methods_CommandBarFlyoutCommandBar_Static) },
        { }
    };

    static PyType_Spec type_spec_CommandBarFlyoutCommandBar_Static =
    {
        "winrt._winrt_microsoft_ui_xaml_controls_primitives.CommandBarFlyoutCommandBar_Static",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,
        type_slots_CommandBarFlyoutCommandBar_Static
    };

    // ----- CommandBarFlyoutCommandBarAutomationProperties class --------------------

    static PyObject* _new_CommandBarFlyoutCommandBarAutomationProperties(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Microsoft::UI::Xaml::Controls::Primitives::CommandBarFlyoutCommandBarAutomationProperties>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Microsoft::UI::Xaml::Controls::Primitives::CommandBarFlyoutCommandBarAutomationProperties>::type_name);
        return nullptr;
    }

    static PyObject* CommandBarFlyoutCommandBarAutomationProperties_GetControlType(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Xaml.Controls.Primitives.CommandBarFlyoutCommandBarAutomationProperties", L"GetControlType", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Microsoft::UI::Xaml::UIElement>(args, 0);

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return winrt::Microsoft::UI::Xaml::Controls::Primitives::CommandBarFlyoutCommandBarAutomationProperties::GetControlType(param0);
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* CommandBarFlyoutCommandBarAutomationProperties_SetControlType(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Xaml.Controls.Primitives.CommandBarFlyoutCommandBarAutomationProperties", L"SetControlType", 2);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(2);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Microsoft::UI::Xaml::UIElement>(args, 0);
                auto param1 = py::convert_to<winrt::Microsoft::UI::Xaml::Automation::Peers::AutomationControlType>(args, 1);

                {
                    auto _gil = release_gil();
                    winrt::Microsoft::UI::Xaml::Controls::Primitives::CommandBarFlyoutCommandBarAutomationProperties::SetControlType(param0, param1);
                }

                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* CommandBarFlyoutCommandBarAutomationProperties_get_ControlTypeProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.CommandBarFlyoutCommandBarAutomationProperties", L"ControlTypeProperty");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return winrt::Microsoft::UI::Xaml::Controls::Primitives::CommandBarFlyoutCommandBarAutomationProperties::ControlTypeProperty();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_CommandBarFlyoutCommandBarAutomationProperties[] = {
        { }
    };

    static PyGetSetDef _getset_CommandBarFlyoutCommandBarAutomationProperties[] = {
        { }
    };

    static PyType_Slot _type_slots_CommandBarFlyoutCommandBarAutomationProperties[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_CommandBarFlyoutCommandBarAutomationProperties) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_CommandBarFlyoutCommandBarAutomationProperties) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_CommandBarFlyoutCommandBarAutomationProperties) },
        { }
    };

    static PyType_Spec type_spec_CommandBarFlyoutCommandBarAutomationProperties = {
        "winrt._winrt_microsoft_ui_xaml_controls_primitives.CommandBarFlyoutCommandBarAutomationProperties",
        0,
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_CommandBarFlyoutCommandBarAutomationProperties};

    static PyGetSetDef getset_CommandBarFlyoutCommandBarAutomationProperties_Static[] = {
        { "control_type_property", reinterpret_cast<getter>(CommandBarFlyoutCommandBarAutomationProperties_get_ControlTypeProperty), nullptr, nullptr, nullptr },
        { }
    };

    static PyMethodDef methods_CommandBarFlyoutCommandBarAutomationProperties_Static[] = {
        { "get_control_type", reinterpret_cast<PyCFunction>(CommandBarFlyoutCommandBarAutomationProperties_GetControlType), METH_VARARGS, nullptr },
        { "set_control_type", reinterpret_cast<PyCFunction>(CommandBarFlyoutCommandBarAutomationProperties_SetControlType), METH_VARARGS, nullptr },
        { }
    };

    static PyType_Slot type_slots_CommandBarFlyoutCommandBarAutomationProperties_Static[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_CommandBarFlyoutCommandBarAutomationProperties_Static) },
        { Py_tp_methods, reinterpret_cast<void*>(methods_CommandBarFlyoutCommandBarAutomationProperties_Static) },
        { }
    };

    static PyType_Spec type_spec_CommandBarFlyoutCommandBarAutomationProperties_Static =
    {
        "winrt._winrt_microsoft_ui_xaml_controls_primitives.CommandBarFlyoutCommandBarAutomationProperties_Static",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT,
        type_slots_CommandBarFlyoutCommandBarAutomationProperties_Static
    };

    // ----- CommandBarFlyoutCommandBarTemplateSettings class --------------------

    static PyObject* _new_CommandBarFlyoutCommandBarTemplateSettings(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Microsoft::UI::Xaml::Controls::Primitives::CommandBarFlyoutCommandBarTemplateSettings>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Microsoft::UI::Xaml::Controls::Primitives::CommandBarFlyoutCommandBarTemplateSettings>::type_name);
        return nullptr;
    }

    static void _dealloc_CommandBarFlyoutCommandBarTemplateSettings(py::wrapper::Microsoft::UI::Xaml::Controls::Primitives::CommandBarFlyoutCommandBarTemplateSettings* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* CommandBarFlyoutCommandBarTemplateSettings_get_CloseAnimationEndPosition(py::wrapper::Microsoft::UI::Xaml::Controls::Primitives::CommandBarFlyoutCommandBarTemplateSettings* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.CommandBarFlyoutCommandBarTemplateSettings", L"CloseAnimationEndPosition");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.CloseAnimationEndPosition();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CommandBarFlyoutCommandBarTemplateSettings_get_ContentClipRect(py::wrapper::Microsoft::UI::Xaml::Controls::Primitives::CommandBarFlyoutCommandBarTemplateSettings* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.CommandBarFlyoutCommandBarTemplateSettings", L"ContentClipRect");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.ContentClipRect();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CommandBarFlyoutCommandBarTemplateSettings_get_CurrentWidth(py::wrapper::Microsoft::UI::Xaml::Controls::Primitives::CommandBarFlyoutCommandBarTemplateSettings* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.CommandBarFlyoutCommandBarTemplateSettings", L"CurrentWidth");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.CurrentWidth();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CommandBarFlyoutCommandBarTemplateSettings_get_ExpandDownAnimationEndPosition(py::wrapper::Microsoft::UI::Xaml::Controls::Primitives::CommandBarFlyoutCommandBarTemplateSettings* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.CommandBarFlyoutCommandBarTemplateSettings", L"ExpandDownAnimationEndPosition");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.ExpandDownAnimationEndPosition();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CommandBarFlyoutCommandBarTemplateSettings_get_ExpandDownAnimationHoldPosition(py::wrapper::Microsoft::UI::Xaml::Controls::Primitives::CommandBarFlyoutCommandBarTemplateSettings* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.CommandBarFlyoutCommandBarTemplateSettings", L"ExpandDownAnimationHoldPosition");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.ExpandDownAnimationHoldPosition();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CommandBarFlyoutCommandBarTemplateSettings_get_ExpandDownAnimationStartPosition(py::wrapper::Microsoft::UI::Xaml::Controls::Primitives::CommandBarFlyoutCommandBarTemplateSettings* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.CommandBarFlyoutCommandBarTemplateSettings", L"ExpandDownAnimationStartPosition");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.ExpandDownAnimationStartPosition();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CommandBarFlyoutCommandBarTemplateSettings_get_ExpandDownOverflowVerticalPosition(py::wrapper::Microsoft::UI::Xaml::Controls::Primitives::CommandBarFlyoutCommandBarTemplateSettings* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.CommandBarFlyoutCommandBarTemplateSettings", L"ExpandDownOverflowVerticalPosition");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.ExpandDownOverflowVerticalPosition();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CommandBarFlyoutCommandBarTemplateSettings_get_ExpandUpAnimationEndPosition(py::wrapper::Microsoft::UI::Xaml::Controls::Primitives::CommandBarFlyoutCommandBarTemplateSettings* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.CommandBarFlyoutCommandBarTemplateSettings", L"ExpandUpAnimationEndPosition");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.ExpandUpAnimationEndPosition();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CommandBarFlyoutCommandBarTemplateSettings_get_ExpandUpAnimationHoldPosition(py::wrapper::Microsoft::UI::Xaml::Controls::Primitives::CommandBarFlyoutCommandBarTemplateSettings* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.CommandBarFlyoutCommandBarTemplateSettings", L"ExpandUpAnimationHoldPosition");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.ExpandUpAnimationHoldPosition();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CommandBarFlyoutCommandBarTemplateSettings_get_ExpandUpAnimationStartPosition(py::wrapper::Microsoft::UI::Xaml::Controls::Primitives::CommandBarFlyoutCommandBarTemplateSettings* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.CommandBarFlyoutCommandBarTemplateSettings", L"ExpandUpAnimationStartPosition");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.ExpandUpAnimationStartPosition();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CommandBarFlyoutCommandBarTemplateSettings_get_ExpandUpOverflowVerticalPosition(py::wrapper::Microsoft::UI::Xaml::Controls::Primitives::CommandBarFlyoutCommandBarTemplateSettings* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.CommandBarFlyoutCommandBarTemplateSettings", L"ExpandUpOverflowVerticalPosition");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.ExpandUpOverflowVerticalPosition();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CommandBarFlyoutCommandBarTemplateSettings_get_ExpandedWidth(py::wrapper::Microsoft::UI::Xaml::Controls::Primitives::CommandBarFlyoutCommandBarTemplateSettings* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.CommandBarFlyoutCommandBarTemplateSettings", L"ExpandedWidth");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.ExpandedWidth();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CommandBarFlyoutCommandBarTemplateSettings_get_OpenAnimationEndPosition(py::wrapper::Microsoft::UI::Xaml::Controls::Primitives::CommandBarFlyoutCommandBarTemplateSettings* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.CommandBarFlyoutCommandBarTemplateSettings", L"OpenAnimationEndPosition");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.OpenAnimationEndPosition();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CommandBarFlyoutCommandBarTemplateSettings_get_OpenAnimationStartPosition(py::wrapper::Microsoft::UI::Xaml::Controls::Primitives::CommandBarFlyoutCommandBarTemplateSettings* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.CommandBarFlyoutCommandBarTemplateSettings", L"OpenAnimationStartPosition");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.OpenAnimationStartPosition();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CommandBarFlyoutCommandBarTemplateSettings_get_OverflowContentClipRect(py::wrapper::Microsoft::UI::Xaml::Controls::Primitives::CommandBarFlyoutCommandBarTemplateSettings* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.CommandBarFlyoutCommandBarTemplateSettings", L"OverflowContentClipRect");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.OverflowContentClipRect();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CommandBarFlyoutCommandBarTemplateSettings_get_WidthExpansionAnimationEndPosition(py::wrapper::Microsoft::UI::Xaml::Controls::Primitives::CommandBarFlyoutCommandBarTemplateSettings* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.CommandBarFlyoutCommandBarTemplateSettings", L"WidthExpansionAnimationEndPosition");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.WidthExpansionAnimationEndPosition();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CommandBarFlyoutCommandBarTemplateSettings_get_WidthExpansionAnimationStartPosition(py::wrapper::Microsoft::UI::Xaml::Controls::Primitives::CommandBarFlyoutCommandBarTemplateSettings* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.CommandBarFlyoutCommandBarTemplateSettings", L"WidthExpansionAnimationStartPosition");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.WidthExpansionAnimationStartPosition();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CommandBarFlyoutCommandBarTemplateSettings_get_WidthExpansionDelta(py::wrapper::Microsoft::UI::Xaml::Controls::Primitives::CommandBarFlyoutCommandBarTemplateSettings* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.CommandBarFlyoutCommandBarTemplateSettings", L"WidthExpansionDelta");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.WidthExpansionDelta();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CommandBarFlyoutCommandBarTemplateSettings_get_WidthExpansionMoreButtonAnimationEndPosition(py::wrapper::Microsoft::UI::Xaml::Controls::Primitives::CommandBarFlyoutCommandBarTemplateSettings* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.CommandBarFlyoutCommandBarTemplateSettings", L"WidthExpansionMoreButtonAnimationEndPosition");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.WidthExpansionMoreButtonAnimationEndPosition();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CommandBarFlyoutCommandBarTemplateSettings_get_WidthExpansionMoreButtonAnimationStartPosition(py::wrapper::Microsoft::UI::Xaml::Controls::Primitives::CommandBarFlyoutCommandBarTemplateSettings* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.CommandBarFlyoutCommandBarTemplateSettings", L"WidthExpansionMoreButtonAnimationStartPosition");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.WidthExpansionMoreButtonAnimationStartPosition();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_CommandBarFlyoutCommandBarTemplateSettings(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Microsoft::UI::Xaml::Controls::Primitives::CommandBarFlyoutCommandBarTemplateSettings>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_CommandBarFlyoutCommandBarTemplateSettings(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Microsoft::UI::Xaml::Controls::Primitives::CommandBarFlyoutCommandBarTemplateSettings>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_CommandBarFlyoutCommandBarTemplateSettings[] = {
        { "_assign_array_", _assign_array_CommandBarFlyoutCommandBarTemplateSettings, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_CommandBarFlyoutCommandBarTemplateSettings), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_CommandBarFlyoutCommandBarTemplateSettings[] = {
        { "close_animation_end_position", reinterpret_cast<getter>(CommandBarFlyoutCommandBarTemplateSettings_get_CloseAnimationEndPosition), nullptr, nullptr, nullptr },
        { "content_clip_rect", reinterpret_cast<getter>(CommandBarFlyoutCommandBarTemplateSettings_get_ContentClipRect), nullptr, nullptr, nullptr },
        { "current_width", reinterpret_cast<getter>(CommandBarFlyoutCommandBarTemplateSettings_get_CurrentWidth), nullptr, nullptr, nullptr },
        { "expand_down_animation_end_position", reinterpret_cast<getter>(CommandBarFlyoutCommandBarTemplateSettings_get_ExpandDownAnimationEndPosition), nullptr, nullptr, nullptr },
        { "expand_down_animation_hold_position", reinterpret_cast<getter>(CommandBarFlyoutCommandBarTemplateSettings_get_ExpandDownAnimationHoldPosition), nullptr, nullptr, nullptr },
        { "expand_down_animation_start_position", reinterpret_cast<getter>(CommandBarFlyoutCommandBarTemplateSettings_get_ExpandDownAnimationStartPosition), nullptr, nullptr, nullptr },
        { "expand_down_overflow_vertical_position", reinterpret_cast<getter>(CommandBarFlyoutCommandBarTemplateSettings_get_ExpandDownOverflowVerticalPosition), nullptr, nullptr, nullptr },
        { "expand_up_animation_end_position", reinterpret_cast<getter>(CommandBarFlyoutCommandBarTemplateSettings_get_ExpandUpAnimationEndPosition), nullptr, nullptr, nullptr },
        { "expand_up_animation_hold_position", reinterpret_cast<getter>(CommandBarFlyoutCommandBarTemplateSettings_get_ExpandUpAnimationHoldPosition), nullptr, nullptr, nullptr },
        { "expand_up_animation_start_position", reinterpret_cast<getter>(CommandBarFlyoutCommandBarTemplateSettings_get_ExpandUpAnimationStartPosition), nullptr, nullptr, nullptr },
        { "expand_up_overflow_vertical_position", reinterpret_cast<getter>(CommandBarFlyoutCommandBarTemplateSettings_get_ExpandUpOverflowVerticalPosition), nullptr, nullptr, nullptr },
        { "expanded_width", reinterpret_cast<getter>(CommandBarFlyoutCommandBarTemplateSettings_get_ExpandedWidth), nullptr, nullptr, nullptr },
        { "open_animation_end_position", reinterpret_cast<getter>(CommandBarFlyoutCommandBarTemplateSettings_get_OpenAnimationEndPosition), nullptr, nullptr, nullptr },
        { "open_animation_start_position", reinterpret_cast<getter>(CommandBarFlyoutCommandBarTemplateSettings_get_OpenAnimationStartPosition), nullptr, nullptr, nullptr },
        { "overflow_content_clip_rect", reinterpret_cast<getter>(CommandBarFlyoutCommandBarTemplateSettings_get_OverflowContentClipRect), nullptr, nullptr, nullptr },
        { "width_expansion_animation_end_position", reinterpret_cast<getter>(CommandBarFlyoutCommandBarTemplateSettings_get_WidthExpansionAnimationEndPosition), nullptr, nullptr, nullptr },
        { "width_expansion_animation_start_position", reinterpret_cast<getter>(CommandBarFlyoutCommandBarTemplateSettings_get_WidthExpansionAnimationStartPosition), nullptr, nullptr, nullptr },
        { "width_expansion_delta", reinterpret_cast<getter>(CommandBarFlyoutCommandBarTemplateSettings_get_WidthExpansionDelta), nullptr, nullptr, nullptr },
        { "width_expansion_more_button_animation_end_position", reinterpret_cast<getter>(CommandBarFlyoutCommandBarTemplateSettings_get_WidthExpansionMoreButtonAnimationEndPosition), nullptr, nullptr, nullptr },
        { "width_expansion_more_button_animation_start_position", reinterpret_cast<getter>(CommandBarFlyoutCommandBarTemplateSettings_get_WidthExpansionMoreButtonAnimationStartPosition), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_CommandBarFlyoutCommandBarTemplateSettings[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_CommandBarFlyoutCommandBarTemplateSettings) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_CommandBarFlyoutCommandBarTemplateSettings) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_CommandBarFlyoutCommandBarTemplateSettings) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_CommandBarFlyoutCommandBarTemplateSettings) },
        { }
    };

    static PyType_Spec type_spec_CommandBarFlyoutCommandBarTemplateSettings = {
        "winrt._winrt_microsoft_ui_xaml_controls_primitives.CommandBarFlyoutCommandBarTemplateSettings",
        sizeof(py::wrapper::Microsoft::UI::Xaml::Controls::Primitives::CommandBarFlyoutCommandBarTemplateSettings),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_CommandBarFlyoutCommandBarTemplateSettings};

    // ----- CommandBarTemplateSettings class --------------------

    static PyObject* _new_CommandBarTemplateSettings(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Microsoft::UI::Xaml::Controls::Primitives::CommandBarTemplateSettings>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Microsoft::UI::Xaml::Controls::Primitives::CommandBarTemplateSettings>::type_name);
        return nullptr;
    }

    static void _dealloc_CommandBarTemplateSettings(py::wrapper::Microsoft::UI::Xaml::Controls::Primitives::CommandBarTemplateSettings* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* CommandBarTemplateSettings_get_ContentHeight(py::wrapper::Microsoft::UI::Xaml::Controls::Primitives::CommandBarTemplateSettings* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.CommandBarTemplateSettings", L"ContentHeight");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.ContentHeight();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CommandBarTemplateSettings_get_EffectiveOverflowButtonVisibility(py::wrapper::Microsoft::UI::Xaml::Controls::Primitives::CommandBarTemplateSettings* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.CommandBarTemplateSettings", L"EffectiveOverflowButtonVisibility");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.EffectiveOverflowButtonVisibility();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CommandBarTemplateSettings_get_NegativeOverflowContentHeight(py::wrapper::Microsoft::UI::Xaml::Controls::Primitives::CommandBarTemplateSettings* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.CommandBarTemplateSettings", L"NegativeOverflowContentHeight");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.NegativeOverflowContentHeight();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CommandBarTemplateSettings_get_OverflowContentClipRect(py::wrapper::Microsoft::UI::Xaml::Controls::Primitives::CommandBarTemplateSettings* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.CommandBarTemplateSettings", L"OverflowContentClipRect");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.OverflowContentClipRect();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CommandBarTemplateSettings_get_OverflowContentCompactYTranslation(py::wrapper::Microsoft::UI::Xaml::Controls::Primitives::CommandBarTemplateSettings* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.CommandBarTemplateSettings", L"OverflowContentCompactYTranslation");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.OverflowContentCompactYTranslation();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CommandBarTemplateSettings_get_OverflowContentHeight(py::wrapper::Microsoft::UI::Xaml::Controls::Primitives::CommandBarTemplateSettings* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.CommandBarTemplateSettings", L"OverflowContentHeight");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.OverflowContentHeight();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CommandBarTemplateSettings_get_OverflowContentHiddenYTranslation(py::wrapper::Microsoft::UI::Xaml::Controls::Primitives::CommandBarTemplateSettings* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.CommandBarTemplateSettings", L"OverflowContentHiddenYTranslation");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.OverflowContentHiddenYTranslation();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CommandBarTemplateSettings_get_OverflowContentHorizontalOffset(py::wrapper::Microsoft::UI::Xaml::Controls::Primitives::CommandBarTemplateSettings* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.CommandBarTemplateSettings", L"OverflowContentHorizontalOffset");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.OverflowContentHorizontalOffset();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CommandBarTemplateSettings_get_OverflowContentMaxHeight(py::wrapper::Microsoft::UI::Xaml::Controls::Primitives::CommandBarTemplateSettings* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.CommandBarTemplateSettings", L"OverflowContentMaxHeight");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.OverflowContentMaxHeight();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CommandBarTemplateSettings_get_OverflowContentMaxWidth(py::wrapper::Microsoft::UI::Xaml::Controls::Primitives::CommandBarTemplateSettings* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.CommandBarTemplateSettings", L"OverflowContentMaxWidth");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.OverflowContentMaxWidth();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CommandBarTemplateSettings_get_OverflowContentMinWidth(py::wrapper::Microsoft::UI::Xaml::Controls::Primitives::CommandBarTemplateSettings* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.CommandBarTemplateSettings", L"OverflowContentMinWidth");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.OverflowContentMinWidth();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CommandBarTemplateSettings_get_OverflowContentMinimalYTranslation(py::wrapper::Microsoft::UI::Xaml::Controls::Primitives::CommandBarTemplateSettings* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.CommandBarTemplateSettings", L"OverflowContentMinimalYTranslation");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.OverflowContentMinimalYTranslation();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_CommandBarTemplateSettings(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Microsoft::UI::Xaml::Controls::Primitives::CommandBarTemplateSettings>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_CommandBarTemplateSettings(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Microsoft::UI::Xaml::Controls::Primitives::CommandBarTemplateSettings>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_CommandBarTemplateSettings[] = {
        { "_assign_array_", _assign_array_CommandBarTemplateSettings, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_CommandBarTemplateSettings), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_CommandBarTemplateSettings[] = {
        { "content_height", reinterpret_cast<getter>(CommandBarTemplateSettings_get_ContentHeight), nullptr, nullptr, nullptr },
        { "effective_overflow_button_visibility", reinterpret_cast<getter>(CommandBarTemplateSettings_get_EffectiveOverflowButtonVisibility), nullptr, nullptr, nullptr },
        { "negative_overflow_content_height", reinterpret_cast<getter>(CommandBarTemplateSettings_get_NegativeOverflowContentHeight), nullptr, nullptr, nullptr },
        { "overflow_content_clip_rect", reinterpret_cast<getter>(CommandBarTemplateSettings_get_OverflowContentClipRect), nullptr, nullptr, nullptr },
        { "overflow_content_compact_y_translation", reinterpret_cast<getter>(CommandBarTemplateSettings_get_OverflowContentCompactYTranslation), nullptr, nullptr, nullptr },
        { "overflow_content_height", reinterpret_cast<getter>(CommandBarTemplateSettings_get_OverflowContentHeight), nullptr, nullptr, nullptr },
        { "overflow_content_hidden_y_translation", reinterpret_cast<getter>(CommandBarTemplateSettings_get_OverflowContentHiddenYTranslation), nullptr, nullptr, nullptr },
        { "overflow_content_horizontal_offset", reinterpret_cast<getter>(CommandBarTemplateSettings_get_OverflowContentHorizontalOffset), nullptr, nullptr, nullptr },
        { "overflow_content_max_height", reinterpret_cast<getter>(CommandBarTemplateSettings_get_OverflowContentMaxHeight), nullptr, nullptr, nullptr },
        { "overflow_content_max_width", reinterpret_cast<getter>(CommandBarTemplateSettings_get_OverflowContentMaxWidth), nullptr, nullptr, nullptr },
        { "overflow_content_min_width", reinterpret_cast<getter>(CommandBarTemplateSettings_get_OverflowContentMinWidth), nullptr, nullptr, nullptr },
        { "overflow_content_minimal_y_translation", reinterpret_cast<getter>(CommandBarTemplateSettings_get_OverflowContentMinimalYTranslation), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_CommandBarTemplateSettings[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_CommandBarTemplateSettings) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_CommandBarTemplateSettings) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_CommandBarTemplateSettings) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_CommandBarTemplateSettings) },
        { }
    };

    static PyType_Spec type_spec_CommandBarTemplateSettings = {
        "winrt._winrt_microsoft_ui_xaml_controls_primitives.CommandBarTemplateSettings",
        sizeof(py::wrapper::Microsoft::UI::Xaml::Controls::Primitives::CommandBarTemplateSettings),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_CommandBarTemplateSettings};

    // ----- CornerRadiusFilterConverter class --------------------

    static PyObject* _new_CornerRadiusFilterConverter(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 0)
        {
            try
            {
                winrt::Microsoft::UI::Xaml::Controls::Primitives::CornerRadiusFilterConverter instance{};
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_CornerRadiusFilterConverter(py::wrapper::Microsoft::UI::Xaml::Controls::Primitives::CornerRadiusFilterConverter* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* CornerRadiusFilterConverter_Convert(py::wrapper::Microsoft::UI::Xaml::Controls::Primitives::CornerRadiusFilterConverter* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 4)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Xaml.Controls.Primitives.CornerRadiusFilterConverter", L"Convert", 4);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(4);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Foundation::IInspectable>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::UI::Xaml::Interop::TypeName>(args, 1);
                auto param2 = py::convert_to<winrt::Windows::Foundation::IInspectable>(args, 2);
                auto param3 = py::convert_to<winrt::hstring>(args, 3);

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return self->obj.Convert(param0, param1, param2, param3);
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* CornerRadiusFilterConverter_ConvertBack(py::wrapper::Microsoft::UI::Xaml::Controls::Primitives::CornerRadiusFilterConverter* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 4)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Xaml.Controls.Primitives.CornerRadiusFilterConverter", L"ConvertBack", 4);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(4);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Foundation::IInspectable>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::UI::Xaml::Interop::TypeName>(args, 1);
                auto param2 = py::convert_to<winrt::Windows::Foundation::IInspectable>(args, 2);
                auto param3 = py::convert_to<winrt::hstring>(args, 3);

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return self->obj.ConvertBack(param0, param1, param2, param3);
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* CornerRadiusFilterConverter_get_Scale(py::wrapper::Microsoft::UI::Xaml::Controls::Primitives::CornerRadiusFilterConverter* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.CornerRadiusFilterConverter", L"Scale");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Scale();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int CornerRadiusFilterConverter_put_Scale(py::wrapper::Microsoft::UI::Xaml::Controls::Primitives::CornerRadiusFilterConverter* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.CornerRadiusFilterConverter", L"Scale");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<double>(arg);

            {
                auto _gil = release_gil();
                self->obj.Scale(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* CornerRadiusFilterConverter_get_Filter(py::wrapper::Microsoft::UI::Xaml::Controls::Primitives::CornerRadiusFilterConverter* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.CornerRadiusFilterConverter", L"Filter");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Filter();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int CornerRadiusFilterConverter_put_Filter(py::wrapper::Microsoft::UI::Xaml::Controls::Primitives::CornerRadiusFilterConverter* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.CornerRadiusFilterConverter", L"Filter");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Microsoft::UI::Xaml::Controls::Primitives::CornerRadiusFilterKind>(arg);

            {
                auto _gil = release_gil();
                self->obj.Filter(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* CornerRadiusFilterConverter_get_FilterProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.CornerRadiusFilterConverter", L"FilterProperty");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return winrt::Microsoft::UI::Xaml::Controls::Primitives::CornerRadiusFilterConverter::FilterProperty();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CornerRadiusFilterConverter_get_ScaleProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.CornerRadiusFilterConverter", L"ScaleProperty");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return winrt::Microsoft::UI::Xaml::Controls::Primitives::CornerRadiusFilterConverter::ScaleProperty();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_CornerRadiusFilterConverter(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Microsoft::UI::Xaml::Controls::Primitives::CornerRadiusFilterConverter>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_CornerRadiusFilterConverter(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Microsoft::UI::Xaml::Controls::Primitives::CornerRadiusFilterConverter>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_CornerRadiusFilterConverter[] = {
        { "convert", reinterpret_cast<PyCFunction>(CornerRadiusFilterConverter_Convert), METH_VARARGS, nullptr },
        { "convert_back", reinterpret_cast<PyCFunction>(CornerRadiusFilterConverter_ConvertBack), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_CornerRadiusFilterConverter, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_CornerRadiusFilterConverter), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_CornerRadiusFilterConverter[] = {
        { "scale", reinterpret_cast<getter>(CornerRadiusFilterConverter_get_Scale), reinterpret_cast<setter>(CornerRadiusFilterConverter_put_Scale), nullptr, nullptr },
        { "filter", reinterpret_cast<getter>(CornerRadiusFilterConverter_get_Filter), reinterpret_cast<setter>(CornerRadiusFilterConverter_put_Filter), nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_CornerRadiusFilterConverter[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_CornerRadiusFilterConverter) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_CornerRadiusFilterConverter) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_CornerRadiusFilterConverter) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_CornerRadiusFilterConverter) },
        { }
    };

    static PyType_Spec type_spec_CornerRadiusFilterConverter = {
        "winrt._winrt_microsoft_ui_xaml_controls_primitives.CornerRadiusFilterConverter",
        sizeof(py::wrapper::Microsoft::UI::Xaml::Controls::Primitives::CornerRadiusFilterConverter),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_CornerRadiusFilterConverter};

    static PyGetSetDef getset_CornerRadiusFilterConverter_Static[] = {
        { "filter_property", reinterpret_cast<getter>(CornerRadiusFilterConverter_get_FilterProperty), nullptr, nullptr, nullptr },
        { "scale_property", reinterpret_cast<getter>(CornerRadiusFilterConverter_get_ScaleProperty), nullptr, nullptr, nullptr },
        { }
    };

    static PyMethodDef methods_CornerRadiusFilterConverter_Static[] = {
        { }
    };

    static PyType_Slot type_slots_CornerRadiusFilterConverter_Static[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_CornerRadiusFilterConverter_Static) },
        { Py_tp_methods, reinterpret_cast<void*>(methods_CornerRadiusFilterConverter_Static) },
        { }
    };

    static PyType_Spec type_spec_CornerRadiusFilterConverter_Static =
    {
        "winrt._winrt_microsoft_ui_xaml_controls_primitives.CornerRadiusFilterConverter_Static",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT,
        type_slots_CornerRadiusFilterConverter_Static
    };

    // ----- CornerRadiusToThicknessConverter class --------------------

    static PyObject* _new_CornerRadiusToThicknessConverter(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 0)
        {
            try
            {
                winrt::Microsoft::UI::Xaml::Controls::Primitives::CornerRadiusToThicknessConverter instance{};
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_CornerRadiusToThicknessConverter(py::wrapper::Microsoft::UI::Xaml::Controls::Primitives::CornerRadiusToThicknessConverter* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* CornerRadiusToThicknessConverter_Convert(py::wrapper::Microsoft::UI::Xaml::Controls::Primitives::CornerRadiusToThicknessConverter* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 4)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Xaml.Controls.Primitives.CornerRadiusToThicknessConverter", L"Convert", 4);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(4);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Foundation::IInspectable>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::UI::Xaml::Interop::TypeName>(args, 1);
                auto param2 = py::convert_to<winrt::Windows::Foundation::IInspectable>(args, 2);
                auto param3 = py::convert_to<winrt::hstring>(args, 3);

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return self->obj.Convert(param0, param1, param2, param3);
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* CornerRadiusToThicknessConverter_ConvertBack(py::wrapper::Microsoft::UI::Xaml::Controls::Primitives::CornerRadiusToThicknessConverter* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 4)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Xaml.Controls.Primitives.CornerRadiusToThicknessConverter", L"ConvertBack", 4);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(4);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Foundation::IInspectable>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::UI::Xaml::Interop::TypeName>(args, 1);
                auto param2 = py::convert_to<winrt::Windows::Foundation::IInspectable>(args, 2);
                auto param3 = py::convert_to<winrt::hstring>(args, 3);

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return self->obj.ConvertBack(param0, param1, param2, param3);
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* CornerRadiusToThicknessConverter_get_Multiplier(py::wrapper::Microsoft::UI::Xaml::Controls::Primitives::CornerRadiusToThicknessConverter* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.CornerRadiusToThicknessConverter", L"Multiplier");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Multiplier();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int CornerRadiusToThicknessConverter_put_Multiplier(py::wrapper::Microsoft::UI::Xaml::Controls::Primitives::CornerRadiusToThicknessConverter* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.CornerRadiusToThicknessConverter", L"Multiplier");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<double>(arg);

            {
                auto _gil = release_gil();
                self->obj.Multiplier(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* CornerRadiusToThicknessConverter_get_ConversionKind(py::wrapper::Microsoft::UI::Xaml::Controls::Primitives::CornerRadiusToThicknessConverter* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.CornerRadiusToThicknessConverter", L"ConversionKind");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.ConversionKind();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int CornerRadiusToThicknessConverter_put_ConversionKind(py::wrapper::Microsoft::UI::Xaml::Controls::Primitives::CornerRadiusToThicknessConverter* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.CornerRadiusToThicknessConverter", L"ConversionKind");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Microsoft::UI::Xaml::Controls::Primitives::CornerRadiusToThicknessConverterKind>(arg);

            {
                auto _gil = release_gil();
                self->obj.ConversionKind(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* CornerRadiusToThicknessConverter_get_ConversionKindProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.CornerRadiusToThicknessConverter", L"ConversionKindProperty");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return winrt::Microsoft::UI::Xaml::Controls::Primitives::CornerRadiusToThicknessConverter::ConversionKindProperty();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CornerRadiusToThicknessConverter_get_MultiplierProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.CornerRadiusToThicknessConverter", L"MultiplierProperty");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return winrt::Microsoft::UI::Xaml::Controls::Primitives::CornerRadiusToThicknessConverter::MultiplierProperty();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_CornerRadiusToThicknessConverter(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Microsoft::UI::Xaml::Controls::Primitives::CornerRadiusToThicknessConverter>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_CornerRadiusToThicknessConverter(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Microsoft::UI::Xaml::Controls::Primitives::CornerRadiusToThicknessConverter>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_CornerRadiusToThicknessConverter[] = {
        { "convert", reinterpret_cast<PyCFunction>(CornerRadiusToThicknessConverter_Convert), METH_VARARGS, nullptr },
        { "convert_back", reinterpret_cast<PyCFunction>(CornerRadiusToThicknessConverter_ConvertBack), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_CornerRadiusToThicknessConverter, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_CornerRadiusToThicknessConverter), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_CornerRadiusToThicknessConverter[] = {
        { "multiplier", reinterpret_cast<getter>(CornerRadiusToThicknessConverter_get_Multiplier), reinterpret_cast<setter>(CornerRadiusToThicknessConverter_put_Multiplier), nullptr, nullptr },
        { "conversion_kind", reinterpret_cast<getter>(CornerRadiusToThicknessConverter_get_ConversionKind), reinterpret_cast<setter>(CornerRadiusToThicknessConverter_put_ConversionKind), nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_CornerRadiusToThicknessConverter[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_CornerRadiusToThicknessConverter) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_CornerRadiusToThicknessConverter) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_CornerRadiusToThicknessConverter) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_CornerRadiusToThicknessConverter) },
        { }
    };

    static PyType_Spec type_spec_CornerRadiusToThicknessConverter = {
        "winrt._winrt_microsoft_ui_xaml_controls_primitives.CornerRadiusToThicknessConverter",
        sizeof(py::wrapper::Microsoft::UI::Xaml::Controls::Primitives::CornerRadiusToThicknessConverter),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_CornerRadiusToThicknessConverter};

    static PyGetSetDef getset_CornerRadiusToThicknessConverter_Static[] = {
        { "conversion_kind_property", reinterpret_cast<getter>(CornerRadiusToThicknessConverter_get_ConversionKindProperty), nullptr, nullptr, nullptr },
        { "multiplier_property", reinterpret_cast<getter>(CornerRadiusToThicknessConverter_get_MultiplierProperty), nullptr, nullptr, nullptr },
        { }
    };

    static PyMethodDef methods_CornerRadiusToThicknessConverter_Static[] = {
        { }
    };

    static PyType_Slot type_slots_CornerRadiusToThicknessConverter_Static[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_CornerRadiusToThicknessConverter_Static) },
        { Py_tp_methods, reinterpret_cast<void*>(methods_CornerRadiusToThicknessConverter_Static) },
        { }
    };

    static PyType_Spec type_spec_CornerRadiusToThicknessConverter_Static =
    {
        "winrt._winrt_microsoft_ui_xaml_controls_primitives.CornerRadiusToThicknessConverter_Static",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT,
        type_slots_CornerRadiusToThicknessConverter_Static
    };

    // ----- DragCompletedEventArgs class --------------------

    struct PyWinrtDragCompletedEventArgs;
    using BasePyWinrtDragCompletedEventArgs = winrt::Microsoft::UI::Xaml::Controls::Primitives::DragCompletedEventArgsT<PyWinrtDragCompletedEventArgs, py::IPywinrtObject>;

    struct PyWinrtDragCompletedEventArgs : py::py_obj_ref, BasePyWinrtDragCompletedEventArgs
    {
        PyWinrtDragCompletedEventArgs(PyObject* py_obj, double horizontalChange, double verticalChange, bool canceled) : py::py_obj_ref(py_obj), BasePyWinrtDragCompletedEventArgs(horizontalChange, verticalChange, canceled) {}

        int32_t __stdcall GetPyObject(PyObject*& obj) override
        {
            obj = py::py_obj_ref::get_py_obj();
            return 0;
        }

        int32_t __stdcall GetComposableInner(winrt::Windows::Foundation::IInspectable& inner) override
        {
            inner = m_inner;
            return winrt::impl::error_ok;
        }

        static void toggle_reference(PyWinrtDragCompletedEventArgs* instance, bool is_last_reference)
        {
            py::py_obj_ref::toggle_reference(instance, is_last_reference);
        }

        int32_t query_interface_tearoff(winrt::guid const& id, void** result) const noexcept override
        {
            return py::py_obj_ref::query_interface_tearoff(id, result);
        }
    };

    static PyObject* _new_DragCompletedEventArgs(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);

        auto self_type = get_python_type_for<winrt::Microsoft::UI::Xaml::Controls::Primitives::DragCompletedEventArgs>();
        if (!self_type)
        {
            return nullptr;
        }

        if (arg_count == 3)
        {
            try
            {
                auto param0 = py::convert_to<double>(args, 0);
                auto param1 = py::convert_to<double>(args, 1);
                auto param2 = py::convert_to<bool>(args, 2);

                if (type != self_type)
                {
                    py::pyobj_handle self{type->tp_alloc(type, 0)};
                    if (!self)
                    {
                        return nullptr;
                    }

                    std::construct_at(&reinterpret_cast<py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>*>(self.get())->obj, nullptr);

                    auto obj_impl = winrt::make_self<PyWinrtDragCompletedEventArgs>(self.get(), param0, param1, param2);

                    auto obj = py::make_py_obj<PyWinrtDragCompletedEventArgs>(obj_impl, type, self.get());
                    if (!obj)
                    {
                        return nullptr;
                    }

                    reinterpret_cast<py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>*>(self.get())->obj = std::move(obj);

                    return self.detach();
                }

                winrt::Microsoft::UI::Xaml::Controls::Primitives::DragCompletedEventArgs instance{param0, param1, param2};
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_DragCompletedEventArgs(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* DragCompletedEventArgs_get_Canceled(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.DragCompletedEventArgs", L"Canceled");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::Primitives::DragCompletedEventArgs>().Canceled();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* DragCompletedEventArgs_get_HorizontalChange(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.DragCompletedEventArgs", L"HorizontalChange");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::Primitives::DragCompletedEventArgs>().HorizontalChange();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* DragCompletedEventArgs_get_VerticalChange(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.DragCompletedEventArgs", L"VerticalChange");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::Primitives::DragCompletedEventArgs>().VerticalChange();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_DragCompletedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Microsoft::UI::Xaml::Controls::Primitives::DragCompletedEventArgs>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_DragCompletedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Microsoft::UI::Xaml::Controls::Primitives::DragCompletedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_DragCompletedEventArgs[] = {
        { "_assign_array_", _assign_array_DragCompletedEventArgs, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_DragCompletedEventArgs), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_DragCompletedEventArgs[] = {
        { "canceled", reinterpret_cast<getter>(DragCompletedEventArgs_get_Canceled), nullptr, nullptr, nullptr },
        { "horizontal_change", reinterpret_cast<getter>(DragCompletedEventArgs_get_HorizontalChange), nullptr, nullptr, nullptr },
        { "vertical_change", reinterpret_cast<getter>(DragCompletedEventArgs_get_VerticalChange), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_DragCompletedEventArgs[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_DragCompletedEventArgs) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_DragCompletedEventArgs) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_DragCompletedEventArgs) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_DragCompletedEventArgs) },
        { }
    };

    static PyType_Spec type_spec_DragCompletedEventArgs = {
        "winrt._winrt_microsoft_ui_xaml_controls_primitives.DragCompletedEventArgs",
        sizeof(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>),
        0,
        Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,
        _type_slots_DragCompletedEventArgs};

    static PyGetSetDef getset_DragCompletedEventArgs_Static[] = {
        { }
    };

    static PyMethodDef methods_DragCompletedEventArgs_Static[] = {
        { }
    };

    static PyType_Slot type_slots_DragCompletedEventArgs_Static[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_DragCompletedEventArgs_Static) },
        { Py_tp_methods, reinterpret_cast<void*>(methods_DragCompletedEventArgs_Static) },
        { }
    };

    static PyType_Spec type_spec_DragCompletedEventArgs_Static =
    {
        "winrt._winrt_microsoft_ui_xaml_controls_primitives.DragCompletedEventArgs_Static",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,
        type_slots_DragCompletedEventArgs_Static
    };

    // ----- DragDeltaEventArgs class --------------------

    struct PyWinrtDragDeltaEventArgs;
    using BasePyWinrtDragDeltaEventArgs = winrt::Microsoft::UI::Xaml::Controls::Primitives::DragDeltaEventArgsT<PyWinrtDragDeltaEventArgs, py::IPywinrtObject>;

    struct PyWinrtDragDeltaEventArgs : py::py_obj_ref, BasePyWinrtDragDeltaEventArgs
    {
        PyWinrtDragDeltaEventArgs(PyObject* py_obj, double horizontalChange, double verticalChange) : py::py_obj_ref(py_obj), BasePyWinrtDragDeltaEventArgs(horizontalChange, verticalChange) {}

        int32_t __stdcall GetPyObject(PyObject*& obj) override
        {
            obj = py::py_obj_ref::get_py_obj();
            return 0;
        }

        int32_t __stdcall GetComposableInner(winrt::Windows::Foundation::IInspectable& inner) override
        {
            inner = m_inner;
            return winrt::impl::error_ok;
        }

        static void toggle_reference(PyWinrtDragDeltaEventArgs* instance, bool is_last_reference)
        {
            py::py_obj_ref::toggle_reference(instance, is_last_reference);
        }

        int32_t query_interface_tearoff(winrt::guid const& id, void** result) const noexcept override
        {
            return py::py_obj_ref::query_interface_tearoff(id, result);
        }
    };

    static PyObject* _new_DragDeltaEventArgs(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);

        auto self_type = get_python_type_for<winrt::Microsoft::UI::Xaml::Controls::Primitives::DragDeltaEventArgs>();
        if (!self_type)
        {
            return nullptr;
        }

        if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<double>(args, 0);
                auto param1 = py::convert_to<double>(args, 1);

                if (type != self_type)
                {
                    py::pyobj_handle self{type->tp_alloc(type, 0)};
                    if (!self)
                    {
                        return nullptr;
                    }

                    std::construct_at(&reinterpret_cast<py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>*>(self.get())->obj, nullptr);

                    auto obj_impl = winrt::make_self<PyWinrtDragDeltaEventArgs>(self.get(), param0, param1);

                    auto obj = py::make_py_obj<PyWinrtDragDeltaEventArgs>(obj_impl, type, self.get());
                    if (!obj)
                    {
                        return nullptr;
                    }

                    reinterpret_cast<py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>*>(self.get())->obj = std::move(obj);

                    return self.detach();
                }

                winrt::Microsoft::UI::Xaml::Controls::Primitives::DragDeltaEventArgs instance{param0, param1};
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_DragDeltaEventArgs(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* DragDeltaEventArgs_get_HorizontalChange(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.DragDeltaEventArgs", L"HorizontalChange");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::Primitives::DragDeltaEventArgs>().HorizontalChange();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* DragDeltaEventArgs_get_VerticalChange(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.DragDeltaEventArgs", L"VerticalChange");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::Primitives::DragDeltaEventArgs>().VerticalChange();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_DragDeltaEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Microsoft::UI::Xaml::Controls::Primitives::DragDeltaEventArgs>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_DragDeltaEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Microsoft::UI::Xaml::Controls::Primitives::DragDeltaEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_DragDeltaEventArgs[] = {
        { "_assign_array_", _assign_array_DragDeltaEventArgs, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_DragDeltaEventArgs), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_DragDeltaEventArgs[] = {
        { "horizontal_change", reinterpret_cast<getter>(DragDeltaEventArgs_get_HorizontalChange), nullptr, nullptr, nullptr },
        { "vertical_change", reinterpret_cast<getter>(DragDeltaEventArgs_get_VerticalChange), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_DragDeltaEventArgs[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_DragDeltaEventArgs) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_DragDeltaEventArgs) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_DragDeltaEventArgs) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_DragDeltaEventArgs) },
        { }
    };

    static PyType_Spec type_spec_DragDeltaEventArgs = {
        "winrt._winrt_microsoft_ui_xaml_controls_primitives.DragDeltaEventArgs",
        sizeof(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>),
        0,
        Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,
        _type_slots_DragDeltaEventArgs};

    static PyGetSetDef getset_DragDeltaEventArgs_Static[] = {
        { }
    };

    static PyMethodDef methods_DragDeltaEventArgs_Static[] = {
        { }
    };

    static PyType_Slot type_slots_DragDeltaEventArgs_Static[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_DragDeltaEventArgs_Static) },
        { Py_tp_methods, reinterpret_cast<void*>(methods_DragDeltaEventArgs_Static) },
        { }
    };

    static PyType_Spec type_spec_DragDeltaEventArgs_Static =
    {
        "winrt._winrt_microsoft_ui_xaml_controls_primitives.DragDeltaEventArgs_Static",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,
        type_slots_DragDeltaEventArgs_Static
    };

    // ----- DragStartedEventArgs class --------------------

    struct PyWinrtDragStartedEventArgs;
    using BasePyWinrtDragStartedEventArgs = winrt::Microsoft::UI::Xaml::Controls::Primitives::DragStartedEventArgsT<PyWinrtDragStartedEventArgs, py::IPywinrtObject>;

    struct PyWinrtDragStartedEventArgs : py::py_obj_ref, BasePyWinrtDragStartedEventArgs
    {
        PyWinrtDragStartedEventArgs(PyObject* py_obj, double horizontalOffset, double verticalOffset) : py::py_obj_ref(py_obj), BasePyWinrtDragStartedEventArgs(horizontalOffset, verticalOffset) {}

        int32_t __stdcall GetPyObject(PyObject*& obj) override
        {
            obj = py::py_obj_ref::get_py_obj();
            return 0;
        }

        int32_t __stdcall GetComposableInner(winrt::Windows::Foundation::IInspectable& inner) override
        {
            inner = m_inner;
            return winrt::impl::error_ok;
        }

        static void toggle_reference(PyWinrtDragStartedEventArgs* instance, bool is_last_reference)
        {
            py::py_obj_ref::toggle_reference(instance, is_last_reference);
        }

        int32_t query_interface_tearoff(winrt::guid const& id, void** result) const noexcept override
        {
            return py::py_obj_ref::query_interface_tearoff(id, result);
        }
    };

    static PyObject* _new_DragStartedEventArgs(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);

        auto self_type = get_python_type_for<winrt::Microsoft::UI::Xaml::Controls::Primitives::DragStartedEventArgs>();
        if (!self_type)
        {
            return nullptr;
        }

        if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<double>(args, 0);
                auto param1 = py::convert_to<double>(args, 1);

                if (type != self_type)
                {
                    py::pyobj_handle self{type->tp_alloc(type, 0)};
                    if (!self)
                    {
                        return nullptr;
                    }

                    std::construct_at(&reinterpret_cast<py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>*>(self.get())->obj, nullptr);

                    auto obj_impl = winrt::make_self<PyWinrtDragStartedEventArgs>(self.get(), param0, param1);

                    auto obj = py::make_py_obj<PyWinrtDragStartedEventArgs>(obj_impl, type, self.get());
                    if (!obj)
                    {
                        return nullptr;
                    }

                    reinterpret_cast<py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>*>(self.get())->obj = std::move(obj);

                    return self.detach();
                }

                winrt::Microsoft::UI::Xaml::Controls::Primitives::DragStartedEventArgs instance{param0, param1};
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_DragStartedEventArgs(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* DragStartedEventArgs_get_HorizontalOffset(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.DragStartedEventArgs", L"HorizontalOffset");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::Primitives::DragStartedEventArgs>().HorizontalOffset();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* DragStartedEventArgs_get_VerticalOffset(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.DragStartedEventArgs", L"VerticalOffset");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::Primitives::DragStartedEventArgs>().VerticalOffset();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_DragStartedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Microsoft::UI::Xaml::Controls::Primitives::DragStartedEventArgs>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_DragStartedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Microsoft::UI::Xaml::Controls::Primitives::DragStartedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_DragStartedEventArgs[] = {
        { "_assign_array_", _assign_array_DragStartedEventArgs, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_DragStartedEventArgs), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_DragStartedEventArgs[] = {
        { "horizontal_offset", reinterpret_cast<getter>(DragStartedEventArgs_get_HorizontalOffset), nullptr, nullptr, nullptr },
        { "vertical_offset", reinterpret_cast<getter>(DragStartedEventArgs_get_VerticalOffset), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_DragStartedEventArgs[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_DragStartedEventArgs) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_DragStartedEventArgs) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_DragStartedEventArgs) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_DragStartedEventArgs) },
        { }
    };

    static PyType_Spec type_spec_DragStartedEventArgs = {
        "winrt._winrt_microsoft_ui_xaml_controls_primitives.DragStartedEventArgs",
        sizeof(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>),
        0,
        Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,
        _type_slots_DragStartedEventArgs};

    static PyGetSetDef getset_DragStartedEventArgs_Static[] = {
        { }
    };

    static PyMethodDef methods_DragStartedEventArgs_Static[] = {
        { }
    };

    static PyType_Slot type_slots_DragStartedEventArgs_Static[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_DragStartedEventArgs_Static) },
        { Py_tp_methods, reinterpret_cast<void*>(methods_DragStartedEventArgs_Static) },
        { }
    };

    static PyType_Spec type_spec_DragStartedEventArgs_Static =
    {
        "winrt._winrt_microsoft_ui_xaml_controls_primitives.DragStartedEventArgs_Static",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,
        type_slots_DragStartedEventArgs_Static
    };

    // ----- FlyoutBase class --------------------

    struct PyWinrtFlyoutBase;
    using BasePyWinrtFlyoutBase = winrt::Microsoft::UI::Xaml::Controls::Primitives::FlyoutBaseT<PyWinrtFlyoutBase, py::IPywinrtObject>;

    struct PyWinrtFlyoutBase : py::py_obj_ref, BasePyWinrtFlyoutBase
    {

        int32_t __stdcall GetPyObject(PyObject*& obj) override
        {
            obj = py::py_obj_ref::get_py_obj();
            return 0;
        }

        int32_t __stdcall GetComposableInner(winrt::Windows::Foundation::IInspectable& inner) override
        {
            inner = m_inner;
            return winrt::impl::error_ok;
        }

        static void toggle_reference(PyWinrtFlyoutBase* instance, bool is_last_reference)
        {
            py::py_obj_ref::toggle_reference(instance, is_last_reference);
        }

        int32_t query_interface_tearoff(winrt::guid const& id, void** result) const noexcept override
        {
            return py::py_obj_ref::query_interface_tearoff(id, result);
        }

        winrt::Microsoft::UI::Xaml::Controls::Control CreatePresenter()
        {
            auto gil = py::ensure_gil();

            try
            {
                py::pyobj_handle self{get_py_obj()};

                py::pyobj_handle method{PyObject_GetAttrString(self.get(), "_create_presenter")};
                if (!method)
                {
                    throw python_exception();
                }

                py::pyobj_handle return_value{PyObject_CallNoArgs(method.get())};
                if (!return_value)
                {
                    throw python_exception();
                }

                return py::convert_to<winrt::Microsoft::UI::Xaml::Controls::Control>(return_value.get());
            }
            catch (python_exception)
            {
                py::write_unraisable_and_throw();
            }
        }

        void OnProcessKeyboardAccelerators(winrt::Microsoft::UI::Xaml::Input::ProcessKeyboardAcceleratorEventArgs const& param0)
        {
            auto gil = py::ensure_gil();

            try
            {
                py::pyobj_handle self{get_py_obj()};

                py::pyobj_handle method{PyObject_GetAttrString(self.get(), "_on_process_keyboard_accelerators")};
                if (!method)
                {
                    throw python_exception();
                }

                py::pyobj_handle py_param0{py::convert(param0)};
                if (!py_param0)
                {
                    throw python_exception();
                }

                py::pyobj_handle return_value{PyObject_CallOneArg(method.get(), py_param0.get())};
                if (!return_value)
                {
                    throw python_exception();
                }
            }
            catch (python_exception)
            {
                py::write_unraisable_and_throw();
            }
        }
    };

    static PyObject* _new_FlyoutBase(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Microsoft::UI::Xaml::Controls::Primitives::FlyoutBase>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Microsoft::UI::Xaml::Controls::Primitives::FlyoutBase>::type_name);
        return nullptr;
    }

    static void _dealloc_FlyoutBase(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* FlyoutBase_CreatePresenter(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Xaml.Controls.Primitives.FlyoutBase", L"CreatePresenter", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return py::get_inner_or_self(self->obj).try_as<winrt::Microsoft::UI::Xaml::Controls::Primitives::IFlyoutBaseOverrides>().CreatePresenter();
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* FlyoutBase_GetAttachedFlyout(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Xaml.Controls.Primitives.FlyoutBase", L"GetAttachedFlyout", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Microsoft::UI::Xaml::FrameworkElement>(args, 0);

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return winrt::Microsoft::UI::Xaml::Controls::Primitives::FlyoutBase::GetAttachedFlyout(param0);
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* FlyoutBase_Hide(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Xaml.Controls.Primitives.FlyoutBase", L"Hide", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                {
                    auto _gil = release_gil();
                    self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::Primitives::FlyoutBase>().Hide();
                }

                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* FlyoutBase_OnProcessKeyboardAccelerators(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Xaml.Controls.Primitives.FlyoutBase", L"OnProcessKeyboardAccelerators", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Microsoft::UI::Xaml::Input::ProcessKeyboardAcceleratorEventArgs>(args, 0);

                {
                    auto _gil = release_gil();
                    py::get_inner_or_self(self->obj).try_as<winrt::Microsoft::UI::Xaml::Controls::Primitives::IFlyoutBaseOverrides>().OnProcessKeyboardAccelerators(param0);
                }

                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* FlyoutBase_SetAttachedFlyout(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Xaml.Controls.Primitives.FlyoutBase", L"SetAttachedFlyout", 2);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(2);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Microsoft::UI::Xaml::FrameworkElement>(args, 0);
                auto param1 = py::convert_to<winrt::Microsoft::UI::Xaml::Controls::Primitives::FlyoutBase>(args, 1);

                {
                    auto _gil = release_gil();
                    winrt::Microsoft::UI::Xaml::Controls::Primitives::FlyoutBase::SetAttachedFlyout(param0, param1);
                }

                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* FlyoutBase_ShowAt(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Xaml.Controls.Primitives.FlyoutBase", L"ShowAt", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Microsoft::UI::Xaml::FrameworkElement>(args, 0);

                {
                    auto _gil = release_gil();
                    self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::Primitives::FlyoutBase>().ShowAt(param0);
                }

                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* FlyoutBase_ShowAtWithOptions(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Xaml.Controls.Primitives.FlyoutBase", L"ShowAt", 2);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(2);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Microsoft::UI::Xaml::DependencyObject>(args, 0);
                auto param1 = py::convert_to<winrt::Microsoft::UI::Xaml::Controls::Primitives::FlyoutShowOptions>(args, 1);

                {
                    auto _gil = release_gil();
                    self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::Primitives::FlyoutBase>().ShowAt(param0, param1);
                }

                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* FlyoutBase_ShowAttachedFlyout(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Xaml.Controls.Primitives.FlyoutBase", L"ShowAttachedFlyout", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Microsoft::UI::Xaml::FrameworkElement>(args, 0);

                {
                    auto _gil = release_gil();
                    winrt::Microsoft::UI::Xaml::Controls::Primitives::FlyoutBase::ShowAttachedFlyout(param0);
                }

                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* FlyoutBase_TryInvokeKeyboardAccelerator(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Xaml.Controls.Primitives.FlyoutBase", L"TryInvokeKeyboardAccelerator", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Microsoft::UI::Xaml::Input::ProcessKeyboardAcceleratorEventArgs>(args, 0);

                {
                    auto _gil = release_gil();
                    self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::Primitives::FlyoutBase>().TryInvokeKeyboardAccelerator(param0);
                }

                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* FlyoutBase_get_XamlRoot(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.FlyoutBase", L"XamlRoot");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::Primitives::FlyoutBase>().XamlRoot();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int FlyoutBase_put_XamlRoot(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.FlyoutBase", L"XamlRoot");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Microsoft::UI::Xaml::XamlRoot>(arg);

            {
                auto _gil = release_gil();
                self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::Primitives::FlyoutBase>().XamlRoot(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* FlyoutBase_get_ShowMode(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.FlyoutBase", L"ShowMode");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::Primitives::FlyoutBase>().ShowMode();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int FlyoutBase_put_ShowMode(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.FlyoutBase", L"ShowMode");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Microsoft::UI::Xaml::Controls::Primitives::FlyoutShowMode>(arg);

            {
                auto _gil = release_gil();
                self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::Primitives::FlyoutBase>().ShowMode(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* FlyoutBase_get_ShouldConstrainToRootBounds(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.FlyoutBase", L"ShouldConstrainToRootBounds");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::Primitives::FlyoutBase>().ShouldConstrainToRootBounds();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int FlyoutBase_put_ShouldConstrainToRootBounds(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.FlyoutBase", L"ShouldConstrainToRootBounds");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<bool>(arg);

            {
                auto _gil = release_gil();
                self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::Primitives::FlyoutBase>().ShouldConstrainToRootBounds(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* FlyoutBase_get_Placement(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.FlyoutBase", L"Placement");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::Primitives::FlyoutBase>().Placement();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int FlyoutBase_put_Placement(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.FlyoutBase", L"Placement");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Microsoft::UI::Xaml::Controls::Primitives::FlyoutPlacementMode>(arg);

            {
                auto _gil = release_gil();
                self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::Primitives::FlyoutBase>().Placement(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* FlyoutBase_get_OverlayInputPassThroughElement(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.FlyoutBase", L"OverlayInputPassThroughElement");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::Primitives::FlyoutBase>().OverlayInputPassThroughElement();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int FlyoutBase_put_OverlayInputPassThroughElement(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.FlyoutBase", L"OverlayInputPassThroughElement");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Microsoft::UI::Xaml::DependencyObject>(arg);

            {
                auto _gil = release_gil();
                self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::Primitives::FlyoutBase>().OverlayInputPassThroughElement(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* FlyoutBase_get_LightDismissOverlayMode(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.FlyoutBase", L"LightDismissOverlayMode");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::Primitives::FlyoutBase>().LightDismissOverlayMode();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int FlyoutBase_put_LightDismissOverlayMode(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.FlyoutBase", L"LightDismissOverlayMode");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Microsoft::UI::Xaml::Controls::LightDismissOverlayMode>(arg);

            {
                auto _gil = release_gil();
                self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::Primitives::FlyoutBase>().LightDismissOverlayMode(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* FlyoutBase_get_ElementSoundMode(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.FlyoutBase", L"ElementSoundMode");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::Primitives::FlyoutBase>().ElementSoundMode();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int FlyoutBase_put_ElementSoundMode(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.FlyoutBase", L"ElementSoundMode");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Microsoft::UI::Xaml::ElementSoundMode>(arg);

            {
                auto _gil = release_gil();
                self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::Primitives::FlyoutBase>().ElementSoundMode(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* FlyoutBase_get_AreOpenCloseAnimationsEnabled(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.FlyoutBase", L"AreOpenCloseAnimationsEnabled");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::Primitives::FlyoutBase>().AreOpenCloseAnimationsEnabled();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int FlyoutBase_put_AreOpenCloseAnimationsEnabled(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.FlyoutBase", L"AreOpenCloseAnimationsEnabled");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<bool>(arg);

            {
                auto _gil = release_gil();
                self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::Primitives::FlyoutBase>().AreOpenCloseAnimationsEnabled(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* FlyoutBase_get_AllowFocusWhenDisabled(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.FlyoutBase", L"AllowFocusWhenDisabled");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::Primitives::FlyoutBase>().AllowFocusWhenDisabled();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int FlyoutBase_put_AllowFocusWhenDisabled(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.FlyoutBase", L"AllowFocusWhenDisabled");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<bool>(arg);

            {
                auto _gil = release_gil();
                self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::Primitives::FlyoutBase>().AllowFocusWhenDisabled(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* FlyoutBase_get_AllowFocusOnInteraction(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.FlyoutBase", L"AllowFocusOnInteraction");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::Primitives::FlyoutBase>().AllowFocusOnInteraction();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int FlyoutBase_put_AllowFocusOnInteraction(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.FlyoutBase", L"AllowFocusOnInteraction");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<bool>(arg);

            {
                auto _gil = release_gil();
                self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::Primitives::FlyoutBase>().AllowFocusOnInteraction(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* FlyoutBase_get_InputDevicePrefersPrimaryCommands(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.FlyoutBase", L"InputDevicePrefersPrimaryCommands");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::Primitives::FlyoutBase>().InputDevicePrefersPrimaryCommands();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* FlyoutBase_get_IsConstrainedToRootBounds(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.FlyoutBase", L"IsConstrainedToRootBounds");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::Primitives::FlyoutBase>().IsConstrainedToRootBounds();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* FlyoutBase_get_IsOpen(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.FlyoutBase", L"IsOpen");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::Primitives::FlyoutBase>().IsOpen();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* FlyoutBase_get_Target(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.FlyoutBase", L"Target");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::Primitives::FlyoutBase>().Target();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* FlyoutBase_get_SystemBackdrop(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.FlyoutBase", L"SystemBackdrop");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::Primitives::FlyoutBase>().SystemBackdrop();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int FlyoutBase_put_SystemBackdrop(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.FlyoutBase", L"SystemBackdrop");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Microsoft::UI::Xaml::Media::SystemBackdrop>(arg);

            {
                auto _gil = release_gil();
                self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::Primitives::FlyoutBase>().SystemBackdrop(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* FlyoutBase_get_AllowFocusOnInteractionProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.FlyoutBase", L"AllowFocusOnInteractionProperty");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return winrt::Microsoft::UI::Xaml::Controls::Primitives::FlyoutBase::AllowFocusOnInteractionProperty();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* FlyoutBase_get_AllowFocusWhenDisabledProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.FlyoutBase", L"AllowFocusWhenDisabledProperty");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return winrt::Microsoft::UI::Xaml::Controls::Primitives::FlyoutBase::AllowFocusWhenDisabledProperty();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* FlyoutBase_get_AreOpenCloseAnimationsEnabledProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.FlyoutBase", L"AreOpenCloseAnimationsEnabledProperty");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return winrt::Microsoft::UI::Xaml::Controls::Primitives::FlyoutBase::AreOpenCloseAnimationsEnabledProperty();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* FlyoutBase_get_AttachedFlyoutProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.FlyoutBase", L"AttachedFlyoutProperty");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return winrt::Microsoft::UI::Xaml::Controls::Primitives::FlyoutBase::AttachedFlyoutProperty();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* FlyoutBase_get_ElementSoundModeProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.FlyoutBase", L"ElementSoundModeProperty");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return winrt::Microsoft::UI::Xaml::Controls::Primitives::FlyoutBase::ElementSoundModeProperty();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* FlyoutBase_get_InputDevicePrefersPrimaryCommandsProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.FlyoutBase", L"InputDevicePrefersPrimaryCommandsProperty");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return winrt::Microsoft::UI::Xaml::Controls::Primitives::FlyoutBase::InputDevicePrefersPrimaryCommandsProperty();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* FlyoutBase_get_IsOpenProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.FlyoutBase", L"IsOpenProperty");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return winrt::Microsoft::UI::Xaml::Controls::Primitives::FlyoutBase::IsOpenProperty();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* FlyoutBase_get_LightDismissOverlayModeProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.FlyoutBase", L"LightDismissOverlayModeProperty");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return winrt::Microsoft::UI::Xaml::Controls::Primitives::FlyoutBase::LightDismissOverlayModeProperty();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* FlyoutBase_get_OverlayInputPassThroughElementProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.FlyoutBase", L"OverlayInputPassThroughElementProperty");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return winrt::Microsoft::UI::Xaml::Controls::Primitives::FlyoutBase::OverlayInputPassThroughElementProperty();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* FlyoutBase_get_PlacementProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.FlyoutBase", L"PlacementProperty");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return winrt::Microsoft::UI::Xaml::Controls::Primitives::FlyoutBase::PlacementProperty();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* FlyoutBase_get_ShouldConstrainToRootBoundsProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.FlyoutBase", L"ShouldConstrainToRootBoundsProperty");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return winrt::Microsoft::UI::Xaml::Controls::Primitives::FlyoutBase::ShouldConstrainToRootBoundsProperty();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* FlyoutBase_get_ShowModeProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.FlyoutBase", L"ShowModeProperty");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return winrt::Microsoft::UI::Xaml::Controls::Primitives::FlyoutBase::ShowModeProperty();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* FlyoutBase_get_TargetProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.FlyoutBase", L"TargetProperty");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return winrt::Microsoft::UI::Xaml::Controls::Primitives::FlyoutBase::TargetProperty();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* FlyoutBase_get_SystemBackdropProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.FlyoutBase", L"SystemBackdropProperty");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return winrt::Microsoft::UI::Xaml::Controls::Primitives::FlyoutBase::SystemBackdropProperty();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* FlyoutBase_add_Closed(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, PyObject* arg) noexcept
    {
        try
        {
            static std::optional<bool> is_event_present{};

            if (!is_event_present.has_value())
            {
                is_event_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Microsoft.UI.Xaml.Controls.Primitives.FlyoutBase", L"Closed");
            }

            if (!is_event_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::EventHandler<winrt::Windows::Foundation::IInspectable>>(arg);

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::Primitives::FlyoutBase>().Closed(param0);
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* FlyoutBase_remove_Closed(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, PyObject* arg) noexcept
    {
        try
        {
            static std::optional<bool> is_event_present{};

            if (!is_event_present.has_value())
            {
                is_event_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Microsoft.UI.Xaml.Controls.Primitives.FlyoutBase", L"Closed");
            }

            if (!is_event_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::event_token>(arg);

            {
                auto _gil = release_gil();
                self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::Primitives::FlyoutBase>().Closed(param0);
            }

            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* FlyoutBase_add_Closing(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, PyObject* arg) noexcept
    {
        try
        {
            static std::optional<bool> is_event_present{};

            if (!is_event_present.has_value())
            {
                is_event_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Microsoft.UI.Xaml.Controls.Primitives.FlyoutBase", L"Closing");
            }

            if (!is_event_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Microsoft::UI::Xaml::Controls::Primitives::FlyoutBase, winrt::Microsoft::UI::Xaml::Controls::Primitives::FlyoutBaseClosingEventArgs>>(arg);

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::Primitives::FlyoutBase>().Closing(param0);
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* FlyoutBase_remove_Closing(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, PyObject* arg) noexcept
    {
        try
        {
            static std::optional<bool> is_event_present{};

            if (!is_event_present.has_value())
            {
                is_event_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Microsoft.UI.Xaml.Controls.Primitives.FlyoutBase", L"Closing");
            }

            if (!is_event_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::event_token>(arg);

            {
                auto _gil = release_gil();
                self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::Primitives::FlyoutBase>().Closing(param0);
            }

            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* FlyoutBase_add_Opened(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, PyObject* arg) noexcept
    {
        try
        {
            static std::optional<bool> is_event_present{};

            if (!is_event_present.has_value())
            {
                is_event_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Microsoft.UI.Xaml.Controls.Primitives.FlyoutBase", L"Opened");
            }

            if (!is_event_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::EventHandler<winrt::Windows::Foundation::IInspectable>>(arg);

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::Primitives::FlyoutBase>().Opened(param0);
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* FlyoutBase_remove_Opened(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, PyObject* arg) noexcept
    {
        try
        {
            static std::optional<bool> is_event_present{};

            if (!is_event_present.has_value())
            {
                is_event_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Microsoft.UI.Xaml.Controls.Primitives.FlyoutBase", L"Opened");
            }

            if (!is_event_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::event_token>(arg);

            {
                auto _gil = release_gil();
                self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::Primitives::FlyoutBase>().Opened(param0);
            }

            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* FlyoutBase_add_Opening(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, PyObject* arg) noexcept
    {
        try
        {
            static std::optional<bool> is_event_present{};

            if (!is_event_present.has_value())
            {
                is_event_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Microsoft.UI.Xaml.Controls.Primitives.FlyoutBase", L"Opening");
            }

            if (!is_event_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::EventHandler<winrt::Windows::Foundation::IInspectable>>(arg);

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::Primitives::FlyoutBase>().Opening(param0);
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* FlyoutBase_remove_Opening(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, PyObject* arg) noexcept
    {
        try
        {
            static std::optional<bool> is_event_present{};

            if (!is_event_present.has_value())
            {
                is_event_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Microsoft.UI.Xaml.Controls.Primitives.FlyoutBase", L"Opening");
            }

            if (!is_event_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::event_token>(arg);

            {
                auto _gil = release_gil();
                self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::Primitives::FlyoutBase>().Opening(param0);
            }

            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_FlyoutBase(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Microsoft::UI::Xaml::Controls::Primitives::FlyoutBase>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_FlyoutBase(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Microsoft::UI::Xaml::Controls::Primitives::FlyoutBase>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_FlyoutBase[] = {
        { "_create_presenter", reinterpret_cast<PyCFunction>(FlyoutBase_CreatePresenter), METH_VARARGS, nullptr },
        { "hide", reinterpret_cast<PyCFunction>(FlyoutBase_Hide), METH_VARARGS, nullptr },
        { "_on_process_keyboard_accelerators", reinterpret_cast<PyCFunction>(FlyoutBase_OnProcessKeyboardAccelerators), METH_VARARGS, nullptr },
        { "show_at", reinterpret_cast<PyCFunction>(FlyoutBase_ShowAt), METH_VARARGS, nullptr },
        { "show_at_with_options", reinterpret_cast<PyCFunction>(FlyoutBase_ShowAtWithOptions), METH_VARARGS, nullptr },
        { "try_invoke_keyboard_accelerator", reinterpret_cast<PyCFunction>(FlyoutBase_TryInvokeKeyboardAccelerator), METH_VARARGS, nullptr },
        { "add_closed", reinterpret_cast<PyCFunction>(FlyoutBase_add_Closed), METH_O, nullptr },
        { "remove_closed", reinterpret_cast<PyCFunction>(FlyoutBase_remove_Closed), METH_O, nullptr },
        { "add_closing", reinterpret_cast<PyCFunction>(FlyoutBase_add_Closing), METH_O, nullptr },
        { "remove_closing", reinterpret_cast<PyCFunction>(FlyoutBase_remove_Closing), METH_O, nullptr },
        { "add_opened", reinterpret_cast<PyCFunction>(FlyoutBase_add_Opened), METH_O, nullptr },
        { "remove_opened", reinterpret_cast<PyCFunction>(FlyoutBase_remove_Opened), METH_O, nullptr },
        { "add_opening", reinterpret_cast<PyCFunction>(FlyoutBase_add_Opening), METH_O, nullptr },
        { "remove_opening", reinterpret_cast<PyCFunction>(FlyoutBase_remove_Opening), METH_O, nullptr },
        { "_assign_array_", _assign_array_FlyoutBase, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_FlyoutBase), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_FlyoutBase[] = {
        { "xaml_root", reinterpret_cast<getter>(FlyoutBase_get_XamlRoot), reinterpret_cast<setter>(FlyoutBase_put_XamlRoot), nullptr, nullptr },
        { "show_mode", reinterpret_cast<getter>(FlyoutBase_get_ShowMode), reinterpret_cast<setter>(FlyoutBase_put_ShowMode), nullptr, nullptr },
        { "should_constrain_to_root_bounds", reinterpret_cast<getter>(FlyoutBase_get_ShouldConstrainToRootBounds), reinterpret_cast<setter>(FlyoutBase_put_ShouldConstrainToRootBounds), nullptr, nullptr },
        { "placement", reinterpret_cast<getter>(FlyoutBase_get_Placement), reinterpret_cast<setter>(FlyoutBase_put_Placement), nullptr, nullptr },
        { "overlay_input_pass_through_element", reinterpret_cast<getter>(FlyoutBase_get_OverlayInputPassThroughElement), reinterpret_cast<setter>(FlyoutBase_put_OverlayInputPassThroughElement), nullptr, nullptr },
        { "light_dismiss_overlay_mode", reinterpret_cast<getter>(FlyoutBase_get_LightDismissOverlayMode), reinterpret_cast<setter>(FlyoutBase_put_LightDismissOverlayMode), nullptr, nullptr },
        { "element_sound_mode", reinterpret_cast<getter>(FlyoutBase_get_ElementSoundMode), reinterpret_cast<setter>(FlyoutBase_put_ElementSoundMode), nullptr, nullptr },
        { "are_open_close_animations_enabled", reinterpret_cast<getter>(FlyoutBase_get_AreOpenCloseAnimationsEnabled), reinterpret_cast<setter>(FlyoutBase_put_AreOpenCloseAnimationsEnabled), nullptr, nullptr },
        { "allow_focus_when_disabled", reinterpret_cast<getter>(FlyoutBase_get_AllowFocusWhenDisabled), reinterpret_cast<setter>(FlyoutBase_put_AllowFocusWhenDisabled), nullptr, nullptr },
        { "allow_focus_on_interaction", reinterpret_cast<getter>(FlyoutBase_get_AllowFocusOnInteraction), reinterpret_cast<setter>(FlyoutBase_put_AllowFocusOnInteraction), nullptr, nullptr },
        { "input_device_prefers_primary_commands", reinterpret_cast<getter>(FlyoutBase_get_InputDevicePrefersPrimaryCommands), nullptr, nullptr, nullptr },
        { "is_constrained_to_root_bounds", reinterpret_cast<getter>(FlyoutBase_get_IsConstrainedToRootBounds), nullptr, nullptr, nullptr },
        { "is_open", reinterpret_cast<getter>(FlyoutBase_get_IsOpen), nullptr, nullptr, nullptr },
        { "target", reinterpret_cast<getter>(FlyoutBase_get_Target), nullptr, nullptr, nullptr },
        { "system_backdrop", reinterpret_cast<getter>(FlyoutBase_get_SystemBackdrop), reinterpret_cast<setter>(FlyoutBase_put_SystemBackdrop), nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_FlyoutBase[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_FlyoutBase) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_FlyoutBase) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_FlyoutBase) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_FlyoutBase) },
        { }
    };

    static PyType_Spec type_spec_FlyoutBase = {
        "winrt._winrt_microsoft_ui_xaml_controls_primitives.FlyoutBase",
        sizeof(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>),
        0,
        Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,
        _type_slots_FlyoutBase};

    static PyGetSetDef getset_FlyoutBase_Static[] = {
        { "allow_focus_on_interaction_property", reinterpret_cast<getter>(FlyoutBase_get_AllowFocusOnInteractionProperty), nullptr, nullptr, nullptr },
        { "allow_focus_when_disabled_property", reinterpret_cast<getter>(FlyoutBase_get_AllowFocusWhenDisabledProperty), nullptr, nullptr, nullptr },
        { "are_open_close_animations_enabled_property", reinterpret_cast<getter>(FlyoutBase_get_AreOpenCloseAnimationsEnabledProperty), nullptr, nullptr, nullptr },
        { "attached_flyout_property", reinterpret_cast<getter>(FlyoutBase_get_AttachedFlyoutProperty), nullptr, nullptr, nullptr },
        { "element_sound_mode_property", reinterpret_cast<getter>(FlyoutBase_get_ElementSoundModeProperty), nullptr, nullptr, nullptr },
        { "input_device_prefers_primary_commands_property", reinterpret_cast<getter>(FlyoutBase_get_InputDevicePrefersPrimaryCommandsProperty), nullptr, nullptr, nullptr },
        { "is_open_property", reinterpret_cast<getter>(FlyoutBase_get_IsOpenProperty), nullptr, nullptr, nullptr },
        { "light_dismiss_overlay_mode_property", reinterpret_cast<getter>(FlyoutBase_get_LightDismissOverlayModeProperty), nullptr, nullptr, nullptr },
        { "overlay_input_pass_through_element_property", reinterpret_cast<getter>(FlyoutBase_get_OverlayInputPassThroughElementProperty), nullptr, nullptr, nullptr },
        { "placement_property", reinterpret_cast<getter>(FlyoutBase_get_PlacementProperty), nullptr, nullptr, nullptr },
        { "should_constrain_to_root_bounds_property", reinterpret_cast<getter>(FlyoutBase_get_ShouldConstrainToRootBoundsProperty), nullptr, nullptr, nullptr },
        { "show_mode_property", reinterpret_cast<getter>(FlyoutBase_get_ShowModeProperty), nullptr, nullptr, nullptr },
        { "target_property", reinterpret_cast<getter>(FlyoutBase_get_TargetProperty), nullptr, nullptr, nullptr },
        { "system_backdrop_property", reinterpret_cast<getter>(FlyoutBase_get_SystemBackdropProperty), nullptr, nullptr, nullptr },
        { }
    };

    static PyMethodDef methods_FlyoutBase_Static[] = {
        { "get_attached_flyout", reinterpret_cast<PyCFunction>(FlyoutBase_GetAttachedFlyout), METH_VARARGS, nullptr },
        { "set_attached_flyout", reinterpret_cast<PyCFunction>(FlyoutBase_SetAttachedFlyout), METH_VARARGS, nullptr },
        { "show_attached_flyout", reinterpret_cast<PyCFunction>(FlyoutBase_ShowAttachedFlyout), METH_VARARGS, nullptr },
        { }
    };

    static PyType_Slot type_slots_FlyoutBase_Static[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_FlyoutBase_Static) },
        { Py_tp_methods, reinterpret_cast<void*>(methods_FlyoutBase_Static) },
        { }
    };

    static PyType_Spec type_spec_FlyoutBase_Static =
    {
        "winrt._winrt_microsoft_ui_xaml_controls_primitives.FlyoutBase_Static",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,
        type_slots_FlyoutBase_Static
    };

    // ----- FlyoutBaseClosingEventArgs class --------------------

    static PyObject* _new_FlyoutBaseClosingEventArgs(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Microsoft::UI::Xaml::Controls::Primitives::FlyoutBaseClosingEventArgs>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Microsoft::UI::Xaml::Controls::Primitives::FlyoutBaseClosingEventArgs>::type_name);
        return nullptr;
    }

    static void _dealloc_FlyoutBaseClosingEventArgs(py::wrapper::Microsoft::UI::Xaml::Controls::Primitives::FlyoutBaseClosingEventArgs* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* FlyoutBaseClosingEventArgs_get_Cancel(py::wrapper::Microsoft::UI::Xaml::Controls::Primitives::FlyoutBaseClosingEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.FlyoutBaseClosingEventArgs", L"Cancel");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Cancel();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int FlyoutBaseClosingEventArgs_put_Cancel(py::wrapper::Microsoft::UI::Xaml::Controls::Primitives::FlyoutBaseClosingEventArgs* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.FlyoutBaseClosingEventArgs", L"Cancel");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<bool>(arg);

            {
                auto _gil = release_gil();
                self->obj.Cancel(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* _assign_array_FlyoutBaseClosingEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Microsoft::UI::Xaml::Controls::Primitives::FlyoutBaseClosingEventArgs>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_FlyoutBaseClosingEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Microsoft::UI::Xaml::Controls::Primitives::FlyoutBaseClosingEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_FlyoutBaseClosingEventArgs[] = {
        { "_assign_array_", _assign_array_FlyoutBaseClosingEventArgs, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_FlyoutBaseClosingEventArgs), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_FlyoutBaseClosingEventArgs[] = {
        { "cancel", reinterpret_cast<getter>(FlyoutBaseClosingEventArgs_get_Cancel), reinterpret_cast<setter>(FlyoutBaseClosingEventArgs_put_Cancel), nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_FlyoutBaseClosingEventArgs[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_FlyoutBaseClosingEventArgs) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_FlyoutBaseClosingEventArgs) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_FlyoutBaseClosingEventArgs) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_FlyoutBaseClosingEventArgs) },
        { }
    };

    static PyType_Spec type_spec_FlyoutBaseClosingEventArgs = {
        "winrt._winrt_microsoft_ui_xaml_controls_primitives.FlyoutBaseClosingEventArgs",
        sizeof(py::wrapper::Microsoft::UI::Xaml::Controls::Primitives::FlyoutBaseClosingEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_FlyoutBaseClosingEventArgs};

    // ----- FlyoutShowOptions class --------------------

    struct PyWinrtFlyoutShowOptions;
    using BasePyWinrtFlyoutShowOptions = winrt::Microsoft::UI::Xaml::Controls::Primitives::FlyoutShowOptionsT<PyWinrtFlyoutShowOptions, py::IPywinrtObject>;

    struct PyWinrtFlyoutShowOptions : py::py_obj_ref, BasePyWinrtFlyoutShowOptions
    {
        PyWinrtFlyoutShowOptions(PyObject* py_obj) : py::py_obj_ref(py_obj), BasePyWinrtFlyoutShowOptions() {}

        int32_t __stdcall GetPyObject(PyObject*& obj) override
        {
            obj = py::py_obj_ref::get_py_obj();
            return 0;
        }

        int32_t __stdcall GetComposableInner(winrt::Windows::Foundation::IInspectable& inner) override
        {
            inner = m_inner;
            return winrt::impl::error_ok;
        }

        static void toggle_reference(PyWinrtFlyoutShowOptions* instance, bool is_last_reference)
        {
            py::py_obj_ref::toggle_reference(instance, is_last_reference);
        }

        int32_t query_interface_tearoff(winrt::guid const& id, void** result) const noexcept override
        {
            return py::py_obj_ref::query_interface_tearoff(id, result);
        }
    };

    static PyObject* _new_FlyoutShowOptions(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);

        auto self_type = get_python_type_for<winrt::Microsoft::UI::Xaml::Controls::Primitives::FlyoutShowOptions>();
        if (!self_type)
        {
            return nullptr;
        }

        if (arg_count == 0)
        {
            try
            {
                if (type != self_type)
                {
                    py::pyobj_handle self{type->tp_alloc(type, 0)};
                    if (!self)
                    {
                        return nullptr;
                    }

                    std::construct_at(&reinterpret_cast<py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>*>(self.get())->obj, nullptr);

                    auto obj_impl = winrt::make_self<PyWinrtFlyoutShowOptions>(self.get());

                    auto obj = py::make_py_obj<PyWinrtFlyoutShowOptions>(obj_impl, type, self.get());
                    if (!obj)
                    {
                        return nullptr;
                    }

                    reinterpret_cast<py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>*>(self.get())->obj = std::move(obj);

                    return self.detach();
                }

                winrt::Microsoft::UI::Xaml::Controls::Primitives::FlyoutShowOptions instance{};
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_FlyoutShowOptions(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* FlyoutShowOptions_get_ShowMode(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.FlyoutShowOptions", L"ShowMode");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::Primitives::FlyoutShowOptions>().ShowMode();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int FlyoutShowOptions_put_ShowMode(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.FlyoutShowOptions", L"ShowMode");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Microsoft::UI::Xaml::Controls::Primitives::FlyoutShowMode>(arg);

            {
                auto _gil = release_gil();
                self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::Primitives::FlyoutShowOptions>().ShowMode(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* FlyoutShowOptions_get_Position(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.FlyoutShowOptions", L"Position");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::Primitives::FlyoutShowOptions>().Position();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int FlyoutShowOptions_put_Position(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.FlyoutShowOptions", L"Position");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::IReference<winrt::Windows::Foundation::Point>>(arg);

            {
                auto _gil = release_gil();
                self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::Primitives::FlyoutShowOptions>().Position(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* FlyoutShowOptions_get_Placement(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.FlyoutShowOptions", L"Placement");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::Primitives::FlyoutShowOptions>().Placement();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int FlyoutShowOptions_put_Placement(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.FlyoutShowOptions", L"Placement");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Microsoft::UI::Xaml::Controls::Primitives::FlyoutPlacementMode>(arg);

            {
                auto _gil = release_gil();
                self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::Primitives::FlyoutShowOptions>().Placement(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* FlyoutShowOptions_get_ExclusionRect(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.FlyoutShowOptions", L"ExclusionRect");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::Primitives::FlyoutShowOptions>().ExclusionRect();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int FlyoutShowOptions_put_ExclusionRect(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.FlyoutShowOptions", L"ExclusionRect");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::IReference<winrt::Windows::Foundation::Rect>>(arg);

            {
                auto _gil = release_gil();
                self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::Primitives::FlyoutShowOptions>().ExclusionRect(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* _assign_array_FlyoutShowOptions(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Microsoft::UI::Xaml::Controls::Primitives::FlyoutShowOptions>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_FlyoutShowOptions(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Microsoft::UI::Xaml::Controls::Primitives::FlyoutShowOptions>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_FlyoutShowOptions[] = {
        { "_assign_array_", _assign_array_FlyoutShowOptions, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_FlyoutShowOptions), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_FlyoutShowOptions[] = {
        { "show_mode", reinterpret_cast<getter>(FlyoutShowOptions_get_ShowMode), reinterpret_cast<setter>(FlyoutShowOptions_put_ShowMode), nullptr, nullptr },
        { "position", reinterpret_cast<getter>(FlyoutShowOptions_get_Position), reinterpret_cast<setter>(FlyoutShowOptions_put_Position), nullptr, nullptr },
        { "placement", reinterpret_cast<getter>(FlyoutShowOptions_get_Placement), reinterpret_cast<setter>(FlyoutShowOptions_put_Placement), nullptr, nullptr },
        { "exclusion_rect", reinterpret_cast<getter>(FlyoutShowOptions_get_ExclusionRect), reinterpret_cast<setter>(FlyoutShowOptions_put_ExclusionRect), nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_FlyoutShowOptions[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_FlyoutShowOptions) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_FlyoutShowOptions) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_FlyoutShowOptions) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_FlyoutShowOptions) },
        { }
    };

    static PyType_Spec type_spec_FlyoutShowOptions = {
        "winrt._winrt_microsoft_ui_xaml_controls_primitives.FlyoutShowOptions",
        sizeof(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>),
        0,
        Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,
        _type_slots_FlyoutShowOptions};

    static PyGetSetDef getset_FlyoutShowOptions_Static[] = {
        { }
    };

    static PyMethodDef methods_FlyoutShowOptions_Static[] = {
        { }
    };

    static PyType_Slot type_slots_FlyoutShowOptions_Static[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_FlyoutShowOptions_Static) },
        { Py_tp_methods, reinterpret_cast<void*>(methods_FlyoutShowOptions_Static) },
        { }
    };

    static PyType_Spec type_spec_FlyoutShowOptions_Static =
    {
        "winrt._winrt_microsoft_ui_xaml_controls_primitives.FlyoutShowOptions_Static",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,
        type_slots_FlyoutShowOptions_Static
    };

    // ----- GeneratorPositionHelper class --------------------

    static PyObject* _new_GeneratorPositionHelper(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Microsoft::UI::Xaml::Controls::Primitives::GeneratorPositionHelper>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Microsoft::UI::Xaml::Controls::Primitives::GeneratorPositionHelper>::type_name);
        return nullptr;
    }

    static void _dealloc_GeneratorPositionHelper(py::wrapper::Microsoft::UI::Xaml::Controls::Primitives::GeneratorPositionHelper* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* GeneratorPositionHelper_FromIndexAndOffset(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Xaml.Controls.Primitives.GeneratorPositionHelper", L"FromIndexAndOffset", 2);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(2);
                    return nullptr;
                }

                auto param0 = py::convert_to<int32_t>(args, 0);
                auto param1 = py::convert_to<int32_t>(args, 1);

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return winrt::Microsoft::UI::Xaml::Controls::Primitives::GeneratorPositionHelper::FromIndexAndOffset(param0, param1);
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* _assign_array_GeneratorPositionHelper(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Microsoft::UI::Xaml::Controls::Primitives::GeneratorPositionHelper>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_GeneratorPositionHelper(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Microsoft::UI::Xaml::Controls::Primitives::GeneratorPositionHelper>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_GeneratorPositionHelper[] = {
        { "_assign_array_", _assign_array_GeneratorPositionHelper, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_GeneratorPositionHelper), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_GeneratorPositionHelper[] = {
        { }
    };

    static PyType_Slot _type_slots_GeneratorPositionHelper[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_GeneratorPositionHelper) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_GeneratorPositionHelper) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_GeneratorPositionHelper) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_GeneratorPositionHelper) },
        { }
    };

    static PyType_Spec type_spec_GeneratorPositionHelper = {
        "winrt._winrt_microsoft_ui_xaml_controls_primitives.GeneratorPositionHelper",
        sizeof(py::wrapper::Microsoft::UI::Xaml::Controls::Primitives::GeneratorPositionHelper),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_GeneratorPositionHelper};

    static PyGetSetDef getset_GeneratorPositionHelper_Static[] = {
        { }
    };

    static PyMethodDef methods_GeneratorPositionHelper_Static[] = {
        { "from_index_and_offset", reinterpret_cast<PyCFunction>(GeneratorPositionHelper_FromIndexAndOffset), METH_VARARGS, nullptr },
        { }
    };

    static PyType_Slot type_slots_GeneratorPositionHelper_Static[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_GeneratorPositionHelper_Static) },
        { Py_tp_methods, reinterpret_cast<void*>(methods_GeneratorPositionHelper_Static) },
        { }
    };

    static PyType_Spec type_spec_GeneratorPositionHelper_Static =
    {
        "winrt._winrt_microsoft_ui_xaml_controls_primitives.GeneratorPositionHelper_Static",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT,
        type_slots_GeneratorPositionHelper_Static
    };

    // ----- GridViewItemPresenter class --------------------

    struct PyWinrtGridViewItemPresenter;
    using BasePyWinrtGridViewItemPresenter = winrt::Microsoft::UI::Xaml::Controls::Primitives::GridViewItemPresenterT<PyWinrtGridViewItemPresenter, py::IPywinrtObject>;

    struct PyWinrtGridViewItemPresenter : py::py_obj_ref, BasePyWinrtGridViewItemPresenter
    {
        PyWinrtGridViewItemPresenter(PyObject* py_obj) : py::py_obj_ref(py_obj), BasePyWinrtGridViewItemPresenter() {}

        int32_t __stdcall GetPyObject(PyObject*& obj) override
        {
            obj = py::py_obj_ref::get_py_obj();
            return 0;
        }

        int32_t __stdcall GetComposableInner(winrt::Windows::Foundation::IInspectable& inner) override
        {
            inner = m_inner;
            return winrt::impl::error_ok;
        }

        static void toggle_reference(PyWinrtGridViewItemPresenter* instance, bool is_last_reference)
        {
            py::py_obj_ref::toggle_reference(instance, is_last_reference);
        }

        int32_t query_interface_tearoff(winrt::guid const& id, void** result) const noexcept override
        {
            return py::py_obj_ref::query_interface_tearoff(id, result);
        }
    };

    static PyObject* _new_GridViewItemPresenter(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);

        auto self_type = get_python_type_for<winrt::Microsoft::UI::Xaml::Controls::Primitives::GridViewItemPresenter>();
        if (!self_type)
        {
            return nullptr;
        }

        if (arg_count == 0)
        {
            try
            {
                if (type != self_type)
                {
                    py::pyobj_handle self{type->tp_alloc(type, 0)};
                    if (!self)
                    {
                        return nullptr;
                    }

                    std::construct_at(&reinterpret_cast<py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>*>(self.get())->obj, nullptr);

                    auto obj_impl = winrt::make_self<PyWinrtGridViewItemPresenter>(self.get());

                    auto obj = py::make_py_obj<PyWinrtGridViewItemPresenter>(obj_impl, type, self.get());
                    if (!obj)
                    {
                        return nullptr;
                    }

                    reinterpret_cast<py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>*>(self.get())->obj = std::move(obj);

                    return self.detach();
                }

                winrt::Microsoft::UI::Xaml::Controls::Primitives::GridViewItemPresenter instance{};
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_GridViewItemPresenter(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* GridViewItemPresenter_get_SelectionCheckMarkVisualEnabled(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.GridViewItemPresenter", L"SelectionCheckMarkVisualEnabled");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::Primitives::GridViewItemPresenter>().SelectionCheckMarkVisualEnabled();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int GridViewItemPresenter_put_SelectionCheckMarkVisualEnabled(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.GridViewItemPresenter", L"SelectionCheckMarkVisualEnabled");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<bool>(arg);

            {
                auto _gil = release_gil();
                self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::Primitives::GridViewItemPresenter>().SelectionCheckMarkVisualEnabled(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* GridViewItemPresenter_get_SelectedPointerOverBorderBrush(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.GridViewItemPresenter", L"SelectedPointerOverBorderBrush");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::Primitives::GridViewItemPresenter>().SelectedPointerOverBorderBrush();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int GridViewItemPresenter_put_SelectedPointerOverBorderBrush(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.GridViewItemPresenter", L"SelectedPointerOverBorderBrush");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Microsoft::UI::Xaml::Media::Brush>(arg);

            {
                auto _gil = release_gil();
                self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::Primitives::GridViewItemPresenter>().SelectedPointerOverBorderBrush(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* GridViewItemPresenter_get_SelectedPointerOverBackground(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.GridViewItemPresenter", L"SelectedPointerOverBackground");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::Primitives::GridViewItemPresenter>().SelectedPointerOverBackground();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int GridViewItemPresenter_put_SelectedPointerOverBackground(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.GridViewItemPresenter", L"SelectedPointerOverBackground");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Microsoft::UI::Xaml::Media::Brush>(arg);

            {
                auto _gil = release_gil();
                self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::Primitives::GridViewItemPresenter>().SelectedPointerOverBackground(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* GridViewItemPresenter_get_SelectedForeground(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.GridViewItemPresenter", L"SelectedForeground");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::Primitives::GridViewItemPresenter>().SelectedForeground();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int GridViewItemPresenter_put_SelectedForeground(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.GridViewItemPresenter", L"SelectedForeground");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Microsoft::UI::Xaml::Media::Brush>(arg);

            {
                auto _gil = release_gil();
                self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::Primitives::GridViewItemPresenter>().SelectedForeground(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* GridViewItemPresenter_get_SelectedBorderThickness(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.GridViewItemPresenter", L"SelectedBorderThickness");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::Primitives::GridViewItemPresenter>().SelectedBorderThickness();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int GridViewItemPresenter_put_SelectedBorderThickness(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.GridViewItemPresenter", L"SelectedBorderThickness");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Microsoft::UI::Xaml::Thickness>(arg);

            {
                auto _gil = release_gil();
                self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::Primitives::GridViewItemPresenter>().SelectedBorderThickness(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* GridViewItemPresenter_get_SelectedBackground(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.GridViewItemPresenter", L"SelectedBackground");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::Primitives::GridViewItemPresenter>().SelectedBackground();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int GridViewItemPresenter_put_SelectedBackground(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.GridViewItemPresenter", L"SelectedBackground");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Microsoft::UI::Xaml::Media::Brush>(arg);

            {
                auto _gil = release_gil();
                self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::Primitives::GridViewItemPresenter>().SelectedBackground(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* GridViewItemPresenter_get_ReorderHintOffset(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.GridViewItemPresenter", L"ReorderHintOffset");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::Primitives::GridViewItemPresenter>().ReorderHintOffset();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int GridViewItemPresenter_put_ReorderHintOffset(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.GridViewItemPresenter", L"ReorderHintOffset");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<double>(arg);

            {
                auto _gil = release_gil();
                self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::Primitives::GridViewItemPresenter>().ReorderHintOffset(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* GridViewItemPresenter_get_PointerOverBackgroundMargin(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.GridViewItemPresenter", L"PointerOverBackgroundMargin");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::Primitives::GridViewItemPresenter>().PointerOverBackgroundMargin();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int GridViewItemPresenter_put_PointerOverBackgroundMargin(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.GridViewItemPresenter", L"PointerOverBackgroundMargin");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Microsoft::UI::Xaml::Thickness>(arg);

            {
                auto _gil = release_gil();
                self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::Primitives::GridViewItemPresenter>().PointerOverBackgroundMargin(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* GridViewItemPresenter_get_PointerOverBackground(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.GridViewItemPresenter", L"PointerOverBackground");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::Primitives::GridViewItemPresenter>().PointerOverBackground();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int GridViewItemPresenter_put_PointerOverBackground(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.GridViewItemPresenter", L"PointerOverBackground");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Microsoft::UI::Xaml::Media::Brush>(arg);

            {
                auto _gil = release_gil();
                self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::Primitives::GridViewItemPresenter>().PointerOverBackground(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* GridViewItemPresenter_get_PlaceholderBackground(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.GridViewItemPresenter", L"PlaceholderBackground");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::Primitives::GridViewItemPresenter>().PlaceholderBackground();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int GridViewItemPresenter_put_PlaceholderBackground(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.GridViewItemPresenter", L"PlaceholderBackground");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Microsoft::UI::Xaml::Media::Brush>(arg);

            {
                auto _gil = release_gil();
                self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::Primitives::GridViewItemPresenter>().PlaceholderBackground(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* GridViewItemPresenter_get_GridViewItemPresenterVerticalContentAlignment(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.GridViewItemPresenter", L"GridViewItemPresenterVerticalContentAlignment");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::Primitives::GridViewItemPresenter>().GridViewItemPresenterVerticalContentAlignment();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int GridViewItemPresenter_put_GridViewItemPresenterVerticalContentAlignment(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.GridViewItemPresenter", L"GridViewItemPresenterVerticalContentAlignment");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Microsoft::UI::Xaml::VerticalAlignment>(arg);

            {
                auto _gil = release_gil();
                self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::Primitives::GridViewItemPresenter>().GridViewItemPresenterVerticalContentAlignment(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* GridViewItemPresenter_get_GridViewItemPresenterPadding(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.GridViewItemPresenter", L"GridViewItemPresenterPadding");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::Primitives::GridViewItemPresenter>().GridViewItemPresenterPadding();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int GridViewItemPresenter_put_GridViewItemPresenterPadding(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.GridViewItemPresenter", L"GridViewItemPresenterPadding");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Microsoft::UI::Xaml::Thickness>(arg);

            {
                auto _gil = release_gil();
                self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::Primitives::GridViewItemPresenter>().GridViewItemPresenterPadding(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* GridViewItemPresenter_get_GridViewItemPresenterHorizontalContentAlignment(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.GridViewItemPresenter", L"GridViewItemPresenterHorizontalContentAlignment");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::Primitives::GridViewItemPresenter>().GridViewItemPresenterHorizontalContentAlignment();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int GridViewItemPresenter_put_GridViewItemPresenterHorizontalContentAlignment(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.GridViewItemPresenter", L"GridViewItemPresenterHorizontalContentAlignment");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Microsoft::UI::Xaml::HorizontalAlignment>(arg);

            {
                auto _gil = release_gil();
                self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::Primitives::GridViewItemPresenter>().GridViewItemPresenterHorizontalContentAlignment(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* GridViewItemPresenter_get_FocusBorderBrush(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.GridViewItemPresenter", L"FocusBorderBrush");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::Primitives::GridViewItemPresenter>().FocusBorderBrush();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int GridViewItemPresenter_put_FocusBorderBrush(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.GridViewItemPresenter", L"FocusBorderBrush");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Microsoft::UI::Xaml::Media::Brush>(arg);

            {
                auto _gil = release_gil();
                self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::Primitives::GridViewItemPresenter>().FocusBorderBrush(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* GridViewItemPresenter_get_DragOpacity(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.GridViewItemPresenter", L"DragOpacity");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::Primitives::GridViewItemPresenter>().DragOpacity();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int GridViewItemPresenter_put_DragOpacity(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.GridViewItemPresenter", L"DragOpacity");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<double>(arg);

            {
                auto _gil = release_gil();
                self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::Primitives::GridViewItemPresenter>().DragOpacity(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* GridViewItemPresenter_get_DragForeground(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.GridViewItemPresenter", L"DragForeground");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::Primitives::GridViewItemPresenter>().DragForeground();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int GridViewItemPresenter_put_DragForeground(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.GridViewItemPresenter", L"DragForeground");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Microsoft::UI::Xaml::Media::Brush>(arg);

            {
                auto _gil = release_gil();
                self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::Primitives::GridViewItemPresenter>().DragForeground(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* GridViewItemPresenter_get_DragBackground(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.GridViewItemPresenter", L"DragBackground");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::Primitives::GridViewItemPresenter>().DragBackground();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int GridViewItemPresenter_put_DragBackground(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.GridViewItemPresenter", L"DragBackground");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Microsoft::UI::Xaml::Media::Brush>(arg);

            {
                auto _gil = release_gil();
                self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::Primitives::GridViewItemPresenter>().DragBackground(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* GridViewItemPresenter_get_DisabledOpacity(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.GridViewItemPresenter", L"DisabledOpacity");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::Primitives::GridViewItemPresenter>().DisabledOpacity();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int GridViewItemPresenter_put_DisabledOpacity(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.GridViewItemPresenter", L"DisabledOpacity");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<double>(arg);

            {
                auto _gil = release_gil();
                self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::Primitives::GridViewItemPresenter>().DisabledOpacity(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* GridViewItemPresenter_get_ContentMargin(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.GridViewItemPresenter", L"ContentMargin");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::Primitives::GridViewItemPresenter>().ContentMargin();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int GridViewItemPresenter_put_ContentMargin(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.GridViewItemPresenter", L"ContentMargin");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Microsoft::UI::Xaml::Thickness>(arg);

            {
                auto _gil = release_gil();
                self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::Primitives::GridViewItemPresenter>().ContentMargin(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* GridViewItemPresenter_get_CheckSelectingBrush(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.GridViewItemPresenter", L"CheckSelectingBrush");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::Primitives::GridViewItemPresenter>().CheckSelectingBrush();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int GridViewItemPresenter_put_CheckSelectingBrush(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.GridViewItemPresenter", L"CheckSelectingBrush");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Microsoft::UI::Xaml::Media::Brush>(arg);

            {
                auto _gil = release_gil();
                self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::Primitives::GridViewItemPresenter>().CheckSelectingBrush(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* GridViewItemPresenter_get_CheckHintBrush(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.GridViewItemPresenter", L"CheckHintBrush");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::Primitives::GridViewItemPresenter>().CheckHintBrush();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int GridViewItemPresenter_put_CheckHintBrush(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.GridViewItemPresenter", L"CheckHintBrush");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Microsoft::UI::Xaml::Media::Brush>(arg);

            {
                auto _gil = release_gil();
                self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::Primitives::GridViewItemPresenter>().CheckHintBrush(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* GridViewItemPresenter_get_CheckBrush(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.GridViewItemPresenter", L"CheckBrush");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::Primitives::GridViewItemPresenter>().CheckBrush();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int GridViewItemPresenter_put_CheckBrush(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.GridViewItemPresenter", L"CheckBrush");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Microsoft::UI::Xaml::Media::Brush>(arg);

            {
                auto _gil = release_gil();
                self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::Primitives::GridViewItemPresenter>().CheckBrush(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* GridViewItemPresenter_get_CheckBrushProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.GridViewItemPresenter", L"CheckBrushProperty");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return winrt::Microsoft::UI::Xaml::Controls::Primitives::GridViewItemPresenter::CheckBrushProperty();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* GridViewItemPresenter_get_CheckHintBrushProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.GridViewItemPresenter", L"CheckHintBrushProperty");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return winrt::Microsoft::UI::Xaml::Controls::Primitives::GridViewItemPresenter::CheckHintBrushProperty();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* GridViewItemPresenter_get_CheckSelectingBrushProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.GridViewItemPresenter", L"CheckSelectingBrushProperty");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return winrt::Microsoft::UI::Xaml::Controls::Primitives::GridViewItemPresenter::CheckSelectingBrushProperty();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* GridViewItemPresenter_get_ContentMarginProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.GridViewItemPresenter", L"ContentMarginProperty");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return winrt::Microsoft::UI::Xaml::Controls::Primitives::GridViewItemPresenter::ContentMarginProperty();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* GridViewItemPresenter_get_DisabledOpacityProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.GridViewItemPresenter", L"DisabledOpacityProperty");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return winrt::Microsoft::UI::Xaml::Controls::Primitives::GridViewItemPresenter::DisabledOpacityProperty();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* GridViewItemPresenter_get_DragBackgroundProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.GridViewItemPresenter", L"DragBackgroundProperty");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return winrt::Microsoft::UI::Xaml::Controls::Primitives::GridViewItemPresenter::DragBackgroundProperty();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* GridViewItemPresenter_get_DragForegroundProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.GridViewItemPresenter", L"DragForegroundProperty");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return winrt::Microsoft::UI::Xaml::Controls::Primitives::GridViewItemPresenter::DragForegroundProperty();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* GridViewItemPresenter_get_DragOpacityProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.GridViewItemPresenter", L"DragOpacityProperty");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return winrt::Microsoft::UI::Xaml::Controls::Primitives::GridViewItemPresenter::DragOpacityProperty();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* GridViewItemPresenter_get_FocusBorderBrushProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.GridViewItemPresenter", L"FocusBorderBrushProperty");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return winrt::Microsoft::UI::Xaml::Controls::Primitives::GridViewItemPresenter::FocusBorderBrushProperty();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* GridViewItemPresenter_get_GridViewItemPresenterHorizontalContentAlignmentProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.GridViewItemPresenter", L"GridViewItemPresenterHorizontalContentAlignmentProperty");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return winrt::Microsoft::UI::Xaml::Controls::Primitives::GridViewItemPresenter::GridViewItemPresenterHorizontalContentAlignmentProperty();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* GridViewItemPresenter_get_GridViewItemPresenterPaddingProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.GridViewItemPresenter", L"GridViewItemPresenterPaddingProperty");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return winrt::Microsoft::UI::Xaml::Controls::Primitives::GridViewItemPresenter::GridViewItemPresenterPaddingProperty();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* GridViewItemPresenter_get_GridViewItemPresenterVerticalContentAlignmentProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.GridViewItemPresenter", L"GridViewItemPresenterVerticalContentAlignmentProperty");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return winrt::Microsoft::UI::Xaml::Controls::Primitives::GridViewItemPresenter::GridViewItemPresenterVerticalContentAlignmentProperty();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* GridViewItemPresenter_get_PlaceholderBackgroundProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.GridViewItemPresenter", L"PlaceholderBackgroundProperty");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return winrt::Microsoft::UI::Xaml::Controls::Primitives::GridViewItemPresenter::PlaceholderBackgroundProperty();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* GridViewItemPresenter_get_PointerOverBackgroundMarginProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.GridViewItemPresenter", L"PointerOverBackgroundMarginProperty");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return winrt::Microsoft::UI::Xaml::Controls::Primitives::GridViewItemPresenter::PointerOverBackgroundMarginProperty();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* GridViewItemPresenter_get_PointerOverBackgroundProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.GridViewItemPresenter", L"PointerOverBackgroundProperty");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return winrt::Microsoft::UI::Xaml::Controls::Primitives::GridViewItemPresenter::PointerOverBackgroundProperty();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* GridViewItemPresenter_get_ReorderHintOffsetProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.GridViewItemPresenter", L"ReorderHintOffsetProperty");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return winrt::Microsoft::UI::Xaml::Controls::Primitives::GridViewItemPresenter::ReorderHintOffsetProperty();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* GridViewItemPresenter_get_SelectedBackgroundProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.GridViewItemPresenter", L"SelectedBackgroundProperty");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return winrt::Microsoft::UI::Xaml::Controls::Primitives::GridViewItemPresenter::SelectedBackgroundProperty();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* GridViewItemPresenter_get_SelectedBorderThicknessProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.GridViewItemPresenter", L"SelectedBorderThicknessProperty");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return winrt::Microsoft::UI::Xaml::Controls::Primitives::GridViewItemPresenter::SelectedBorderThicknessProperty();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* GridViewItemPresenter_get_SelectedForegroundProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.GridViewItemPresenter", L"SelectedForegroundProperty");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return winrt::Microsoft::UI::Xaml::Controls::Primitives::GridViewItemPresenter::SelectedForegroundProperty();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* GridViewItemPresenter_get_SelectedPointerOverBackgroundProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.GridViewItemPresenter", L"SelectedPointerOverBackgroundProperty");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return winrt::Microsoft::UI::Xaml::Controls::Primitives::GridViewItemPresenter::SelectedPointerOverBackgroundProperty();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* GridViewItemPresenter_get_SelectedPointerOverBorderBrushProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.GridViewItemPresenter", L"SelectedPointerOverBorderBrushProperty");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return winrt::Microsoft::UI::Xaml::Controls::Primitives::GridViewItemPresenter::SelectedPointerOverBorderBrushProperty();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* GridViewItemPresenter_get_SelectionCheckMarkVisualEnabledProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.GridViewItemPresenter", L"SelectionCheckMarkVisualEnabledProperty");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return winrt::Microsoft::UI::Xaml::Controls::Primitives::GridViewItemPresenter::SelectionCheckMarkVisualEnabledProperty();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_GridViewItemPresenter(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Microsoft::UI::Xaml::Controls::Primitives::GridViewItemPresenter>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_GridViewItemPresenter(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Microsoft::UI::Xaml::Controls::Primitives::GridViewItemPresenter>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_GridViewItemPresenter[] = {
        { "_assign_array_", _assign_array_GridViewItemPresenter, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_GridViewItemPresenter), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_GridViewItemPresenter[] = {
        { "selection_check_mark_visual_enabled", reinterpret_cast<getter>(GridViewItemPresenter_get_SelectionCheckMarkVisualEnabled), reinterpret_cast<setter>(GridViewItemPresenter_put_SelectionCheckMarkVisualEnabled), nullptr, nullptr },
        { "selected_pointer_over_border_brush", reinterpret_cast<getter>(GridViewItemPresenter_get_SelectedPointerOverBorderBrush), reinterpret_cast<setter>(GridViewItemPresenter_put_SelectedPointerOverBorderBrush), nullptr, nullptr },
        { "selected_pointer_over_background", reinterpret_cast<getter>(GridViewItemPresenter_get_SelectedPointerOverBackground), reinterpret_cast<setter>(GridViewItemPresenter_put_SelectedPointerOverBackground), nullptr, nullptr },
        { "selected_foreground", reinterpret_cast<getter>(GridViewItemPresenter_get_SelectedForeground), reinterpret_cast<setter>(GridViewItemPresenter_put_SelectedForeground), nullptr, nullptr },
        { "selected_border_thickness", reinterpret_cast<getter>(GridViewItemPresenter_get_SelectedBorderThickness), reinterpret_cast<setter>(GridViewItemPresenter_put_SelectedBorderThickness), nullptr, nullptr },
        { "selected_background", reinterpret_cast<getter>(GridViewItemPresenter_get_SelectedBackground), reinterpret_cast<setter>(GridViewItemPresenter_put_SelectedBackground), nullptr, nullptr },
        { "reorder_hint_offset", reinterpret_cast<getter>(GridViewItemPresenter_get_ReorderHintOffset), reinterpret_cast<setter>(GridViewItemPresenter_put_ReorderHintOffset), nullptr, nullptr },
        { "pointer_over_background_margin", reinterpret_cast<getter>(GridViewItemPresenter_get_PointerOverBackgroundMargin), reinterpret_cast<setter>(GridViewItemPresenter_put_PointerOverBackgroundMargin), nullptr, nullptr },
        { "pointer_over_background", reinterpret_cast<getter>(GridViewItemPresenter_get_PointerOverBackground), reinterpret_cast<setter>(GridViewItemPresenter_put_PointerOverBackground), nullptr, nullptr },
        { "placeholder_background", reinterpret_cast<getter>(GridViewItemPresenter_get_PlaceholderBackground), reinterpret_cast<setter>(GridViewItemPresenter_put_PlaceholderBackground), nullptr, nullptr },
        { "grid_view_item_presenter_vertical_content_alignment", reinterpret_cast<getter>(GridViewItemPresenter_get_GridViewItemPresenterVerticalContentAlignment), reinterpret_cast<setter>(GridViewItemPresenter_put_GridViewItemPresenterVerticalContentAlignment), nullptr, nullptr },
        { "grid_view_item_presenter_padding", reinterpret_cast<getter>(GridViewItemPresenter_get_GridViewItemPresenterPadding), reinterpret_cast<setter>(GridViewItemPresenter_put_GridViewItemPresenterPadding), nullptr, nullptr },
        { "grid_view_item_presenter_horizontal_content_alignment", reinterpret_cast<getter>(GridViewItemPresenter_get_GridViewItemPresenterHorizontalContentAlignment), reinterpret_cast<setter>(GridViewItemPresenter_put_GridViewItemPresenterHorizontalContentAlignment), nullptr, nullptr },
        { "focus_border_brush", reinterpret_cast<getter>(GridViewItemPresenter_get_FocusBorderBrush), reinterpret_cast<setter>(GridViewItemPresenter_put_FocusBorderBrush), nullptr, nullptr },
        { "drag_opacity", reinterpret_cast<getter>(GridViewItemPresenter_get_DragOpacity), reinterpret_cast<setter>(GridViewItemPresenter_put_DragOpacity), nullptr, nullptr },
        { "drag_foreground", reinterpret_cast<getter>(GridViewItemPresenter_get_DragForeground), reinterpret_cast<setter>(GridViewItemPresenter_put_DragForeground), nullptr, nullptr },
        { "drag_background", reinterpret_cast<getter>(GridViewItemPresenter_get_DragBackground), reinterpret_cast<setter>(GridViewItemPresenter_put_DragBackground), nullptr, nullptr },
        { "disabled_opacity", reinterpret_cast<getter>(GridViewItemPresenter_get_DisabledOpacity), reinterpret_cast<setter>(GridViewItemPresenter_put_DisabledOpacity), nullptr, nullptr },
        { "content_margin", reinterpret_cast<getter>(GridViewItemPresenter_get_ContentMargin), reinterpret_cast<setter>(GridViewItemPresenter_put_ContentMargin), nullptr, nullptr },
        { "check_selecting_brush", reinterpret_cast<getter>(GridViewItemPresenter_get_CheckSelectingBrush), reinterpret_cast<setter>(GridViewItemPresenter_put_CheckSelectingBrush), nullptr, nullptr },
        { "check_hint_brush", reinterpret_cast<getter>(GridViewItemPresenter_get_CheckHintBrush), reinterpret_cast<setter>(GridViewItemPresenter_put_CheckHintBrush), nullptr, nullptr },
        { "check_brush", reinterpret_cast<getter>(GridViewItemPresenter_get_CheckBrush), reinterpret_cast<setter>(GridViewItemPresenter_put_CheckBrush), nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_GridViewItemPresenter[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_GridViewItemPresenter) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_GridViewItemPresenter) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_GridViewItemPresenter) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_GridViewItemPresenter) },
        { }
    };

    static PyType_Spec type_spec_GridViewItemPresenter = {
        "winrt._winrt_microsoft_ui_xaml_controls_primitives.GridViewItemPresenter",
        sizeof(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>),
        0,
        Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,
        _type_slots_GridViewItemPresenter};

    static PyGetSetDef getset_GridViewItemPresenter_Static[] = {
        { "check_brush_property", reinterpret_cast<getter>(GridViewItemPresenter_get_CheckBrushProperty), nullptr, nullptr, nullptr },
        { "check_hint_brush_property", reinterpret_cast<getter>(GridViewItemPresenter_get_CheckHintBrushProperty), nullptr, nullptr, nullptr },
        { "check_selecting_brush_property", reinterpret_cast<getter>(GridViewItemPresenter_get_CheckSelectingBrushProperty), nullptr, nullptr, nullptr },
        { "content_margin_property", reinterpret_cast<getter>(GridViewItemPresenter_get_ContentMarginProperty), nullptr, nullptr, nullptr },
        { "disabled_opacity_property", reinterpret_cast<getter>(GridViewItemPresenter_get_DisabledOpacityProperty), nullptr, nullptr, nullptr },
        { "drag_background_property", reinterpret_cast<getter>(GridViewItemPresenter_get_DragBackgroundProperty), nullptr, nullptr, nullptr },
        { "drag_foreground_property", reinterpret_cast<getter>(GridViewItemPresenter_get_DragForegroundProperty), nullptr, nullptr, nullptr },
        { "drag_opacity_property", reinterpret_cast<getter>(GridViewItemPresenter_get_DragOpacityProperty), nullptr, nullptr, nullptr },
        { "focus_border_brush_property", reinterpret_cast<getter>(GridViewItemPresenter_get_FocusBorderBrushProperty), nullptr, nullptr, nullptr },
        { "grid_view_item_presenter_horizontal_content_alignment_property", reinterpret_cast<getter>(GridViewItemPresenter_get_GridViewItemPresenterHorizontalContentAlignmentProperty), nullptr, nullptr, nullptr },
        { "grid_view_item_presenter_padding_property", reinterpret_cast<getter>(GridViewItemPresenter_get_GridViewItemPresenterPaddingProperty), nullptr, nullptr, nullptr },
        { "grid_view_item_presenter_vertical_content_alignment_property", reinterpret_cast<getter>(GridViewItemPresenter_get_GridViewItemPresenterVerticalContentAlignmentProperty), nullptr, nullptr, nullptr },
        { "placeholder_background_property", reinterpret_cast<getter>(GridViewItemPresenter_get_PlaceholderBackgroundProperty), nullptr, nullptr, nullptr },
        { "pointer_over_background_margin_property", reinterpret_cast<getter>(GridViewItemPresenter_get_PointerOverBackgroundMarginProperty), nullptr, nullptr, nullptr },
        { "pointer_over_background_property", reinterpret_cast<getter>(GridViewItemPresenter_get_PointerOverBackgroundProperty), nullptr, nullptr, nullptr },
        { "reorder_hint_offset_property", reinterpret_cast<getter>(GridViewItemPresenter_get_ReorderHintOffsetProperty), nullptr, nullptr, nullptr },
        { "selected_background_property", reinterpret_cast<getter>(GridViewItemPresenter_get_SelectedBackgroundProperty), nullptr, nullptr, nullptr },
        { "selected_border_thickness_property", reinterpret_cast<getter>(GridViewItemPresenter_get_SelectedBorderThicknessProperty), nullptr, nullptr, nullptr },
        { "selected_foreground_property", reinterpret_cast<getter>(GridViewItemPresenter_get_SelectedForegroundProperty), nullptr, nullptr, nullptr },
        { "selected_pointer_over_background_property", reinterpret_cast<getter>(GridViewItemPresenter_get_SelectedPointerOverBackgroundProperty), nullptr, nullptr, nullptr },
        { "selected_pointer_over_border_brush_property", reinterpret_cast<getter>(GridViewItemPresenter_get_SelectedPointerOverBorderBrushProperty), nullptr, nullptr, nullptr },
        { "selection_check_mark_visual_enabled_property", reinterpret_cast<getter>(GridViewItemPresenter_get_SelectionCheckMarkVisualEnabledProperty), nullptr, nullptr, nullptr },
        { }
    };

    static PyMethodDef methods_GridViewItemPresenter_Static[] = {
        { }
    };

    static PyType_Slot type_slots_GridViewItemPresenter_Static[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_GridViewItemPresenter_Static) },
        { Py_tp_methods, reinterpret_cast<void*>(methods_GridViewItemPresenter_Static) },
        { }
    };

    static PyType_Spec type_spec_GridViewItemPresenter_Static =
    {
        "winrt._winrt_microsoft_ui_xaml_controls_primitives.GridViewItemPresenter_Static",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,
        type_slots_GridViewItemPresenter_Static
    };

    // ----- GridViewItemTemplateSettings class --------------------

    static PyObject* _new_GridViewItemTemplateSettings(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Microsoft::UI::Xaml::Controls::Primitives::GridViewItemTemplateSettings>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Microsoft::UI::Xaml::Controls::Primitives::GridViewItemTemplateSettings>::type_name);
        return nullptr;
    }

    static void _dealloc_GridViewItemTemplateSettings(py::wrapper::Microsoft::UI::Xaml::Controls::Primitives::GridViewItemTemplateSettings* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* GridViewItemTemplateSettings_get_DragItemsCount(py::wrapper::Microsoft::UI::Xaml::Controls::Primitives::GridViewItemTemplateSettings* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.GridViewItemTemplateSettings", L"DragItemsCount");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.DragItemsCount();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_GridViewItemTemplateSettings(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Microsoft::UI::Xaml::Controls::Primitives::GridViewItemTemplateSettings>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_GridViewItemTemplateSettings(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Microsoft::UI::Xaml::Controls::Primitives::GridViewItemTemplateSettings>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_GridViewItemTemplateSettings[] = {
        { "_assign_array_", _assign_array_GridViewItemTemplateSettings, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_GridViewItemTemplateSettings), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_GridViewItemTemplateSettings[] = {
        { "drag_items_count", reinterpret_cast<getter>(GridViewItemTemplateSettings_get_DragItemsCount), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_GridViewItemTemplateSettings[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_GridViewItemTemplateSettings) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_GridViewItemTemplateSettings) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_GridViewItemTemplateSettings) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_GridViewItemTemplateSettings) },
        { }
    };

    static PyType_Spec type_spec_GridViewItemTemplateSettings = {
        "winrt._winrt_microsoft_ui_xaml_controls_primitives.GridViewItemTemplateSettings",
        sizeof(py::wrapper::Microsoft::UI::Xaml::Controls::Primitives::GridViewItemTemplateSettings),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_GridViewItemTemplateSettings};

    // ----- InfoBarPanel class --------------------

    struct PyWinrtInfoBarPanel;
    using BasePyWinrtInfoBarPanel = winrt::Microsoft::UI::Xaml::Controls::Primitives::InfoBarPanelT<PyWinrtInfoBarPanel, py::IPywinrtObject>;

    struct PyWinrtInfoBarPanel : py::py_obj_ref, BasePyWinrtInfoBarPanel
    {
        PyWinrtInfoBarPanel(PyObject* py_obj) : py::py_obj_ref(py_obj), BasePyWinrtInfoBarPanel() {}

        int32_t __stdcall GetPyObject(PyObject*& obj) override
        {
            obj = py::py_obj_ref::get_py_obj();
            return 0;
        }

        int32_t __stdcall GetComposableInner(winrt::Windows::Foundation::IInspectable& inner) override
        {
            inner = m_inner;
            return winrt::impl::error_ok;
        }

        static void toggle_reference(PyWinrtInfoBarPanel* instance, bool is_last_reference)
        {
            py::py_obj_ref::toggle_reference(instance, is_last_reference);
        }

        int32_t query_interface_tearoff(winrt::guid const& id, void** result) const noexcept override
        {
            return py::py_obj_ref::query_interface_tearoff(id, result);
        }
    };

    static PyObject* _new_InfoBarPanel(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);

        auto self_type = get_python_type_for<winrt::Microsoft::UI::Xaml::Controls::Primitives::InfoBarPanel>();
        if (!self_type)
        {
            return nullptr;
        }

        if (arg_count == 0)
        {
            try
            {
                if (type != self_type)
                {
                    py::pyobj_handle self{type->tp_alloc(type, 0)};
                    if (!self)
                    {
                        return nullptr;
                    }

                    std::construct_at(&reinterpret_cast<py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>*>(self.get())->obj, nullptr);

                    auto obj_impl = winrt::make_self<PyWinrtInfoBarPanel>(self.get());

                    auto obj = py::make_py_obj<PyWinrtInfoBarPanel>(obj_impl, type, self.get());
                    if (!obj)
                    {
                        return nullptr;
                    }

                    reinterpret_cast<py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>*>(self.get())->obj = std::move(obj);

                    return self.detach();
                }

                winrt::Microsoft::UI::Xaml::Controls::Primitives::InfoBarPanel instance{};
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_InfoBarPanel(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* InfoBarPanel_GetHorizontalOrientationMargin(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Xaml.Controls.Primitives.InfoBarPanel", L"GetHorizontalOrientationMargin", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Microsoft::UI::Xaml::DependencyObject>(args, 0);

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return winrt::Microsoft::UI::Xaml::Controls::Primitives::InfoBarPanel::GetHorizontalOrientationMargin(param0);
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* InfoBarPanel_GetVerticalOrientationMargin(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Xaml.Controls.Primitives.InfoBarPanel", L"GetVerticalOrientationMargin", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Microsoft::UI::Xaml::DependencyObject>(args, 0);

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return winrt::Microsoft::UI::Xaml::Controls::Primitives::InfoBarPanel::GetVerticalOrientationMargin(param0);
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* InfoBarPanel_SetHorizontalOrientationMargin(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Xaml.Controls.Primitives.InfoBarPanel", L"SetHorizontalOrientationMargin", 2);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(2);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Microsoft::UI::Xaml::DependencyObject>(args, 0);
                auto param1 = py::convert_to<winrt::Microsoft::UI::Xaml::Thickness>(args, 1);

                {
                    auto _gil = release_gil();
                    winrt::Microsoft::UI::Xaml::Controls::Primitives::InfoBarPanel::SetHorizontalOrientationMargin(param0, param1);
                }

                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* InfoBarPanel_SetVerticalOrientationMargin(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Xaml.Controls.Primitives.InfoBarPanel", L"SetVerticalOrientationMargin", 2);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(2);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Microsoft::UI::Xaml::DependencyObject>(args, 0);
                auto param1 = py::convert_to<winrt::Microsoft::UI::Xaml::Thickness>(args, 1);

                {
                    auto _gil = release_gil();
                    winrt::Microsoft::UI::Xaml::Controls::Primitives::InfoBarPanel::SetVerticalOrientationMargin(param0, param1);
                }

                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* InfoBarPanel_get_VerticalOrientationPadding(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.InfoBarPanel", L"VerticalOrientationPadding");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::Primitives::InfoBarPanel>().VerticalOrientationPadding();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int InfoBarPanel_put_VerticalOrientationPadding(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.InfoBarPanel", L"VerticalOrientationPadding");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Microsoft::UI::Xaml::Thickness>(arg);

            {
                auto _gil = release_gil();
                self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::Primitives::InfoBarPanel>().VerticalOrientationPadding(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* InfoBarPanel_get_HorizontalOrientationPadding(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.InfoBarPanel", L"HorizontalOrientationPadding");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::Primitives::InfoBarPanel>().HorizontalOrientationPadding();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int InfoBarPanel_put_HorizontalOrientationPadding(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.InfoBarPanel", L"HorizontalOrientationPadding");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Microsoft::UI::Xaml::Thickness>(arg);

            {
                auto _gil = release_gil();
                self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::Primitives::InfoBarPanel>().HorizontalOrientationPadding(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* InfoBarPanel_get_HorizontalOrientationMarginProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.InfoBarPanel", L"HorizontalOrientationMarginProperty");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return winrt::Microsoft::UI::Xaml::Controls::Primitives::InfoBarPanel::HorizontalOrientationMarginProperty();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* InfoBarPanel_get_HorizontalOrientationPaddingProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.InfoBarPanel", L"HorizontalOrientationPaddingProperty");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return winrt::Microsoft::UI::Xaml::Controls::Primitives::InfoBarPanel::HorizontalOrientationPaddingProperty();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* InfoBarPanel_get_VerticalOrientationMarginProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.InfoBarPanel", L"VerticalOrientationMarginProperty");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return winrt::Microsoft::UI::Xaml::Controls::Primitives::InfoBarPanel::VerticalOrientationMarginProperty();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* InfoBarPanel_get_VerticalOrientationPaddingProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.InfoBarPanel", L"VerticalOrientationPaddingProperty");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return winrt::Microsoft::UI::Xaml::Controls::Primitives::InfoBarPanel::VerticalOrientationPaddingProperty();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_InfoBarPanel(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Microsoft::UI::Xaml::Controls::Primitives::InfoBarPanel>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_InfoBarPanel(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Microsoft::UI::Xaml::Controls::Primitives::InfoBarPanel>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_InfoBarPanel[] = {
        { "_assign_array_", _assign_array_InfoBarPanel, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_InfoBarPanel), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_InfoBarPanel[] = {
        { "vertical_orientation_padding", reinterpret_cast<getter>(InfoBarPanel_get_VerticalOrientationPadding), reinterpret_cast<setter>(InfoBarPanel_put_VerticalOrientationPadding), nullptr, nullptr },
        { "horizontal_orientation_padding", reinterpret_cast<getter>(InfoBarPanel_get_HorizontalOrientationPadding), reinterpret_cast<setter>(InfoBarPanel_put_HorizontalOrientationPadding), nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_InfoBarPanel[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_InfoBarPanel) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_InfoBarPanel) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_InfoBarPanel) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_InfoBarPanel) },
        { }
    };

    static PyType_Spec type_spec_InfoBarPanel = {
        "winrt._winrt_microsoft_ui_xaml_controls_primitives.InfoBarPanel",
        sizeof(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>),
        0,
        Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,
        _type_slots_InfoBarPanel};

    static PyGetSetDef getset_InfoBarPanel_Static[] = {
        { "horizontal_orientation_margin_property", reinterpret_cast<getter>(InfoBarPanel_get_HorizontalOrientationMarginProperty), nullptr, nullptr, nullptr },
        { "horizontal_orientation_padding_property", reinterpret_cast<getter>(InfoBarPanel_get_HorizontalOrientationPaddingProperty), nullptr, nullptr, nullptr },
        { "vertical_orientation_margin_property", reinterpret_cast<getter>(InfoBarPanel_get_VerticalOrientationMarginProperty), nullptr, nullptr, nullptr },
        { "vertical_orientation_padding_property", reinterpret_cast<getter>(InfoBarPanel_get_VerticalOrientationPaddingProperty), nullptr, nullptr, nullptr },
        { }
    };

    static PyMethodDef methods_InfoBarPanel_Static[] = {
        { "get_horizontal_orientation_margin", reinterpret_cast<PyCFunction>(InfoBarPanel_GetHorizontalOrientationMargin), METH_VARARGS, nullptr },
        { "get_vertical_orientation_margin", reinterpret_cast<PyCFunction>(InfoBarPanel_GetVerticalOrientationMargin), METH_VARARGS, nullptr },
        { "set_horizontal_orientation_margin", reinterpret_cast<PyCFunction>(InfoBarPanel_SetHorizontalOrientationMargin), METH_VARARGS, nullptr },
        { "set_vertical_orientation_margin", reinterpret_cast<PyCFunction>(InfoBarPanel_SetVerticalOrientationMargin), METH_VARARGS, nullptr },
        { }
    };

    static PyType_Slot type_slots_InfoBarPanel_Static[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_InfoBarPanel_Static) },
        { Py_tp_methods, reinterpret_cast<void*>(methods_InfoBarPanel_Static) },
        { }
    };

    static PyType_Spec type_spec_InfoBarPanel_Static =
    {
        "winrt._winrt_microsoft_ui_xaml_controls_primitives.InfoBarPanel_Static",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,
        type_slots_InfoBarPanel_Static
    };

    // ----- ItemsChangedEventArgs class --------------------

    static PyObject* _new_ItemsChangedEventArgs(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Microsoft::UI::Xaml::Controls::Primitives::ItemsChangedEventArgs>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Microsoft::UI::Xaml::Controls::Primitives::ItemsChangedEventArgs>::type_name);
        return nullptr;
    }

    static void _dealloc_ItemsChangedEventArgs(py::wrapper::Microsoft::UI::Xaml::Controls::Primitives::ItemsChangedEventArgs* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* ItemsChangedEventArgs_get_Action(py::wrapper::Microsoft::UI::Xaml::Controls::Primitives::ItemsChangedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.ItemsChangedEventArgs", L"Action");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Action();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ItemsChangedEventArgs_get_ItemCount(py::wrapper::Microsoft::UI::Xaml::Controls::Primitives::ItemsChangedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.ItemsChangedEventArgs", L"ItemCount");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.ItemCount();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ItemsChangedEventArgs_get_ItemUICount(py::wrapper::Microsoft::UI::Xaml::Controls::Primitives::ItemsChangedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.ItemsChangedEventArgs", L"ItemUICount");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.ItemUICount();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ItemsChangedEventArgs_get_OldPosition(py::wrapper::Microsoft::UI::Xaml::Controls::Primitives::ItemsChangedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.ItemsChangedEventArgs", L"OldPosition");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.OldPosition();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ItemsChangedEventArgs_get_Position(py::wrapper::Microsoft::UI::Xaml::Controls::Primitives::ItemsChangedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.ItemsChangedEventArgs", L"Position");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Position();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_ItemsChangedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Microsoft::UI::Xaml::Controls::Primitives::ItemsChangedEventArgs>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_ItemsChangedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Microsoft::UI::Xaml::Controls::Primitives::ItemsChangedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_ItemsChangedEventArgs[] = {
        { "_assign_array_", _assign_array_ItemsChangedEventArgs, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_ItemsChangedEventArgs), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_ItemsChangedEventArgs[] = {
        { "action", reinterpret_cast<getter>(ItemsChangedEventArgs_get_Action), nullptr, nullptr, nullptr },
        { "item_count", reinterpret_cast<getter>(ItemsChangedEventArgs_get_ItemCount), nullptr, nullptr, nullptr },
        { "item_ui_count", reinterpret_cast<getter>(ItemsChangedEventArgs_get_ItemUICount), nullptr, nullptr, nullptr },
        { "old_position", reinterpret_cast<getter>(ItemsChangedEventArgs_get_OldPosition), nullptr, nullptr, nullptr },
        { "position", reinterpret_cast<getter>(ItemsChangedEventArgs_get_Position), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_ItemsChangedEventArgs[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_ItemsChangedEventArgs) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_ItemsChangedEventArgs) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_ItemsChangedEventArgs) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_ItemsChangedEventArgs) },
        { }
    };

    static PyType_Spec type_spec_ItemsChangedEventArgs = {
        "winrt._winrt_microsoft_ui_xaml_controls_primitives.ItemsChangedEventArgs",
        sizeof(py::wrapper::Microsoft::UI::Xaml::Controls::Primitives::ItemsChangedEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_ItemsChangedEventArgs};

    // ----- JumpListItemBackgroundConverter class --------------------

    static PyObject* _new_JumpListItemBackgroundConverter(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 0)
        {
            try
            {
                winrt::Microsoft::UI::Xaml::Controls::Primitives::JumpListItemBackgroundConverter instance{};
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_JumpListItemBackgroundConverter(py::wrapper::Microsoft::UI::Xaml::Controls::Primitives::JumpListItemBackgroundConverter* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* JumpListItemBackgroundConverter_Convert(py::wrapper::Microsoft::UI::Xaml::Controls::Primitives::JumpListItemBackgroundConverter* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 4)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Xaml.Controls.Primitives.JumpListItemBackgroundConverter", L"Convert", 4);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(4);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Foundation::IInspectable>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::UI::Xaml::Interop::TypeName>(args, 1);
                auto param2 = py::convert_to<winrt::Windows::Foundation::IInspectable>(args, 2);
                auto param3 = py::convert_to<winrt::hstring>(args, 3);

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return self->obj.Convert(param0, param1, param2, param3);
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* JumpListItemBackgroundConverter_ConvertBack(py::wrapper::Microsoft::UI::Xaml::Controls::Primitives::JumpListItemBackgroundConverter* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 4)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Xaml.Controls.Primitives.JumpListItemBackgroundConverter", L"ConvertBack", 4);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(4);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Foundation::IInspectable>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::UI::Xaml::Interop::TypeName>(args, 1);
                auto param2 = py::convert_to<winrt::Windows::Foundation::IInspectable>(args, 2);
                auto param3 = py::convert_to<winrt::hstring>(args, 3);

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return self->obj.ConvertBack(param0, param1, param2, param3);
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* JumpListItemBackgroundConverter_get_Enabled(py::wrapper::Microsoft::UI::Xaml::Controls::Primitives::JumpListItemBackgroundConverter* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.JumpListItemBackgroundConverter", L"Enabled");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Enabled();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int JumpListItemBackgroundConverter_put_Enabled(py::wrapper::Microsoft::UI::Xaml::Controls::Primitives::JumpListItemBackgroundConverter* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.JumpListItemBackgroundConverter", L"Enabled");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Microsoft::UI::Xaml::Media::Brush>(arg);

            {
                auto _gil = release_gil();
                self->obj.Enabled(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* JumpListItemBackgroundConverter_get_Disabled(py::wrapper::Microsoft::UI::Xaml::Controls::Primitives::JumpListItemBackgroundConverter* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.JumpListItemBackgroundConverter", L"Disabled");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Disabled();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int JumpListItemBackgroundConverter_put_Disabled(py::wrapper::Microsoft::UI::Xaml::Controls::Primitives::JumpListItemBackgroundConverter* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.JumpListItemBackgroundConverter", L"Disabled");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Microsoft::UI::Xaml::Media::Brush>(arg);

            {
                auto _gil = release_gil();
                self->obj.Disabled(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* JumpListItemBackgroundConverter_get_DisabledProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.JumpListItemBackgroundConverter", L"DisabledProperty");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return winrt::Microsoft::UI::Xaml::Controls::Primitives::JumpListItemBackgroundConverter::DisabledProperty();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* JumpListItemBackgroundConverter_get_EnabledProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.JumpListItemBackgroundConverter", L"EnabledProperty");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return winrt::Microsoft::UI::Xaml::Controls::Primitives::JumpListItemBackgroundConverter::EnabledProperty();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_JumpListItemBackgroundConverter(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Microsoft::UI::Xaml::Controls::Primitives::JumpListItemBackgroundConverter>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_JumpListItemBackgroundConverter(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Microsoft::UI::Xaml::Controls::Primitives::JumpListItemBackgroundConverter>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_JumpListItemBackgroundConverter[] = {
        { "convert", reinterpret_cast<PyCFunction>(JumpListItemBackgroundConverter_Convert), METH_VARARGS, nullptr },
        { "convert_back", reinterpret_cast<PyCFunction>(JumpListItemBackgroundConverter_ConvertBack), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_JumpListItemBackgroundConverter, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_JumpListItemBackgroundConverter), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_JumpListItemBackgroundConverter[] = {
        { "enabled", reinterpret_cast<getter>(JumpListItemBackgroundConverter_get_Enabled), reinterpret_cast<setter>(JumpListItemBackgroundConverter_put_Enabled), nullptr, nullptr },
        { "disabled", reinterpret_cast<getter>(JumpListItemBackgroundConverter_get_Disabled), reinterpret_cast<setter>(JumpListItemBackgroundConverter_put_Disabled), nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_JumpListItemBackgroundConverter[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_JumpListItemBackgroundConverter) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_JumpListItemBackgroundConverter) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_JumpListItemBackgroundConverter) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_JumpListItemBackgroundConverter) },
        { }
    };

    static PyType_Spec type_spec_JumpListItemBackgroundConverter = {
        "winrt._winrt_microsoft_ui_xaml_controls_primitives.JumpListItemBackgroundConverter",
        sizeof(py::wrapper::Microsoft::UI::Xaml::Controls::Primitives::JumpListItemBackgroundConverter),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_JumpListItemBackgroundConverter};

    static PyGetSetDef getset_JumpListItemBackgroundConverter_Static[] = {
        { "disabled_property", reinterpret_cast<getter>(JumpListItemBackgroundConverter_get_DisabledProperty), nullptr, nullptr, nullptr },
        { "enabled_property", reinterpret_cast<getter>(JumpListItemBackgroundConverter_get_EnabledProperty), nullptr, nullptr, nullptr },
        { }
    };

    static PyMethodDef methods_JumpListItemBackgroundConverter_Static[] = {
        { }
    };

    static PyType_Slot type_slots_JumpListItemBackgroundConverter_Static[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_JumpListItemBackgroundConverter_Static) },
        { Py_tp_methods, reinterpret_cast<void*>(methods_JumpListItemBackgroundConverter_Static) },
        { }
    };

    static PyType_Spec type_spec_JumpListItemBackgroundConverter_Static =
    {
        "winrt._winrt_microsoft_ui_xaml_controls_primitives.JumpListItemBackgroundConverter_Static",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT,
        type_slots_JumpListItemBackgroundConverter_Static
    };

    // ----- JumpListItemForegroundConverter class --------------------

    static PyObject* _new_JumpListItemForegroundConverter(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 0)
        {
            try
            {
                winrt::Microsoft::UI::Xaml::Controls::Primitives::JumpListItemForegroundConverter instance{};
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_JumpListItemForegroundConverter(py::wrapper::Microsoft::UI::Xaml::Controls::Primitives::JumpListItemForegroundConverter* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* JumpListItemForegroundConverter_Convert(py::wrapper::Microsoft::UI::Xaml::Controls::Primitives::JumpListItemForegroundConverter* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 4)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Xaml.Controls.Primitives.JumpListItemForegroundConverter", L"Convert", 4);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(4);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Foundation::IInspectable>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::UI::Xaml::Interop::TypeName>(args, 1);
                auto param2 = py::convert_to<winrt::Windows::Foundation::IInspectable>(args, 2);
                auto param3 = py::convert_to<winrt::hstring>(args, 3);

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return self->obj.Convert(param0, param1, param2, param3);
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* JumpListItemForegroundConverter_ConvertBack(py::wrapper::Microsoft::UI::Xaml::Controls::Primitives::JumpListItemForegroundConverter* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 4)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Xaml.Controls.Primitives.JumpListItemForegroundConverter", L"ConvertBack", 4);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(4);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Foundation::IInspectable>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::UI::Xaml::Interop::TypeName>(args, 1);
                auto param2 = py::convert_to<winrt::Windows::Foundation::IInspectable>(args, 2);
                auto param3 = py::convert_to<winrt::hstring>(args, 3);

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return self->obj.ConvertBack(param0, param1, param2, param3);
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* JumpListItemForegroundConverter_get_Enabled(py::wrapper::Microsoft::UI::Xaml::Controls::Primitives::JumpListItemForegroundConverter* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.JumpListItemForegroundConverter", L"Enabled");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Enabled();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int JumpListItemForegroundConverter_put_Enabled(py::wrapper::Microsoft::UI::Xaml::Controls::Primitives::JumpListItemForegroundConverter* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.JumpListItemForegroundConverter", L"Enabled");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Microsoft::UI::Xaml::Media::Brush>(arg);

            {
                auto _gil = release_gil();
                self->obj.Enabled(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* JumpListItemForegroundConverter_get_Disabled(py::wrapper::Microsoft::UI::Xaml::Controls::Primitives::JumpListItemForegroundConverter* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.JumpListItemForegroundConverter", L"Disabled");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Disabled();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int JumpListItemForegroundConverter_put_Disabled(py::wrapper::Microsoft::UI::Xaml::Controls::Primitives::JumpListItemForegroundConverter* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.JumpListItemForegroundConverter", L"Disabled");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Microsoft::UI::Xaml::Media::Brush>(arg);

            {
                auto _gil = release_gil();
                self->obj.Disabled(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* JumpListItemForegroundConverter_get_DisabledProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.JumpListItemForegroundConverter", L"DisabledProperty");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return winrt::Microsoft::UI::Xaml::Controls::Primitives::JumpListItemForegroundConverter::DisabledProperty();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* JumpListItemForegroundConverter_get_EnabledProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.JumpListItemForegroundConverter", L"EnabledProperty");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return winrt::Microsoft::UI::Xaml::Controls::Primitives::JumpListItemForegroundConverter::EnabledProperty();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_JumpListItemForegroundConverter(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Microsoft::UI::Xaml::Controls::Primitives::JumpListItemForegroundConverter>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_JumpListItemForegroundConverter(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Microsoft::UI::Xaml::Controls::Primitives::JumpListItemForegroundConverter>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_JumpListItemForegroundConverter[] = {
        { "convert", reinterpret_cast<PyCFunction>(JumpListItemForegroundConverter_Convert), METH_VARARGS, nullptr },
        { "convert_back", reinterpret_cast<PyCFunction>(JumpListItemForegroundConverter_ConvertBack), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_JumpListItemForegroundConverter, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_JumpListItemForegroundConverter), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_JumpListItemForegroundConverter[] = {
        { "enabled", reinterpret_cast<getter>(JumpListItemForegroundConverter_get_Enabled), reinterpret_cast<setter>(JumpListItemForegroundConverter_put_Enabled), nullptr, nullptr },
        { "disabled", reinterpret_cast<getter>(JumpListItemForegroundConverter_get_Disabled), reinterpret_cast<setter>(JumpListItemForegroundConverter_put_Disabled), nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_JumpListItemForegroundConverter[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_JumpListItemForegroundConverter) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_JumpListItemForegroundConverter) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_JumpListItemForegroundConverter) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_JumpListItemForegroundConverter) },
        { }
    };

    static PyType_Spec type_spec_JumpListItemForegroundConverter = {
        "winrt._winrt_microsoft_ui_xaml_controls_primitives.JumpListItemForegroundConverter",
        sizeof(py::wrapper::Microsoft::UI::Xaml::Controls::Primitives::JumpListItemForegroundConverter),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_JumpListItemForegroundConverter};

    static PyGetSetDef getset_JumpListItemForegroundConverter_Static[] = {
        { "disabled_property", reinterpret_cast<getter>(JumpListItemForegroundConverter_get_DisabledProperty), nullptr, nullptr, nullptr },
        { "enabled_property", reinterpret_cast<getter>(JumpListItemForegroundConverter_get_EnabledProperty), nullptr, nullptr, nullptr },
        { }
    };

    static PyMethodDef methods_JumpListItemForegroundConverter_Static[] = {
        { }
    };

    static PyType_Slot type_slots_JumpListItemForegroundConverter_Static[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_JumpListItemForegroundConverter_Static) },
        { Py_tp_methods, reinterpret_cast<void*>(methods_JumpListItemForegroundConverter_Static) },
        { }
    };

    static PyType_Spec type_spec_JumpListItemForegroundConverter_Static =
    {
        "winrt._winrt_microsoft_ui_xaml_controls_primitives.JumpListItemForegroundConverter_Static",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT,
        type_slots_JumpListItemForegroundConverter_Static
    };

    // ----- LayoutInformation class --------------------

    static PyObject* _new_LayoutInformation(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Microsoft::UI::Xaml::Controls::Primitives::LayoutInformation>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Microsoft::UI::Xaml::Controls::Primitives::LayoutInformation>::type_name);
        return nullptr;
    }

    static void _dealloc_LayoutInformation(py::wrapper::Microsoft::UI::Xaml::Controls::Primitives::LayoutInformation* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* LayoutInformation_GetAvailableSize(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Xaml.Controls.Primitives.LayoutInformation", L"GetAvailableSize", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Microsoft::UI::Xaml::UIElement>(args, 0);

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return winrt::Microsoft::UI::Xaml::Controls::Primitives::LayoutInformation::GetAvailableSize(param0);
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* LayoutInformation_GetLayoutExceptionElement(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Xaml.Controls.Primitives.LayoutInformation", L"GetLayoutExceptionElement", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Foundation::IInspectable>(args, 0);

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return winrt::Microsoft::UI::Xaml::Controls::Primitives::LayoutInformation::GetLayoutExceptionElement(param0);
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* LayoutInformation_GetLayoutSlot(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Xaml.Controls.Primitives.LayoutInformation", L"GetLayoutSlot", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Microsoft::UI::Xaml::FrameworkElement>(args, 0);

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return winrt::Microsoft::UI::Xaml::Controls::Primitives::LayoutInformation::GetLayoutSlot(param0);
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* _assign_array_LayoutInformation(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Microsoft::UI::Xaml::Controls::Primitives::LayoutInformation>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_LayoutInformation(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Microsoft::UI::Xaml::Controls::Primitives::LayoutInformation>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_LayoutInformation[] = {
        { "_assign_array_", _assign_array_LayoutInformation, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_LayoutInformation), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_LayoutInformation[] = {
        { }
    };

    static PyType_Slot _type_slots_LayoutInformation[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_LayoutInformation) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_LayoutInformation) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_LayoutInformation) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_LayoutInformation) },
        { }
    };

    static PyType_Spec type_spec_LayoutInformation = {
        "winrt._winrt_microsoft_ui_xaml_controls_primitives.LayoutInformation",
        sizeof(py::wrapper::Microsoft::UI::Xaml::Controls::Primitives::LayoutInformation),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_LayoutInformation};

    static PyGetSetDef getset_LayoutInformation_Static[] = {
        { }
    };

    static PyMethodDef methods_LayoutInformation_Static[] = {
        { "get_available_size", reinterpret_cast<PyCFunction>(LayoutInformation_GetAvailableSize), METH_VARARGS, nullptr },
        { "get_layout_exception_element", reinterpret_cast<PyCFunction>(LayoutInformation_GetLayoutExceptionElement), METH_VARARGS, nullptr },
        { "get_layout_slot", reinterpret_cast<PyCFunction>(LayoutInformation_GetLayoutSlot), METH_VARARGS, nullptr },
        { }
    };

    static PyType_Slot type_slots_LayoutInformation_Static[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_LayoutInformation_Static) },
        { Py_tp_methods, reinterpret_cast<void*>(methods_LayoutInformation_Static) },
        { }
    };

    static PyType_Spec type_spec_LayoutInformation_Static =
    {
        "winrt._winrt_microsoft_ui_xaml_controls_primitives.LayoutInformation_Static",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT,
        type_slots_LayoutInformation_Static
    };

    // ----- ListViewItemPresenter class --------------------

    struct PyWinrtListViewItemPresenter;
    using BasePyWinrtListViewItemPresenter = winrt::Microsoft::UI::Xaml::Controls::Primitives::ListViewItemPresenterT<PyWinrtListViewItemPresenter, py::IPywinrtObject>;

    struct PyWinrtListViewItemPresenter : py::py_obj_ref, BasePyWinrtListViewItemPresenter
    {
        PyWinrtListViewItemPresenter(PyObject* py_obj) : py::py_obj_ref(py_obj), BasePyWinrtListViewItemPresenter() {}

        int32_t __stdcall GetPyObject(PyObject*& obj) override
        {
            obj = py::py_obj_ref::get_py_obj();
            return 0;
        }

        int32_t __stdcall GetComposableInner(winrt::Windows::Foundation::IInspectable& inner) override
        {
            inner = m_inner;
            return winrt::impl::error_ok;
        }

        static void toggle_reference(PyWinrtListViewItemPresenter* instance, bool is_last_reference)
        {
            py::py_obj_ref::toggle_reference(instance, is_last_reference);
        }

        int32_t query_interface_tearoff(winrt::guid const& id, void** result) const noexcept override
        {
            return py::py_obj_ref::query_interface_tearoff(id, result);
        }
    };

    static PyObject* _new_ListViewItemPresenter(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);

        auto self_type = get_python_type_for<winrt::Microsoft::UI::Xaml::Controls::Primitives::ListViewItemPresenter>();
        if (!self_type)
        {
            return nullptr;
        }

        if (arg_count == 0)
        {
            try
            {
                if (type != self_type)
                {
                    py::pyobj_handle self{type->tp_alloc(type, 0)};
                    if (!self)
                    {
                        return nullptr;
                    }

                    std::construct_at(&reinterpret_cast<py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>*>(self.get())->obj, nullptr);

                    auto obj_impl = winrt::make_self<PyWinrtListViewItemPresenter>(self.get());

                    auto obj = py::make_py_obj<PyWinrtListViewItemPresenter>(obj_impl, type, self.get());
                    if (!obj)
                    {
                        return nullptr;
                    }

                    reinterpret_cast<py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>*>(self.get())->obj = std::move(obj);

                    return self.detach();
                }

                winrt::Microsoft::UI::Xaml::Controls::Primitives::ListViewItemPresenter instance{};
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_ListViewItemPresenter(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* ListViewItemPresenter_get_ListViewItemPresenterVerticalContentAlignment(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.ListViewItemPresenter", L"ListViewItemPresenterVerticalContentAlignment");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::Primitives::ListViewItemPresenter>().ListViewItemPresenterVerticalContentAlignment();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ListViewItemPresenter_put_ListViewItemPresenterVerticalContentAlignment(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.ListViewItemPresenter", L"ListViewItemPresenterVerticalContentAlignment");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Microsoft::UI::Xaml::VerticalAlignment>(arg);

            {
                auto _gil = release_gil();
                self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::Primitives::ListViewItemPresenter>().ListViewItemPresenterVerticalContentAlignment(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ListViewItemPresenter_get_ListViewItemPresenterPadding(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.ListViewItemPresenter", L"ListViewItemPresenterPadding");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::Primitives::ListViewItemPresenter>().ListViewItemPresenterPadding();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ListViewItemPresenter_put_ListViewItemPresenterPadding(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.ListViewItemPresenter", L"ListViewItemPresenterPadding");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Microsoft::UI::Xaml::Thickness>(arg);

            {
                auto _gil = release_gil();
                self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::Primitives::ListViewItemPresenter>().ListViewItemPresenterPadding(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ListViewItemPresenter_get_ListViewItemPresenterHorizontalContentAlignment(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.ListViewItemPresenter", L"ListViewItemPresenterHorizontalContentAlignment");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::Primitives::ListViewItemPresenter>().ListViewItemPresenterHorizontalContentAlignment();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ListViewItemPresenter_put_ListViewItemPresenterHorizontalContentAlignment(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.ListViewItemPresenter", L"ListViewItemPresenterHorizontalContentAlignment");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Microsoft::UI::Xaml::HorizontalAlignment>(arg);

            {
                auto _gil = release_gil();
                self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::Primitives::ListViewItemPresenter>().ListViewItemPresenterHorizontalContentAlignment(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ListViewItemPresenter_get_FocusSecondaryBorderBrush(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.ListViewItemPresenter", L"FocusSecondaryBorderBrush");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::Primitives::ListViewItemPresenter>().FocusSecondaryBorderBrush();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ListViewItemPresenter_put_FocusSecondaryBorderBrush(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.ListViewItemPresenter", L"FocusSecondaryBorderBrush");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Microsoft::UI::Xaml::Media::Brush>(arg);

            {
                auto _gil = release_gil();
                self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::Primitives::ListViewItemPresenter>().FocusSecondaryBorderBrush(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ListViewItemPresenter_get_FocusBorderBrush(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.ListViewItemPresenter", L"FocusBorderBrush");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::Primitives::ListViewItemPresenter>().FocusBorderBrush();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ListViewItemPresenter_put_FocusBorderBrush(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.ListViewItemPresenter", L"FocusBorderBrush");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Microsoft::UI::Xaml::Media::Brush>(arg);

            {
                auto _gil = release_gil();
                self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::Primitives::ListViewItemPresenter>().FocusBorderBrush(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ListViewItemPresenter_get_DragOpacity(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.ListViewItemPresenter", L"DragOpacity");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::Primitives::ListViewItemPresenter>().DragOpacity();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ListViewItemPresenter_put_DragOpacity(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.ListViewItemPresenter", L"DragOpacity");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<double>(arg);

            {
                auto _gil = release_gil();
                self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::Primitives::ListViewItemPresenter>().DragOpacity(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ListViewItemPresenter_get_RevealBackground(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.ListViewItemPresenter", L"RevealBackground");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::Primitives::ListViewItemPresenter>().RevealBackground();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ListViewItemPresenter_put_RevealBackground(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.ListViewItemPresenter", L"RevealBackground");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Microsoft::UI::Xaml::Media::Brush>(arg);

            {
                auto _gil = release_gil();
                self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::Primitives::ListViewItemPresenter>().RevealBackground(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ListViewItemPresenter_get_DragBackground(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.ListViewItemPresenter", L"DragBackground");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::Primitives::ListViewItemPresenter>().DragBackground();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ListViewItemPresenter_put_DragBackground(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.ListViewItemPresenter", L"DragBackground");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Microsoft::UI::Xaml::Media::Brush>(arg);

            {
                auto _gil = release_gil();
                self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::Primitives::ListViewItemPresenter>().DragBackground(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ListViewItemPresenter_get_DisabledOpacity(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.ListViewItemPresenter", L"DisabledOpacity");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::Primitives::ListViewItemPresenter>().DisabledOpacity();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ListViewItemPresenter_put_DisabledOpacity(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.ListViewItemPresenter", L"DisabledOpacity");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<double>(arg);

            {
                auto _gil = release_gil();
                self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::Primitives::ListViewItemPresenter>().DisabledOpacity(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ListViewItemPresenter_get_ContentMargin(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.ListViewItemPresenter", L"ContentMargin");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::Primitives::ListViewItemPresenter>().ContentMargin();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ListViewItemPresenter_put_ContentMargin(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.ListViewItemPresenter", L"ContentMargin");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Microsoft::UI::Xaml::Thickness>(arg);

            {
                auto _gil = release_gil();
                self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::Primitives::ListViewItemPresenter>().ContentMargin(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ListViewItemPresenter_get_CheckSelectingBrush(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.ListViewItemPresenter", L"CheckSelectingBrush");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::Primitives::ListViewItemPresenter>().CheckSelectingBrush();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ListViewItemPresenter_put_CheckSelectingBrush(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.ListViewItemPresenter", L"CheckSelectingBrush");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Microsoft::UI::Xaml::Media::Brush>(arg);

            {
                auto _gil = release_gil();
                self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::Primitives::ListViewItemPresenter>().CheckSelectingBrush(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ListViewItemPresenter_get_CheckPressedBrush(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.ListViewItemPresenter", L"CheckPressedBrush");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::Primitives::ListViewItemPresenter>().CheckPressedBrush();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ListViewItemPresenter_put_CheckPressedBrush(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.ListViewItemPresenter", L"CheckPressedBrush");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Microsoft::UI::Xaml::Media::Brush>(arg);

            {
                auto _gil = release_gil();
                self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::Primitives::ListViewItemPresenter>().CheckPressedBrush(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ListViewItemPresenter_get_CheckMode(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.ListViewItemPresenter", L"CheckMode");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::Primitives::ListViewItemPresenter>().CheckMode();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ListViewItemPresenter_put_CheckMode(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.ListViewItemPresenter", L"CheckMode");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Microsoft::UI::Xaml::Controls::Primitives::ListViewItemPresenterCheckMode>(arg);

            {
                auto _gil = release_gil();
                self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::Primitives::ListViewItemPresenter>().CheckMode(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ListViewItemPresenter_get_CheckHintBrush(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.ListViewItemPresenter", L"CheckHintBrush");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::Primitives::ListViewItemPresenter>().CheckHintBrush();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ListViewItemPresenter_put_CheckHintBrush(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.ListViewItemPresenter", L"CheckHintBrush");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Microsoft::UI::Xaml::Media::Brush>(arg);

            {
                auto _gil = release_gil();
                self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::Primitives::ListViewItemPresenter>().CheckHintBrush(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ListViewItemPresenter_get_CheckBoxBorderBrush(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.ListViewItemPresenter", L"CheckBoxBorderBrush");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::Primitives::ListViewItemPresenter>().CheckBoxBorderBrush();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ListViewItemPresenter_put_CheckBoxBorderBrush(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.ListViewItemPresenter", L"CheckBoxBorderBrush");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Microsoft::UI::Xaml::Media::Brush>(arg);

            {
                auto _gil = release_gil();
                self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::Primitives::ListViewItemPresenter>().CheckBoxBorderBrush(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ListViewItemPresenter_get_CheckBrush(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.ListViewItemPresenter", L"CheckBrush");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::Primitives::ListViewItemPresenter>().CheckBrush();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ListViewItemPresenter_put_CheckBrush(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.ListViewItemPresenter", L"CheckBrush");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Microsoft::UI::Xaml::Media::Brush>(arg);

            {
                auto _gil = release_gil();
                self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::Primitives::ListViewItemPresenter>().CheckBrush(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ListViewItemPresenter_get_CheckBoxSelectedPressedBrush(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.ListViewItemPresenter", L"CheckBoxSelectedPressedBrush");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::Primitives::ListViewItemPresenter>().CheckBoxSelectedPressedBrush();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ListViewItemPresenter_put_CheckBoxSelectedPressedBrush(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.ListViewItemPresenter", L"CheckBoxSelectedPressedBrush");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Microsoft::UI::Xaml::Media::Brush>(arg);

            {
                auto _gil = release_gil();
                self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::Primitives::ListViewItemPresenter>().CheckBoxSelectedPressedBrush(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ListViewItemPresenter_get_CheckBoxSelectedPointerOverBrush(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.ListViewItemPresenter", L"CheckBoxSelectedPointerOverBrush");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::Primitives::ListViewItemPresenter>().CheckBoxSelectedPointerOverBrush();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ListViewItemPresenter_put_CheckBoxSelectedPointerOverBrush(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.ListViewItemPresenter", L"CheckBoxSelectedPointerOverBrush");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Microsoft::UI::Xaml::Media::Brush>(arg);

            {
                auto _gil = release_gil();
                self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::Primitives::ListViewItemPresenter>().CheckBoxSelectedPointerOverBrush(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ListViewItemPresenter_get_CheckBoxSelectedDisabledBrush(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.ListViewItemPresenter", L"CheckBoxSelectedDisabledBrush");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::Primitives::ListViewItemPresenter>().CheckBoxSelectedDisabledBrush();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ListViewItemPresenter_put_CheckBoxSelectedDisabledBrush(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.ListViewItemPresenter", L"CheckBoxSelectedDisabledBrush");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Microsoft::UI::Xaml::Media::Brush>(arg);

            {
                auto _gil = release_gil();
                self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::Primitives::ListViewItemPresenter>().CheckBoxSelectedDisabledBrush(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ListViewItemPresenter_get_CheckBoxSelectedBrush(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.ListViewItemPresenter", L"CheckBoxSelectedBrush");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::Primitives::ListViewItemPresenter>().CheckBoxSelectedBrush();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ListViewItemPresenter_put_CheckBoxSelectedBrush(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.ListViewItemPresenter", L"CheckBoxSelectedBrush");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Microsoft::UI::Xaml::Media::Brush>(arg);

            {
                auto _gil = release_gil();
                self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::Primitives::ListViewItemPresenter>().CheckBoxSelectedBrush(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ListViewItemPresenter_get_CheckBoxPressedBrush(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.ListViewItemPresenter", L"CheckBoxPressedBrush");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::Primitives::ListViewItemPresenter>().CheckBoxPressedBrush();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ListViewItemPresenter_put_CheckBoxPressedBrush(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.ListViewItemPresenter", L"CheckBoxPressedBrush");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Microsoft::UI::Xaml::Media::Brush>(arg);

            {
                auto _gil = release_gil();
                self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::Primitives::ListViewItemPresenter>().CheckBoxPressedBrush(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ListViewItemPresenter_get_SelectionCheckMarkVisualEnabled(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.ListViewItemPresenter", L"SelectionCheckMarkVisualEnabled");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::Primitives::ListViewItemPresenter>().SelectionCheckMarkVisualEnabled();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ListViewItemPresenter_put_SelectionCheckMarkVisualEnabled(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.ListViewItemPresenter", L"SelectionCheckMarkVisualEnabled");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<bool>(arg);

            {
                auto _gil = release_gil();
                self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::Primitives::ListViewItemPresenter>().SelectionCheckMarkVisualEnabled(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ListViewItemPresenter_get_CheckBoxPointerOverBrush(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.ListViewItemPresenter", L"CheckBoxPointerOverBrush");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::Primitives::ListViewItemPresenter>().CheckBoxPointerOverBrush();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ListViewItemPresenter_put_CheckBoxPointerOverBrush(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.ListViewItemPresenter", L"CheckBoxPointerOverBrush");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Microsoft::UI::Xaml::Media::Brush>(arg);

            {
                auto _gil = release_gil();
                self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::Primitives::ListViewItemPresenter>().CheckBoxPointerOverBrush(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ListViewItemPresenter_get_CheckBoxPointerOverBorderBrush(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.ListViewItemPresenter", L"CheckBoxPointerOverBorderBrush");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::Primitives::ListViewItemPresenter>().CheckBoxPointerOverBorderBrush();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ListViewItemPresenter_put_CheckBoxPointerOverBorderBrush(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.ListViewItemPresenter", L"CheckBoxPointerOverBorderBrush");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Microsoft::UI::Xaml::Media::Brush>(arg);

            {
                auto _gil = release_gil();
                self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::Primitives::ListViewItemPresenter>().CheckBoxPointerOverBorderBrush(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ListViewItemPresenter_get_CheckBoxDisabledBrush(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.ListViewItemPresenter", L"CheckBoxDisabledBrush");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::Primitives::ListViewItemPresenter>().CheckBoxDisabledBrush();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ListViewItemPresenter_put_CheckBoxDisabledBrush(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.ListViewItemPresenter", L"CheckBoxDisabledBrush");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Microsoft::UI::Xaml::Media::Brush>(arg);

            {
                auto _gil = release_gil();
                self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::Primitives::ListViewItemPresenter>().CheckBoxDisabledBrush(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ListViewItemPresenter_get_CheckBoxDisabledBorderBrush(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.ListViewItemPresenter", L"CheckBoxDisabledBorderBrush");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::Primitives::ListViewItemPresenter>().CheckBoxDisabledBorderBrush();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ListViewItemPresenter_put_CheckBoxDisabledBorderBrush(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.ListViewItemPresenter", L"CheckBoxDisabledBorderBrush");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Microsoft::UI::Xaml::Media::Brush>(arg);

            {
                auto _gil = release_gil();
                self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::Primitives::ListViewItemPresenter>().CheckBoxDisabledBorderBrush(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ListViewItemPresenter_get_CheckBoxCornerRadius(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.ListViewItemPresenter", L"CheckBoxCornerRadius");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::Primitives::ListViewItemPresenter>().CheckBoxCornerRadius();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ListViewItemPresenter_put_CheckBoxCornerRadius(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.ListViewItemPresenter", L"CheckBoxCornerRadius");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Microsoft::UI::Xaml::CornerRadius>(arg);

            {
                auto _gil = release_gil();
                self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::Primitives::ListViewItemPresenter>().CheckBoxCornerRadius(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ListViewItemPresenter_get_CheckBoxBrush(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.ListViewItemPresenter", L"CheckBoxBrush");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::Primitives::ListViewItemPresenter>().CheckBoxBrush();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ListViewItemPresenter_put_CheckBoxBrush(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.ListViewItemPresenter", L"CheckBoxBrush");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Microsoft::UI::Xaml::Media::Brush>(arg);

            {
                auto _gil = release_gil();
                self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::Primitives::ListViewItemPresenter>().CheckBoxBrush(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ListViewItemPresenter_get_CheckDisabledBrush(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.ListViewItemPresenter", L"CheckDisabledBrush");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::Primitives::ListViewItemPresenter>().CheckDisabledBrush();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ListViewItemPresenter_put_CheckDisabledBrush(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.ListViewItemPresenter", L"CheckDisabledBrush");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Microsoft::UI::Xaml::Media::Brush>(arg);

            {
                auto _gil = release_gil();
                self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::Primitives::ListViewItemPresenter>().CheckDisabledBrush(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ListViewItemPresenter_get_PlaceholderBackground(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.ListViewItemPresenter", L"PlaceholderBackground");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::Primitives::ListViewItemPresenter>().PlaceholderBackground();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ListViewItemPresenter_put_PlaceholderBackground(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.ListViewItemPresenter", L"PlaceholderBackground");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Microsoft::UI::Xaml::Media::Brush>(arg);

            {
                auto _gil = release_gil();
                self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::Primitives::ListViewItemPresenter>().PlaceholderBackground(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ListViewItemPresenter_get_SelectedDisabledBorderBrush(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.ListViewItemPresenter", L"SelectedDisabledBorderBrush");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::Primitives::ListViewItemPresenter>().SelectedDisabledBorderBrush();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ListViewItemPresenter_put_SelectedDisabledBorderBrush(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.ListViewItemPresenter", L"SelectedDisabledBorderBrush");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Microsoft::UI::Xaml::Media::Brush>(arg);

            {
                auto _gil = release_gil();
                self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::Primitives::ListViewItemPresenter>().SelectedDisabledBorderBrush(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ListViewItemPresenter_get_SelectionIndicatorPressedBrush(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.ListViewItemPresenter", L"SelectionIndicatorPressedBrush");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::Primitives::ListViewItemPresenter>().SelectionIndicatorPressedBrush();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ListViewItemPresenter_put_SelectionIndicatorPressedBrush(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.ListViewItemPresenter", L"SelectionIndicatorPressedBrush");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Microsoft::UI::Xaml::Media::Brush>(arg);

            {
                auto _gil = release_gil();
                self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::Primitives::ListViewItemPresenter>().SelectionIndicatorPressedBrush(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ListViewItemPresenter_get_SelectionIndicatorPointerOverBrush(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.ListViewItemPresenter", L"SelectionIndicatorPointerOverBrush");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::Primitives::ListViewItemPresenter>().SelectionIndicatorPointerOverBrush();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ListViewItemPresenter_put_SelectionIndicatorPointerOverBrush(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.ListViewItemPresenter", L"SelectionIndicatorPointerOverBrush");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Microsoft::UI::Xaml::Media::Brush>(arg);

            {
                auto _gil = release_gil();
                self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::Primitives::ListViewItemPresenter>().SelectionIndicatorPointerOverBrush(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ListViewItemPresenter_get_SelectionIndicatorMode(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.ListViewItemPresenter", L"SelectionIndicatorMode");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::Primitives::ListViewItemPresenter>().SelectionIndicatorMode();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ListViewItemPresenter_put_SelectionIndicatorMode(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.ListViewItemPresenter", L"SelectionIndicatorMode");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Microsoft::UI::Xaml::Controls::Primitives::ListViewItemPresenterSelectionIndicatorMode>(arg);

            {
                auto _gil = release_gil();
                self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::Primitives::ListViewItemPresenter>().SelectionIndicatorMode(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ListViewItemPresenter_get_SelectionIndicatorDisabledBrush(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.ListViewItemPresenter", L"SelectionIndicatorDisabledBrush");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::Primitives::ListViewItemPresenter>().SelectionIndicatorDisabledBrush();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ListViewItemPresenter_put_SelectionIndicatorDisabledBrush(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.ListViewItemPresenter", L"SelectionIndicatorDisabledBrush");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Microsoft::UI::Xaml::Media::Brush>(arg);

            {
                auto _gil = release_gil();
                self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::Primitives::ListViewItemPresenter>().SelectionIndicatorDisabledBrush(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ListViewItemPresenter_get_SelectionIndicatorCornerRadius(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.ListViewItemPresenter", L"SelectionIndicatorCornerRadius");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::Primitives::ListViewItemPresenter>().SelectionIndicatorCornerRadius();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ListViewItemPresenter_put_SelectionIndicatorCornerRadius(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.ListViewItemPresenter", L"SelectionIndicatorCornerRadius");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Microsoft::UI::Xaml::CornerRadius>(arg);

            {
                auto _gil = release_gil();
                self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::Primitives::ListViewItemPresenter>().SelectionIndicatorCornerRadius(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ListViewItemPresenter_get_SelectionIndicatorBrush(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.ListViewItemPresenter", L"SelectionIndicatorBrush");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::Primitives::ListViewItemPresenter>().SelectionIndicatorBrush();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ListViewItemPresenter_put_SelectionIndicatorBrush(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.ListViewItemPresenter", L"SelectionIndicatorBrush");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Microsoft::UI::Xaml::Media::Brush>(arg);

            {
                auto _gil = release_gil();
                self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::Primitives::ListViewItemPresenter>().SelectionIndicatorBrush(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ListViewItemPresenter_get_CheckBoxPressedBorderBrush(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.ListViewItemPresenter", L"CheckBoxPressedBorderBrush");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::Primitives::ListViewItemPresenter>().CheckBoxPressedBorderBrush();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ListViewItemPresenter_put_CheckBoxPressedBorderBrush(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.ListViewItemPresenter", L"CheckBoxPressedBorderBrush");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Microsoft::UI::Xaml::Media::Brush>(arg);

            {
                auto _gil = release_gil();
                self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::Primitives::ListViewItemPresenter>().CheckBoxPressedBorderBrush(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ListViewItemPresenter_get_SelectedPressedBorderBrush(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.ListViewItemPresenter", L"SelectedPressedBorderBrush");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::Primitives::ListViewItemPresenter>().SelectedPressedBorderBrush();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ListViewItemPresenter_put_SelectedPressedBorderBrush(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.ListViewItemPresenter", L"SelectedPressedBorderBrush");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Microsoft::UI::Xaml::Media::Brush>(arg);

            {
                auto _gil = release_gil();
                self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::Primitives::ListViewItemPresenter>().SelectedPressedBorderBrush(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ListViewItemPresenter_get_SelectedPressedBackground(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.ListViewItemPresenter", L"SelectedPressedBackground");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::Primitives::ListViewItemPresenter>().SelectedPressedBackground();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ListViewItemPresenter_put_SelectedPressedBackground(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.ListViewItemPresenter", L"SelectedPressedBackground");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Microsoft::UI::Xaml::Media::Brush>(arg);

            {
                auto _gil = release_gil();
                self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::Primitives::ListViewItemPresenter>().SelectedPressedBackground(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ListViewItemPresenter_get_SelectedPointerOverBorderBrush(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.ListViewItemPresenter", L"SelectedPointerOverBorderBrush");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::Primitives::ListViewItemPresenter>().SelectedPointerOverBorderBrush();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ListViewItemPresenter_put_SelectedPointerOverBorderBrush(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.ListViewItemPresenter", L"SelectedPointerOverBorderBrush");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Microsoft::UI::Xaml::Media::Brush>(arg);

            {
                auto _gil = release_gil();
                self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::Primitives::ListViewItemPresenter>().SelectedPointerOverBorderBrush(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ListViewItemPresenter_get_SelectedPointerOverBackground(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.ListViewItemPresenter", L"SelectedPointerOverBackground");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::Primitives::ListViewItemPresenter>().SelectedPointerOverBackground();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ListViewItemPresenter_put_SelectedPointerOverBackground(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.ListViewItemPresenter", L"SelectedPointerOverBackground");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Microsoft::UI::Xaml::Media::Brush>(arg);

            {
                auto _gil = release_gil();
                self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::Primitives::ListViewItemPresenter>().SelectedPointerOverBackground(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ListViewItemPresenter_get_SelectedInnerBorderBrush(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.ListViewItemPresenter", L"SelectedInnerBorderBrush");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::Primitives::ListViewItemPresenter>().SelectedInnerBorderBrush();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ListViewItemPresenter_put_SelectedInnerBorderBrush(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.ListViewItemPresenter", L"SelectedInnerBorderBrush");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Microsoft::UI::Xaml::Media::Brush>(arg);

            {
                auto _gil = release_gil();
                self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::Primitives::ListViewItemPresenter>().SelectedInnerBorderBrush(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ListViewItemPresenter_get_SelectedForeground(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.ListViewItemPresenter", L"SelectedForeground");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::Primitives::ListViewItemPresenter>().SelectedForeground();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ListViewItemPresenter_put_SelectedForeground(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.ListViewItemPresenter", L"SelectedForeground");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Microsoft::UI::Xaml::Media::Brush>(arg);

            {
                auto _gil = release_gil();
                self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::Primitives::ListViewItemPresenter>().SelectedForeground(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ListViewItemPresenter_get_SelectionIndicatorVisualEnabled(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.ListViewItemPresenter", L"SelectionIndicatorVisualEnabled");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::Primitives::ListViewItemPresenter>().SelectionIndicatorVisualEnabled();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ListViewItemPresenter_put_SelectionIndicatorVisualEnabled(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.ListViewItemPresenter", L"SelectionIndicatorVisualEnabled");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<bool>(arg);

            {
                auto _gil = release_gil();
                self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::Primitives::ListViewItemPresenter>().SelectionIndicatorVisualEnabled(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ListViewItemPresenter_get_SelectedDisabledBackground(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.ListViewItemPresenter", L"SelectedDisabledBackground");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::Primitives::ListViewItemPresenter>().SelectedDisabledBackground();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ListViewItemPresenter_put_SelectedDisabledBackground(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.ListViewItemPresenter", L"SelectedDisabledBackground");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Microsoft::UI::Xaml::Media::Brush>(arg);

            {
                auto _gil = release_gil();
                self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::Primitives::ListViewItemPresenter>().SelectedDisabledBackground(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ListViewItemPresenter_get_SelectedBorderThickness(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.ListViewItemPresenter", L"SelectedBorderThickness");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::Primitives::ListViewItemPresenter>().SelectedBorderThickness();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ListViewItemPresenter_put_SelectedBorderThickness(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.ListViewItemPresenter", L"SelectedBorderThickness");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Microsoft::UI::Xaml::Thickness>(arg);

            {
                auto _gil = release_gil();
                self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::Primitives::ListViewItemPresenter>().SelectedBorderThickness(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ListViewItemPresenter_get_SelectedBorderBrush(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.ListViewItemPresenter", L"SelectedBorderBrush");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::Primitives::ListViewItemPresenter>().SelectedBorderBrush();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ListViewItemPresenter_put_SelectedBorderBrush(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.ListViewItemPresenter", L"SelectedBorderBrush");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Microsoft::UI::Xaml::Media::Brush>(arg);

            {
                auto _gil = release_gil();
                self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::Primitives::ListViewItemPresenter>().SelectedBorderBrush(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ListViewItemPresenter_get_SelectedBackground(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.ListViewItemPresenter", L"SelectedBackground");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::Primitives::ListViewItemPresenter>().SelectedBackground();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ListViewItemPresenter_put_SelectedBackground(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.ListViewItemPresenter", L"SelectedBackground");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Microsoft::UI::Xaml::Media::Brush>(arg);

            {
                auto _gil = release_gil();
                self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::Primitives::ListViewItemPresenter>().SelectedBackground(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ListViewItemPresenter_get_RevealBorderThickness(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.ListViewItemPresenter", L"RevealBorderThickness");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::Primitives::ListViewItemPresenter>().RevealBorderThickness();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ListViewItemPresenter_put_RevealBorderThickness(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.ListViewItemPresenter", L"RevealBorderThickness");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Microsoft::UI::Xaml::Thickness>(arg);

            {
                auto _gil = release_gil();
                self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::Primitives::ListViewItemPresenter>().RevealBorderThickness(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ListViewItemPresenter_get_RevealBorderBrush(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.ListViewItemPresenter", L"RevealBorderBrush");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::Primitives::ListViewItemPresenter>().RevealBorderBrush();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ListViewItemPresenter_put_RevealBorderBrush(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.ListViewItemPresenter", L"RevealBorderBrush");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Microsoft::UI::Xaml::Media::Brush>(arg);

            {
                auto _gil = release_gil();
                self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::Primitives::ListViewItemPresenter>().RevealBorderBrush(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ListViewItemPresenter_get_RevealBackgroundShowsAboveContent(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.ListViewItemPresenter", L"RevealBackgroundShowsAboveContent");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::Primitives::ListViewItemPresenter>().RevealBackgroundShowsAboveContent();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ListViewItemPresenter_put_RevealBackgroundShowsAboveContent(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.ListViewItemPresenter", L"RevealBackgroundShowsAboveContent");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<bool>(arg);

            {
                auto _gil = release_gil();
                self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::Primitives::ListViewItemPresenter>().RevealBackgroundShowsAboveContent(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ListViewItemPresenter_get_DragForeground(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.ListViewItemPresenter", L"DragForeground");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::Primitives::ListViewItemPresenter>().DragForeground();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ListViewItemPresenter_put_DragForeground(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.ListViewItemPresenter", L"DragForeground");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Microsoft::UI::Xaml::Media::Brush>(arg);

            {
                auto _gil = release_gil();
                self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::Primitives::ListViewItemPresenter>().DragForeground(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ListViewItemPresenter_get_ReorderHintOffset(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.ListViewItemPresenter", L"ReorderHintOffset");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::Primitives::ListViewItemPresenter>().ReorderHintOffset();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ListViewItemPresenter_put_ReorderHintOffset(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.ListViewItemPresenter", L"ReorderHintOffset");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<double>(arg);

            {
                auto _gil = release_gil();
                self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::Primitives::ListViewItemPresenter>().ReorderHintOffset(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ListViewItemPresenter_get_PressedBackground(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.ListViewItemPresenter", L"PressedBackground");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::Primitives::ListViewItemPresenter>().PressedBackground();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ListViewItemPresenter_put_PressedBackground(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.ListViewItemPresenter", L"PressedBackground");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Microsoft::UI::Xaml::Media::Brush>(arg);

            {
                auto _gil = release_gil();
                self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::Primitives::ListViewItemPresenter>().PressedBackground(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ListViewItemPresenter_get_PointerOverForeground(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.ListViewItemPresenter", L"PointerOverForeground");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::Primitives::ListViewItemPresenter>().PointerOverForeground();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ListViewItemPresenter_put_PointerOverForeground(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.ListViewItemPresenter", L"PointerOverForeground");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Microsoft::UI::Xaml::Media::Brush>(arg);

            {
                auto _gil = release_gil();
                self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::Primitives::ListViewItemPresenter>().PointerOverForeground(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ListViewItemPresenter_get_PointerOverBorderBrush(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.ListViewItemPresenter", L"PointerOverBorderBrush");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::Primitives::ListViewItemPresenter>().PointerOverBorderBrush();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ListViewItemPresenter_put_PointerOverBorderBrush(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.ListViewItemPresenter", L"PointerOverBorderBrush");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Microsoft::UI::Xaml::Media::Brush>(arg);

            {
                auto _gil = release_gil();
                self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::Primitives::ListViewItemPresenter>().PointerOverBorderBrush(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ListViewItemPresenter_get_PointerOverBackgroundMargin(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.ListViewItemPresenter", L"PointerOverBackgroundMargin");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::Primitives::ListViewItemPresenter>().PointerOverBackgroundMargin();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ListViewItemPresenter_put_PointerOverBackgroundMargin(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.ListViewItemPresenter", L"PointerOverBackgroundMargin");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Microsoft::UI::Xaml::Thickness>(arg);

            {
                auto _gil = release_gil();
                self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::Primitives::ListViewItemPresenter>().PointerOverBackgroundMargin(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ListViewItemPresenter_get_PointerOverBackground(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.ListViewItemPresenter", L"PointerOverBackground");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::Primitives::ListViewItemPresenter>().PointerOverBackground();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ListViewItemPresenter_put_PointerOverBackground(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.ListViewItemPresenter", L"PointerOverBackground");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Microsoft::UI::Xaml::Media::Brush>(arg);

            {
                auto _gil = release_gil();
                self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::Primitives::ListViewItemPresenter>().PointerOverBackground(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ListViewItemPresenter_get_CheckBoxBorderBrushProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.ListViewItemPresenter", L"CheckBoxBorderBrushProperty");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return winrt::Microsoft::UI::Xaml::Controls::Primitives::ListViewItemPresenter::CheckBoxBorderBrushProperty();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ListViewItemPresenter_get_CheckBoxBrushProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.ListViewItemPresenter", L"CheckBoxBrushProperty");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return winrt::Microsoft::UI::Xaml::Controls::Primitives::ListViewItemPresenter::CheckBoxBrushProperty();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ListViewItemPresenter_get_CheckBoxCornerRadiusProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.ListViewItemPresenter", L"CheckBoxCornerRadiusProperty");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return winrt::Microsoft::UI::Xaml::Controls::Primitives::ListViewItemPresenter::CheckBoxCornerRadiusProperty();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ListViewItemPresenter_get_CheckBoxDisabledBorderBrushProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.ListViewItemPresenter", L"CheckBoxDisabledBorderBrushProperty");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return winrt::Microsoft::UI::Xaml::Controls::Primitives::ListViewItemPresenter::CheckBoxDisabledBorderBrushProperty();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ListViewItemPresenter_get_CheckBoxDisabledBrushProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.ListViewItemPresenter", L"CheckBoxDisabledBrushProperty");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return winrt::Microsoft::UI::Xaml::Controls::Primitives::ListViewItemPresenter::CheckBoxDisabledBrushProperty();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ListViewItemPresenter_get_CheckBoxPointerOverBorderBrushProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.ListViewItemPresenter", L"CheckBoxPointerOverBorderBrushProperty");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return winrt::Microsoft::UI::Xaml::Controls::Primitives::ListViewItemPresenter::CheckBoxPointerOverBorderBrushProperty();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ListViewItemPresenter_get_CheckBoxPointerOverBrushProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.ListViewItemPresenter", L"CheckBoxPointerOverBrushProperty");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return winrt::Microsoft::UI::Xaml::Controls::Primitives::ListViewItemPresenter::CheckBoxPointerOverBrushProperty();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ListViewItemPresenter_get_CheckBoxPressedBorderBrushProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.ListViewItemPresenter", L"CheckBoxPressedBorderBrushProperty");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return winrt::Microsoft::UI::Xaml::Controls::Primitives::ListViewItemPresenter::CheckBoxPressedBorderBrushProperty();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ListViewItemPresenter_get_CheckBoxPressedBrushProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.ListViewItemPresenter", L"CheckBoxPressedBrushProperty");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return winrt::Microsoft::UI::Xaml::Controls::Primitives::ListViewItemPresenter::CheckBoxPressedBrushProperty();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ListViewItemPresenter_get_CheckBoxSelectedBrushProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.ListViewItemPresenter", L"CheckBoxSelectedBrushProperty");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return winrt::Microsoft::UI::Xaml::Controls::Primitives::ListViewItemPresenter::CheckBoxSelectedBrushProperty();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ListViewItemPresenter_get_CheckBoxSelectedDisabledBrushProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.ListViewItemPresenter", L"CheckBoxSelectedDisabledBrushProperty");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return winrt::Microsoft::UI::Xaml::Controls::Primitives::ListViewItemPresenter::CheckBoxSelectedDisabledBrushProperty();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ListViewItemPresenter_get_CheckBoxSelectedPointerOverBrushProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.ListViewItemPresenter", L"CheckBoxSelectedPointerOverBrushProperty");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return winrt::Microsoft::UI::Xaml::Controls::Primitives::ListViewItemPresenter::CheckBoxSelectedPointerOverBrushProperty();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ListViewItemPresenter_get_CheckBoxSelectedPressedBrushProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.ListViewItemPresenter", L"CheckBoxSelectedPressedBrushProperty");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return winrt::Microsoft::UI::Xaml::Controls::Primitives::ListViewItemPresenter::CheckBoxSelectedPressedBrushProperty();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ListViewItemPresenter_get_CheckBrushProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.ListViewItemPresenter", L"CheckBrushProperty");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return winrt::Microsoft::UI::Xaml::Controls::Primitives::ListViewItemPresenter::CheckBrushProperty();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ListViewItemPresenter_get_CheckDisabledBrushProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.ListViewItemPresenter", L"CheckDisabledBrushProperty");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return winrt::Microsoft::UI::Xaml::Controls::Primitives::ListViewItemPresenter::CheckDisabledBrushProperty();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ListViewItemPresenter_get_CheckHintBrushProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.ListViewItemPresenter", L"CheckHintBrushProperty");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return winrt::Microsoft::UI::Xaml::Controls::Primitives::ListViewItemPresenter::CheckHintBrushProperty();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ListViewItemPresenter_get_CheckModeProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.ListViewItemPresenter", L"CheckModeProperty");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return winrt::Microsoft::UI::Xaml::Controls::Primitives::ListViewItemPresenter::CheckModeProperty();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ListViewItemPresenter_get_CheckPressedBrushProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.ListViewItemPresenter", L"CheckPressedBrushProperty");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return winrt::Microsoft::UI::Xaml::Controls::Primitives::ListViewItemPresenter::CheckPressedBrushProperty();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ListViewItemPresenter_get_CheckSelectingBrushProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.ListViewItemPresenter", L"CheckSelectingBrushProperty");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return winrt::Microsoft::UI::Xaml::Controls::Primitives::ListViewItemPresenter::CheckSelectingBrushProperty();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ListViewItemPresenter_get_ContentMarginProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.ListViewItemPresenter", L"ContentMarginProperty");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return winrt::Microsoft::UI::Xaml::Controls::Primitives::ListViewItemPresenter::ContentMarginProperty();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ListViewItemPresenter_get_DisabledOpacityProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.ListViewItemPresenter", L"DisabledOpacityProperty");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return winrt::Microsoft::UI::Xaml::Controls::Primitives::ListViewItemPresenter::DisabledOpacityProperty();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ListViewItemPresenter_get_DragBackgroundProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.ListViewItemPresenter", L"DragBackgroundProperty");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return winrt::Microsoft::UI::Xaml::Controls::Primitives::ListViewItemPresenter::DragBackgroundProperty();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ListViewItemPresenter_get_DragForegroundProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.ListViewItemPresenter", L"DragForegroundProperty");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return winrt::Microsoft::UI::Xaml::Controls::Primitives::ListViewItemPresenter::DragForegroundProperty();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ListViewItemPresenter_get_DragOpacityProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.ListViewItemPresenter", L"DragOpacityProperty");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return winrt::Microsoft::UI::Xaml::Controls::Primitives::ListViewItemPresenter::DragOpacityProperty();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ListViewItemPresenter_get_FocusBorderBrushProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.ListViewItemPresenter", L"FocusBorderBrushProperty");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return winrt::Microsoft::UI::Xaml::Controls::Primitives::ListViewItemPresenter::FocusBorderBrushProperty();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ListViewItemPresenter_get_FocusSecondaryBorderBrushProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.ListViewItemPresenter", L"FocusSecondaryBorderBrushProperty");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return winrt::Microsoft::UI::Xaml::Controls::Primitives::ListViewItemPresenter::FocusSecondaryBorderBrushProperty();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ListViewItemPresenter_get_ListViewItemPresenterHorizontalContentAlignmentProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.ListViewItemPresenter", L"ListViewItemPresenterHorizontalContentAlignmentProperty");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return winrt::Microsoft::UI::Xaml::Controls::Primitives::ListViewItemPresenter::ListViewItemPresenterHorizontalContentAlignmentProperty();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ListViewItemPresenter_get_ListViewItemPresenterPaddingProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.ListViewItemPresenter", L"ListViewItemPresenterPaddingProperty");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return winrt::Microsoft::UI::Xaml::Controls::Primitives::ListViewItemPresenter::ListViewItemPresenterPaddingProperty();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ListViewItemPresenter_get_ListViewItemPresenterVerticalContentAlignmentProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.ListViewItemPresenter", L"ListViewItemPresenterVerticalContentAlignmentProperty");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return winrt::Microsoft::UI::Xaml::Controls::Primitives::ListViewItemPresenter::ListViewItemPresenterVerticalContentAlignmentProperty();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ListViewItemPresenter_get_PlaceholderBackgroundProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.ListViewItemPresenter", L"PlaceholderBackgroundProperty");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return winrt::Microsoft::UI::Xaml::Controls::Primitives::ListViewItemPresenter::PlaceholderBackgroundProperty();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ListViewItemPresenter_get_PointerOverBackgroundMarginProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.ListViewItemPresenter", L"PointerOverBackgroundMarginProperty");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return winrt::Microsoft::UI::Xaml::Controls::Primitives::ListViewItemPresenter::PointerOverBackgroundMarginProperty();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ListViewItemPresenter_get_PointerOverBackgroundProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.ListViewItemPresenter", L"PointerOverBackgroundProperty");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return winrt::Microsoft::UI::Xaml::Controls::Primitives::ListViewItemPresenter::PointerOverBackgroundProperty();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ListViewItemPresenter_get_PointerOverBorderBrushProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.ListViewItemPresenter", L"PointerOverBorderBrushProperty");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return winrt::Microsoft::UI::Xaml::Controls::Primitives::ListViewItemPresenter::PointerOverBorderBrushProperty();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ListViewItemPresenter_get_PointerOverForegroundProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.ListViewItemPresenter", L"PointerOverForegroundProperty");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return winrt::Microsoft::UI::Xaml::Controls::Primitives::ListViewItemPresenter::PointerOverForegroundProperty();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ListViewItemPresenter_get_PressedBackgroundProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.ListViewItemPresenter", L"PressedBackgroundProperty");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return winrt::Microsoft::UI::Xaml::Controls::Primitives::ListViewItemPresenter::PressedBackgroundProperty();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ListViewItemPresenter_get_ReorderHintOffsetProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.ListViewItemPresenter", L"ReorderHintOffsetProperty");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return winrt::Microsoft::UI::Xaml::Controls::Primitives::ListViewItemPresenter::ReorderHintOffsetProperty();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ListViewItemPresenter_get_RevealBackgroundProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.ListViewItemPresenter", L"RevealBackgroundProperty");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return winrt::Microsoft::UI::Xaml::Controls::Primitives::ListViewItemPresenter::RevealBackgroundProperty();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ListViewItemPresenter_get_RevealBackgroundShowsAboveContentProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.ListViewItemPresenter", L"RevealBackgroundShowsAboveContentProperty");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return winrt::Microsoft::UI::Xaml::Controls::Primitives::ListViewItemPresenter::RevealBackgroundShowsAboveContentProperty();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ListViewItemPresenter_get_RevealBorderBrushProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.ListViewItemPresenter", L"RevealBorderBrushProperty");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return winrt::Microsoft::UI::Xaml::Controls::Primitives::ListViewItemPresenter::RevealBorderBrushProperty();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ListViewItemPresenter_get_RevealBorderThicknessProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.ListViewItemPresenter", L"RevealBorderThicknessProperty");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return winrt::Microsoft::UI::Xaml::Controls::Primitives::ListViewItemPresenter::RevealBorderThicknessProperty();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ListViewItemPresenter_get_SelectedBackgroundProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.ListViewItemPresenter", L"SelectedBackgroundProperty");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return winrt::Microsoft::UI::Xaml::Controls::Primitives::ListViewItemPresenter::SelectedBackgroundProperty();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ListViewItemPresenter_get_SelectedBorderBrushProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.ListViewItemPresenter", L"SelectedBorderBrushProperty");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return winrt::Microsoft::UI::Xaml::Controls::Primitives::ListViewItemPresenter::SelectedBorderBrushProperty();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ListViewItemPresenter_get_SelectedBorderThicknessProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.ListViewItemPresenter", L"SelectedBorderThicknessProperty");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return winrt::Microsoft::UI::Xaml::Controls::Primitives::ListViewItemPresenter::SelectedBorderThicknessProperty();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ListViewItemPresenter_get_SelectedDisabledBackgroundProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.ListViewItemPresenter", L"SelectedDisabledBackgroundProperty");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return winrt::Microsoft::UI::Xaml::Controls::Primitives::ListViewItemPresenter::SelectedDisabledBackgroundProperty();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ListViewItemPresenter_get_SelectedDisabledBorderBrushProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.ListViewItemPresenter", L"SelectedDisabledBorderBrushProperty");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return winrt::Microsoft::UI::Xaml::Controls::Primitives::ListViewItemPresenter::SelectedDisabledBorderBrushProperty();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ListViewItemPresenter_get_SelectedForegroundProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.ListViewItemPresenter", L"SelectedForegroundProperty");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return winrt::Microsoft::UI::Xaml::Controls::Primitives::ListViewItemPresenter::SelectedForegroundProperty();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ListViewItemPresenter_get_SelectedInnerBorderBrushProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.ListViewItemPresenter", L"SelectedInnerBorderBrushProperty");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return winrt::Microsoft::UI::Xaml::Controls::Primitives::ListViewItemPresenter::SelectedInnerBorderBrushProperty();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ListViewItemPresenter_get_SelectedPointerOverBackgroundProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.ListViewItemPresenter", L"SelectedPointerOverBackgroundProperty");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return winrt::Microsoft::UI::Xaml::Controls::Primitives::ListViewItemPresenter::SelectedPointerOverBackgroundProperty();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ListViewItemPresenter_get_SelectedPointerOverBorderBrushProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.ListViewItemPresenter", L"SelectedPointerOverBorderBrushProperty");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return winrt::Microsoft::UI::Xaml::Controls::Primitives::ListViewItemPresenter::SelectedPointerOverBorderBrushProperty();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ListViewItemPresenter_get_SelectedPressedBackgroundProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.ListViewItemPresenter", L"SelectedPressedBackgroundProperty");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return winrt::Microsoft::UI::Xaml::Controls::Primitives::ListViewItemPresenter::SelectedPressedBackgroundProperty();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ListViewItemPresenter_get_SelectedPressedBorderBrushProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.ListViewItemPresenter", L"SelectedPressedBorderBrushProperty");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return winrt::Microsoft::UI::Xaml::Controls::Primitives::ListViewItemPresenter::SelectedPressedBorderBrushProperty();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ListViewItemPresenter_get_SelectionCheckMarkVisualEnabledProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.ListViewItemPresenter", L"SelectionCheckMarkVisualEnabledProperty");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return winrt::Microsoft::UI::Xaml::Controls::Primitives::ListViewItemPresenter::SelectionCheckMarkVisualEnabledProperty();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ListViewItemPresenter_get_SelectionIndicatorBrushProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.ListViewItemPresenter", L"SelectionIndicatorBrushProperty");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return winrt::Microsoft::UI::Xaml::Controls::Primitives::ListViewItemPresenter::SelectionIndicatorBrushProperty();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ListViewItemPresenter_get_SelectionIndicatorCornerRadiusProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.ListViewItemPresenter", L"SelectionIndicatorCornerRadiusProperty");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return winrt::Microsoft::UI::Xaml::Controls::Primitives::ListViewItemPresenter::SelectionIndicatorCornerRadiusProperty();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ListViewItemPresenter_get_SelectionIndicatorDisabledBrushProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.ListViewItemPresenter", L"SelectionIndicatorDisabledBrushProperty");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return winrt::Microsoft::UI::Xaml::Controls::Primitives::ListViewItemPresenter::SelectionIndicatorDisabledBrushProperty();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ListViewItemPresenter_get_SelectionIndicatorModeProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.ListViewItemPresenter", L"SelectionIndicatorModeProperty");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return winrt::Microsoft::UI::Xaml::Controls::Primitives::ListViewItemPresenter::SelectionIndicatorModeProperty();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ListViewItemPresenter_get_SelectionIndicatorPointerOverBrushProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.ListViewItemPresenter", L"SelectionIndicatorPointerOverBrushProperty");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return winrt::Microsoft::UI::Xaml::Controls::Primitives::ListViewItemPresenter::SelectionIndicatorPointerOverBrushProperty();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ListViewItemPresenter_get_SelectionIndicatorPressedBrushProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.ListViewItemPresenter", L"SelectionIndicatorPressedBrushProperty");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return winrt::Microsoft::UI::Xaml::Controls::Primitives::ListViewItemPresenter::SelectionIndicatorPressedBrushProperty();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ListViewItemPresenter_get_SelectionIndicatorVisualEnabledProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.ListViewItemPresenter", L"SelectionIndicatorVisualEnabledProperty");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return winrt::Microsoft::UI::Xaml::Controls::Primitives::ListViewItemPresenter::SelectionIndicatorVisualEnabledProperty();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_ListViewItemPresenter(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Microsoft::UI::Xaml::Controls::Primitives::ListViewItemPresenter>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_ListViewItemPresenter(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Microsoft::UI::Xaml::Controls::Primitives::ListViewItemPresenter>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_ListViewItemPresenter[] = {
        { "_assign_array_", _assign_array_ListViewItemPresenter, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_ListViewItemPresenter), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_ListViewItemPresenter[] = {
        { "list_view_item_presenter_vertical_content_alignment", reinterpret_cast<getter>(ListViewItemPresenter_get_ListViewItemPresenterVerticalContentAlignment), reinterpret_cast<setter>(ListViewItemPresenter_put_ListViewItemPresenterVerticalContentAlignment), nullptr, nullptr },
        { "list_view_item_presenter_padding", reinterpret_cast<getter>(ListViewItemPresenter_get_ListViewItemPresenterPadding), reinterpret_cast<setter>(ListViewItemPresenter_put_ListViewItemPresenterPadding), nullptr, nullptr },
        { "list_view_item_presenter_horizontal_content_alignment", reinterpret_cast<getter>(ListViewItemPresenter_get_ListViewItemPresenterHorizontalContentAlignment), reinterpret_cast<setter>(ListViewItemPresenter_put_ListViewItemPresenterHorizontalContentAlignment), nullptr, nullptr },
        { "focus_secondary_border_brush", reinterpret_cast<getter>(ListViewItemPresenter_get_FocusSecondaryBorderBrush), reinterpret_cast<setter>(ListViewItemPresenter_put_FocusSecondaryBorderBrush), nullptr, nullptr },
        { "focus_border_brush", reinterpret_cast<getter>(ListViewItemPresenter_get_FocusBorderBrush), reinterpret_cast<setter>(ListViewItemPresenter_put_FocusBorderBrush), nullptr, nullptr },
        { "drag_opacity", reinterpret_cast<getter>(ListViewItemPresenter_get_DragOpacity), reinterpret_cast<setter>(ListViewItemPresenter_put_DragOpacity), nullptr, nullptr },
        { "reveal_background", reinterpret_cast<getter>(ListViewItemPresenter_get_RevealBackground), reinterpret_cast<setter>(ListViewItemPresenter_put_RevealBackground), nullptr, nullptr },
        { "drag_background", reinterpret_cast<getter>(ListViewItemPresenter_get_DragBackground), reinterpret_cast<setter>(ListViewItemPresenter_put_DragBackground), nullptr, nullptr },
        { "disabled_opacity", reinterpret_cast<getter>(ListViewItemPresenter_get_DisabledOpacity), reinterpret_cast<setter>(ListViewItemPresenter_put_DisabledOpacity), nullptr, nullptr },
        { "content_margin", reinterpret_cast<getter>(ListViewItemPresenter_get_ContentMargin), reinterpret_cast<setter>(ListViewItemPresenter_put_ContentMargin), nullptr, nullptr },
        { "check_selecting_brush", reinterpret_cast<getter>(ListViewItemPresenter_get_CheckSelectingBrush), reinterpret_cast<setter>(ListViewItemPresenter_put_CheckSelectingBrush), nullptr, nullptr },
        { "check_pressed_brush", reinterpret_cast<getter>(ListViewItemPresenter_get_CheckPressedBrush), reinterpret_cast<setter>(ListViewItemPresenter_put_CheckPressedBrush), nullptr, nullptr },
        { "check_mode", reinterpret_cast<getter>(ListViewItemPresenter_get_CheckMode), reinterpret_cast<setter>(ListViewItemPresenter_put_CheckMode), nullptr, nullptr },
        { "check_hint_brush", reinterpret_cast<getter>(ListViewItemPresenter_get_CheckHintBrush), reinterpret_cast<setter>(ListViewItemPresenter_put_CheckHintBrush), nullptr, nullptr },
        { "check_box_border_brush", reinterpret_cast<getter>(ListViewItemPresenter_get_CheckBoxBorderBrush), reinterpret_cast<setter>(ListViewItemPresenter_put_CheckBoxBorderBrush), nullptr, nullptr },
        { "check_brush", reinterpret_cast<getter>(ListViewItemPresenter_get_CheckBrush), reinterpret_cast<setter>(ListViewItemPresenter_put_CheckBrush), nullptr, nullptr },
        { "check_box_selected_pressed_brush", reinterpret_cast<getter>(ListViewItemPresenter_get_CheckBoxSelectedPressedBrush), reinterpret_cast<setter>(ListViewItemPresenter_put_CheckBoxSelectedPressedBrush), nullptr, nullptr },
        { "check_box_selected_pointer_over_brush", reinterpret_cast<getter>(ListViewItemPresenter_get_CheckBoxSelectedPointerOverBrush), reinterpret_cast<setter>(ListViewItemPresenter_put_CheckBoxSelectedPointerOverBrush), nullptr, nullptr },
        { "check_box_selected_disabled_brush", reinterpret_cast<getter>(ListViewItemPresenter_get_CheckBoxSelectedDisabledBrush), reinterpret_cast<setter>(ListViewItemPresenter_put_CheckBoxSelectedDisabledBrush), nullptr, nullptr },
        { "check_box_selected_brush", reinterpret_cast<getter>(ListViewItemPresenter_get_CheckBoxSelectedBrush), reinterpret_cast<setter>(ListViewItemPresenter_put_CheckBoxSelectedBrush), nullptr, nullptr },
        { "check_box_pressed_brush", reinterpret_cast<getter>(ListViewItemPresenter_get_CheckBoxPressedBrush), reinterpret_cast<setter>(ListViewItemPresenter_put_CheckBoxPressedBrush), nullptr, nullptr },
        { "selection_check_mark_visual_enabled", reinterpret_cast<getter>(ListViewItemPresenter_get_SelectionCheckMarkVisualEnabled), reinterpret_cast<setter>(ListViewItemPresenter_put_SelectionCheckMarkVisualEnabled), nullptr, nullptr },
        { "check_box_pointer_over_brush", reinterpret_cast<getter>(ListViewItemPresenter_get_CheckBoxPointerOverBrush), reinterpret_cast<setter>(ListViewItemPresenter_put_CheckBoxPointerOverBrush), nullptr, nullptr },
        { "check_box_pointer_over_border_brush", reinterpret_cast<getter>(ListViewItemPresenter_get_CheckBoxPointerOverBorderBrush), reinterpret_cast<setter>(ListViewItemPresenter_put_CheckBoxPointerOverBorderBrush), nullptr, nullptr },
        { "check_box_disabled_brush", reinterpret_cast<getter>(ListViewItemPresenter_get_CheckBoxDisabledBrush), reinterpret_cast<setter>(ListViewItemPresenter_put_CheckBoxDisabledBrush), nullptr, nullptr },
        { "check_box_disabled_border_brush", reinterpret_cast<getter>(ListViewItemPresenter_get_CheckBoxDisabledBorderBrush), reinterpret_cast<setter>(ListViewItemPresenter_put_CheckBoxDisabledBorderBrush), nullptr, nullptr },
        { "check_box_corner_radius", reinterpret_cast<getter>(ListViewItemPresenter_get_CheckBoxCornerRadius), reinterpret_cast<setter>(ListViewItemPresenter_put_CheckBoxCornerRadius), nullptr, nullptr },
        { "check_box_brush", reinterpret_cast<getter>(ListViewItemPresenter_get_CheckBoxBrush), reinterpret_cast<setter>(ListViewItemPresenter_put_CheckBoxBrush), nullptr, nullptr },
        { "check_disabled_brush", reinterpret_cast<getter>(ListViewItemPresenter_get_CheckDisabledBrush), reinterpret_cast<setter>(ListViewItemPresenter_put_CheckDisabledBrush), nullptr, nullptr },
        { "placeholder_background", reinterpret_cast<getter>(ListViewItemPresenter_get_PlaceholderBackground), reinterpret_cast<setter>(ListViewItemPresenter_put_PlaceholderBackground), nullptr, nullptr },
        { "selected_disabled_border_brush", reinterpret_cast<getter>(ListViewItemPresenter_get_SelectedDisabledBorderBrush), reinterpret_cast<setter>(ListViewItemPresenter_put_SelectedDisabledBorderBrush), nullptr, nullptr },
        { "selection_indicator_pressed_brush", reinterpret_cast<getter>(ListViewItemPresenter_get_SelectionIndicatorPressedBrush), reinterpret_cast<setter>(ListViewItemPresenter_put_SelectionIndicatorPressedBrush), nullptr, nullptr },
        { "selection_indicator_pointer_over_brush", reinterpret_cast<getter>(ListViewItemPresenter_get_SelectionIndicatorPointerOverBrush), reinterpret_cast<setter>(ListViewItemPresenter_put_SelectionIndicatorPointerOverBrush), nullptr, nullptr },
        { "selection_indicator_mode", reinterpret_cast<getter>(ListViewItemPresenter_get_SelectionIndicatorMode), reinterpret_cast<setter>(ListViewItemPresenter_put_SelectionIndicatorMode), nullptr, nullptr },
        { "selection_indicator_disabled_brush", reinterpret_cast<getter>(ListViewItemPresenter_get_SelectionIndicatorDisabledBrush), reinterpret_cast<setter>(ListViewItemPresenter_put_SelectionIndicatorDisabledBrush), nullptr, nullptr },
        { "selection_indicator_corner_radius", reinterpret_cast<getter>(ListViewItemPresenter_get_SelectionIndicatorCornerRadius), reinterpret_cast<setter>(ListViewItemPresenter_put_SelectionIndicatorCornerRadius), nullptr, nullptr },
        { "selection_indicator_brush", reinterpret_cast<getter>(ListViewItemPresenter_get_SelectionIndicatorBrush), reinterpret_cast<setter>(ListViewItemPresenter_put_SelectionIndicatorBrush), nullptr, nullptr },
        { "check_box_pressed_border_brush", reinterpret_cast<getter>(ListViewItemPresenter_get_CheckBoxPressedBorderBrush), reinterpret_cast<setter>(ListViewItemPresenter_put_CheckBoxPressedBorderBrush), nullptr, nullptr },
        { "selected_pressed_border_brush", reinterpret_cast<getter>(ListViewItemPresenter_get_SelectedPressedBorderBrush), reinterpret_cast<setter>(ListViewItemPresenter_put_SelectedPressedBorderBrush), nullptr, nullptr },
        { "selected_pressed_background", reinterpret_cast<getter>(ListViewItemPresenter_get_SelectedPressedBackground), reinterpret_cast<setter>(ListViewItemPresenter_put_SelectedPressedBackground), nullptr, nullptr },
        { "selected_pointer_over_border_brush", reinterpret_cast<getter>(ListViewItemPresenter_get_SelectedPointerOverBorderBrush), reinterpret_cast<setter>(ListViewItemPresenter_put_SelectedPointerOverBorderBrush), nullptr, nullptr },
        { "selected_pointer_over_background", reinterpret_cast<getter>(ListViewItemPresenter_get_SelectedPointerOverBackground), reinterpret_cast<setter>(ListViewItemPresenter_put_SelectedPointerOverBackground), nullptr, nullptr },
        { "selected_inner_border_brush", reinterpret_cast<getter>(ListViewItemPresenter_get_SelectedInnerBorderBrush), reinterpret_cast<setter>(ListViewItemPresenter_put_SelectedInnerBorderBrush), nullptr, nullptr },
        { "selected_foreground", reinterpret_cast<getter>(ListViewItemPresenter_get_SelectedForeground), reinterpret_cast<setter>(ListViewItemPresenter_put_SelectedForeground), nullptr, nullptr },
        { "selection_indicator_visual_enabled", reinterpret_cast<getter>(ListViewItemPresenter_get_SelectionIndicatorVisualEnabled), reinterpret_cast<setter>(ListViewItemPresenter_put_SelectionIndicatorVisualEnabled), nullptr, nullptr },
        { "selected_disabled_background", reinterpret_cast<getter>(ListViewItemPresenter_get_SelectedDisabledBackground), reinterpret_cast<setter>(ListViewItemPresenter_put_SelectedDisabledBackground), nullptr, nullptr },
        { "selected_border_thickness", reinterpret_cast<getter>(ListViewItemPresenter_get_SelectedBorderThickness), reinterpret_cast<setter>(ListViewItemPresenter_put_SelectedBorderThickness), nullptr, nullptr },
        { "selected_border_brush", reinterpret_cast<getter>(ListViewItemPresenter_get_SelectedBorderBrush), reinterpret_cast<setter>(ListViewItemPresenter_put_SelectedBorderBrush), nullptr, nullptr },
        { "selected_background", reinterpret_cast<getter>(ListViewItemPresenter_get_SelectedBackground), reinterpret_cast<setter>(ListViewItemPresenter_put_SelectedBackground), nullptr, nullptr },
        { "reveal_border_thickness", reinterpret_cast<getter>(ListViewItemPresenter_get_RevealBorderThickness), reinterpret_cast<setter>(ListViewItemPresenter_put_RevealBorderThickness), nullptr, nullptr },
        { "reveal_border_brush", reinterpret_cast<getter>(ListViewItemPresenter_get_RevealBorderBrush), reinterpret_cast<setter>(ListViewItemPresenter_put_RevealBorderBrush), nullptr, nullptr },
        { "reveal_background_shows_above_content", reinterpret_cast<getter>(ListViewItemPresenter_get_RevealBackgroundShowsAboveContent), reinterpret_cast<setter>(ListViewItemPresenter_put_RevealBackgroundShowsAboveContent), nullptr, nullptr },
        { "drag_foreground", reinterpret_cast<getter>(ListViewItemPresenter_get_DragForeground), reinterpret_cast<setter>(ListViewItemPresenter_put_DragForeground), nullptr, nullptr },
        { "reorder_hint_offset", reinterpret_cast<getter>(ListViewItemPresenter_get_ReorderHintOffset), reinterpret_cast<setter>(ListViewItemPresenter_put_ReorderHintOffset), nullptr, nullptr },
        { "pressed_background", reinterpret_cast<getter>(ListViewItemPresenter_get_PressedBackground), reinterpret_cast<setter>(ListViewItemPresenter_put_PressedBackground), nullptr, nullptr },
        { "pointer_over_foreground", reinterpret_cast<getter>(ListViewItemPresenter_get_PointerOverForeground), reinterpret_cast<setter>(ListViewItemPresenter_put_PointerOverForeground), nullptr, nullptr },
        { "pointer_over_border_brush", reinterpret_cast<getter>(ListViewItemPresenter_get_PointerOverBorderBrush), reinterpret_cast<setter>(ListViewItemPresenter_put_PointerOverBorderBrush), nullptr, nullptr },
        { "pointer_over_background_margin", reinterpret_cast<getter>(ListViewItemPresenter_get_PointerOverBackgroundMargin), reinterpret_cast<setter>(ListViewItemPresenter_put_PointerOverBackgroundMargin), nullptr, nullptr },
        { "pointer_over_background", reinterpret_cast<getter>(ListViewItemPresenter_get_PointerOverBackground), reinterpret_cast<setter>(ListViewItemPresenter_put_PointerOverBackground), nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_ListViewItemPresenter[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_ListViewItemPresenter) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_ListViewItemPresenter) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_ListViewItemPresenter) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_ListViewItemPresenter) },
        { }
    };

    static PyType_Spec type_spec_ListViewItemPresenter = {
        "winrt._winrt_microsoft_ui_xaml_controls_primitives.ListViewItemPresenter",
        sizeof(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>),
        0,
        Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,
        _type_slots_ListViewItemPresenter};

    static PyGetSetDef getset_ListViewItemPresenter_Static[] = {
        { "check_box_border_brush_property", reinterpret_cast<getter>(ListViewItemPresenter_get_CheckBoxBorderBrushProperty), nullptr, nullptr, nullptr },
        { "check_box_brush_property", reinterpret_cast<getter>(ListViewItemPresenter_get_CheckBoxBrushProperty), nullptr, nullptr, nullptr },
        { "check_box_corner_radius_property", reinterpret_cast<getter>(ListViewItemPresenter_get_CheckBoxCornerRadiusProperty), nullptr, nullptr, nullptr },
        { "check_box_disabled_border_brush_property", reinterpret_cast<getter>(ListViewItemPresenter_get_CheckBoxDisabledBorderBrushProperty), nullptr, nullptr, nullptr },
        { "check_box_disabled_brush_property", reinterpret_cast<getter>(ListViewItemPresenter_get_CheckBoxDisabledBrushProperty), nullptr, nullptr, nullptr },
        { "check_box_pointer_over_border_brush_property", reinterpret_cast<getter>(ListViewItemPresenter_get_CheckBoxPointerOverBorderBrushProperty), nullptr, nullptr, nullptr },
        { "check_box_pointer_over_brush_property", reinterpret_cast<getter>(ListViewItemPresenter_get_CheckBoxPointerOverBrushProperty), nullptr, nullptr, nullptr },
        { "check_box_pressed_border_brush_property", reinterpret_cast<getter>(ListViewItemPresenter_get_CheckBoxPressedBorderBrushProperty), nullptr, nullptr, nullptr },
        { "check_box_pressed_brush_property", reinterpret_cast<getter>(ListViewItemPresenter_get_CheckBoxPressedBrushProperty), nullptr, nullptr, nullptr },
        { "check_box_selected_brush_property", reinterpret_cast<getter>(ListViewItemPresenter_get_CheckBoxSelectedBrushProperty), nullptr, nullptr, nullptr },
        { "check_box_selected_disabled_brush_property", reinterpret_cast<getter>(ListViewItemPresenter_get_CheckBoxSelectedDisabledBrushProperty), nullptr, nullptr, nullptr },
        { "check_box_selected_pointer_over_brush_property", reinterpret_cast<getter>(ListViewItemPresenter_get_CheckBoxSelectedPointerOverBrushProperty), nullptr, nullptr, nullptr },
        { "check_box_selected_pressed_brush_property", reinterpret_cast<getter>(ListViewItemPresenter_get_CheckBoxSelectedPressedBrushProperty), nullptr, nullptr, nullptr },
        { "check_brush_property", reinterpret_cast<getter>(ListViewItemPresenter_get_CheckBrushProperty), nullptr, nullptr, nullptr },
        { "check_disabled_brush_property", reinterpret_cast<getter>(ListViewItemPresenter_get_CheckDisabledBrushProperty), nullptr, nullptr, nullptr },
        { "check_hint_brush_property", reinterpret_cast<getter>(ListViewItemPresenter_get_CheckHintBrushProperty), nullptr, nullptr, nullptr },
        { "check_mode_property", reinterpret_cast<getter>(ListViewItemPresenter_get_CheckModeProperty), nullptr, nullptr, nullptr },
        { "check_pressed_brush_property", reinterpret_cast<getter>(ListViewItemPresenter_get_CheckPressedBrushProperty), nullptr, nullptr, nullptr },
        { "check_selecting_brush_property", reinterpret_cast<getter>(ListViewItemPresenter_get_CheckSelectingBrushProperty), nullptr, nullptr, nullptr },
        { "content_margin_property", reinterpret_cast<getter>(ListViewItemPresenter_get_ContentMarginProperty), nullptr, nullptr, nullptr },
        { "disabled_opacity_property", reinterpret_cast<getter>(ListViewItemPresenter_get_DisabledOpacityProperty), nullptr, nullptr, nullptr },
        { "drag_background_property", reinterpret_cast<getter>(ListViewItemPresenter_get_DragBackgroundProperty), nullptr, nullptr, nullptr },
        { "drag_foreground_property", reinterpret_cast<getter>(ListViewItemPresenter_get_DragForegroundProperty), nullptr, nullptr, nullptr },
        { "drag_opacity_property", reinterpret_cast<getter>(ListViewItemPresenter_get_DragOpacityProperty), nullptr, nullptr, nullptr },
        { "focus_border_brush_property", reinterpret_cast<getter>(ListViewItemPresenter_get_FocusBorderBrushProperty), nullptr, nullptr, nullptr },
        { "focus_secondary_border_brush_property", reinterpret_cast<getter>(ListViewItemPresenter_get_FocusSecondaryBorderBrushProperty), nullptr, nullptr, nullptr },
        { "list_view_item_presenter_horizontal_content_alignment_property", reinterpret_cast<getter>(ListViewItemPresenter_get_ListViewItemPresenterHorizontalContentAlignmentProperty), nullptr, nullptr, nullptr },
        { "list_view_item_presenter_padding_property", reinterpret_cast<getter>(ListViewItemPresenter_get_ListViewItemPresenterPaddingProperty), nullptr, nullptr, nullptr },
        { "list_view_item_presenter_vertical_content_alignment_property", reinterpret_cast<getter>(ListViewItemPresenter_get_ListViewItemPresenterVerticalContentAlignmentProperty), nullptr, nullptr, nullptr },
        { "placeholder_background_property", reinterpret_cast<getter>(ListViewItemPresenter_get_PlaceholderBackgroundProperty), nullptr, nullptr, nullptr },
        { "pointer_over_background_margin_property", reinterpret_cast<getter>(ListViewItemPresenter_get_PointerOverBackgroundMarginProperty), nullptr, nullptr, nullptr },
        { "pointer_over_background_property", reinterpret_cast<getter>(ListViewItemPresenter_get_PointerOverBackgroundProperty), nullptr, nullptr, nullptr },
        { "pointer_over_border_brush_property", reinterpret_cast<getter>(ListViewItemPresenter_get_PointerOverBorderBrushProperty), nullptr, nullptr, nullptr },
        { "pointer_over_foreground_property", reinterpret_cast<getter>(ListViewItemPresenter_get_PointerOverForegroundProperty), nullptr, nullptr, nullptr },
        { "pressed_background_property", reinterpret_cast<getter>(ListViewItemPresenter_get_PressedBackgroundProperty), nullptr, nullptr, nullptr },
        { "reorder_hint_offset_property", reinterpret_cast<getter>(ListViewItemPresenter_get_ReorderHintOffsetProperty), nullptr, nullptr, nullptr },
        { "reveal_background_property", reinterpret_cast<getter>(ListViewItemPresenter_get_RevealBackgroundProperty), nullptr, nullptr, nullptr },
        { "reveal_background_shows_above_content_property", reinterpret_cast<getter>(ListViewItemPresenter_get_RevealBackgroundShowsAboveContentProperty), nullptr, nullptr, nullptr },
        { "reveal_border_brush_property", reinterpret_cast<getter>(ListViewItemPresenter_get_RevealBorderBrushProperty), nullptr, nullptr, nullptr },
        { "reveal_border_thickness_property", reinterpret_cast<getter>(ListViewItemPresenter_get_RevealBorderThicknessProperty), nullptr, nullptr, nullptr },
        { "selected_background_property", reinterpret_cast<getter>(ListViewItemPresenter_get_SelectedBackgroundProperty), nullptr, nullptr, nullptr },
        { "selected_border_brush_property", reinterpret_cast<getter>(ListViewItemPresenter_get_SelectedBorderBrushProperty), nullptr, nullptr, nullptr },
        { "selected_border_thickness_property", reinterpret_cast<getter>(ListViewItemPresenter_get_SelectedBorderThicknessProperty), nullptr, nullptr, nullptr },
        { "selected_disabled_background_property", reinterpret_cast<getter>(ListViewItemPresenter_get_SelectedDisabledBackgroundProperty), nullptr, nullptr, nullptr },
        { "selected_disabled_border_brush_property", reinterpret_cast<getter>(ListViewItemPresenter_get_SelectedDisabledBorderBrushProperty), nullptr, nullptr, nullptr },
        { "selected_foreground_property", reinterpret_cast<getter>(ListViewItemPresenter_get_SelectedForegroundProperty), nullptr, nullptr, nullptr },
        { "selected_inner_border_brush_property", reinterpret_cast<getter>(ListViewItemPresenter_get_SelectedInnerBorderBrushProperty), nullptr, nullptr, nullptr },
        { "selected_pointer_over_background_property", reinterpret_cast<getter>(ListViewItemPresenter_get_SelectedPointerOverBackgroundProperty), nullptr, nullptr, nullptr },
        { "selected_pointer_over_border_brush_property", reinterpret_cast<getter>(ListViewItemPresenter_get_SelectedPointerOverBorderBrushProperty), nullptr, nullptr, nullptr },
        { "selected_pressed_background_property", reinterpret_cast<getter>(ListViewItemPresenter_get_SelectedPressedBackgroundProperty), nullptr, nullptr, nullptr },
        { "selected_pressed_border_brush_property", reinterpret_cast<getter>(ListViewItemPresenter_get_SelectedPressedBorderBrushProperty), nullptr, nullptr, nullptr },
        { "selection_check_mark_visual_enabled_property", reinterpret_cast<getter>(ListViewItemPresenter_get_SelectionCheckMarkVisualEnabledProperty), nullptr, nullptr, nullptr },
        { "selection_indicator_brush_property", reinterpret_cast<getter>(ListViewItemPresenter_get_SelectionIndicatorBrushProperty), nullptr, nullptr, nullptr },
        { "selection_indicator_corner_radius_property", reinterpret_cast<getter>(ListViewItemPresenter_get_SelectionIndicatorCornerRadiusProperty), nullptr, nullptr, nullptr },
        { "selection_indicator_disabled_brush_property", reinterpret_cast<getter>(ListViewItemPresenter_get_SelectionIndicatorDisabledBrushProperty), nullptr, nullptr, nullptr },
        { "selection_indicator_mode_property", reinterpret_cast<getter>(ListViewItemPresenter_get_SelectionIndicatorModeProperty), nullptr, nullptr, nullptr },
        { "selection_indicator_pointer_over_brush_property", reinterpret_cast<getter>(ListViewItemPresenter_get_SelectionIndicatorPointerOverBrushProperty), nullptr, nullptr, nullptr },
        { "selection_indicator_pressed_brush_property", reinterpret_cast<getter>(ListViewItemPresenter_get_SelectionIndicatorPressedBrushProperty), nullptr, nullptr, nullptr },
        { "selection_indicator_visual_enabled_property", reinterpret_cast<getter>(ListViewItemPresenter_get_SelectionIndicatorVisualEnabledProperty), nullptr, nullptr, nullptr },
        { }
    };

    static PyMethodDef methods_ListViewItemPresenter_Static[] = {
        { }
    };

    static PyType_Slot type_slots_ListViewItemPresenter_Static[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_ListViewItemPresenter_Static) },
        { Py_tp_methods, reinterpret_cast<void*>(methods_ListViewItemPresenter_Static) },
        { }
    };

    static PyType_Spec type_spec_ListViewItemPresenter_Static =
    {
        "winrt._winrt_microsoft_ui_xaml_controls_primitives.ListViewItemPresenter_Static",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,
        type_slots_ListViewItemPresenter_Static
    };

    // ----- ListViewItemTemplateSettings class --------------------

    static PyObject* _new_ListViewItemTemplateSettings(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Microsoft::UI::Xaml::Controls::Primitives::ListViewItemTemplateSettings>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Microsoft::UI::Xaml::Controls::Primitives::ListViewItemTemplateSettings>::type_name);
        return nullptr;
    }

    static void _dealloc_ListViewItemTemplateSettings(py::wrapper::Microsoft::UI::Xaml::Controls::Primitives::ListViewItemTemplateSettings* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* ListViewItemTemplateSettings_get_DragItemsCount(py::wrapper::Microsoft::UI::Xaml::Controls::Primitives::ListViewItemTemplateSettings* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.ListViewItemTemplateSettings", L"DragItemsCount");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.DragItemsCount();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_ListViewItemTemplateSettings(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Microsoft::UI::Xaml::Controls::Primitives::ListViewItemTemplateSettings>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_ListViewItemTemplateSettings(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Microsoft::UI::Xaml::Controls::Primitives::ListViewItemTemplateSettings>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_ListViewItemTemplateSettings[] = {
        { "_assign_array_", _assign_array_ListViewItemTemplateSettings, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_ListViewItemTemplateSettings), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_ListViewItemTemplateSettings[] = {
        { "drag_items_count", reinterpret_cast<getter>(ListViewItemTemplateSettings_get_DragItemsCount), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_ListViewItemTemplateSettings[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_ListViewItemTemplateSettings) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_ListViewItemTemplateSettings) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_ListViewItemTemplateSettings) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_ListViewItemTemplateSettings) },
        { }
    };

    static PyType_Spec type_spec_ListViewItemTemplateSettings = {
        "winrt._winrt_microsoft_ui_xaml_controls_primitives.ListViewItemTemplateSettings",
        sizeof(py::wrapper::Microsoft::UI::Xaml::Controls::Primitives::ListViewItemTemplateSettings),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_ListViewItemTemplateSettings};

    // ----- LoopingSelector class --------------------

    static PyObject* _new_LoopingSelector(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Microsoft::UI::Xaml::Controls::Primitives::LoopingSelector>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Microsoft::UI::Xaml::Controls::Primitives::LoopingSelector>::type_name);
        return nullptr;
    }

    static void _dealloc_LoopingSelector(py::wrapper::Microsoft::UI::Xaml::Controls::Primitives::LoopingSelector* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* LoopingSelector_get_ShouldLoop(py::wrapper::Microsoft::UI::Xaml::Controls::Primitives::LoopingSelector* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.LoopingSelector", L"ShouldLoop");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.ShouldLoop();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int LoopingSelector_put_ShouldLoop(py::wrapper::Microsoft::UI::Xaml::Controls::Primitives::LoopingSelector* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.LoopingSelector", L"ShouldLoop");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<bool>(arg);

            {
                auto _gil = release_gil();
                self->obj.ShouldLoop(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* LoopingSelector_get_SelectedItem(py::wrapper::Microsoft::UI::Xaml::Controls::Primitives::LoopingSelector* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.LoopingSelector", L"SelectedItem");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.SelectedItem();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int LoopingSelector_put_SelectedItem(py::wrapper::Microsoft::UI::Xaml::Controls::Primitives::LoopingSelector* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.LoopingSelector", L"SelectedItem");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);

            {
                auto _gil = release_gil();
                self->obj.SelectedItem(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* LoopingSelector_get_SelectedIndex(py::wrapper::Microsoft::UI::Xaml::Controls::Primitives::LoopingSelector* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.LoopingSelector", L"SelectedIndex");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.SelectedIndex();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int LoopingSelector_put_SelectedIndex(py::wrapper::Microsoft::UI::Xaml::Controls::Primitives::LoopingSelector* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.LoopingSelector", L"SelectedIndex");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<int32_t>(arg);

            {
                auto _gil = release_gil();
                self->obj.SelectedIndex(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* LoopingSelector_get_Items(py::wrapper::Microsoft::UI::Xaml::Controls::Primitives::LoopingSelector* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.LoopingSelector", L"Items");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Items();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int LoopingSelector_put_Items(py::wrapper::Microsoft::UI::Xaml::Controls::Primitives::LoopingSelector* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.LoopingSelector", L"Items");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::Collections::IVector<winrt::Windows::Foundation::IInspectable>>(arg);

            {
                auto _gil = release_gil();
                self->obj.Items(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* LoopingSelector_get_ItemWidth(py::wrapper::Microsoft::UI::Xaml::Controls::Primitives::LoopingSelector* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.LoopingSelector", L"ItemWidth");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.ItemWidth();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int LoopingSelector_put_ItemWidth(py::wrapper::Microsoft::UI::Xaml::Controls::Primitives::LoopingSelector* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.LoopingSelector", L"ItemWidth");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<int32_t>(arg);

            {
                auto _gil = release_gil();
                self->obj.ItemWidth(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* LoopingSelector_get_ItemTemplate(py::wrapper::Microsoft::UI::Xaml::Controls::Primitives::LoopingSelector* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.LoopingSelector", L"ItemTemplate");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.ItemTemplate();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int LoopingSelector_put_ItemTemplate(py::wrapper::Microsoft::UI::Xaml::Controls::Primitives::LoopingSelector* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.LoopingSelector", L"ItemTemplate");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Microsoft::UI::Xaml::DataTemplate>(arg);

            {
                auto _gil = release_gil();
                self->obj.ItemTemplate(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* LoopingSelector_get_ItemHeight(py::wrapper::Microsoft::UI::Xaml::Controls::Primitives::LoopingSelector* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.LoopingSelector", L"ItemHeight");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.ItemHeight();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int LoopingSelector_put_ItemHeight(py::wrapper::Microsoft::UI::Xaml::Controls::Primitives::LoopingSelector* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.LoopingSelector", L"ItemHeight");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<int32_t>(arg);

            {
                auto _gil = release_gil();
                self->obj.ItemHeight(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* LoopingSelector_get_ItemHeightProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.LoopingSelector", L"ItemHeightProperty");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return winrt::Microsoft::UI::Xaml::Controls::Primitives::LoopingSelector::ItemHeightProperty();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* LoopingSelector_get_ItemTemplateProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.LoopingSelector", L"ItemTemplateProperty");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return winrt::Microsoft::UI::Xaml::Controls::Primitives::LoopingSelector::ItemTemplateProperty();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* LoopingSelector_get_ItemWidthProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.LoopingSelector", L"ItemWidthProperty");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return winrt::Microsoft::UI::Xaml::Controls::Primitives::LoopingSelector::ItemWidthProperty();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* LoopingSelector_get_ItemsProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.LoopingSelector", L"ItemsProperty");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return winrt::Microsoft::UI::Xaml::Controls::Primitives::LoopingSelector::ItemsProperty();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* LoopingSelector_get_SelectedIndexProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.LoopingSelector", L"SelectedIndexProperty");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return winrt::Microsoft::UI::Xaml::Controls::Primitives::LoopingSelector::SelectedIndexProperty();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* LoopingSelector_get_SelectedItemProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.LoopingSelector", L"SelectedItemProperty");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return winrt::Microsoft::UI::Xaml::Controls::Primitives::LoopingSelector::SelectedItemProperty();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* LoopingSelector_get_ShouldLoopProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.LoopingSelector", L"ShouldLoopProperty");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return winrt::Microsoft::UI::Xaml::Controls::Primitives::LoopingSelector::ShouldLoopProperty();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* LoopingSelector_add_SelectionChanged(py::wrapper::Microsoft::UI::Xaml::Controls::Primitives::LoopingSelector* self, PyObject* arg) noexcept
    {
        try
        {
            static std::optional<bool> is_event_present{};

            if (!is_event_present.has_value())
            {
                is_event_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Microsoft.UI.Xaml.Controls.Primitives.LoopingSelector", L"SelectionChanged");
            }

            if (!is_event_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::Microsoft::UI::Xaml::Controls::SelectionChangedEventHandler>(arg);

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.SelectionChanged(param0);
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* LoopingSelector_remove_SelectionChanged(py::wrapper::Microsoft::UI::Xaml::Controls::Primitives::LoopingSelector* self, PyObject* arg) noexcept
    {
        try
        {
            static std::optional<bool> is_event_present{};

            if (!is_event_present.has_value())
            {
                is_event_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Microsoft.UI.Xaml.Controls.Primitives.LoopingSelector", L"SelectionChanged");
            }

            if (!is_event_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::event_token>(arg);

            {
                auto _gil = release_gil();
                self->obj.SelectionChanged(param0);
            }

            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_LoopingSelector(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Microsoft::UI::Xaml::Controls::Primitives::LoopingSelector>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_LoopingSelector(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Microsoft::UI::Xaml::Controls::Primitives::LoopingSelector>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_LoopingSelector[] = {
        { "add_selection_changed", reinterpret_cast<PyCFunction>(LoopingSelector_add_SelectionChanged), METH_O, nullptr },
        { "remove_selection_changed", reinterpret_cast<PyCFunction>(LoopingSelector_remove_SelectionChanged), METH_O, nullptr },
        { "_assign_array_", _assign_array_LoopingSelector, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_LoopingSelector), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_LoopingSelector[] = {
        { "should_loop", reinterpret_cast<getter>(LoopingSelector_get_ShouldLoop), reinterpret_cast<setter>(LoopingSelector_put_ShouldLoop), nullptr, nullptr },
        { "selected_item", reinterpret_cast<getter>(LoopingSelector_get_SelectedItem), reinterpret_cast<setter>(LoopingSelector_put_SelectedItem), nullptr, nullptr },
        { "selected_index", reinterpret_cast<getter>(LoopingSelector_get_SelectedIndex), reinterpret_cast<setter>(LoopingSelector_put_SelectedIndex), nullptr, nullptr },
        { "items", reinterpret_cast<getter>(LoopingSelector_get_Items), reinterpret_cast<setter>(LoopingSelector_put_Items), nullptr, nullptr },
        { "item_width", reinterpret_cast<getter>(LoopingSelector_get_ItemWidth), reinterpret_cast<setter>(LoopingSelector_put_ItemWidth), nullptr, nullptr },
        { "item_template", reinterpret_cast<getter>(LoopingSelector_get_ItemTemplate), reinterpret_cast<setter>(LoopingSelector_put_ItemTemplate), nullptr, nullptr },
        { "item_height", reinterpret_cast<getter>(LoopingSelector_get_ItemHeight), reinterpret_cast<setter>(LoopingSelector_put_ItemHeight), nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_LoopingSelector[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_LoopingSelector) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_LoopingSelector) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_LoopingSelector) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_LoopingSelector) },
        { }
    };

    static PyType_Spec type_spec_LoopingSelector = {
        "winrt._winrt_microsoft_ui_xaml_controls_primitives.LoopingSelector",
        sizeof(py::wrapper::Microsoft::UI::Xaml::Controls::Primitives::LoopingSelector),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_LoopingSelector};

    static PyGetSetDef getset_LoopingSelector_Static[] = {
        { "item_height_property", reinterpret_cast<getter>(LoopingSelector_get_ItemHeightProperty), nullptr, nullptr, nullptr },
        { "item_template_property", reinterpret_cast<getter>(LoopingSelector_get_ItemTemplateProperty), nullptr, nullptr, nullptr },
        { "item_width_property", reinterpret_cast<getter>(LoopingSelector_get_ItemWidthProperty), nullptr, nullptr, nullptr },
        { "items_property", reinterpret_cast<getter>(LoopingSelector_get_ItemsProperty), nullptr, nullptr, nullptr },
        { "selected_index_property", reinterpret_cast<getter>(LoopingSelector_get_SelectedIndexProperty), nullptr, nullptr, nullptr },
        { "selected_item_property", reinterpret_cast<getter>(LoopingSelector_get_SelectedItemProperty), nullptr, nullptr, nullptr },
        { "should_loop_property", reinterpret_cast<getter>(LoopingSelector_get_ShouldLoopProperty), nullptr, nullptr, nullptr },
        { }
    };

    static PyMethodDef methods_LoopingSelector_Static[] = {
        { }
    };

    static PyType_Slot type_slots_LoopingSelector_Static[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_LoopingSelector_Static) },
        { Py_tp_methods, reinterpret_cast<void*>(methods_LoopingSelector_Static) },
        { }
    };

    static PyType_Spec type_spec_LoopingSelector_Static =
    {
        "winrt._winrt_microsoft_ui_xaml_controls_primitives.LoopingSelector_Static",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT,
        type_slots_LoopingSelector_Static
    };

    // ----- LoopingSelectorItem class --------------------

    static PyObject* _new_LoopingSelectorItem(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Microsoft::UI::Xaml::Controls::Primitives::LoopingSelectorItem>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Microsoft::UI::Xaml::Controls::Primitives::LoopingSelectorItem>::type_name);
        return nullptr;
    }

    static void _dealloc_LoopingSelectorItem(py::wrapper::Microsoft::UI::Xaml::Controls::Primitives::LoopingSelectorItem* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* _assign_array_LoopingSelectorItem(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Microsoft::UI::Xaml::Controls::Primitives::LoopingSelectorItem>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_LoopingSelectorItem(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Microsoft::UI::Xaml::Controls::Primitives::LoopingSelectorItem>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_LoopingSelectorItem[] = {
        { "_assign_array_", _assign_array_LoopingSelectorItem, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_LoopingSelectorItem), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_LoopingSelectorItem[] = {
        { }
    };

    static PyType_Slot _type_slots_LoopingSelectorItem[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_LoopingSelectorItem) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_LoopingSelectorItem) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_LoopingSelectorItem) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_LoopingSelectorItem) },
        { }
    };

    static PyType_Spec type_spec_LoopingSelectorItem = {
        "winrt._winrt_microsoft_ui_xaml_controls_primitives.LoopingSelectorItem",
        sizeof(py::wrapper::Microsoft::UI::Xaml::Controls::Primitives::LoopingSelectorItem),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_LoopingSelectorItem};

    // ----- LoopingSelectorPanel class --------------------

    static PyObject* _new_LoopingSelectorPanel(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Microsoft::UI::Xaml::Controls::Primitives::LoopingSelectorPanel>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Microsoft::UI::Xaml::Controls::Primitives::LoopingSelectorPanel>::type_name);
        return nullptr;
    }

    static void _dealloc_LoopingSelectorPanel(py::wrapper::Microsoft::UI::Xaml::Controls::Primitives::LoopingSelectorPanel* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* LoopingSelectorPanel_GetIrregularSnapPoints(py::wrapper::Microsoft::UI::Xaml::Controls::Primitives::LoopingSelectorPanel* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Xaml.Controls.Primitives.LoopingSelectorPanel", L"GetIrregularSnapPoints", 2);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(2);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Microsoft::UI::Xaml::Controls::Orientation>(args, 0);
                auto param1 = py::convert_to<winrt::Microsoft::UI::Xaml::Controls::Primitives::SnapPointsAlignment>(args, 1);

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return self->obj.GetIrregularSnapPoints(param0, param1);
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* LoopingSelectorPanel_GetRegularSnapPoints(py::wrapper::Microsoft::UI::Xaml::Controls::Primitives::LoopingSelectorPanel* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Xaml.Controls.Primitives.LoopingSelectorPanel", L"GetRegularSnapPoints", 2);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(2);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Microsoft::UI::Xaml::Controls::Orientation>(args, 0);
                auto param1 = py::convert_to<winrt::Microsoft::UI::Xaml::Controls::Primitives::SnapPointsAlignment>(args, 1);
                float param2{};

                auto return_value = [&]()
                {
                    auto _gil = release_gil();
                    return self->obj.GetRegularSnapPoints(param0, param1, param2);
                }();

                py::pyobj_handle out_return_value{ py::convert(return_value) };
                if (!out_return_value)
                {
                    return nullptr;
                }
                py::pyobj_handle out2{ py::convert(param2) };
                if (!out2)
                {
                    return nullptr;
                }

                return PyTuple_Pack(2, out_return_value.get(), out2.get());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* LoopingSelectorPanel_get_AreHorizontalSnapPointsRegular(py::wrapper::Microsoft::UI::Xaml::Controls::Primitives::LoopingSelectorPanel* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.LoopingSelectorPanel", L"AreHorizontalSnapPointsRegular");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.AreHorizontalSnapPointsRegular();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* LoopingSelectorPanel_get_AreVerticalSnapPointsRegular(py::wrapper::Microsoft::UI::Xaml::Controls::Primitives::LoopingSelectorPanel* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.LoopingSelectorPanel", L"AreVerticalSnapPointsRegular");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.AreVerticalSnapPointsRegular();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* LoopingSelectorPanel_add_HorizontalSnapPointsChanged(py::wrapper::Microsoft::UI::Xaml::Controls::Primitives::LoopingSelectorPanel* self, PyObject* arg) noexcept
    {
        try
        {
            static std::optional<bool> is_event_present{};

            if (!is_event_present.has_value())
            {
                is_event_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Microsoft.UI.Xaml.Controls.Primitives.LoopingSelectorPanel", L"HorizontalSnapPointsChanged");
            }

            if (!is_event_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::EventHandler<winrt::Windows::Foundation::IInspectable>>(arg);

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.HorizontalSnapPointsChanged(param0);
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* LoopingSelectorPanel_remove_HorizontalSnapPointsChanged(py::wrapper::Microsoft::UI::Xaml::Controls::Primitives::LoopingSelectorPanel* self, PyObject* arg) noexcept
    {
        try
        {
            static std::optional<bool> is_event_present{};

            if (!is_event_present.has_value())
            {
                is_event_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Microsoft.UI.Xaml.Controls.Primitives.LoopingSelectorPanel", L"HorizontalSnapPointsChanged");
            }

            if (!is_event_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::event_token>(arg);

            {
                auto _gil = release_gil();
                self->obj.HorizontalSnapPointsChanged(param0);
            }

            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* LoopingSelectorPanel_add_VerticalSnapPointsChanged(py::wrapper::Microsoft::UI::Xaml::Controls::Primitives::LoopingSelectorPanel* self, PyObject* arg) noexcept
    {
        try
        {
            static std::optional<bool> is_event_present{};

            if (!is_event_present.has_value())
            {
                is_event_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Microsoft.UI.Xaml.Controls.Primitives.LoopingSelectorPanel", L"VerticalSnapPointsChanged");
            }

            if (!is_event_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::EventHandler<winrt::Windows::Foundation::IInspectable>>(arg);

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.VerticalSnapPointsChanged(param0);
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* LoopingSelectorPanel_remove_VerticalSnapPointsChanged(py::wrapper::Microsoft::UI::Xaml::Controls::Primitives::LoopingSelectorPanel* self, PyObject* arg) noexcept
    {
        try
        {
            static std::optional<bool> is_event_present{};

            if (!is_event_present.has_value())
            {
                is_event_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Microsoft.UI.Xaml.Controls.Primitives.LoopingSelectorPanel", L"VerticalSnapPointsChanged");
            }

            if (!is_event_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::event_token>(arg);

            {
                auto _gil = release_gil();
                self->obj.VerticalSnapPointsChanged(param0);
            }

            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_LoopingSelectorPanel(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Microsoft::UI::Xaml::Controls::Primitives::LoopingSelectorPanel>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_LoopingSelectorPanel(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Microsoft::UI::Xaml::Controls::Primitives::LoopingSelectorPanel>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_LoopingSelectorPanel[] = {
        { "get_irregular_snap_points", reinterpret_cast<PyCFunction>(LoopingSelectorPanel_GetIrregularSnapPoints), METH_VARARGS, nullptr },
        { "get_regular_snap_points", reinterpret_cast<PyCFunction>(LoopingSelectorPanel_GetRegularSnapPoints), METH_VARARGS, nullptr },
        { "add_horizontal_snap_points_changed", reinterpret_cast<PyCFunction>(LoopingSelectorPanel_add_HorizontalSnapPointsChanged), METH_O, nullptr },
        { "remove_horizontal_snap_points_changed", reinterpret_cast<PyCFunction>(LoopingSelectorPanel_remove_HorizontalSnapPointsChanged), METH_O, nullptr },
        { "add_vertical_snap_points_changed", reinterpret_cast<PyCFunction>(LoopingSelectorPanel_add_VerticalSnapPointsChanged), METH_O, nullptr },
        { "remove_vertical_snap_points_changed", reinterpret_cast<PyCFunction>(LoopingSelectorPanel_remove_VerticalSnapPointsChanged), METH_O, nullptr },
        { "_assign_array_", _assign_array_LoopingSelectorPanel, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_LoopingSelectorPanel), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_LoopingSelectorPanel[] = {
        { "are_horizontal_snap_points_regular", reinterpret_cast<getter>(LoopingSelectorPanel_get_AreHorizontalSnapPointsRegular), nullptr, nullptr, nullptr },
        { "are_vertical_snap_points_regular", reinterpret_cast<getter>(LoopingSelectorPanel_get_AreVerticalSnapPointsRegular), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_LoopingSelectorPanel[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_LoopingSelectorPanel) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_LoopingSelectorPanel) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_LoopingSelectorPanel) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_LoopingSelectorPanel) },
        { }
    };

    static PyType_Spec type_spec_LoopingSelectorPanel = {
        "winrt._winrt_microsoft_ui_xaml_controls_primitives.LoopingSelectorPanel",
        sizeof(py::wrapper::Microsoft::UI::Xaml::Controls::Primitives::LoopingSelectorPanel),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_LoopingSelectorPanel};

    // ----- MenuFlyoutItemTemplateSettings class --------------------

    static PyObject* _new_MenuFlyoutItemTemplateSettings(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Microsoft::UI::Xaml::Controls::Primitives::MenuFlyoutItemTemplateSettings>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Microsoft::UI::Xaml::Controls::Primitives::MenuFlyoutItemTemplateSettings>::type_name);
        return nullptr;
    }

    static void _dealloc_MenuFlyoutItemTemplateSettings(py::wrapper::Microsoft::UI::Xaml::Controls::Primitives::MenuFlyoutItemTemplateSettings* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* MenuFlyoutItemTemplateSettings_get_KeyboardAcceleratorTextMinWidth(py::wrapper::Microsoft::UI::Xaml::Controls::Primitives::MenuFlyoutItemTemplateSettings* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.MenuFlyoutItemTemplateSettings", L"KeyboardAcceleratorTextMinWidth");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.KeyboardAcceleratorTextMinWidth();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_MenuFlyoutItemTemplateSettings(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Microsoft::UI::Xaml::Controls::Primitives::MenuFlyoutItemTemplateSettings>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_MenuFlyoutItemTemplateSettings(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Microsoft::UI::Xaml::Controls::Primitives::MenuFlyoutItemTemplateSettings>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_MenuFlyoutItemTemplateSettings[] = {
        { "_assign_array_", _assign_array_MenuFlyoutItemTemplateSettings, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_MenuFlyoutItemTemplateSettings), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_MenuFlyoutItemTemplateSettings[] = {
        { "keyboard_accelerator_text_min_width", reinterpret_cast<getter>(MenuFlyoutItemTemplateSettings_get_KeyboardAcceleratorTextMinWidth), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_MenuFlyoutItemTemplateSettings[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_MenuFlyoutItemTemplateSettings) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_MenuFlyoutItemTemplateSettings) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_MenuFlyoutItemTemplateSettings) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_MenuFlyoutItemTemplateSettings) },
        { }
    };

    static PyType_Spec type_spec_MenuFlyoutItemTemplateSettings = {
        "winrt._winrt_microsoft_ui_xaml_controls_primitives.MenuFlyoutItemTemplateSettings",
        sizeof(py::wrapper::Microsoft::UI::Xaml::Controls::Primitives::MenuFlyoutItemTemplateSettings),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_MenuFlyoutItemTemplateSettings};

    // ----- MenuFlyoutPresenterTemplateSettings class --------------------

    static PyObject* _new_MenuFlyoutPresenterTemplateSettings(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Microsoft::UI::Xaml::Controls::Primitives::MenuFlyoutPresenterTemplateSettings>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Microsoft::UI::Xaml::Controls::Primitives::MenuFlyoutPresenterTemplateSettings>::type_name);
        return nullptr;
    }

    static void _dealloc_MenuFlyoutPresenterTemplateSettings(py::wrapper::Microsoft::UI::Xaml::Controls::Primitives::MenuFlyoutPresenterTemplateSettings* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* MenuFlyoutPresenterTemplateSettings_get_FlyoutContentMinWidth(py::wrapper::Microsoft::UI::Xaml::Controls::Primitives::MenuFlyoutPresenterTemplateSettings* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.MenuFlyoutPresenterTemplateSettings", L"FlyoutContentMinWidth");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.FlyoutContentMinWidth();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_MenuFlyoutPresenterTemplateSettings(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Microsoft::UI::Xaml::Controls::Primitives::MenuFlyoutPresenterTemplateSettings>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_MenuFlyoutPresenterTemplateSettings(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Microsoft::UI::Xaml::Controls::Primitives::MenuFlyoutPresenterTemplateSettings>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_MenuFlyoutPresenterTemplateSettings[] = {
        { "_assign_array_", _assign_array_MenuFlyoutPresenterTemplateSettings, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_MenuFlyoutPresenterTemplateSettings), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_MenuFlyoutPresenterTemplateSettings[] = {
        { "flyout_content_min_width", reinterpret_cast<getter>(MenuFlyoutPresenterTemplateSettings_get_FlyoutContentMinWidth), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_MenuFlyoutPresenterTemplateSettings[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_MenuFlyoutPresenterTemplateSettings) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_MenuFlyoutPresenterTemplateSettings) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_MenuFlyoutPresenterTemplateSettings) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_MenuFlyoutPresenterTemplateSettings) },
        { }
    };

    static PyType_Spec type_spec_MenuFlyoutPresenterTemplateSettings = {
        "winrt._winrt_microsoft_ui_xaml_controls_primitives.MenuFlyoutPresenterTemplateSettings",
        sizeof(py::wrapper::Microsoft::UI::Xaml::Controls::Primitives::MenuFlyoutPresenterTemplateSettings),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_MenuFlyoutPresenterTemplateSettings};

    // ----- MonochromaticOverlayPresenter class --------------------

    struct PyWinrtMonochromaticOverlayPresenter;
    using BasePyWinrtMonochromaticOverlayPresenter = winrt::Microsoft::UI::Xaml::Controls::Primitives::MonochromaticOverlayPresenterT<PyWinrtMonochromaticOverlayPresenter, py::IPywinrtObject>;

    struct PyWinrtMonochromaticOverlayPresenter : py::py_obj_ref, BasePyWinrtMonochromaticOverlayPresenter
    {
        PyWinrtMonochromaticOverlayPresenter(PyObject* py_obj) : py::py_obj_ref(py_obj), BasePyWinrtMonochromaticOverlayPresenter() {}

        int32_t __stdcall GetPyObject(PyObject*& obj) override
        {
            obj = py::py_obj_ref::get_py_obj();
            return 0;
        }

        int32_t __stdcall GetComposableInner(winrt::Windows::Foundation::IInspectable& inner) override
        {
            inner = m_inner;
            return winrt::impl::error_ok;
        }

        static void toggle_reference(PyWinrtMonochromaticOverlayPresenter* instance, bool is_last_reference)
        {
            py::py_obj_ref::toggle_reference(instance, is_last_reference);
        }

        int32_t query_interface_tearoff(winrt::guid const& id, void** result) const noexcept override
        {
            return py::py_obj_ref::query_interface_tearoff(id, result);
        }
    };

    static PyObject* _new_MonochromaticOverlayPresenter(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);

        auto self_type = get_python_type_for<winrt::Microsoft::UI::Xaml::Controls::Primitives::MonochromaticOverlayPresenter>();
        if (!self_type)
        {
            return nullptr;
        }

        if (arg_count == 0)
        {
            try
            {
                if (type != self_type)
                {
                    py::pyobj_handle self{type->tp_alloc(type, 0)};
                    if (!self)
                    {
                        return nullptr;
                    }

                    std::construct_at(&reinterpret_cast<py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>*>(self.get())->obj, nullptr);

                    auto obj_impl = winrt::make_self<PyWinrtMonochromaticOverlayPresenter>(self.get());

                    auto obj = py::make_py_obj<PyWinrtMonochromaticOverlayPresenter>(obj_impl, type, self.get());
                    if (!obj)
                    {
                        return nullptr;
                    }

                    reinterpret_cast<py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>*>(self.get())->obj = std::move(obj);

                    return self.detach();
                }

                winrt::Microsoft::UI::Xaml::Controls::Primitives::MonochromaticOverlayPresenter instance{};
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_MonochromaticOverlayPresenter(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* MonochromaticOverlayPresenter_get_SourceElement(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.MonochromaticOverlayPresenter", L"SourceElement");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::Primitives::MonochromaticOverlayPresenter>().SourceElement();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int MonochromaticOverlayPresenter_put_SourceElement(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.MonochromaticOverlayPresenter", L"SourceElement");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Microsoft::UI::Xaml::UIElement>(arg);

            {
                auto _gil = release_gil();
                self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::Primitives::MonochromaticOverlayPresenter>().SourceElement(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* MonochromaticOverlayPresenter_get_ReplacementColor(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.MonochromaticOverlayPresenter", L"ReplacementColor");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::Primitives::MonochromaticOverlayPresenter>().ReplacementColor();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int MonochromaticOverlayPresenter_put_ReplacementColor(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.MonochromaticOverlayPresenter", L"ReplacementColor");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::UI::Color>(arg);

            {
                auto _gil = release_gil();
                self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::Primitives::MonochromaticOverlayPresenter>().ReplacementColor(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* MonochromaticOverlayPresenter_get_ReplacementColorProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.MonochromaticOverlayPresenter", L"ReplacementColorProperty");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return winrt::Microsoft::UI::Xaml::Controls::Primitives::MonochromaticOverlayPresenter::ReplacementColorProperty();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MonochromaticOverlayPresenter_get_SourceElementProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.MonochromaticOverlayPresenter", L"SourceElementProperty");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return winrt::Microsoft::UI::Xaml::Controls::Primitives::MonochromaticOverlayPresenter::SourceElementProperty();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_MonochromaticOverlayPresenter(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Microsoft::UI::Xaml::Controls::Primitives::MonochromaticOverlayPresenter>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_MonochromaticOverlayPresenter(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Microsoft::UI::Xaml::Controls::Primitives::MonochromaticOverlayPresenter>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_MonochromaticOverlayPresenter[] = {
        { "_assign_array_", _assign_array_MonochromaticOverlayPresenter, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_MonochromaticOverlayPresenter), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_MonochromaticOverlayPresenter[] = {
        { "source_element", reinterpret_cast<getter>(MonochromaticOverlayPresenter_get_SourceElement), reinterpret_cast<setter>(MonochromaticOverlayPresenter_put_SourceElement), nullptr, nullptr },
        { "replacement_color", reinterpret_cast<getter>(MonochromaticOverlayPresenter_get_ReplacementColor), reinterpret_cast<setter>(MonochromaticOverlayPresenter_put_ReplacementColor), nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_MonochromaticOverlayPresenter[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_MonochromaticOverlayPresenter) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_MonochromaticOverlayPresenter) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_MonochromaticOverlayPresenter) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_MonochromaticOverlayPresenter) },
        { }
    };

    static PyType_Spec type_spec_MonochromaticOverlayPresenter = {
        "winrt._winrt_microsoft_ui_xaml_controls_primitives.MonochromaticOverlayPresenter",
        sizeof(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>),
        0,
        Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,
        _type_slots_MonochromaticOverlayPresenter};

    static PyGetSetDef getset_MonochromaticOverlayPresenter_Static[] = {
        { "replacement_color_property", reinterpret_cast<getter>(MonochromaticOverlayPresenter_get_ReplacementColorProperty), nullptr, nullptr, nullptr },
        { "source_element_property", reinterpret_cast<getter>(MonochromaticOverlayPresenter_get_SourceElementProperty), nullptr, nullptr, nullptr },
        { }
    };

    static PyMethodDef methods_MonochromaticOverlayPresenter_Static[] = {
        { }
    };

    static PyType_Slot type_slots_MonochromaticOverlayPresenter_Static[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_MonochromaticOverlayPresenter_Static) },
        { Py_tp_methods, reinterpret_cast<void*>(methods_MonochromaticOverlayPresenter_Static) },
        { }
    };

    static PyType_Spec type_spec_MonochromaticOverlayPresenter_Static =
    {
        "winrt._winrt_microsoft_ui_xaml_controls_primitives.MonochromaticOverlayPresenter_Static",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,
        type_slots_MonochromaticOverlayPresenter_Static
    };

    // ----- NavigationViewItemPresenter class --------------------

    struct PyWinrtNavigationViewItemPresenter;
    using BasePyWinrtNavigationViewItemPresenter = winrt::Microsoft::UI::Xaml::Controls::Primitives::NavigationViewItemPresenterT<PyWinrtNavigationViewItemPresenter, py::IPywinrtObject>;

    struct PyWinrtNavigationViewItemPresenter : py::py_obj_ref, BasePyWinrtNavigationViewItemPresenter
    {
        PyWinrtNavigationViewItemPresenter(PyObject* py_obj) : py::py_obj_ref(py_obj), BasePyWinrtNavigationViewItemPresenter() {}

        int32_t __stdcall GetPyObject(PyObject*& obj) override
        {
            obj = py::py_obj_ref::get_py_obj();
            return 0;
        }

        int32_t __stdcall GetComposableInner(winrt::Windows::Foundation::IInspectable& inner) override
        {
            inner = m_inner;
            return winrt::impl::error_ok;
        }

        static void toggle_reference(PyWinrtNavigationViewItemPresenter* instance, bool is_last_reference)
        {
            py::py_obj_ref::toggle_reference(instance, is_last_reference);
        }

        int32_t query_interface_tearoff(winrt::guid const& id, void** result) const noexcept override
        {
            return py::py_obj_ref::query_interface_tearoff(id, result);
        }
    };

    static PyObject* _new_NavigationViewItemPresenter(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);

        auto self_type = get_python_type_for<winrt::Microsoft::UI::Xaml::Controls::Primitives::NavigationViewItemPresenter>();
        if (!self_type)
        {
            return nullptr;
        }

        if (arg_count == 0)
        {
            try
            {
                if (type != self_type)
                {
                    py::pyobj_handle self{type->tp_alloc(type, 0)};
                    if (!self)
                    {
                        return nullptr;
                    }

                    std::construct_at(&reinterpret_cast<py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>*>(self.get())->obj, nullptr);

                    auto obj_impl = winrt::make_self<PyWinrtNavigationViewItemPresenter>(self.get());

                    auto obj = py::make_py_obj<PyWinrtNavigationViewItemPresenter>(obj_impl, type, self.get());
                    if (!obj)
                    {
                        return nullptr;
                    }

                    reinterpret_cast<py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>*>(self.get())->obj = std::move(obj);

                    return self.detach();
                }

                winrt::Microsoft::UI::Xaml::Controls::Primitives::NavigationViewItemPresenter instance{};
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_NavigationViewItemPresenter(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* NavigationViewItemPresenter_get_Icon(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.NavigationViewItemPresenter", L"Icon");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::Primitives::NavigationViewItemPresenter>().Icon();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int NavigationViewItemPresenter_put_Icon(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.NavigationViewItemPresenter", L"Icon");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Microsoft::UI::Xaml::Controls::IconElement>(arg);

            {
                auto _gil = release_gil();
                self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::Primitives::NavigationViewItemPresenter>().Icon(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* NavigationViewItemPresenter_get_TemplateSettings(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.NavigationViewItemPresenter", L"TemplateSettings");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::Primitives::NavigationViewItemPresenter>().TemplateSettings();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* NavigationViewItemPresenter_get_InfoBadge(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.NavigationViewItemPresenter", L"InfoBadge");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::Primitives::NavigationViewItemPresenter>().InfoBadge();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int NavigationViewItemPresenter_put_InfoBadge(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.NavigationViewItemPresenter", L"InfoBadge");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Microsoft::UI::Xaml::Controls::InfoBadge>(arg);

            {
                auto _gil = release_gil();
                self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::Primitives::NavigationViewItemPresenter>().InfoBadge(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* NavigationViewItemPresenter_get_IconProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.NavigationViewItemPresenter", L"IconProperty");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return winrt::Microsoft::UI::Xaml::Controls::Primitives::NavigationViewItemPresenter::IconProperty();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* NavigationViewItemPresenter_get_TemplateSettingsProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.NavigationViewItemPresenter", L"TemplateSettingsProperty");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return winrt::Microsoft::UI::Xaml::Controls::Primitives::NavigationViewItemPresenter::TemplateSettingsProperty();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* NavigationViewItemPresenter_get_InfoBadgeProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.NavigationViewItemPresenter", L"InfoBadgeProperty");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return winrt::Microsoft::UI::Xaml::Controls::Primitives::NavigationViewItemPresenter::InfoBadgeProperty();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_NavigationViewItemPresenter(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Microsoft::UI::Xaml::Controls::Primitives::NavigationViewItemPresenter>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_NavigationViewItemPresenter(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Microsoft::UI::Xaml::Controls::Primitives::NavigationViewItemPresenter>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_NavigationViewItemPresenter[] = {
        { "_assign_array_", _assign_array_NavigationViewItemPresenter, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_NavigationViewItemPresenter), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_NavigationViewItemPresenter[] = {
        { "icon", reinterpret_cast<getter>(NavigationViewItemPresenter_get_Icon), reinterpret_cast<setter>(NavigationViewItemPresenter_put_Icon), nullptr, nullptr },
        { "template_settings", reinterpret_cast<getter>(NavigationViewItemPresenter_get_TemplateSettings), nullptr, nullptr, nullptr },
        { "info_badge", reinterpret_cast<getter>(NavigationViewItemPresenter_get_InfoBadge), reinterpret_cast<setter>(NavigationViewItemPresenter_put_InfoBadge), nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_NavigationViewItemPresenter[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_NavigationViewItemPresenter) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_NavigationViewItemPresenter) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_NavigationViewItemPresenter) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_NavigationViewItemPresenter) },
        { }
    };

    static PyType_Spec type_spec_NavigationViewItemPresenter = {
        "winrt._winrt_microsoft_ui_xaml_controls_primitives.NavigationViewItemPresenter",
        sizeof(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>),
        0,
        Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,
        _type_slots_NavigationViewItemPresenter};

    static PyGetSetDef getset_NavigationViewItemPresenter_Static[] = {
        { "icon_property", reinterpret_cast<getter>(NavigationViewItemPresenter_get_IconProperty), nullptr, nullptr, nullptr },
        { "template_settings_property", reinterpret_cast<getter>(NavigationViewItemPresenter_get_TemplateSettingsProperty), nullptr, nullptr, nullptr },
        { "info_badge_property", reinterpret_cast<getter>(NavigationViewItemPresenter_get_InfoBadgeProperty), nullptr, nullptr, nullptr },
        { }
    };

    static PyMethodDef methods_NavigationViewItemPresenter_Static[] = {
        { }
    };

    static PyType_Slot type_slots_NavigationViewItemPresenter_Static[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_NavigationViewItemPresenter_Static) },
        { Py_tp_methods, reinterpret_cast<void*>(methods_NavigationViewItemPresenter_Static) },
        { }
    };

    static PyType_Spec type_spec_NavigationViewItemPresenter_Static =
    {
        "winrt._winrt_microsoft_ui_xaml_controls_primitives.NavigationViewItemPresenter_Static",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,
        type_slots_NavigationViewItemPresenter_Static
    };

    // ----- NavigationViewItemPresenterTemplateSettings class --------------------

    struct PyWinrtNavigationViewItemPresenterTemplateSettings;
    using BasePyWinrtNavigationViewItemPresenterTemplateSettings = winrt::Microsoft::UI::Xaml::Controls::Primitives::NavigationViewItemPresenterTemplateSettingsT<PyWinrtNavigationViewItemPresenterTemplateSettings, py::IPywinrtObject>;

    struct PyWinrtNavigationViewItemPresenterTemplateSettings : py::py_obj_ref, BasePyWinrtNavigationViewItemPresenterTemplateSettings
    {
        PyWinrtNavigationViewItemPresenterTemplateSettings(PyObject* py_obj) : py::py_obj_ref(py_obj), BasePyWinrtNavigationViewItemPresenterTemplateSettings() {}

        int32_t __stdcall GetPyObject(PyObject*& obj) override
        {
            obj = py::py_obj_ref::get_py_obj();
            return 0;
        }

        int32_t __stdcall GetComposableInner(winrt::Windows::Foundation::IInspectable& inner) override
        {
            inner = m_inner;
            return winrt::impl::error_ok;
        }

        static void toggle_reference(PyWinrtNavigationViewItemPresenterTemplateSettings* instance, bool is_last_reference)
        {
            py::py_obj_ref::toggle_reference(instance, is_last_reference);
        }

        int32_t query_interface_tearoff(winrt::guid const& id, void** result) const noexcept override
        {
            return py::py_obj_ref::query_interface_tearoff(id, result);
        }
    };

    static PyObject* _new_NavigationViewItemPresenterTemplateSettings(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);

        auto self_type = get_python_type_for<winrt::Microsoft::UI::Xaml::Controls::Primitives::NavigationViewItemPresenterTemplateSettings>();
        if (!self_type)
        {
            return nullptr;
        }

        if (arg_count == 0)
        {
            try
            {
                if (type != self_type)
                {
                    py::pyobj_handle self{type->tp_alloc(type, 0)};
                    if (!self)
                    {
                        return nullptr;
                    }

                    std::construct_at(&reinterpret_cast<py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>*>(self.get())->obj, nullptr);

                    auto obj_impl = winrt::make_self<PyWinrtNavigationViewItemPresenterTemplateSettings>(self.get());

                    auto obj = py::make_py_obj<PyWinrtNavigationViewItemPresenterTemplateSettings>(obj_impl, type, self.get());
                    if (!obj)
                    {
                        return nullptr;
                    }

                    reinterpret_cast<py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>*>(self.get())->obj = std::move(obj);

                    return self.detach();
                }

                winrt::Microsoft::UI::Xaml::Controls::Primitives::NavigationViewItemPresenterTemplateSettings instance{};
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_NavigationViewItemPresenterTemplateSettings(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* NavigationViewItemPresenterTemplateSettings_get_IconWidth(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.NavigationViewItemPresenterTemplateSettings", L"IconWidth");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::Primitives::NavigationViewItemPresenterTemplateSettings>().IconWidth();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* NavigationViewItemPresenterTemplateSettings_get_SmallerIconWidth(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.NavigationViewItemPresenterTemplateSettings", L"SmallerIconWidth");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::Primitives::NavigationViewItemPresenterTemplateSettings>().SmallerIconWidth();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* NavigationViewItemPresenterTemplateSettings_get_IconWidthProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.NavigationViewItemPresenterTemplateSettings", L"IconWidthProperty");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return winrt::Microsoft::UI::Xaml::Controls::Primitives::NavigationViewItemPresenterTemplateSettings::IconWidthProperty();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* NavigationViewItemPresenterTemplateSettings_get_SmallerIconWidthProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.NavigationViewItemPresenterTemplateSettings", L"SmallerIconWidthProperty");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return winrt::Microsoft::UI::Xaml::Controls::Primitives::NavigationViewItemPresenterTemplateSettings::SmallerIconWidthProperty();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_NavigationViewItemPresenterTemplateSettings(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Microsoft::UI::Xaml::Controls::Primitives::NavigationViewItemPresenterTemplateSettings>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_NavigationViewItemPresenterTemplateSettings(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Microsoft::UI::Xaml::Controls::Primitives::NavigationViewItemPresenterTemplateSettings>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_NavigationViewItemPresenterTemplateSettings[] = {
        { "_assign_array_", _assign_array_NavigationViewItemPresenterTemplateSettings, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_NavigationViewItemPresenterTemplateSettings), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_NavigationViewItemPresenterTemplateSettings[] = {
        { "icon_width", reinterpret_cast<getter>(NavigationViewItemPresenterTemplateSettings_get_IconWidth), nullptr, nullptr, nullptr },
        { "smaller_icon_width", reinterpret_cast<getter>(NavigationViewItemPresenterTemplateSettings_get_SmallerIconWidth), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_NavigationViewItemPresenterTemplateSettings[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_NavigationViewItemPresenterTemplateSettings) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_NavigationViewItemPresenterTemplateSettings) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_NavigationViewItemPresenterTemplateSettings) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_NavigationViewItemPresenterTemplateSettings) },
        { }
    };

    static PyType_Spec type_spec_NavigationViewItemPresenterTemplateSettings = {
        "winrt._winrt_microsoft_ui_xaml_controls_primitives.NavigationViewItemPresenterTemplateSettings",
        sizeof(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>),
        0,
        Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,
        _type_slots_NavigationViewItemPresenterTemplateSettings};

    static PyGetSetDef getset_NavigationViewItemPresenterTemplateSettings_Static[] = {
        { "icon_width_property", reinterpret_cast<getter>(NavigationViewItemPresenterTemplateSettings_get_IconWidthProperty), nullptr, nullptr, nullptr },
        { "smaller_icon_width_property", reinterpret_cast<getter>(NavigationViewItemPresenterTemplateSettings_get_SmallerIconWidthProperty), nullptr, nullptr, nullptr },
        { }
    };

    static PyMethodDef methods_NavigationViewItemPresenterTemplateSettings_Static[] = {
        { }
    };

    static PyType_Slot type_slots_NavigationViewItemPresenterTemplateSettings_Static[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_NavigationViewItemPresenterTemplateSettings_Static) },
        { Py_tp_methods, reinterpret_cast<void*>(methods_NavigationViewItemPresenterTemplateSettings_Static) },
        { }
    };

    static PyType_Spec type_spec_NavigationViewItemPresenterTemplateSettings_Static =
    {
        "winrt._winrt_microsoft_ui_xaml_controls_primitives.NavigationViewItemPresenterTemplateSettings_Static",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,
        type_slots_NavigationViewItemPresenterTemplateSettings_Static
    };

    // ----- OrientedVirtualizingPanel class --------------------

    static PyObject* _new_OrientedVirtualizingPanel(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Microsoft::UI::Xaml::Controls::Primitives::OrientedVirtualizingPanel>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Microsoft::UI::Xaml::Controls::Primitives::OrientedVirtualizingPanel>::type_name);
        return nullptr;
    }

    static void _dealloc_OrientedVirtualizingPanel(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* OrientedVirtualizingPanel_GetInsertionIndexes(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Xaml.Controls.Primitives.OrientedVirtualizingPanel", L"GetInsertionIndexes", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Foundation::Point>(args, 0);
                int32_t param1{};
                int32_t param2{};

                {
                    auto _gil = release_gil();
                    self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::Primitives::OrientedVirtualizingPanel>().GetInsertionIndexes(param0, param1, param2);
                }

                py::pyobj_handle out1{ py::convert(param1) };
                if (!out1)
                {
                    return nullptr;
                }
                py::pyobj_handle out2{ py::convert(param2) };
                if (!out2)
                {
                    return nullptr;
                }

                return PyTuple_Pack(2, out1.get(), out2.get());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* OrientedVirtualizingPanel_GetIrregularSnapPoints(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Xaml.Controls.Primitives.OrientedVirtualizingPanel", L"GetIrregularSnapPoints", 2);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(2);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Microsoft::UI::Xaml::Controls::Orientation>(args, 0);
                auto param1 = py::convert_to<winrt::Microsoft::UI::Xaml::Controls::Primitives::SnapPointsAlignment>(args, 1);

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::Primitives::OrientedVirtualizingPanel>().GetIrregularSnapPoints(param0, param1);
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* OrientedVirtualizingPanel_GetRegularSnapPoints(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Xaml.Controls.Primitives.OrientedVirtualizingPanel", L"GetRegularSnapPoints", 2);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(2);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Microsoft::UI::Xaml::Controls::Orientation>(args, 0);
                auto param1 = py::convert_to<winrt::Microsoft::UI::Xaml::Controls::Primitives::SnapPointsAlignment>(args, 1);
                float param2{};

                auto return_value = [&]()
                {
                    auto _gil = release_gil();
                    return self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::Primitives::OrientedVirtualizingPanel>().GetRegularSnapPoints(param0, param1, param2);
                }();

                py::pyobj_handle out_return_value{ py::convert(return_value) };
                if (!out_return_value)
                {
                    return nullptr;
                }
                py::pyobj_handle out2{ py::convert(param2) };
                if (!out2)
                {
                    return nullptr;
                }

                return PyTuple_Pack(2, out_return_value.get(), out2.get());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* OrientedVirtualizingPanel_LineDown(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Xaml.Controls.Primitives.OrientedVirtualizingPanel", L"LineDown", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                {
                    auto _gil = release_gil();
                    self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::Primitives::OrientedVirtualizingPanel>().LineDown();
                }

                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* OrientedVirtualizingPanel_LineLeft(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Xaml.Controls.Primitives.OrientedVirtualizingPanel", L"LineLeft", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                {
                    auto _gil = release_gil();
                    self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::Primitives::OrientedVirtualizingPanel>().LineLeft();
                }

                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* OrientedVirtualizingPanel_LineRight(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Xaml.Controls.Primitives.OrientedVirtualizingPanel", L"LineRight", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                {
                    auto _gil = release_gil();
                    self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::Primitives::OrientedVirtualizingPanel>().LineRight();
                }

                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* OrientedVirtualizingPanel_LineUp(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Xaml.Controls.Primitives.OrientedVirtualizingPanel", L"LineUp", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                {
                    auto _gil = release_gil();
                    self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::Primitives::OrientedVirtualizingPanel>().LineUp();
                }

                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* OrientedVirtualizingPanel_MakeVisible(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Xaml.Controls.Primitives.OrientedVirtualizingPanel", L"MakeVisible", 2);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(2);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Microsoft::UI::Xaml::UIElement>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Foundation::Rect>(args, 1);

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::Primitives::OrientedVirtualizingPanel>().MakeVisible(param0, param1);
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* OrientedVirtualizingPanel_MouseWheelDown(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Xaml.Controls.Primitives.OrientedVirtualizingPanel", L"MouseWheelDown", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                {
                    auto _gil = release_gil();
                    self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::Primitives::OrientedVirtualizingPanel>().MouseWheelDown();
                }

                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* OrientedVirtualizingPanel_MouseWheelLeft(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Xaml.Controls.Primitives.OrientedVirtualizingPanel", L"MouseWheelLeft", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                {
                    auto _gil = release_gil();
                    self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::Primitives::OrientedVirtualizingPanel>().MouseWheelLeft();
                }

                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* OrientedVirtualizingPanel_MouseWheelRight(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Xaml.Controls.Primitives.OrientedVirtualizingPanel", L"MouseWheelRight", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                {
                    auto _gil = release_gil();
                    self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::Primitives::OrientedVirtualizingPanel>().MouseWheelRight();
                }

                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* OrientedVirtualizingPanel_MouseWheelUp(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Xaml.Controls.Primitives.OrientedVirtualizingPanel", L"MouseWheelUp", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                {
                    auto _gil = release_gil();
                    self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::Primitives::OrientedVirtualizingPanel>().MouseWheelUp();
                }

                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* OrientedVirtualizingPanel_PageDown(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Xaml.Controls.Primitives.OrientedVirtualizingPanel", L"PageDown", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                {
                    auto _gil = release_gil();
                    self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::Primitives::OrientedVirtualizingPanel>().PageDown();
                }

                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* OrientedVirtualizingPanel_PageLeft(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Xaml.Controls.Primitives.OrientedVirtualizingPanel", L"PageLeft", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                {
                    auto _gil = release_gil();
                    self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::Primitives::OrientedVirtualizingPanel>().PageLeft();
                }

                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* OrientedVirtualizingPanel_PageRight(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Xaml.Controls.Primitives.OrientedVirtualizingPanel", L"PageRight", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                {
                    auto _gil = release_gil();
                    self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::Primitives::OrientedVirtualizingPanel>().PageRight();
                }

                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* OrientedVirtualizingPanel_PageUp(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Xaml.Controls.Primitives.OrientedVirtualizingPanel", L"PageUp", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                {
                    auto _gil = release_gil();
                    self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::Primitives::OrientedVirtualizingPanel>().PageUp();
                }

                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* OrientedVirtualizingPanel_SetHorizontalOffset(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Xaml.Controls.Primitives.OrientedVirtualizingPanel", L"SetHorizontalOffset", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<double>(args, 0);

                {
                    auto _gil = release_gil();
                    self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::Primitives::OrientedVirtualizingPanel>().SetHorizontalOffset(param0);
                }

                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* OrientedVirtualizingPanel_SetVerticalOffset(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Xaml.Controls.Primitives.OrientedVirtualizingPanel", L"SetVerticalOffset", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<double>(args, 0);

                {
                    auto _gil = release_gil();
                    self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::Primitives::OrientedVirtualizingPanel>().SetVerticalOffset(param0);
                }

                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* OrientedVirtualizingPanel_get_ScrollOwner(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.OrientedVirtualizingPanel", L"ScrollOwner");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::Primitives::OrientedVirtualizingPanel>().ScrollOwner();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int OrientedVirtualizingPanel_put_ScrollOwner(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.OrientedVirtualizingPanel", L"ScrollOwner");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);

            {
                auto _gil = release_gil();
                self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::Primitives::OrientedVirtualizingPanel>().ScrollOwner(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* OrientedVirtualizingPanel_get_CanVerticallyScroll(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.OrientedVirtualizingPanel", L"CanVerticallyScroll");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::Primitives::OrientedVirtualizingPanel>().CanVerticallyScroll();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int OrientedVirtualizingPanel_put_CanVerticallyScroll(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.OrientedVirtualizingPanel", L"CanVerticallyScroll");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<bool>(arg);

            {
                auto _gil = release_gil();
                self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::Primitives::OrientedVirtualizingPanel>().CanVerticallyScroll(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* OrientedVirtualizingPanel_get_CanHorizontallyScroll(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.OrientedVirtualizingPanel", L"CanHorizontallyScroll");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::Primitives::OrientedVirtualizingPanel>().CanHorizontallyScroll();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int OrientedVirtualizingPanel_put_CanHorizontallyScroll(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.OrientedVirtualizingPanel", L"CanHorizontallyScroll");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<bool>(arg);

            {
                auto _gil = release_gil();
                self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::Primitives::OrientedVirtualizingPanel>().CanHorizontallyScroll(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* OrientedVirtualizingPanel_get_ExtentHeight(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.OrientedVirtualizingPanel", L"ExtentHeight");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::Primitives::OrientedVirtualizingPanel>().ExtentHeight();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* OrientedVirtualizingPanel_get_ExtentWidth(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.OrientedVirtualizingPanel", L"ExtentWidth");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::Primitives::OrientedVirtualizingPanel>().ExtentWidth();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* OrientedVirtualizingPanel_get_HorizontalOffset(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.OrientedVirtualizingPanel", L"HorizontalOffset");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::Primitives::OrientedVirtualizingPanel>().HorizontalOffset();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* OrientedVirtualizingPanel_get_VerticalOffset(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.OrientedVirtualizingPanel", L"VerticalOffset");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::Primitives::OrientedVirtualizingPanel>().VerticalOffset();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* OrientedVirtualizingPanel_get_ViewportHeight(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.OrientedVirtualizingPanel", L"ViewportHeight");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::Primitives::OrientedVirtualizingPanel>().ViewportHeight();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* OrientedVirtualizingPanel_get_ViewportWidth(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.OrientedVirtualizingPanel", L"ViewportWidth");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::Primitives::OrientedVirtualizingPanel>().ViewportWidth();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* OrientedVirtualizingPanel_get_AreHorizontalSnapPointsRegular(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.OrientedVirtualizingPanel", L"AreHorizontalSnapPointsRegular");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::Primitives::OrientedVirtualizingPanel>().AreHorizontalSnapPointsRegular();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* OrientedVirtualizingPanel_get_AreVerticalSnapPointsRegular(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.OrientedVirtualizingPanel", L"AreVerticalSnapPointsRegular");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::Primitives::OrientedVirtualizingPanel>().AreVerticalSnapPointsRegular();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* OrientedVirtualizingPanel_add_HorizontalSnapPointsChanged(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, PyObject* arg) noexcept
    {
        try
        {
            static std::optional<bool> is_event_present{};

            if (!is_event_present.has_value())
            {
                is_event_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Microsoft.UI.Xaml.Controls.Primitives.OrientedVirtualizingPanel", L"HorizontalSnapPointsChanged");
            }

            if (!is_event_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::EventHandler<winrt::Windows::Foundation::IInspectable>>(arg);

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::Primitives::OrientedVirtualizingPanel>().HorizontalSnapPointsChanged(param0);
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* OrientedVirtualizingPanel_remove_HorizontalSnapPointsChanged(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, PyObject* arg) noexcept
    {
        try
        {
            static std::optional<bool> is_event_present{};

            if (!is_event_present.has_value())
            {
                is_event_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Microsoft.UI.Xaml.Controls.Primitives.OrientedVirtualizingPanel", L"HorizontalSnapPointsChanged");
            }

            if (!is_event_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::event_token>(arg);

            {
                auto _gil = release_gil();
                self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::Primitives::OrientedVirtualizingPanel>().HorizontalSnapPointsChanged(param0);
            }

            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* OrientedVirtualizingPanel_add_VerticalSnapPointsChanged(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, PyObject* arg) noexcept
    {
        try
        {
            static std::optional<bool> is_event_present{};

            if (!is_event_present.has_value())
            {
                is_event_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Microsoft.UI.Xaml.Controls.Primitives.OrientedVirtualizingPanel", L"VerticalSnapPointsChanged");
            }

            if (!is_event_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::EventHandler<winrt::Windows::Foundation::IInspectable>>(arg);

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::Primitives::OrientedVirtualizingPanel>().VerticalSnapPointsChanged(param0);
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* OrientedVirtualizingPanel_remove_VerticalSnapPointsChanged(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, PyObject* arg) noexcept
    {
        try
        {
            static std::optional<bool> is_event_present{};

            if (!is_event_present.has_value())
            {
                is_event_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Microsoft.UI.Xaml.Controls.Primitives.OrientedVirtualizingPanel", L"VerticalSnapPointsChanged");
            }

            if (!is_event_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::event_token>(arg);

            {
                auto _gil = release_gil();
                self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::Primitives::OrientedVirtualizingPanel>().VerticalSnapPointsChanged(param0);
            }

            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_OrientedVirtualizingPanel(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Microsoft::UI::Xaml::Controls::Primitives::OrientedVirtualizingPanel>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_OrientedVirtualizingPanel(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Microsoft::UI::Xaml::Controls::Primitives::OrientedVirtualizingPanel>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_OrientedVirtualizingPanel[] = {
        { "get_insertion_indexes", reinterpret_cast<PyCFunction>(OrientedVirtualizingPanel_GetInsertionIndexes), METH_VARARGS, nullptr },
        { "get_irregular_snap_points", reinterpret_cast<PyCFunction>(OrientedVirtualizingPanel_GetIrregularSnapPoints), METH_VARARGS, nullptr },
        { "get_regular_snap_points", reinterpret_cast<PyCFunction>(OrientedVirtualizingPanel_GetRegularSnapPoints), METH_VARARGS, nullptr },
        { "line_down", reinterpret_cast<PyCFunction>(OrientedVirtualizingPanel_LineDown), METH_VARARGS, nullptr },
        { "line_left", reinterpret_cast<PyCFunction>(OrientedVirtualizingPanel_LineLeft), METH_VARARGS, nullptr },
        { "line_right", reinterpret_cast<PyCFunction>(OrientedVirtualizingPanel_LineRight), METH_VARARGS, nullptr },
        { "line_up", reinterpret_cast<PyCFunction>(OrientedVirtualizingPanel_LineUp), METH_VARARGS, nullptr },
        { "make_visible", reinterpret_cast<PyCFunction>(OrientedVirtualizingPanel_MakeVisible), METH_VARARGS, nullptr },
        { "mouse_wheel_down", reinterpret_cast<PyCFunction>(OrientedVirtualizingPanel_MouseWheelDown), METH_VARARGS, nullptr },
        { "mouse_wheel_left", reinterpret_cast<PyCFunction>(OrientedVirtualizingPanel_MouseWheelLeft), METH_VARARGS, nullptr },
        { "mouse_wheel_right", reinterpret_cast<PyCFunction>(OrientedVirtualizingPanel_MouseWheelRight), METH_VARARGS, nullptr },
        { "mouse_wheel_up", reinterpret_cast<PyCFunction>(OrientedVirtualizingPanel_MouseWheelUp), METH_VARARGS, nullptr },
        { "page_down", reinterpret_cast<PyCFunction>(OrientedVirtualizingPanel_PageDown), METH_VARARGS, nullptr },
        { "page_left", reinterpret_cast<PyCFunction>(OrientedVirtualizingPanel_PageLeft), METH_VARARGS, nullptr },
        { "page_right", reinterpret_cast<PyCFunction>(OrientedVirtualizingPanel_PageRight), METH_VARARGS, nullptr },
        { "page_up", reinterpret_cast<PyCFunction>(OrientedVirtualizingPanel_PageUp), METH_VARARGS, nullptr },
        { "set_horizontal_offset", reinterpret_cast<PyCFunction>(OrientedVirtualizingPanel_SetHorizontalOffset), METH_VARARGS, nullptr },
        { "set_vertical_offset", reinterpret_cast<PyCFunction>(OrientedVirtualizingPanel_SetVerticalOffset), METH_VARARGS, nullptr },
        { "add_horizontal_snap_points_changed", reinterpret_cast<PyCFunction>(OrientedVirtualizingPanel_add_HorizontalSnapPointsChanged), METH_O, nullptr },
        { "remove_horizontal_snap_points_changed", reinterpret_cast<PyCFunction>(OrientedVirtualizingPanel_remove_HorizontalSnapPointsChanged), METH_O, nullptr },
        { "add_vertical_snap_points_changed", reinterpret_cast<PyCFunction>(OrientedVirtualizingPanel_add_VerticalSnapPointsChanged), METH_O, nullptr },
        { "remove_vertical_snap_points_changed", reinterpret_cast<PyCFunction>(OrientedVirtualizingPanel_remove_VerticalSnapPointsChanged), METH_O, nullptr },
        { "_assign_array_", _assign_array_OrientedVirtualizingPanel, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_OrientedVirtualizingPanel), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_OrientedVirtualizingPanel[] = {
        { "scroll_owner", reinterpret_cast<getter>(OrientedVirtualizingPanel_get_ScrollOwner), reinterpret_cast<setter>(OrientedVirtualizingPanel_put_ScrollOwner), nullptr, nullptr },
        { "can_vertically_scroll", reinterpret_cast<getter>(OrientedVirtualizingPanel_get_CanVerticallyScroll), reinterpret_cast<setter>(OrientedVirtualizingPanel_put_CanVerticallyScroll), nullptr, nullptr },
        { "can_horizontally_scroll", reinterpret_cast<getter>(OrientedVirtualizingPanel_get_CanHorizontallyScroll), reinterpret_cast<setter>(OrientedVirtualizingPanel_put_CanHorizontallyScroll), nullptr, nullptr },
        { "extent_height", reinterpret_cast<getter>(OrientedVirtualizingPanel_get_ExtentHeight), nullptr, nullptr, nullptr },
        { "extent_width", reinterpret_cast<getter>(OrientedVirtualizingPanel_get_ExtentWidth), nullptr, nullptr, nullptr },
        { "horizontal_offset", reinterpret_cast<getter>(OrientedVirtualizingPanel_get_HorizontalOffset), nullptr, nullptr, nullptr },
        { "vertical_offset", reinterpret_cast<getter>(OrientedVirtualizingPanel_get_VerticalOffset), nullptr, nullptr, nullptr },
        { "viewport_height", reinterpret_cast<getter>(OrientedVirtualizingPanel_get_ViewportHeight), nullptr, nullptr, nullptr },
        { "viewport_width", reinterpret_cast<getter>(OrientedVirtualizingPanel_get_ViewportWidth), nullptr, nullptr, nullptr },
        { "are_horizontal_snap_points_regular", reinterpret_cast<getter>(OrientedVirtualizingPanel_get_AreHorizontalSnapPointsRegular), nullptr, nullptr, nullptr },
        { "are_vertical_snap_points_regular", reinterpret_cast<getter>(OrientedVirtualizingPanel_get_AreVerticalSnapPointsRegular), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_OrientedVirtualizingPanel[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_OrientedVirtualizingPanel) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_OrientedVirtualizingPanel) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_OrientedVirtualizingPanel) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_OrientedVirtualizingPanel) },
        { }
    };

    static PyType_Spec type_spec_OrientedVirtualizingPanel = {
        "winrt._winrt_microsoft_ui_xaml_controls_primitives.OrientedVirtualizingPanel",
        sizeof(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>),
        0,
        Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,
        _type_slots_OrientedVirtualizingPanel};

    static PyGetSetDef getset_OrientedVirtualizingPanel_Static[] = {
        { }
    };

    static PyMethodDef methods_OrientedVirtualizingPanel_Static[] = {
        { }
    };

    static PyType_Slot type_slots_OrientedVirtualizingPanel_Static[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_OrientedVirtualizingPanel_Static) },
        { Py_tp_methods, reinterpret_cast<void*>(methods_OrientedVirtualizingPanel_Static) },
        { }
    };

    static PyType_Spec type_spec_OrientedVirtualizingPanel_Static =
    {
        "winrt._winrt_microsoft_ui_xaml_controls_primitives.OrientedVirtualizingPanel_Static",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,
        type_slots_OrientedVirtualizingPanel_Static
    };

    // ----- PickerFlyoutBase class --------------------

    struct PyWinrtPickerFlyoutBase;
    using BasePyWinrtPickerFlyoutBase = winrt::Microsoft::UI::Xaml::Controls::Primitives::PickerFlyoutBaseT<PyWinrtPickerFlyoutBase, py::IPywinrtObject>;

    struct PyWinrtPickerFlyoutBase : py::py_obj_ref, BasePyWinrtPickerFlyoutBase
    {

        int32_t __stdcall GetPyObject(PyObject*& obj) override
        {
            obj = py::py_obj_ref::get_py_obj();
            return 0;
        }

        int32_t __stdcall GetComposableInner(winrt::Windows::Foundation::IInspectable& inner) override
        {
            inner = m_inner;
            return winrt::impl::error_ok;
        }

        static void toggle_reference(PyWinrtPickerFlyoutBase* instance, bool is_last_reference)
        {
            py::py_obj_ref::toggle_reference(instance, is_last_reference);
        }

        int32_t query_interface_tearoff(winrt::guid const& id, void** result) const noexcept override
        {
            return py::py_obj_ref::query_interface_tearoff(id, result);
        }

        void OnConfirmed()
        {
            auto gil = py::ensure_gil();

            try
            {
                py::pyobj_handle self{get_py_obj()};

                py::pyobj_handle method{PyObject_GetAttrString(self.get(), "_on_confirmed")};
                if (!method)
                {
                    throw python_exception();
                }

                py::pyobj_handle return_value{PyObject_CallNoArgs(method.get())};
                if (!return_value)
                {
                    throw python_exception();
                }
            }
            catch (python_exception)
            {
                py::write_unraisable_and_throw();
            }
        }

        bool ShouldShowConfirmationButtons()
        {
            auto gil = py::ensure_gil();

            try
            {
                py::pyobj_handle self{get_py_obj()};

                py::pyobj_handle method{PyObject_GetAttrString(self.get(), "_should_show_confirmation_buttons")};
                if (!method)
                {
                    throw python_exception();
                }

                py::pyobj_handle return_value{PyObject_CallNoArgs(method.get())};
                if (!return_value)
                {
                    throw python_exception();
                }

                return py::convert_to<bool>(return_value.get());
            }
            catch (python_exception)
            {
                py::write_unraisable_and_throw();
            }
        }
    };

    static PyObject* _new_PickerFlyoutBase(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Microsoft::UI::Xaml::Controls::Primitives::PickerFlyoutBase>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Microsoft::UI::Xaml::Controls::Primitives::PickerFlyoutBase>::type_name);
        return nullptr;
    }

    static void _dealloc_PickerFlyoutBase(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* PickerFlyoutBase_GetTitle(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Xaml.Controls.Primitives.PickerFlyoutBase", L"GetTitle", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Microsoft::UI::Xaml::DependencyObject>(args, 0);

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return winrt::Microsoft::UI::Xaml::Controls::Primitives::PickerFlyoutBase::GetTitle(param0);
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PickerFlyoutBase_OnConfirmed(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Xaml.Controls.Primitives.PickerFlyoutBase", L"OnConfirmed", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                {
                    auto _gil = release_gil();
                    py::get_inner_or_self(self->obj).try_as<winrt::Microsoft::UI::Xaml::Controls::Primitives::IPickerFlyoutBaseOverrides>().OnConfirmed();
                }

                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PickerFlyoutBase_SetTitle(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Xaml.Controls.Primitives.PickerFlyoutBase", L"SetTitle", 2);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(2);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Microsoft::UI::Xaml::DependencyObject>(args, 0);
                auto param1 = py::convert_to<winrt::hstring>(args, 1);

                {
                    auto _gil = release_gil();
                    winrt::Microsoft::UI::Xaml::Controls::Primitives::PickerFlyoutBase::SetTitle(param0, param1);
                }

                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PickerFlyoutBase_ShouldShowConfirmationButtons(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Xaml.Controls.Primitives.PickerFlyoutBase", L"ShouldShowConfirmationButtons", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return py::get_inner_or_self(self->obj).try_as<winrt::Microsoft::UI::Xaml::Controls::Primitives::IPickerFlyoutBaseOverrides>().ShouldShowConfirmationButtons();
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PickerFlyoutBase_get_TitleProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.PickerFlyoutBase", L"TitleProperty");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return winrt::Microsoft::UI::Xaml::Controls::Primitives::PickerFlyoutBase::TitleProperty();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_PickerFlyoutBase(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Microsoft::UI::Xaml::Controls::Primitives::PickerFlyoutBase>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_PickerFlyoutBase(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Microsoft::UI::Xaml::Controls::Primitives::PickerFlyoutBase>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_PickerFlyoutBase[] = {
        { "_on_confirmed", reinterpret_cast<PyCFunction>(PickerFlyoutBase_OnConfirmed), METH_VARARGS, nullptr },
        { "_should_show_confirmation_buttons", reinterpret_cast<PyCFunction>(PickerFlyoutBase_ShouldShowConfirmationButtons), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_PickerFlyoutBase, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_PickerFlyoutBase), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_PickerFlyoutBase[] = {
        { }
    };

    static PyType_Slot _type_slots_PickerFlyoutBase[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_PickerFlyoutBase) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_PickerFlyoutBase) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_PickerFlyoutBase) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_PickerFlyoutBase) },
        { }
    };

    static PyType_Spec type_spec_PickerFlyoutBase = {
        "winrt._winrt_microsoft_ui_xaml_controls_primitives.PickerFlyoutBase",
        sizeof(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>),
        0,
        Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,
        _type_slots_PickerFlyoutBase};

    static PyGetSetDef getset_PickerFlyoutBase_Static[] = {
        { "title_property", reinterpret_cast<getter>(PickerFlyoutBase_get_TitleProperty), nullptr, nullptr, nullptr },
        { }
    };

    static PyMethodDef methods_PickerFlyoutBase_Static[] = {
        { "get_title", reinterpret_cast<PyCFunction>(PickerFlyoutBase_GetTitle), METH_VARARGS, nullptr },
        { "set_title", reinterpret_cast<PyCFunction>(PickerFlyoutBase_SetTitle), METH_VARARGS, nullptr },
        { }
    };

    static PyType_Slot type_slots_PickerFlyoutBase_Static[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_PickerFlyoutBase_Static) },
        { Py_tp_methods, reinterpret_cast<void*>(methods_PickerFlyoutBase_Static) },
        { }
    };

    static PyType_Spec type_spec_PickerFlyoutBase_Static =
    {
        "winrt._winrt_microsoft_ui_xaml_controls_primitives.PickerFlyoutBase_Static",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,
        type_slots_PickerFlyoutBase_Static
    };

    // ----- PivotHeaderItem class --------------------

    struct PyWinrtPivotHeaderItem;
    using BasePyWinrtPivotHeaderItem = winrt::Microsoft::UI::Xaml::Controls::Primitives::PivotHeaderItemT<PyWinrtPivotHeaderItem, py::IPywinrtObject>;

    struct PyWinrtPivotHeaderItem : py::py_obj_ref, BasePyWinrtPivotHeaderItem
    {
        PyWinrtPivotHeaderItem(PyObject* py_obj) : py::py_obj_ref(py_obj), BasePyWinrtPivotHeaderItem() {}

        int32_t __stdcall GetPyObject(PyObject*& obj) override
        {
            obj = py::py_obj_ref::get_py_obj();
            return 0;
        }

        int32_t __stdcall GetComposableInner(winrt::Windows::Foundation::IInspectable& inner) override
        {
            inner = m_inner;
            return winrt::impl::error_ok;
        }

        static void toggle_reference(PyWinrtPivotHeaderItem* instance, bool is_last_reference)
        {
            py::py_obj_ref::toggle_reference(instance, is_last_reference);
        }

        int32_t query_interface_tearoff(winrt::guid const& id, void** result) const noexcept override
        {
            return py::py_obj_ref::query_interface_tearoff(id, result);
        }
    };

    static PyObject* _new_PivotHeaderItem(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);

        auto self_type = get_python_type_for<winrt::Microsoft::UI::Xaml::Controls::Primitives::PivotHeaderItem>();
        if (!self_type)
        {
            return nullptr;
        }

        if (arg_count == 0)
        {
            try
            {
                if (type != self_type)
                {
                    py::pyobj_handle self{type->tp_alloc(type, 0)};
                    if (!self)
                    {
                        return nullptr;
                    }

                    std::construct_at(&reinterpret_cast<py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>*>(self.get())->obj, nullptr);

                    auto obj_impl = winrt::make_self<PyWinrtPivotHeaderItem>(self.get());

                    auto obj = py::make_py_obj<PyWinrtPivotHeaderItem>(obj_impl, type, self.get());
                    if (!obj)
                    {
                        return nullptr;
                    }

                    reinterpret_cast<py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>*>(self.get())->obj = std::move(obj);

                    return self.detach();
                }

                winrt::Microsoft::UI::Xaml::Controls::Primitives::PivotHeaderItem instance{};
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_PivotHeaderItem(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* _assign_array_PivotHeaderItem(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Microsoft::UI::Xaml::Controls::Primitives::PivotHeaderItem>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_PivotHeaderItem(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Microsoft::UI::Xaml::Controls::Primitives::PivotHeaderItem>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_PivotHeaderItem[] = {
        { "_assign_array_", _assign_array_PivotHeaderItem, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_PivotHeaderItem), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_PivotHeaderItem[] = {
        { }
    };

    static PyType_Slot _type_slots_PivotHeaderItem[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_PivotHeaderItem) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_PivotHeaderItem) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_PivotHeaderItem) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_PivotHeaderItem) },
        { }
    };

    static PyType_Spec type_spec_PivotHeaderItem = {
        "winrt._winrt_microsoft_ui_xaml_controls_primitives.PivotHeaderItem",
        sizeof(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>),
        0,
        Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,
        _type_slots_PivotHeaderItem};

    static PyGetSetDef getset_PivotHeaderItem_Static[] = {
        { }
    };

    static PyMethodDef methods_PivotHeaderItem_Static[] = {
        { }
    };

    static PyType_Slot type_slots_PivotHeaderItem_Static[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_PivotHeaderItem_Static) },
        { Py_tp_methods, reinterpret_cast<void*>(methods_PivotHeaderItem_Static) },
        { }
    };

    static PyType_Spec type_spec_PivotHeaderItem_Static =
    {
        "winrt._winrt_microsoft_ui_xaml_controls_primitives.PivotHeaderItem_Static",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,
        type_slots_PivotHeaderItem_Static
    };

    // ----- PivotHeaderPanel class --------------------

    static PyObject* _new_PivotHeaderPanel(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 0)
        {
            try
            {
                winrt::Microsoft::UI::Xaml::Controls::Primitives::PivotHeaderPanel instance{};
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_PivotHeaderPanel(py::wrapper::Microsoft::UI::Xaml::Controls::Primitives::PivotHeaderPanel* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* _assign_array_PivotHeaderPanel(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Microsoft::UI::Xaml::Controls::Primitives::PivotHeaderPanel>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_PivotHeaderPanel(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Microsoft::UI::Xaml::Controls::Primitives::PivotHeaderPanel>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_PivotHeaderPanel[] = {
        { "_assign_array_", _assign_array_PivotHeaderPanel, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_PivotHeaderPanel), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_PivotHeaderPanel[] = {
        { }
    };

    static PyType_Slot _type_slots_PivotHeaderPanel[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_PivotHeaderPanel) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_PivotHeaderPanel) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_PivotHeaderPanel) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_PivotHeaderPanel) },
        { }
    };

    static PyType_Spec type_spec_PivotHeaderPanel = {
        "winrt._winrt_microsoft_ui_xaml_controls_primitives.PivotHeaderPanel",
        sizeof(py::wrapper::Microsoft::UI::Xaml::Controls::Primitives::PivotHeaderPanel),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_PivotHeaderPanel};

    // ----- PivotPanel class --------------------

    static PyObject* _new_PivotPanel(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 0)
        {
            try
            {
                winrt::Microsoft::UI::Xaml::Controls::Primitives::PivotPanel instance{};
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_PivotPanel(py::wrapper::Microsoft::UI::Xaml::Controls::Primitives::PivotPanel* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* PivotPanel_GetIrregularSnapPoints(py::wrapper::Microsoft::UI::Xaml::Controls::Primitives::PivotPanel* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Xaml.Controls.Primitives.PivotPanel", L"GetIrregularSnapPoints", 2);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(2);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Microsoft::UI::Xaml::Controls::Orientation>(args, 0);
                auto param1 = py::convert_to<winrt::Microsoft::UI::Xaml::Controls::Primitives::SnapPointsAlignment>(args, 1);

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return self->obj.GetIrregularSnapPoints(param0, param1);
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PivotPanel_GetRegularSnapPoints(py::wrapper::Microsoft::UI::Xaml::Controls::Primitives::PivotPanel* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Xaml.Controls.Primitives.PivotPanel", L"GetRegularSnapPoints", 2);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(2);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Microsoft::UI::Xaml::Controls::Orientation>(args, 0);
                auto param1 = py::convert_to<winrt::Microsoft::UI::Xaml::Controls::Primitives::SnapPointsAlignment>(args, 1);
                float param2{};

                auto return_value = [&]()
                {
                    auto _gil = release_gil();
                    return self->obj.GetRegularSnapPoints(param0, param1, param2);
                }();

                py::pyobj_handle out_return_value{ py::convert(return_value) };
                if (!out_return_value)
                {
                    return nullptr;
                }
                py::pyobj_handle out2{ py::convert(param2) };
                if (!out2)
                {
                    return nullptr;
                }

                return PyTuple_Pack(2, out_return_value.get(), out2.get());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PivotPanel_get_AreHorizontalSnapPointsRegular(py::wrapper::Microsoft::UI::Xaml::Controls::Primitives::PivotPanel* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.PivotPanel", L"AreHorizontalSnapPointsRegular");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.AreHorizontalSnapPointsRegular();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PivotPanel_get_AreVerticalSnapPointsRegular(py::wrapper::Microsoft::UI::Xaml::Controls::Primitives::PivotPanel* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.PivotPanel", L"AreVerticalSnapPointsRegular");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.AreVerticalSnapPointsRegular();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PivotPanel_add_HorizontalSnapPointsChanged(py::wrapper::Microsoft::UI::Xaml::Controls::Primitives::PivotPanel* self, PyObject* arg) noexcept
    {
        try
        {
            static std::optional<bool> is_event_present{};

            if (!is_event_present.has_value())
            {
                is_event_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Microsoft.UI.Xaml.Controls.Primitives.PivotPanel", L"HorizontalSnapPointsChanged");
            }

            if (!is_event_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::EventHandler<winrt::Windows::Foundation::IInspectable>>(arg);

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.HorizontalSnapPointsChanged(param0);
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PivotPanel_remove_HorizontalSnapPointsChanged(py::wrapper::Microsoft::UI::Xaml::Controls::Primitives::PivotPanel* self, PyObject* arg) noexcept
    {
        try
        {
            static std::optional<bool> is_event_present{};

            if (!is_event_present.has_value())
            {
                is_event_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Microsoft.UI.Xaml.Controls.Primitives.PivotPanel", L"HorizontalSnapPointsChanged");
            }

            if (!is_event_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::event_token>(arg);

            {
                auto _gil = release_gil();
                self->obj.HorizontalSnapPointsChanged(param0);
            }

            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PivotPanel_add_VerticalSnapPointsChanged(py::wrapper::Microsoft::UI::Xaml::Controls::Primitives::PivotPanel* self, PyObject* arg) noexcept
    {
        try
        {
            static std::optional<bool> is_event_present{};

            if (!is_event_present.has_value())
            {
                is_event_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Microsoft.UI.Xaml.Controls.Primitives.PivotPanel", L"VerticalSnapPointsChanged");
            }

            if (!is_event_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::EventHandler<winrt::Windows::Foundation::IInspectable>>(arg);

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.VerticalSnapPointsChanged(param0);
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PivotPanel_remove_VerticalSnapPointsChanged(py::wrapper::Microsoft::UI::Xaml::Controls::Primitives::PivotPanel* self, PyObject* arg) noexcept
    {
        try
        {
            static std::optional<bool> is_event_present{};

            if (!is_event_present.has_value())
            {
                is_event_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Microsoft.UI.Xaml.Controls.Primitives.PivotPanel", L"VerticalSnapPointsChanged");
            }

            if (!is_event_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::event_token>(arg);

            {
                auto _gil = release_gil();
                self->obj.VerticalSnapPointsChanged(param0);
            }

            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_PivotPanel(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Microsoft::UI::Xaml::Controls::Primitives::PivotPanel>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_PivotPanel(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Microsoft::UI::Xaml::Controls::Primitives::PivotPanel>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_PivotPanel[] = {
        { "get_irregular_snap_points", reinterpret_cast<PyCFunction>(PivotPanel_GetIrregularSnapPoints), METH_VARARGS, nullptr },
        { "get_regular_snap_points", reinterpret_cast<PyCFunction>(PivotPanel_GetRegularSnapPoints), METH_VARARGS, nullptr },
        { "add_horizontal_snap_points_changed", reinterpret_cast<PyCFunction>(PivotPanel_add_HorizontalSnapPointsChanged), METH_O, nullptr },
        { "remove_horizontal_snap_points_changed", reinterpret_cast<PyCFunction>(PivotPanel_remove_HorizontalSnapPointsChanged), METH_O, nullptr },
        { "add_vertical_snap_points_changed", reinterpret_cast<PyCFunction>(PivotPanel_add_VerticalSnapPointsChanged), METH_O, nullptr },
        { "remove_vertical_snap_points_changed", reinterpret_cast<PyCFunction>(PivotPanel_remove_VerticalSnapPointsChanged), METH_O, nullptr },
        { "_assign_array_", _assign_array_PivotPanel, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_PivotPanel), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_PivotPanel[] = {
        { "are_horizontal_snap_points_regular", reinterpret_cast<getter>(PivotPanel_get_AreHorizontalSnapPointsRegular), nullptr, nullptr, nullptr },
        { "are_vertical_snap_points_regular", reinterpret_cast<getter>(PivotPanel_get_AreVerticalSnapPointsRegular), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_PivotPanel[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_PivotPanel) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_PivotPanel) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_PivotPanel) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_PivotPanel) },
        { }
    };

    static PyType_Spec type_spec_PivotPanel = {
        "winrt._winrt_microsoft_ui_xaml_controls_primitives.PivotPanel",
        sizeof(py::wrapper::Microsoft::UI::Xaml::Controls::Primitives::PivotPanel),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_PivotPanel};

    // ----- Popup class --------------------

    static PyObject* _new_Popup(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 0)
        {
            try
            {
                winrt::Microsoft::UI::Xaml::Controls::Primitives::Popup instance{};
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_Popup(py::wrapper::Microsoft::UI::Xaml::Controls::Primitives::Popup* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* Popup_get_VerticalOffset(py::wrapper::Microsoft::UI::Xaml::Controls::Primitives::Popup* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.Popup", L"VerticalOffset");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.VerticalOffset();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int Popup_put_VerticalOffset(py::wrapper::Microsoft::UI::Xaml::Controls::Primitives::Popup* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.Popup", L"VerticalOffset");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<double>(arg);

            {
                auto _gil = release_gil();
                self->obj.VerticalOffset(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* Popup_get_ShouldConstrainToRootBounds(py::wrapper::Microsoft::UI::Xaml::Controls::Primitives::Popup* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.Popup", L"ShouldConstrainToRootBounds");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.ShouldConstrainToRootBounds();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int Popup_put_ShouldConstrainToRootBounds(py::wrapper::Microsoft::UI::Xaml::Controls::Primitives::Popup* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.Popup", L"ShouldConstrainToRootBounds");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<bool>(arg);

            {
                auto _gil = release_gil();
                self->obj.ShouldConstrainToRootBounds(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* Popup_get_LightDismissOverlayMode(py::wrapper::Microsoft::UI::Xaml::Controls::Primitives::Popup* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.Popup", L"LightDismissOverlayMode");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.LightDismissOverlayMode();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int Popup_put_LightDismissOverlayMode(py::wrapper::Microsoft::UI::Xaml::Controls::Primitives::Popup* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.Popup", L"LightDismissOverlayMode");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Microsoft::UI::Xaml::Controls::LightDismissOverlayMode>(arg);

            {
                auto _gil = release_gil();
                self->obj.LightDismissOverlayMode(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* Popup_get_IsOpen(py::wrapper::Microsoft::UI::Xaml::Controls::Primitives::Popup* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.Popup", L"IsOpen");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.IsOpen();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int Popup_put_IsOpen(py::wrapper::Microsoft::UI::Xaml::Controls::Primitives::Popup* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.Popup", L"IsOpen");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<bool>(arg);

            {
                auto _gil = release_gil();
                self->obj.IsOpen(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* Popup_get_IsLightDismissEnabled(py::wrapper::Microsoft::UI::Xaml::Controls::Primitives::Popup* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.Popup", L"IsLightDismissEnabled");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.IsLightDismissEnabled();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int Popup_put_IsLightDismissEnabled(py::wrapper::Microsoft::UI::Xaml::Controls::Primitives::Popup* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.Popup", L"IsLightDismissEnabled");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<bool>(arg);

            {
                auto _gil = release_gil();
                self->obj.IsLightDismissEnabled(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* Popup_get_HorizontalOffset(py::wrapper::Microsoft::UI::Xaml::Controls::Primitives::Popup* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.Popup", L"HorizontalOffset");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.HorizontalOffset();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int Popup_put_HorizontalOffset(py::wrapper::Microsoft::UI::Xaml::Controls::Primitives::Popup* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.Popup", L"HorizontalOffset");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<double>(arg);

            {
                auto _gil = release_gil();
                self->obj.HorizontalOffset(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* Popup_get_ChildTransitions(py::wrapper::Microsoft::UI::Xaml::Controls::Primitives::Popup* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.Popup", L"ChildTransitions");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.ChildTransitions();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int Popup_put_ChildTransitions(py::wrapper::Microsoft::UI::Xaml::Controls::Primitives::Popup* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.Popup", L"ChildTransitions");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Microsoft::UI::Xaml::Media::Animation::TransitionCollection>(arg);

            {
                auto _gil = release_gil();
                self->obj.ChildTransitions(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* Popup_get_Child(py::wrapper::Microsoft::UI::Xaml::Controls::Primitives::Popup* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.Popup", L"Child");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Child();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int Popup_put_Child(py::wrapper::Microsoft::UI::Xaml::Controls::Primitives::Popup* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.Popup", L"Child");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Microsoft::UI::Xaml::UIElement>(arg);

            {
                auto _gil = release_gil();
                self->obj.Child(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* Popup_get_IsConstrainedToRootBounds(py::wrapper::Microsoft::UI::Xaml::Controls::Primitives::Popup* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.Popup", L"IsConstrainedToRootBounds");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.IsConstrainedToRootBounds();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* Popup_get_PlacementTarget(py::wrapper::Microsoft::UI::Xaml::Controls::Primitives::Popup* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.Popup", L"PlacementTarget");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.PlacementTarget();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int Popup_put_PlacementTarget(py::wrapper::Microsoft::UI::Xaml::Controls::Primitives::Popup* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.Popup", L"PlacementTarget");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Microsoft::UI::Xaml::FrameworkElement>(arg);

            {
                auto _gil = release_gil();
                self->obj.PlacementTarget(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* Popup_get_DesiredPlacement(py::wrapper::Microsoft::UI::Xaml::Controls::Primitives::Popup* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.Popup", L"DesiredPlacement");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.DesiredPlacement();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int Popup_put_DesiredPlacement(py::wrapper::Microsoft::UI::Xaml::Controls::Primitives::Popup* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.Popup", L"DesiredPlacement");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Microsoft::UI::Xaml::Controls::Primitives::PopupPlacementMode>(arg);

            {
                auto _gil = release_gil();
                self->obj.DesiredPlacement(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* Popup_get_ActualPlacement(py::wrapper::Microsoft::UI::Xaml::Controls::Primitives::Popup* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.Popup", L"ActualPlacement");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.ActualPlacement();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* Popup_get_SystemBackdrop(py::wrapper::Microsoft::UI::Xaml::Controls::Primitives::Popup* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.Popup", L"SystemBackdrop");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.SystemBackdrop();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int Popup_put_SystemBackdrop(py::wrapper::Microsoft::UI::Xaml::Controls::Primitives::Popup* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.Popup", L"SystemBackdrop");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Microsoft::UI::Xaml::Media::SystemBackdrop>(arg);

            {
                auto _gil = release_gil();
                self->obj.SystemBackdrop(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* Popup_get_ChildProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.Popup", L"ChildProperty");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return winrt::Microsoft::UI::Xaml::Controls::Primitives::Popup::ChildProperty();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* Popup_get_ChildTransitionsProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.Popup", L"ChildTransitionsProperty");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return winrt::Microsoft::UI::Xaml::Controls::Primitives::Popup::ChildTransitionsProperty();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* Popup_get_HorizontalOffsetProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.Popup", L"HorizontalOffsetProperty");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return winrt::Microsoft::UI::Xaml::Controls::Primitives::Popup::HorizontalOffsetProperty();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* Popup_get_IsLightDismissEnabledProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.Popup", L"IsLightDismissEnabledProperty");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return winrt::Microsoft::UI::Xaml::Controls::Primitives::Popup::IsLightDismissEnabledProperty();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* Popup_get_IsOpenProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.Popup", L"IsOpenProperty");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return winrt::Microsoft::UI::Xaml::Controls::Primitives::Popup::IsOpenProperty();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* Popup_get_LightDismissOverlayModeProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.Popup", L"LightDismissOverlayModeProperty");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return winrt::Microsoft::UI::Xaml::Controls::Primitives::Popup::LightDismissOverlayModeProperty();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* Popup_get_ShouldConstrainToRootBoundsProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.Popup", L"ShouldConstrainToRootBoundsProperty");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return winrt::Microsoft::UI::Xaml::Controls::Primitives::Popup::ShouldConstrainToRootBoundsProperty();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* Popup_get_VerticalOffsetProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.Popup", L"VerticalOffsetProperty");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return winrt::Microsoft::UI::Xaml::Controls::Primitives::Popup::VerticalOffsetProperty();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* Popup_get_DesiredPlacementProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.Popup", L"DesiredPlacementProperty");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return winrt::Microsoft::UI::Xaml::Controls::Primitives::Popup::DesiredPlacementProperty();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* Popup_get_PlacementTargetProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.Popup", L"PlacementTargetProperty");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return winrt::Microsoft::UI::Xaml::Controls::Primitives::Popup::PlacementTargetProperty();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* Popup_get_SystemBackdropProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.Popup", L"SystemBackdropProperty");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return winrt::Microsoft::UI::Xaml::Controls::Primitives::Popup::SystemBackdropProperty();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* Popup_add_Closed(py::wrapper::Microsoft::UI::Xaml::Controls::Primitives::Popup* self, PyObject* arg) noexcept
    {
        try
        {
            static std::optional<bool> is_event_present{};

            if (!is_event_present.has_value())
            {
                is_event_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Microsoft.UI.Xaml.Controls.Primitives.Popup", L"Closed");
            }

            if (!is_event_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::EventHandler<winrt::Windows::Foundation::IInspectable>>(arg);

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Closed(param0);
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* Popup_remove_Closed(py::wrapper::Microsoft::UI::Xaml::Controls::Primitives::Popup* self, PyObject* arg) noexcept
    {
        try
        {
            static std::optional<bool> is_event_present{};

            if (!is_event_present.has_value())
            {
                is_event_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Microsoft.UI.Xaml.Controls.Primitives.Popup", L"Closed");
            }

            if (!is_event_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::event_token>(arg);

            {
                auto _gil = release_gil();
                self->obj.Closed(param0);
            }

            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* Popup_add_Opened(py::wrapper::Microsoft::UI::Xaml::Controls::Primitives::Popup* self, PyObject* arg) noexcept
    {
        try
        {
            static std::optional<bool> is_event_present{};

            if (!is_event_present.has_value())
            {
                is_event_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Microsoft.UI.Xaml.Controls.Primitives.Popup", L"Opened");
            }

            if (!is_event_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::EventHandler<winrt::Windows::Foundation::IInspectable>>(arg);

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Opened(param0);
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* Popup_remove_Opened(py::wrapper::Microsoft::UI::Xaml::Controls::Primitives::Popup* self, PyObject* arg) noexcept
    {
        try
        {
            static std::optional<bool> is_event_present{};

            if (!is_event_present.has_value())
            {
                is_event_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Microsoft.UI.Xaml.Controls.Primitives.Popup", L"Opened");
            }

            if (!is_event_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::event_token>(arg);

            {
                auto _gil = release_gil();
                self->obj.Opened(param0);
            }

            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* Popup_add_ActualPlacementChanged(py::wrapper::Microsoft::UI::Xaml::Controls::Primitives::Popup* self, PyObject* arg) noexcept
    {
        try
        {
            static std::optional<bool> is_event_present{};

            if (!is_event_present.has_value())
            {
                is_event_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Microsoft.UI.Xaml.Controls.Primitives.Popup", L"ActualPlacementChanged");
            }

            if (!is_event_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::EventHandler<winrt::Windows::Foundation::IInspectable>>(arg);

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.ActualPlacementChanged(param0);
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* Popup_remove_ActualPlacementChanged(py::wrapper::Microsoft::UI::Xaml::Controls::Primitives::Popup* self, PyObject* arg) noexcept
    {
        try
        {
            static std::optional<bool> is_event_present{};

            if (!is_event_present.has_value())
            {
                is_event_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Microsoft.UI.Xaml.Controls.Primitives.Popup", L"ActualPlacementChanged");
            }

            if (!is_event_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::event_token>(arg);

            {
                auto _gil = release_gil();
                self->obj.ActualPlacementChanged(param0);
            }

            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_Popup(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Microsoft::UI::Xaml::Controls::Primitives::Popup>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_Popup(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Microsoft::UI::Xaml::Controls::Primitives::Popup>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_Popup[] = {
        { "add_closed", reinterpret_cast<PyCFunction>(Popup_add_Closed), METH_O, nullptr },
        { "remove_closed", reinterpret_cast<PyCFunction>(Popup_remove_Closed), METH_O, nullptr },
        { "add_opened", reinterpret_cast<PyCFunction>(Popup_add_Opened), METH_O, nullptr },
        { "remove_opened", reinterpret_cast<PyCFunction>(Popup_remove_Opened), METH_O, nullptr },
        { "add_actual_placement_changed", reinterpret_cast<PyCFunction>(Popup_add_ActualPlacementChanged), METH_O, nullptr },
        { "remove_actual_placement_changed", reinterpret_cast<PyCFunction>(Popup_remove_ActualPlacementChanged), METH_O, nullptr },
        { "_assign_array_", _assign_array_Popup, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_Popup), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_Popup[] = {
        { "vertical_offset", reinterpret_cast<getter>(Popup_get_VerticalOffset), reinterpret_cast<setter>(Popup_put_VerticalOffset), nullptr, nullptr },
        { "should_constrain_to_root_bounds", reinterpret_cast<getter>(Popup_get_ShouldConstrainToRootBounds), reinterpret_cast<setter>(Popup_put_ShouldConstrainToRootBounds), nullptr, nullptr },
        { "light_dismiss_overlay_mode", reinterpret_cast<getter>(Popup_get_LightDismissOverlayMode), reinterpret_cast<setter>(Popup_put_LightDismissOverlayMode), nullptr, nullptr },
        { "is_open", reinterpret_cast<getter>(Popup_get_IsOpen), reinterpret_cast<setter>(Popup_put_IsOpen), nullptr, nullptr },
        { "is_light_dismiss_enabled", reinterpret_cast<getter>(Popup_get_IsLightDismissEnabled), reinterpret_cast<setter>(Popup_put_IsLightDismissEnabled), nullptr, nullptr },
        { "horizontal_offset", reinterpret_cast<getter>(Popup_get_HorizontalOffset), reinterpret_cast<setter>(Popup_put_HorizontalOffset), nullptr, nullptr },
        { "child_transitions", reinterpret_cast<getter>(Popup_get_ChildTransitions), reinterpret_cast<setter>(Popup_put_ChildTransitions), nullptr, nullptr },
        { "child", reinterpret_cast<getter>(Popup_get_Child), reinterpret_cast<setter>(Popup_put_Child), nullptr, nullptr },
        { "is_constrained_to_root_bounds", reinterpret_cast<getter>(Popup_get_IsConstrainedToRootBounds), nullptr, nullptr, nullptr },
        { "placement_target", reinterpret_cast<getter>(Popup_get_PlacementTarget), reinterpret_cast<setter>(Popup_put_PlacementTarget), nullptr, nullptr },
        { "desired_placement", reinterpret_cast<getter>(Popup_get_DesiredPlacement), reinterpret_cast<setter>(Popup_put_DesiredPlacement), nullptr, nullptr },
        { "actual_placement", reinterpret_cast<getter>(Popup_get_ActualPlacement), nullptr, nullptr, nullptr },
        { "system_backdrop", reinterpret_cast<getter>(Popup_get_SystemBackdrop), reinterpret_cast<setter>(Popup_put_SystemBackdrop), nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_Popup[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_Popup) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_Popup) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_Popup) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_Popup) },
        { }
    };

    static PyType_Spec type_spec_Popup = {
        "winrt._winrt_microsoft_ui_xaml_controls_primitives.Popup",
        sizeof(py::wrapper::Microsoft::UI::Xaml::Controls::Primitives::Popup),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_Popup};

    static PyGetSetDef getset_Popup_Static[] = {
        { "child_property", reinterpret_cast<getter>(Popup_get_ChildProperty), nullptr, nullptr, nullptr },
        { "child_transitions_property", reinterpret_cast<getter>(Popup_get_ChildTransitionsProperty), nullptr, nullptr, nullptr },
        { "horizontal_offset_property", reinterpret_cast<getter>(Popup_get_HorizontalOffsetProperty), nullptr, nullptr, nullptr },
        { "is_light_dismiss_enabled_property", reinterpret_cast<getter>(Popup_get_IsLightDismissEnabledProperty), nullptr, nullptr, nullptr },
        { "is_open_property", reinterpret_cast<getter>(Popup_get_IsOpenProperty), nullptr, nullptr, nullptr },
        { "light_dismiss_overlay_mode_property", reinterpret_cast<getter>(Popup_get_LightDismissOverlayModeProperty), nullptr, nullptr, nullptr },
        { "should_constrain_to_root_bounds_property", reinterpret_cast<getter>(Popup_get_ShouldConstrainToRootBoundsProperty), nullptr, nullptr, nullptr },
        { "vertical_offset_property", reinterpret_cast<getter>(Popup_get_VerticalOffsetProperty), nullptr, nullptr, nullptr },
        { "desired_placement_property", reinterpret_cast<getter>(Popup_get_DesiredPlacementProperty), nullptr, nullptr, nullptr },
        { "placement_target_property", reinterpret_cast<getter>(Popup_get_PlacementTargetProperty), nullptr, nullptr, nullptr },
        { "system_backdrop_property", reinterpret_cast<getter>(Popup_get_SystemBackdropProperty), nullptr, nullptr, nullptr },
        { }
    };

    static PyMethodDef methods_Popup_Static[] = {
        { }
    };

    static PyType_Slot type_slots_Popup_Static[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_Popup_Static) },
        { Py_tp_methods, reinterpret_cast<void*>(methods_Popup_Static) },
        { }
    };

    static PyType_Spec type_spec_Popup_Static =
    {
        "winrt._winrt_microsoft_ui_xaml_controls_primitives.Popup_Static",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT,
        type_slots_Popup_Static
    };

    // ----- RangeBase class --------------------

    struct PyWinrtRangeBase;
    using BasePyWinrtRangeBase = winrt::Microsoft::UI::Xaml::Controls::Primitives::RangeBaseT<PyWinrtRangeBase, py::IPywinrtObject>;

    struct PyWinrtRangeBase : py::py_obj_ref, BasePyWinrtRangeBase
    {

        int32_t __stdcall GetPyObject(PyObject*& obj) override
        {
            obj = py::py_obj_ref::get_py_obj();
            return 0;
        }

        int32_t __stdcall GetComposableInner(winrt::Windows::Foundation::IInspectable& inner) override
        {
            inner = m_inner;
            return winrt::impl::error_ok;
        }

        static void toggle_reference(PyWinrtRangeBase* instance, bool is_last_reference)
        {
            py::py_obj_ref::toggle_reference(instance, is_last_reference);
        }

        int32_t query_interface_tearoff(winrt::guid const& id, void** result) const noexcept override
        {
            return py::py_obj_ref::query_interface_tearoff(id, result);
        }

        void OnMaximumChanged(double param0, double param1)
        {
            auto gil = py::ensure_gil();

            try
            {
                py::pyobj_handle self{get_py_obj()};

                py::pyobj_handle method{PyObject_GetAttrString(self.get(), "_on_maximum_changed")};
                if (!method)
                {
                    throw python_exception();
                }

                py::pyobj_handle py_param0{py::convert(param0)};
                if (!py_param0)
                {
                    throw python_exception();
                }

                py::pyobj_handle py_param1{py::convert(param1)};
                if (!py_param1)
                {
                    throw python_exception();
                }

                py::pyobj_handle args{PyTuple_Pack(2, py_param0.get(), py_param1.get())};
                if (!args)
                {
                    throw python_exception();
                }

                py::pyobj_handle return_value{PyObject_CallObject(method.get(), args.get())};
                if (!return_value)
                {
                    throw python_exception();
                }
            }
            catch (python_exception)
            {
                py::write_unraisable_and_throw();
            }
        }

        void OnMinimumChanged(double param0, double param1)
        {
            auto gil = py::ensure_gil();

            try
            {
                py::pyobj_handle self{get_py_obj()};

                py::pyobj_handle method{PyObject_GetAttrString(self.get(), "_on_minimum_changed")};
                if (!method)
                {
                    throw python_exception();
                }

                py::pyobj_handle py_param0{py::convert(param0)};
                if (!py_param0)
                {
                    throw python_exception();
                }

                py::pyobj_handle py_param1{py::convert(param1)};
                if (!py_param1)
                {
                    throw python_exception();
                }

                py::pyobj_handle args{PyTuple_Pack(2, py_param0.get(), py_param1.get())};
                if (!args)
                {
                    throw python_exception();
                }

                py::pyobj_handle return_value{PyObject_CallObject(method.get(), args.get())};
                if (!return_value)
                {
                    throw python_exception();
                }
            }
            catch (python_exception)
            {
                py::write_unraisable_and_throw();
            }
        }

        void OnValueChanged(double param0, double param1)
        {
            auto gil = py::ensure_gil();

            try
            {
                py::pyobj_handle self{get_py_obj()};

                py::pyobj_handle method{PyObject_GetAttrString(self.get(), "_on_value_changed")};
                if (!method)
                {
                    throw python_exception();
                }

                py::pyobj_handle py_param0{py::convert(param0)};
                if (!py_param0)
                {
                    throw python_exception();
                }

                py::pyobj_handle py_param1{py::convert(param1)};
                if (!py_param1)
                {
                    throw python_exception();
                }

                py::pyobj_handle args{PyTuple_Pack(2, py_param0.get(), py_param1.get())};
                if (!args)
                {
                    throw python_exception();
                }

                py::pyobj_handle return_value{PyObject_CallObject(method.get(), args.get())};
                if (!return_value)
                {
                    throw python_exception();
                }
            }
            catch (python_exception)
            {
                py::write_unraisable_and_throw();
            }
        }
    };

    static PyObject* _new_RangeBase(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Microsoft::UI::Xaml::Controls::Primitives::RangeBase>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Microsoft::UI::Xaml::Controls::Primitives::RangeBase>::type_name);
        return nullptr;
    }

    static void _dealloc_RangeBase(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* RangeBase_OnMaximumChanged(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Xaml.Controls.Primitives.RangeBase", L"OnMaximumChanged", 2);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(2);
                    return nullptr;
                }

                auto param0 = py::convert_to<double>(args, 0);
                auto param1 = py::convert_to<double>(args, 1);

                {
                    auto _gil = release_gil();
                    py::get_inner_or_self(self->obj).try_as<winrt::Microsoft::UI::Xaml::Controls::Primitives::IRangeBaseOverrides>().OnMaximumChanged(param0, param1);
                }

                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* RangeBase_OnMinimumChanged(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Xaml.Controls.Primitives.RangeBase", L"OnMinimumChanged", 2);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(2);
                    return nullptr;
                }

                auto param0 = py::convert_to<double>(args, 0);
                auto param1 = py::convert_to<double>(args, 1);

                {
                    auto _gil = release_gil();
                    py::get_inner_or_self(self->obj).try_as<winrt::Microsoft::UI::Xaml::Controls::Primitives::IRangeBaseOverrides>().OnMinimumChanged(param0, param1);
                }

                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* RangeBase_OnValueChanged(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Xaml.Controls.Primitives.RangeBase", L"OnValueChanged", 2);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(2);
                    return nullptr;
                }

                auto param0 = py::convert_to<double>(args, 0);
                auto param1 = py::convert_to<double>(args, 1);

                {
                    auto _gil = release_gil();
                    py::get_inner_or_self(self->obj).try_as<winrt::Microsoft::UI::Xaml::Controls::Primitives::IRangeBaseOverrides>().OnValueChanged(param0, param1);
                }

                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* RangeBase_get_Value(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.RangeBase", L"Value");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::Primitives::RangeBase>().Value();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int RangeBase_put_Value(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.RangeBase", L"Value");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<double>(arg);

            {
                auto _gil = release_gil();
                self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::Primitives::RangeBase>().Value(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* RangeBase_get_SmallChange(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.RangeBase", L"SmallChange");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::Primitives::RangeBase>().SmallChange();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int RangeBase_put_SmallChange(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.RangeBase", L"SmallChange");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<double>(arg);

            {
                auto _gil = release_gil();
                self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::Primitives::RangeBase>().SmallChange(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* RangeBase_get_Minimum(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.RangeBase", L"Minimum");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::Primitives::RangeBase>().Minimum();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int RangeBase_put_Minimum(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.RangeBase", L"Minimum");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<double>(arg);

            {
                auto _gil = release_gil();
                self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::Primitives::RangeBase>().Minimum(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* RangeBase_get_Maximum(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.RangeBase", L"Maximum");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::Primitives::RangeBase>().Maximum();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int RangeBase_put_Maximum(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.RangeBase", L"Maximum");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<double>(arg);

            {
                auto _gil = release_gil();
                self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::Primitives::RangeBase>().Maximum(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* RangeBase_get_LargeChange(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.RangeBase", L"LargeChange");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::Primitives::RangeBase>().LargeChange();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int RangeBase_put_LargeChange(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.RangeBase", L"LargeChange");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<double>(arg);

            {
                auto _gil = release_gil();
                self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::Primitives::RangeBase>().LargeChange(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* RangeBase_get_LargeChangeProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.RangeBase", L"LargeChangeProperty");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return winrt::Microsoft::UI::Xaml::Controls::Primitives::RangeBase::LargeChangeProperty();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* RangeBase_get_MaximumProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.RangeBase", L"MaximumProperty");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return winrt::Microsoft::UI::Xaml::Controls::Primitives::RangeBase::MaximumProperty();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* RangeBase_get_MinimumProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.RangeBase", L"MinimumProperty");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return winrt::Microsoft::UI::Xaml::Controls::Primitives::RangeBase::MinimumProperty();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* RangeBase_get_SmallChangeProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.RangeBase", L"SmallChangeProperty");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return winrt::Microsoft::UI::Xaml::Controls::Primitives::RangeBase::SmallChangeProperty();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* RangeBase_get_ValueProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.RangeBase", L"ValueProperty");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return winrt::Microsoft::UI::Xaml::Controls::Primitives::RangeBase::ValueProperty();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* RangeBase_add_ValueChanged(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, PyObject* arg) noexcept
    {
        try
        {
            static std::optional<bool> is_event_present{};

            if (!is_event_present.has_value())
            {
                is_event_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Microsoft.UI.Xaml.Controls.Primitives.RangeBase", L"ValueChanged");
            }

            if (!is_event_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::Microsoft::UI::Xaml::Controls::Primitives::RangeBaseValueChangedEventHandler>(arg);

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::Primitives::RangeBase>().ValueChanged(param0);
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* RangeBase_remove_ValueChanged(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, PyObject* arg) noexcept
    {
        try
        {
            static std::optional<bool> is_event_present{};

            if (!is_event_present.has_value())
            {
                is_event_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Microsoft.UI.Xaml.Controls.Primitives.RangeBase", L"ValueChanged");
            }

            if (!is_event_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::event_token>(arg);

            {
                auto _gil = release_gil();
                self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::Primitives::RangeBase>().ValueChanged(param0);
            }

            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_RangeBase(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Microsoft::UI::Xaml::Controls::Primitives::RangeBase>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_RangeBase(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Microsoft::UI::Xaml::Controls::Primitives::RangeBase>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_RangeBase[] = {
        { "_on_maximum_changed", reinterpret_cast<PyCFunction>(RangeBase_OnMaximumChanged), METH_VARARGS, nullptr },
        { "_on_minimum_changed", reinterpret_cast<PyCFunction>(RangeBase_OnMinimumChanged), METH_VARARGS, nullptr },
        { "_on_value_changed", reinterpret_cast<PyCFunction>(RangeBase_OnValueChanged), METH_VARARGS, nullptr },
        { "add_value_changed", reinterpret_cast<PyCFunction>(RangeBase_add_ValueChanged), METH_O, nullptr },
        { "remove_value_changed", reinterpret_cast<PyCFunction>(RangeBase_remove_ValueChanged), METH_O, nullptr },
        { "_assign_array_", _assign_array_RangeBase, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_RangeBase), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_RangeBase[] = {
        { "value", reinterpret_cast<getter>(RangeBase_get_Value), reinterpret_cast<setter>(RangeBase_put_Value), nullptr, nullptr },
        { "small_change", reinterpret_cast<getter>(RangeBase_get_SmallChange), reinterpret_cast<setter>(RangeBase_put_SmallChange), nullptr, nullptr },
        { "minimum", reinterpret_cast<getter>(RangeBase_get_Minimum), reinterpret_cast<setter>(RangeBase_put_Minimum), nullptr, nullptr },
        { "maximum", reinterpret_cast<getter>(RangeBase_get_Maximum), reinterpret_cast<setter>(RangeBase_put_Maximum), nullptr, nullptr },
        { "large_change", reinterpret_cast<getter>(RangeBase_get_LargeChange), reinterpret_cast<setter>(RangeBase_put_LargeChange), nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_RangeBase[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_RangeBase) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_RangeBase) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_RangeBase) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_RangeBase) },
        { }
    };

    static PyType_Spec type_spec_RangeBase = {
        "winrt._winrt_microsoft_ui_xaml_controls_primitives.RangeBase",
        sizeof(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>),
        0,
        Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,
        _type_slots_RangeBase};

    static PyGetSetDef getset_RangeBase_Static[] = {
        { "large_change_property", reinterpret_cast<getter>(RangeBase_get_LargeChangeProperty), nullptr, nullptr, nullptr },
        { "maximum_property", reinterpret_cast<getter>(RangeBase_get_MaximumProperty), nullptr, nullptr, nullptr },
        { "minimum_property", reinterpret_cast<getter>(RangeBase_get_MinimumProperty), nullptr, nullptr, nullptr },
        { "small_change_property", reinterpret_cast<getter>(RangeBase_get_SmallChangeProperty), nullptr, nullptr, nullptr },
        { "value_property", reinterpret_cast<getter>(RangeBase_get_ValueProperty), nullptr, nullptr, nullptr },
        { }
    };

    static PyMethodDef methods_RangeBase_Static[] = {
        { }
    };

    static PyType_Slot type_slots_RangeBase_Static[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_RangeBase_Static) },
        { Py_tp_methods, reinterpret_cast<void*>(methods_RangeBase_Static) },
        { }
    };

    static PyType_Spec type_spec_RangeBase_Static =
    {
        "winrt._winrt_microsoft_ui_xaml_controls_primitives.RangeBase_Static",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,
        type_slots_RangeBase_Static
    };

    // ----- RangeBaseValueChangedEventArgs class --------------------

    static PyObject* _new_RangeBaseValueChangedEventArgs(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Microsoft::UI::Xaml::Controls::Primitives::RangeBaseValueChangedEventArgs>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Microsoft::UI::Xaml::Controls::Primitives::RangeBaseValueChangedEventArgs>::type_name);
        return nullptr;
    }

    static void _dealloc_RangeBaseValueChangedEventArgs(py::wrapper::Microsoft::UI::Xaml::Controls::Primitives::RangeBaseValueChangedEventArgs* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* RangeBaseValueChangedEventArgs_get_NewValue(py::wrapper::Microsoft::UI::Xaml::Controls::Primitives::RangeBaseValueChangedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.RangeBaseValueChangedEventArgs", L"NewValue");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.NewValue();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* RangeBaseValueChangedEventArgs_get_OldValue(py::wrapper::Microsoft::UI::Xaml::Controls::Primitives::RangeBaseValueChangedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.RangeBaseValueChangedEventArgs", L"OldValue");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.OldValue();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_RangeBaseValueChangedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Microsoft::UI::Xaml::Controls::Primitives::RangeBaseValueChangedEventArgs>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_RangeBaseValueChangedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Microsoft::UI::Xaml::Controls::Primitives::RangeBaseValueChangedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_RangeBaseValueChangedEventArgs[] = {
        { "_assign_array_", _assign_array_RangeBaseValueChangedEventArgs, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_RangeBaseValueChangedEventArgs), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_RangeBaseValueChangedEventArgs[] = {
        { "new_value", reinterpret_cast<getter>(RangeBaseValueChangedEventArgs_get_NewValue), nullptr, nullptr, nullptr },
        { "old_value", reinterpret_cast<getter>(RangeBaseValueChangedEventArgs_get_OldValue), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_RangeBaseValueChangedEventArgs[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_RangeBaseValueChangedEventArgs) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_RangeBaseValueChangedEventArgs) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_RangeBaseValueChangedEventArgs) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_RangeBaseValueChangedEventArgs) },
        { }
    };

    static PyType_Spec type_spec_RangeBaseValueChangedEventArgs = {
        "winrt._winrt_microsoft_ui_xaml_controls_primitives.RangeBaseValueChangedEventArgs",
        sizeof(py::wrapper::Microsoft::UI::Xaml::Controls::Primitives::RangeBaseValueChangedEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_RangeBaseValueChangedEventArgs};

    // ----- RepeatButton class --------------------

    static PyObject* _new_RepeatButton(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 0)
        {
            try
            {
                winrt::Microsoft::UI::Xaml::Controls::Primitives::RepeatButton instance{};
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_RepeatButton(py::wrapper::Microsoft::UI::Xaml::Controls::Primitives::RepeatButton* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* RepeatButton_get_Interval(py::wrapper::Microsoft::UI::Xaml::Controls::Primitives::RepeatButton* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.RepeatButton", L"Interval");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Interval();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int RepeatButton_put_Interval(py::wrapper::Microsoft::UI::Xaml::Controls::Primitives::RepeatButton* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.RepeatButton", L"Interval");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<int32_t>(arg);

            {
                auto _gil = release_gil();
                self->obj.Interval(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* RepeatButton_get_Delay(py::wrapper::Microsoft::UI::Xaml::Controls::Primitives::RepeatButton* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.RepeatButton", L"Delay");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Delay();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int RepeatButton_put_Delay(py::wrapper::Microsoft::UI::Xaml::Controls::Primitives::RepeatButton* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.RepeatButton", L"Delay");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<int32_t>(arg);

            {
                auto _gil = release_gil();
                self->obj.Delay(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* RepeatButton_get_DelayProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.RepeatButton", L"DelayProperty");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return winrt::Microsoft::UI::Xaml::Controls::Primitives::RepeatButton::DelayProperty();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* RepeatButton_get_IntervalProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.RepeatButton", L"IntervalProperty");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return winrt::Microsoft::UI::Xaml::Controls::Primitives::RepeatButton::IntervalProperty();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_RepeatButton(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Microsoft::UI::Xaml::Controls::Primitives::RepeatButton>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_RepeatButton(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Microsoft::UI::Xaml::Controls::Primitives::RepeatButton>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_RepeatButton[] = {
        { "_assign_array_", _assign_array_RepeatButton, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_RepeatButton), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_RepeatButton[] = {
        { "interval", reinterpret_cast<getter>(RepeatButton_get_Interval), reinterpret_cast<setter>(RepeatButton_put_Interval), nullptr, nullptr },
        { "delay", reinterpret_cast<getter>(RepeatButton_get_Delay), reinterpret_cast<setter>(RepeatButton_put_Delay), nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_RepeatButton[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_RepeatButton) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_RepeatButton) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_RepeatButton) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_RepeatButton) },
        { }
    };

    static PyType_Spec type_spec_RepeatButton = {
        "winrt._winrt_microsoft_ui_xaml_controls_primitives.RepeatButton",
        sizeof(py::wrapper::Microsoft::UI::Xaml::Controls::Primitives::RepeatButton),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_RepeatButton};

    static PyGetSetDef getset_RepeatButton_Static[] = {
        { "delay_property", reinterpret_cast<getter>(RepeatButton_get_DelayProperty), nullptr, nullptr, nullptr },
        { "interval_property", reinterpret_cast<getter>(RepeatButton_get_IntervalProperty), nullptr, nullptr, nullptr },
        { }
    };

    static PyMethodDef methods_RepeatButton_Static[] = {
        { }
    };

    static PyType_Slot type_slots_RepeatButton_Static[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_RepeatButton_Static) },
        { Py_tp_methods, reinterpret_cast<void*>(methods_RepeatButton_Static) },
        { }
    };

    static PyType_Spec type_spec_RepeatButton_Static =
    {
        "winrt._winrt_microsoft_ui_xaml_controls_primitives.RepeatButton_Static",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT,
        type_slots_RepeatButton_Static
    };

    // ----- RepeatedScrollSnapPoint class --------------------

    struct PyWinrtRepeatedScrollSnapPoint;
    using BasePyWinrtRepeatedScrollSnapPoint = winrt::Microsoft::UI::Xaml::Controls::Primitives::RepeatedScrollSnapPointT<PyWinrtRepeatedScrollSnapPoint, py::IPywinrtObject>;

    struct PyWinrtRepeatedScrollSnapPoint : py::py_obj_ref, BasePyWinrtRepeatedScrollSnapPoint
    {
        PyWinrtRepeatedScrollSnapPoint(PyObject* py_obj, double offset, double interval, double start, double end, winrt::Microsoft::UI::Xaml::Controls::Primitives::ScrollSnapPointsAlignment alignment) : py::py_obj_ref(py_obj), BasePyWinrtRepeatedScrollSnapPoint(offset, interval, start, end, alignment) {}

        int32_t __stdcall GetPyObject(PyObject*& obj) override
        {
            obj = py::py_obj_ref::get_py_obj();
            return 0;
        }

        int32_t __stdcall GetComposableInner(winrt::Windows::Foundation::IInspectable& inner) override
        {
            inner = m_inner;
            return winrt::impl::error_ok;
        }

        static void toggle_reference(PyWinrtRepeatedScrollSnapPoint* instance, bool is_last_reference)
        {
            py::py_obj_ref::toggle_reference(instance, is_last_reference);
        }

        int32_t query_interface_tearoff(winrt::guid const& id, void** result) const noexcept override
        {
            return py::py_obj_ref::query_interface_tearoff(id, result);
        }
    };

    static PyObject* _new_RepeatedScrollSnapPoint(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);

        auto self_type = get_python_type_for<winrt::Microsoft::UI::Xaml::Controls::Primitives::RepeatedScrollSnapPoint>();
        if (!self_type)
        {
            return nullptr;
        }

        if (arg_count == 5)
        {
            try
            {
                auto param0 = py::convert_to<double>(args, 0);
                auto param1 = py::convert_to<double>(args, 1);
                auto param2 = py::convert_to<double>(args, 2);
                auto param3 = py::convert_to<double>(args, 3);
                auto param4 = py::convert_to<winrt::Microsoft::UI::Xaml::Controls::Primitives::ScrollSnapPointsAlignment>(args, 4);

                if (type != self_type)
                {
                    py::pyobj_handle self{type->tp_alloc(type, 0)};
                    if (!self)
                    {
                        return nullptr;
                    }

                    std::construct_at(&reinterpret_cast<py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>*>(self.get())->obj, nullptr);

                    auto obj_impl = winrt::make_self<PyWinrtRepeatedScrollSnapPoint>(self.get(), param0, param1, param2, param3, param4);

                    auto obj = py::make_py_obj<PyWinrtRepeatedScrollSnapPoint>(obj_impl, type, self.get());
                    if (!obj)
                    {
                        return nullptr;
                    }

                    reinterpret_cast<py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>*>(self.get())->obj = std::move(obj);

                    return self.detach();
                }

                winrt::Microsoft::UI::Xaml::Controls::Primitives::RepeatedScrollSnapPoint instance{param0, param1, param2, param3, param4};
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_RepeatedScrollSnapPoint(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* RepeatedScrollSnapPoint_get_End(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.RepeatedScrollSnapPoint", L"End");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::Primitives::RepeatedScrollSnapPoint>().End();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* RepeatedScrollSnapPoint_get_Interval(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.RepeatedScrollSnapPoint", L"Interval");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::Primitives::RepeatedScrollSnapPoint>().Interval();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* RepeatedScrollSnapPoint_get_Offset(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.RepeatedScrollSnapPoint", L"Offset");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::Primitives::RepeatedScrollSnapPoint>().Offset();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* RepeatedScrollSnapPoint_get_Start(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.RepeatedScrollSnapPoint", L"Start");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::Primitives::RepeatedScrollSnapPoint>().Start();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_RepeatedScrollSnapPoint(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Microsoft::UI::Xaml::Controls::Primitives::RepeatedScrollSnapPoint>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_RepeatedScrollSnapPoint(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Microsoft::UI::Xaml::Controls::Primitives::RepeatedScrollSnapPoint>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_RepeatedScrollSnapPoint[] = {
        { "_assign_array_", _assign_array_RepeatedScrollSnapPoint, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_RepeatedScrollSnapPoint), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_RepeatedScrollSnapPoint[] = {
        { "end", reinterpret_cast<getter>(RepeatedScrollSnapPoint_get_End), nullptr, nullptr, nullptr },
        { "interval", reinterpret_cast<getter>(RepeatedScrollSnapPoint_get_Interval), nullptr, nullptr, nullptr },
        { "offset", reinterpret_cast<getter>(RepeatedScrollSnapPoint_get_Offset), nullptr, nullptr, nullptr },
        { "start", reinterpret_cast<getter>(RepeatedScrollSnapPoint_get_Start), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_RepeatedScrollSnapPoint[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_RepeatedScrollSnapPoint) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_RepeatedScrollSnapPoint) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_RepeatedScrollSnapPoint) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_RepeatedScrollSnapPoint) },
        { }
    };

    static PyType_Spec type_spec_RepeatedScrollSnapPoint = {
        "winrt._winrt_microsoft_ui_xaml_controls_primitives.RepeatedScrollSnapPoint",
        sizeof(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>),
        0,
        Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,
        _type_slots_RepeatedScrollSnapPoint};

    static PyGetSetDef getset_RepeatedScrollSnapPoint_Static[] = {
        { }
    };

    static PyMethodDef methods_RepeatedScrollSnapPoint_Static[] = {
        { }
    };

    static PyType_Slot type_slots_RepeatedScrollSnapPoint_Static[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_RepeatedScrollSnapPoint_Static) },
        { Py_tp_methods, reinterpret_cast<void*>(methods_RepeatedScrollSnapPoint_Static) },
        { }
    };

    static PyType_Spec type_spec_RepeatedScrollSnapPoint_Static =
    {
        "winrt._winrt_microsoft_ui_xaml_controls_primitives.RepeatedScrollSnapPoint_Static",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,
        type_slots_RepeatedScrollSnapPoint_Static
    };

    // ----- RepeatedZoomSnapPoint class --------------------

    struct PyWinrtRepeatedZoomSnapPoint;
    using BasePyWinrtRepeatedZoomSnapPoint = winrt::Microsoft::UI::Xaml::Controls::Primitives::RepeatedZoomSnapPointT<PyWinrtRepeatedZoomSnapPoint, py::IPywinrtObject>;

    struct PyWinrtRepeatedZoomSnapPoint : py::py_obj_ref, BasePyWinrtRepeatedZoomSnapPoint
    {
        PyWinrtRepeatedZoomSnapPoint(PyObject* py_obj, double offset, double interval, double start, double end) : py::py_obj_ref(py_obj), BasePyWinrtRepeatedZoomSnapPoint(offset, interval, start, end) {}

        int32_t __stdcall GetPyObject(PyObject*& obj) override
        {
            obj = py::py_obj_ref::get_py_obj();
            return 0;
        }

        int32_t __stdcall GetComposableInner(winrt::Windows::Foundation::IInspectable& inner) override
        {
            inner = m_inner;
            return winrt::impl::error_ok;
        }

        static void toggle_reference(PyWinrtRepeatedZoomSnapPoint* instance, bool is_last_reference)
        {
            py::py_obj_ref::toggle_reference(instance, is_last_reference);
        }

        int32_t query_interface_tearoff(winrt::guid const& id, void** result) const noexcept override
        {
            return py::py_obj_ref::query_interface_tearoff(id, result);
        }
    };

    static PyObject* _new_RepeatedZoomSnapPoint(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);

        auto self_type = get_python_type_for<winrt::Microsoft::UI::Xaml::Controls::Primitives::RepeatedZoomSnapPoint>();
        if (!self_type)
        {
            return nullptr;
        }

        if (arg_count == 4)
        {
            try
            {
                auto param0 = py::convert_to<double>(args, 0);
                auto param1 = py::convert_to<double>(args, 1);
                auto param2 = py::convert_to<double>(args, 2);
                auto param3 = py::convert_to<double>(args, 3);

                if (type != self_type)
                {
                    py::pyobj_handle self{type->tp_alloc(type, 0)};
                    if (!self)
                    {
                        return nullptr;
                    }

                    std::construct_at(&reinterpret_cast<py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>*>(self.get())->obj, nullptr);

                    auto obj_impl = winrt::make_self<PyWinrtRepeatedZoomSnapPoint>(self.get(), param0, param1, param2, param3);

                    auto obj = py::make_py_obj<PyWinrtRepeatedZoomSnapPoint>(obj_impl, type, self.get());
                    if (!obj)
                    {
                        return nullptr;
                    }

                    reinterpret_cast<py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>*>(self.get())->obj = std::move(obj);

                    return self.detach();
                }

                winrt::Microsoft::UI::Xaml::Controls::Primitives::RepeatedZoomSnapPoint instance{param0, param1, param2, param3};
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_RepeatedZoomSnapPoint(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* RepeatedZoomSnapPoint_get_End(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.RepeatedZoomSnapPoint", L"End");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::Primitives::RepeatedZoomSnapPoint>().End();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* RepeatedZoomSnapPoint_get_Interval(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.RepeatedZoomSnapPoint", L"Interval");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::Primitives::RepeatedZoomSnapPoint>().Interval();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* RepeatedZoomSnapPoint_get_Offset(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.RepeatedZoomSnapPoint", L"Offset");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::Primitives::RepeatedZoomSnapPoint>().Offset();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* RepeatedZoomSnapPoint_get_Start(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.RepeatedZoomSnapPoint", L"Start");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::Primitives::RepeatedZoomSnapPoint>().Start();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_RepeatedZoomSnapPoint(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Microsoft::UI::Xaml::Controls::Primitives::RepeatedZoomSnapPoint>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_RepeatedZoomSnapPoint(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Microsoft::UI::Xaml::Controls::Primitives::RepeatedZoomSnapPoint>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_RepeatedZoomSnapPoint[] = {
        { "_assign_array_", _assign_array_RepeatedZoomSnapPoint, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_RepeatedZoomSnapPoint), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_RepeatedZoomSnapPoint[] = {
        { "end", reinterpret_cast<getter>(RepeatedZoomSnapPoint_get_End), nullptr, nullptr, nullptr },
        { "interval", reinterpret_cast<getter>(RepeatedZoomSnapPoint_get_Interval), nullptr, nullptr, nullptr },
        { "offset", reinterpret_cast<getter>(RepeatedZoomSnapPoint_get_Offset), nullptr, nullptr, nullptr },
        { "start", reinterpret_cast<getter>(RepeatedZoomSnapPoint_get_Start), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_RepeatedZoomSnapPoint[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_RepeatedZoomSnapPoint) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_RepeatedZoomSnapPoint) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_RepeatedZoomSnapPoint) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_RepeatedZoomSnapPoint) },
        { }
    };

    static PyType_Spec type_spec_RepeatedZoomSnapPoint = {
        "winrt._winrt_microsoft_ui_xaml_controls_primitives.RepeatedZoomSnapPoint",
        sizeof(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>),
        0,
        Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,
        _type_slots_RepeatedZoomSnapPoint};

    static PyGetSetDef getset_RepeatedZoomSnapPoint_Static[] = {
        { }
    };

    static PyMethodDef methods_RepeatedZoomSnapPoint_Static[] = {
        { }
    };

    static PyType_Slot type_slots_RepeatedZoomSnapPoint_Static[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_RepeatedZoomSnapPoint_Static) },
        { Py_tp_methods, reinterpret_cast<void*>(methods_RepeatedZoomSnapPoint_Static) },
        { }
    };

    static PyType_Spec type_spec_RepeatedZoomSnapPoint_Static =
    {
        "winrt._winrt_microsoft_ui_xaml_controls_primitives.RepeatedZoomSnapPoint_Static",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,
        type_slots_RepeatedZoomSnapPoint_Static
    };

    // ----- ScrollBar class --------------------

    static PyObject* _new_ScrollBar(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 0)
        {
            try
            {
                winrt::Microsoft::UI::Xaml::Controls::Primitives::ScrollBar instance{};
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_ScrollBar(py::wrapper::Microsoft::UI::Xaml::Controls::Primitives::ScrollBar* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* ScrollBar_get_ViewportSize(py::wrapper::Microsoft::UI::Xaml::Controls::Primitives::ScrollBar* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.ScrollBar", L"ViewportSize");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.ViewportSize();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ScrollBar_put_ViewportSize(py::wrapper::Microsoft::UI::Xaml::Controls::Primitives::ScrollBar* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.ScrollBar", L"ViewportSize");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<double>(arg);

            {
                auto _gil = release_gil();
                self->obj.ViewportSize(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ScrollBar_get_Orientation(py::wrapper::Microsoft::UI::Xaml::Controls::Primitives::ScrollBar* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.ScrollBar", L"Orientation");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Orientation();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ScrollBar_put_Orientation(py::wrapper::Microsoft::UI::Xaml::Controls::Primitives::ScrollBar* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.ScrollBar", L"Orientation");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Microsoft::UI::Xaml::Controls::Orientation>(arg);

            {
                auto _gil = release_gil();
                self->obj.Orientation(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ScrollBar_get_IndicatorMode(py::wrapper::Microsoft::UI::Xaml::Controls::Primitives::ScrollBar* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.ScrollBar", L"IndicatorMode");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.IndicatorMode();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ScrollBar_put_IndicatorMode(py::wrapper::Microsoft::UI::Xaml::Controls::Primitives::ScrollBar* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.ScrollBar", L"IndicatorMode");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Microsoft::UI::Xaml::Controls::Primitives::ScrollingIndicatorMode>(arg);

            {
                auto _gil = release_gil();
                self->obj.IndicatorMode(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ScrollBar_get_IndicatorModeProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.ScrollBar", L"IndicatorModeProperty");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return winrt::Microsoft::UI::Xaml::Controls::Primitives::ScrollBar::IndicatorModeProperty();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ScrollBar_get_OrientationProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.ScrollBar", L"OrientationProperty");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return winrt::Microsoft::UI::Xaml::Controls::Primitives::ScrollBar::OrientationProperty();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ScrollBar_get_ViewportSizeProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.ScrollBar", L"ViewportSizeProperty");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return winrt::Microsoft::UI::Xaml::Controls::Primitives::ScrollBar::ViewportSizeProperty();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ScrollBar_add_Scroll(py::wrapper::Microsoft::UI::Xaml::Controls::Primitives::ScrollBar* self, PyObject* arg) noexcept
    {
        try
        {
            static std::optional<bool> is_event_present{};

            if (!is_event_present.has_value())
            {
                is_event_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Microsoft.UI.Xaml.Controls.Primitives.ScrollBar", L"Scroll");
            }

            if (!is_event_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::Microsoft::UI::Xaml::Controls::Primitives::ScrollEventHandler>(arg);

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Scroll(param0);
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ScrollBar_remove_Scroll(py::wrapper::Microsoft::UI::Xaml::Controls::Primitives::ScrollBar* self, PyObject* arg) noexcept
    {
        try
        {
            static std::optional<bool> is_event_present{};

            if (!is_event_present.has_value())
            {
                is_event_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Microsoft.UI.Xaml.Controls.Primitives.ScrollBar", L"Scroll");
            }

            if (!is_event_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::event_token>(arg);

            {
                auto _gil = release_gil();
                self->obj.Scroll(param0);
            }

            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_ScrollBar(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Microsoft::UI::Xaml::Controls::Primitives::ScrollBar>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_ScrollBar(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Microsoft::UI::Xaml::Controls::Primitives::ScrollBar>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_ScrollBar[] = {
        { "add_scroll", reinterpret_cast<PyCFunction>(ScrollBar_add_Scroll), METH_O, nullptr },
        { "remove_scroll", reinterpret_cast<PyCFunction>(ScrollBar_remove_Scroll), METH_O, nullptr },
        { "_assign_array_", _assign_array_ScrollBar, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_ScrollBar), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_ScrollBar[] = {
        { "viewport_size", reinterpret_cast<getter>(ScrollBar_get_ViewportSize), reinterpret_cast<setter>(ScrollBar_put_ViewportSize), nullptr, nullptr },
        { "orientation", reinterpret_cast<getter>(ScrollBar_get_Orientation), reinterpret_cast<setter>(ScrollBar_put_Orientation), nullptr, nullptr },
        { "indicator_mode", reinterpret_cast<getter>(ScrollBar_get_IndicatorMode), reinterpret_cast<setter>(ScrollBar_put_IndicatorMode), nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_ScrollBar[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_ScrollBar) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_ScrollBar) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_ScrollBar) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_ScrollBar) },
        { }
    };

    static PyType_Spec type_spec_ScrollBar = {
        "winrt._winrt_microsoft_ui_xaml_controls_primitives.ScrollBar",
        sizeof(py::wrapper::Microsoft::UI::Xaml::Controls::Primitives::ScrollBar),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_ScrollBar};

    static PyGetSetDef getset_ScrollBar_Static[] = {
        { "indicator_mode_property", reinterpret_cast<getter>(ScrollBar_get_IndicatorModeProperty), nullptr, nullptr, nullptr },
        { "orientation_property", reinterpret_cast<getter>(ScrollBar_get_OrientationProperty), nullptr, nullptr, nullptr },
        { "viewport_size_property", reinterpret_cast<getter>(ScrollBar_get_ViewportSizeProperty), nullptr, nullptr, nullptr },
        { }
    };

    static PyMethodDef methods_ScrollBar_Static[] = {
        { }
    };

    static PyType_Slot type_slots_ScrollBar_Static[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_ScrollBar_Static) },
        { Py_tp_methods, reinterpret_cast<void*>(methods_ScrollBar_Static) },
        { }
    };

    static PyType_Spec type_spec_ScrollBar_Static =
    {
        "winrt._winrt_microsoft_ui_xaml_controls_primitives.ScrollBar_Static",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT,
        type_slots_ScrollBar_Static
    };

    // ----- ScrollControllerAddScrollVelocityRequestedEventArgs class --------------------

    static PyObject* _new_ScrollControllerAddScrollVelocityRequestedEventArgs(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<float>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Foundation::IReference<float>>(args, 1);

                winrt::Microsoft::UI::Xaml::Controls::Primitives::ScrollControllerAddScrollVelocityRequestedEventArgs instance{param0, param1};
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_ScrollControllerAddScrollVelocityRequestedEventArgs(py::wrapper::Microsoft::UI::Xaml::Controls::Primitives::ScrollControllerAddScrollVelocityRequestedEventArgs* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* ScrollControllerAddScrollVelocityRequestedEventArgs_get_CorrelationId(py::wrapper::Microsoft::UI::Xaml::Controls::Primitives::ScrollControllerAddScrollVelocityRequestedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.ScrollControllerAddScrollVelocityRequestedEventArgs", L"CorrelationId");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.CorrelationId();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ScrollControllerAddScrollVelocityRequestedEventArgs_put_CorrelationId(py::wrapper::Microsoft::UI::Xaml::Controls::Primitives::ScrollControllerAddScrollVelocityRequestedEventArgs* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.ScrollControllerAddScrollVelocityRequestedEventArgs", L"CorrelationId");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<int32_t>(arg);

            {
                auto _gil = release_gil();
                self->obj.CorrelationId(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ScrollControllerAddScrollVelocityRequestedEventArgs_get_InertiaDecayRate(py::wrapper::Microsoft::UI::Xaml::Controls::Primitives::ScrollControllerAddScrollVelocityRequestedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.ScrollControllerAddScrollVelocityRequestedEventArgs", L"InertiaDecayRate");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.InertiaDecayRate();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ScrollControllerAddScrollVelocityRequestedEventArgs_get_OffsetVelocity(py::wrapper::Microsoft::UI::Xaml::Controls::Primitives::ScrollControllerAddScrollVelocityRequestedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.ScrollControllerAddScrollVelocityRequestedEventArgs", L"OffsetVelocity");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.OffsetVelocity();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_ScrollControllerAddScrollVelocityRequestedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Microsoft::UI::Xaml::Controls::Primitives::ScrollControllerAddScrollVelocityRequestedEventArgs>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_ScrollControllerAddScrollVelocityRequestedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Microsoft::UI::Xaml::Controls::Primitives::ScrollControllerAddScrollVelocityRequestedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_ScrollControllerAddScrollVelocityRequestedEventArgs[] = {
        { "_assign_array_", _assign_array_ScrollControllerAddScrollVelocityRequestedEventArgs, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_ScrollControllerAddScrollVelocityRequestedEventArgs), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_ScrollControllerAddScrollVelocityRequestedEventArgs[] = {
        { "correlation_id", reinterpret_cast<getter>(ScrollControllerAddScrollVelocityRequestedEventArgs_get_CorrelationId), reinterpret_cast<setter>(ScrollControllerAddScrollVelocityRequestedEventArgs_put_CorrelationId), nullptr, nullptr },
        { "inertia_decay_rate", reinterpret_cast<getter>(ScrollControllerAddScrollVelocityRequestedEventArgs_get_InertiaDecayRate), nullptr, nullptr, nullptr },
        { "offset_velocity", reinterpret_cast<getter>(ScrollControllerAddScrollVelocityRequestedEventArgs_get_OffsetVelocity), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_ScrollControllerAddScrollVelocityRequestedEventArgs[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_ScrollControllerAddScrollVelocityRequestedEventArgs) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_ScrollControllerAddScrollVelocityRequestedEventArgs) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_ScrollControllerAddScrollVelocityRequestedEventArgs) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_ScrollControllerAddScrollVelocityRequestedEventArgs) },
        { }
    };

    static PyType_Spec type_spec_ScrollControllerAddScrollVelocityRequestedEventArgs = {
        "winrt._winrt_microsoft_ui_xaml_controls_primitives.ScrollControllerAddScrollVelocityRequestedEventArgs",
        sizeof(py::wrapper::Microsoft::UI::Xaml::Controls::Primitives::ScrollControllerAddScrollVelocityRequestedEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_ScrollControllerAddScrollVelocityRequestedEventArgs};

    // ----- ScrollControllerPanRequestedEventArgs class --------------------

    static PyObject* _new_ScrollControllerPanRequestedEventArgs(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Microsoft::UI::Input::PointerPoint>(args, 0);

                winrt::Microsoft::UI::Xaml::Controls::Primitives::ScrollControllerPanRequestedEventArgs instance{param0};
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_ScrollControllerPanRequestedEventArgs(py::wrapper::Microsoft::UI::Xaml::Controls::Primitives::ScrollControllerPanRequestedEventArgs* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* ScrollControllerPanRequestedEventArgs_get_Handled(py::wrapper::Microsoft::UI::Xaml::Controls::Primitives::ScrollControllerPanRequestedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.ScrollControllerPanRequestedEventArgs", L"Handled");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Handled();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ScrollControllerPanRequestedEventArgs_put_Handled(py::wrapper::Microsoft::UI::Xaml::Controls::Primitives::ScrollControllerPanRequestedEventArgs* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.ScrollControllerPanRequestedEventArgs", L"Handled");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<bool>(arg);

            {
                auto _gil = release_gil();
                self->obj.Handled(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ScrollControllerPanRequestedEventArgs_get_PointerPoint(py::wrapper::Microsoft::UI::Xaml::Controls::Primitives::ScrollControllerPanRequestedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.ScrollControllerPanRequestedEventArgs", L"PointerPoint");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.PointerPoint();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_ScrollControllerPanRequestedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Microsoft::UI::Xaml::Controls::Primitives::ScrollControllerPanRequestedEventArgs>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_ScrollControllerPanRequestedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Microsoft::UI::Xaml::Controls::Primitives::ScrollControllerPanRequestedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_ScrollControllerPanRequestedEventArgs[] = {
        { "_assign_array_", _assign_array_ScrollControllerPanRequestedEventArgs, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_ScrollControllerPanRequestedEventArgs), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_ScrollControllerPanRequestedEventArgs[] = {
        { "handled", reinterpret_cast<getter>(ScrollControllerPanRequestedEventArgs_get_Handled), reinterpret_cast<setter>(ScrollControllerPanRequestedEventArgs_put_Handled), nullptr, nullptr },
        { "pointer_point", reinterpret_cast<getter>(ScrollControllerPanRequestedEventArgs_get_PointerPoint), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_ScrollControllerPanRequestedEventArgs[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_ScrollControllerPanRequestedEventArgs) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_ScrollControllerPanRequestedEventArgs) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_ScrollControllerPanRequestedEventArgs) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_ScrollControllerPanRequestedEventArgs) },
        { }
    };

    static PyType_Spec type_spec_ScrollControllerPanRequestedEventArgs = {
        "winrt._winrt_microsoft_ui_xaml_controls_primitives.ScrollControllerPanRequestedEventArgs",
        sizeof(py::wrapper::Microsoft::UI::Xaml::Controls::Primitives::ScrollControllerPanRequestedEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_ScrollControllerPanRequestedEventArgs};

    // ----- ScrollControllerScrollByRequestedEventArgs class --------------------

    static PyObject* _new_ScrollControllerScrollByRequestedEventArgs(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<double>(args, 0);
                auto param1 = py::convert_to<winrt::Microsoft::UI::Xaml::Controls::ScrollingScrollOptions>(args, 1);

                winrt::Microsoft::UI::Xaml::Controls::Primitives::ScrollControllerScrollByRequestedEventArgs instance{param0, param1};
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_ScrollControllerScrollByRequestedEventArgs(py::wrapper::Microsoft::UI::Xaml::Controls::Primitives::ScrollControllerScrollByRequestedEventArgs* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* ScrollControllerScrollByRequestedEventArgs_get_CorrelationId(py::wrapper::Microsoft::UI::Xaml::Controls::Primitives::ScrollControllerScrollByRequestedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.ScrollControllerScrollByRequestedEventArgs", L"CorrelationId");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.CorrelationId();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ScrollControllerScrollByRequestedEventArgs_put_CorrelationId(py::wrapper::Microsoft::UI::Xaml::Controls::Primitives::ScrollControllerScrollByRequestedEventArgs* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.ScrollControllerScrollByRequestedEventArgs", L"CorrelationId");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<int32_t>(arg);

            {
                auto _gil = release_gil();
                self->obj.CorrelationId(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ScrollControllerScrollByRequestedEventArgs_get_OffsetDelta(py::wrapper::Microsoft::UI::Xaml::Controls::Primitives::ScrollControllerScrollByRequestedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.ScrollControllerScrollByRequestedEventArgs", L"OffsetDelta");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.OffsetDelta();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ScrollControllerScrollByRequestedEventArgs_get_Options(py::wrapper::Microsoft::UI::Xaml::Controls::Primitives::ScrollControllerScrollByRequestedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.ScrollControllerScrollByRequestedEventArgs", L"Options");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Options();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_ScrollControllerScrollByRequestedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Microsoft::UI::Xaml::Controls::Primitives::ScrollControllerScrollByRequestedEventArgs>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_ScrollControllerScrollByRequestedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Microsoft::UI::Xaml::Controls::Primitives::ScrollControllerScrollByRequestedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_ScrollControllerScrollByRequestedEventArgs[] = {
        { "_assign_array_", _assign_array_ScrollControllerScrollByRequestedEventArgs, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_ScrollControllerScrollByRequestedEventArgs), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_ScrollControllerScrollByRequestedEventArgs[] = {
        { "correlation_id", reinterpret_cast<getter>(ScrollControllerScrollByRequestedEventArgs_get_CorrelationId), reinterpret_cast<setter>(ScrollControllerScrollByRequestedEventArgs_put_CorrelationId), nullptr, nullptr },
        { "offset_delta", reinterpret_cast<getter>(ScrollControllerScrollByRequestedEventArgs_get_OffsetDelta), nullptr, nullptr, nullptr },
        { "options", reinterpret_cast<getter>(ScrollControllerScrollByRequestedEventArgs_get_Options), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_ScrollControllerScrollByRequestedEventArgs[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_ScrollControllerScrollByRequestedEventArgs) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_ScrollControllerScrollByRequestedEventArgs) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_ScrollControllerScrollByRequestedEventArgs) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_ScrollControllerScrollByRequestedEventArgs) },
        { }
    };

    static PyType_Spec type_spec_ScrollControllerScrollByRequestedEventArgs = {
        "winrt._winrt_microsoft_ui_xaml_controls_primitives.ScrollControllerScrollByRequestedEventArgs",
        sizeof(py::wrapper::Microsoft::UI::Xaml::Controls::Primitives::ScrollControllerScrollByRequestedEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_ScrollControllerScrollByRequestedEventArgs};

    // ----- ScrollControllerScrollToRequestedEventArgs class --------------------

    static PyObject* _new_ScrollControllerScrollToRequestedEventArgs(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<double>(args, 0);
                auto param1 = py::convert_to<winrt::Microsoft::UI::Xaml::Controls::ScrollingScrollOptions>(args, 1);

                winrt::Microsoft::UI::Xaml::Controls::Primitives::ScrollControllerScrollToRequestedEventArgs instance{param0, param1};
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_ScrollControllerScrollToRequestedEventArgs(py::wrapper::Microsoft::UI::Xaml::Controls::Primitives::ScrollControllerScrollToRequestedEventArgs* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* ScrollControllerScrollToRequestedEventArgs_get_CorrelationId(py::wrapper::Microsoft::UI::Xaml::Controls::Primitives::ScrollControllerScrollToRequestedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.ScrollControllerScrollToRequestedEventArgs", L"CorrelationId");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.CorrelationId();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ScrollControllerScrollToRequestedEventArgs_put_CorrelationId(py::wrapper::Microsoft::UI::Xaml::Controls::Primitives::ScrollControllerScrollToRequestedEventArgs* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.ScrollControllerScrollToRequestedEventArgs", L"CorrelationId");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<int32_t>(arg);

            {
                auto _gil = release_gil();
                self->obj.CorrelationId(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ScrollControllerScrollToRequestedEventArgs_get_Offset(py::wrapper::Microsoft::UI::Xaml::Controls::Primitives::ScrollControllerScrollToRequestedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.ScrollControllerScrollToRequestedEventArgs", L"Offset");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Offset();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ScrollControllerScrollToRequestedEventArgs_get_Options(py::wrapper::Microsoft::UI::Xaml::Controls::Primitives::ScrollControllerScrollToRequestedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.ScrollControllerScrollToRequestedEventArgs", L"Options");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Options();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_ScrollControllerScrollToRequestedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Microsoft::UI::Xaml::Controls::Primitives::ScrollControllerScrollToRequestedEventArgs>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_ScrollControllerScrollToRequestedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Microsoft::UI::Xaml::Controls::Primitives::ScrollControllerScrollToRequestedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_ScrollControllerScrollToRequestedEventArgs[] = {
        { "_assign_array_", _assign_array_ScrollControllerScrollToRequestedEventArgs, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_ScrollControllerScrollToRequestedEventArgs), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_ScrollControllerScrollToRequestedEventArgs[] = {
        { "correlation_id", reinterpret_cast<getter>(ScrollControllerScrollToRequestedEventArgs_get_CorrelationId), reinterpret_cast<setter>(ScrollControllerScrollToRequestedEventArgs_put_CorrelationId), nullptr, nullptr },
        { "offset", reinterpret_cast<getter>(ScrollControllerScrollToRequestedEventArgs_get_Offset), nullptr, nullptr, nullptr },
        { "options", reinterpret_cast<getter>(ScrollControllerScrollToRequestedEventArgs_get_Options), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_ScrollControllerScrollToRequestedEventArgs[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_ScrollControllerScrollToRequestedEventArgs) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_ScrollControllerScrollToRequestedEventArgs) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_ScrollControllerScrollToRequestedEventArgs) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_ScrollControllerScrollToRequestedEventArgs) },
        { }
    };

    static PyType_Spec type_spec_ScrollControllerScrollToRequestedEventArgs = {
        "winrt._winrt_microsoft_ui_xaml_controls_primitives.ScrollControllerScrollToRequestedEventArgs",
        sizeof(py::wrapper::Microsoft::UI::Xaml::Controls::Primitives::ScrollControllerScrollToRequestedEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_ScrollControllerScrollToRequestedEventArgs};

    // ----- ScrollEventArgs class --------------------

    static PyObject* _new_ScrollEventArgs(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 0)
        {
            try
            {
                winrt::Microsoft::UI::Xaml::Controls::Primitives::ScrollEventArgs instance{};
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_ScrollEventArgs(py::wrapper::Microsoft::UI::Xaml::Controls::Primitives::ScrollEventArgs* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* ScrollEventArgs_get_NewValue(py::wrapper::Microsoft::UI::Xaml::Controls::Primitives::ScrollEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.ScrollEventArgs", L"NewValue");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.NewValue();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ScrollEventArgs_get_ScrollEventType(py::wrapper::Microsoft::UI::Xaml::Controls::Primitives::ScrollEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.ScrollEventArgs", L"ScrollEventType");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.ScrollEventType();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_ScrollEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Microsoft::UI::Xaml::Controls::Primitives::ScrollEventArgs>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_ScrollEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Microsoft::UI::Xaml::Controls::Primitives::ScrollEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_ScrollEventArgs[] = {
        { "_assign_array_", _assign_array_ScrollEventArgs, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_ScrollEventArgs), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_ScrollEventArgs[] = {
        { "new_value", reinterpret_cast<getter>(ScrollEventArgs_get_NewValue), nullptr, nullptr, nullptr },
        { "scroll_event_type", reinterpret_cast<getter>(ScrollEventArgs_get_ScrollEventType), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_ScrollEventArgs[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_ScrollEventArgs) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_ScrollEventArgs) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_ScrollEventArgs) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_ScrollEventArgs) },
        { }
    };

    static PyType_Spec type_spec_ScrollEventArgs = {
        "winrt._winrt_microsoft_ui_xaml_controls_primitives.ScrollEventArgs",
        sizeof(py::wrapper::Microsoft::UI::Xaml::Controls::Primitives::ScrollEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_ScrollEventArgs};

    // ----- ScrollPresenter class --------------------

    struct PyWinrtScrollPresenter;
    using BasePyWinrtScrollPresenter = winrt::Microsoft::UI::Xaml::Controls::Primitives::ScrollPresenterT<PyWinrtScrollPresenter, py::IPywinrtObject>;

    struct PyWinrtScrollPresenter : py::py_obj_ref, BasePyWinrtScrollPresenter
    {
        PyWinrtScrollPresenter(PyObject* py_obj) : py::py_obj_ref(py_obj), BasePyWinrtScrollPresenter() {}

        int32_t __stdcall GetPyObject(PyObject*& obj) override
        {
            obj = py::py_obj_ref::get_py_obj();
            return 0;
        }

        int32_t __stdcall GetComposableInner(winrt::Windows::Foundation::IInspectable& inner) override
        {
            inner = m_inner;
            return winrt::impl::error_ok;
        }

        static void toggle_reference(PyWinrtScrollPresenter* instance, bool is_last_reference)
        {
            py::py_obj_ref::toggle_reference(instance, is_last_reference);
        }

        int32_t query_interface_tearoff(winrt::guid const& id, void** result) const noexcept override
        {
            return py::py_obj_ref::query_interface_tearoff(id, result);
        }
    };

    static PyObject* _new_ScrollPresenter(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);

        auto self_type = get_python_type_for<winrt::Microsoft::UI::Xaml::Controls::Primitives::ScrollPresenter>();
        if (!self_type)
        {
            return nullptr;
        }

        if (arg_count == 0)
        {
            try
            {
                if (type != self_type)
                {
                    py::pyobj_handle self{type->tp_alloc(type, 0)};
                    if (!self)
                    {
                        return nullptr;
                    }

                    std::construct_at(&reinterpret_cast<py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>*>(self.get())->obj, nullptr);

                    auto obj_impl = winrt::make_self<PyWinrtScrollPresenter>(self.get());

                    auto obj = py::make_py_obj<PyWinrtScrollPresenter>(obj_impl, type, self.get());
                    if (!obj)
                    {
                        return nullptr;
                    }

                    reinterpret_cast<py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>*>(self.get())->obj = std::move(obj);

                    return self.detach();
                }

                winrt::Microsoft::UI::Xaml::Controls::Primitives::ScrollPresenter instance{};
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_ScrollPresenter(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* ScrollPresenter_AddScrollVelocity(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Xaml.Controls.Primitives.ScrollPresenter", L"AddScrollVelocity", 2);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(2);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Foundation::Numerics::float2>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Foundation::IReference<winrt::Windows::Foundation::Numerics::float2>>(args, 1);

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::Primitives::ScrollPresenter>().AddScrollVelocity(param0, param1);
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ScrollPresenter_AddZoomVelocity(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 3)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Xaml.Controls.Primitives.ScrollPresenter", L"AddZoomVelocity", 3);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(3);
                    return nullptr;
                }

                auto param0 = py::convert_to<float>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Foundation::IReference<winrt::Windows::Foundation::Numerics::float2>>(args, 1);
                auto param2 = py::convert_to<winrt::Windows::Foundation::IReference<float>>(args, 2);

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::Primitives::ScrollPresenter>().AddZoomVelocity(param0, param1, param2);
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ScrollPresenter_RegisterAnchorCandidate(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Xaml.Controls.Primitives.ScrollPresenter", L"RegisterAnchorCandidate", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Microsoft::UI::Xaml::UIElement>(args, 0);

                {
                    auto _gil = release_gil();
                    self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::Primitives::ScrollPresenter>().RegisterAnchorCandidate(param0);
                }

                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ScrollPresenter_ScrollBy(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Xaml.Controls.Primitives.ScrollPresenter", L"ScrollBy", 2);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(2);
                    return nullptr;
                }

                auto param0 = py::convert_to<double>(args, 0);
                auto param1 = py::convert_to<double>(args, 1);

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::Primitives::ScrollPresenter>().ScrollBy(param0, param1);
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ScrollPresenter_ScrollByWithOptions(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 3)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Xaml.Controls.Primitives.ScrollPresenter", L"ScrollBy", 3);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(3);
                    return nullptr;
                }

                auto param0 = py::convert_to<double>(args, 0);
                auto param1 = py::convert_to<double>(args, 1);
                auto param2 = py::convert_to<winrt::Microsoft::UI::Xaml::Controls::ScrollingScrollOptions>(args, 2);

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::Primitives::ScrollPresenter>().ScrollBy(param0, param1, param2);
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ScrollPresenter_ScrollTo(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Xaml.Controls.Primitives.ScrollPresenter", L"ScrollTo", 2);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(2);
                    return nullptr;
                }

                auto param0 = py::convert_to<double>(args, 0);
                auto param1 = py::convert_to<double>(args, 1);

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::Primitives::ScrollPresenter>().ScrollTo(param0, param1);
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ScrollPresenter_ScrollToWithOptions(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 3)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Xaml.Controls.Primitives.ScrollPresenter", L"ScrollTo", 3);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(3);
                    return nullptr;
                }

                auto param0 = py::convert_to<double>(args, 0);
                auto param1 = py::convert_to<double>(args, 1);
                auto param2 = py::convert_to<winrt::Microsoft::UI::Xaml::Controls::ScrollingScrollOptions>(args, 2);

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::Primitives::ScrollPresenter>().ScrollTo(param0, param1, param2);
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ScrollPresenter_UnregisterAnchorCandidate(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Xaml.Controls.Primitives.ScrollPresenter", L"UnregisterAnchorCandidate", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Microsoft::UI::Xaml::UIElement>(args, 0);

                {
                    auto _gil = release_gil();
                    self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::Primitives::ScrollPresenter>().UnregisterAnchorCandidate(param0);
                }

                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ScrollPresenter_ZoomBy(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Xaml.Controls.Primitives.ScrollPresenter", L"ZoomBy", 2);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(2);
                    return nullptr;
                }

                auto param0 = py::convert_to<float>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Foundation::IReference<winrt::Windows::Foundation::Numerics::float2>>(args, 1);

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::Primitives::ScrollPresenter>().ZoomBy(param0, param1);
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ScrollPresenter_ZoomByWithOptions(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 3)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Xaml.Controls.Primitives.ScrollPresenter", L"ZoomBy", 3);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(3);
                    return nullptr;
                }

                auto param0 = py::convert_to<float>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Foundation::IReference<winrt::Windows::Foundation::Numerics::float2>>(args, 1);
                auto param2 = py::convert_to<winrt::Microsoft::UI::Xaml::Controls::ScrollingZoomOptions>(args, 2);

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::Primitives::ScrollPresenter>().ZoomBy(param0, param1, param2);
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ScrollPresenter_ZoomTo(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Xaml.Controls.Primitives.ScrollPresenter", L"ZoomTo", 2);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(2);
                    return nullptr;
                }

                auto param0 = py::convert_to<float>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Foundation::IReference<winrt::Windows::Foundation::Numerics::float2>>(args, 1);

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::Primitives::ScrollPresenter>().ZoomTo(param0, param1);
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ScrollPresenter_ZoomToWithOptions(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 3)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Xaml.Controls.Primitives.ScrollPresenter", L"ZoomTo", 3);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(3);
                    return nullptr;
                }

                auto param0 = py::convert_to<float>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Foundation::IReference<winrt::Windows::Foundation::Numerics::float2>>(args, 1);
                auto param2 = py::convert_to<winrt::Microsoft::UI::Xaml::Controls::ScrollingZoomOptions>(args, 2);

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::Primitives::ScrollPresenter>().ZoomTo(param0, param1, param2);
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ScrollPresenter_get_CurrentAnchor(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.ScrollPresenter", L"CurrentAnchor");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::Primitives::ScrollPresenter>().CurrentAnchor();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ScrollPresenter_get_IgnoredInputKinds(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.ScrollPresenter", L"IgnoredInputKinds");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::Primitives::ScrollPresenter>().IgnoredInputKinds();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ScrollPresenter_put_IgnoredInputKinds(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.ScrollPresenter", L"IgnoredInputKinds");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Microsoft::UI::Xaml::Controls::ScrollingInputKinds>(arg);

            {
                auto _gil = release_gil();
                self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::Primitives::ScrollPresenter>().IgnoredInputKinds(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ScrollPresenter_get_HorizontalAnchorRatio(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.ScrollPresenter", L"HorizontalAnchorRatio");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::Primitives::ScrollPresenter>().HorizontalAnchorRatio();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ScrollPresenter_put_HorizontalAnchorRatio(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.ScrollPresenter", L"HorizontalAnchorRatio");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<double>(arg);

            {
                auto _gil = release_gil();
                self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::Primitives::ScrollPresenter>().HorizontalAnchorRatio(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ScrollPresenter_get_MaxZoomFactor(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.ScrollPresenter", L"MaxZoomFactor");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::Primitives::ScrollPresenter>().MaxZoomFactor();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ScrollPresenter_put_MaxZoomFactor(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.ScrollPresenter", L"MaxZoomFactor");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<double>(arg);

            {
                auto _gil = release_gil();
                self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::Primitives::ScrollPresenter>().MaxZoomFactor(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ScrollPresenter_get_HorizontalScrollRailMode(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.ScrollPresenter", L"HorizontalScrollRailMode");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::Primitives::ScrollPresenter>().HorizontalScrollRailMode();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ScrollPresenter_put_HorizontalScrollRailMode(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.ScrollPresenter", L"HorizontalScrollRailMode");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Microsoft::UI::Xaml::Controls::ScrollingRailMode>(arg);

            {
                auto _gil = release_gil();
                self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::Primitives::ScrollPresenter>().HorizontalScrollRailMode(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ScrollPresenter_get_HorizontalScrollMode(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.ScrollPresenter", L"HorizontalScrollMode");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::Primitives::ScrollPresenter>().HorizontalScrollMode();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ScrollPresenter_put_HorizontalScrollMode(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.ScrollPresenter", L"HorizontalScrollMode");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Microsoft::UI::Xaml::Controls::ScrollingScrollMode>(arg);

            {
                auto _gil = release_gil();
                self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::Primitives::ScrollPresenter>().HorizontalScrollMode(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ScrollPresenter_get_ContentOrientation(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.ScrollPresenter", L"ContentOrientation");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::Primitives::ScrollPresenter>().ContentOrientation();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ScrollPresenter_put_ContentOrientation(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.ScrollPresenter", L"ContentOrientation");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Microsoft::UI::Xaml::Controls::ScrollingContentOrientation>(arg);

            {
                auto _gil = release_gil();
                self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::Primitives::ScrollPresenter>().ContentOrientation(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ScrollPresenter_get_Content(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.ScrollPresenter", L"Content");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::Primitives::ScrollPresenter>().Content();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ScrollPresenter_put_Content(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.ScrollPresenter", L"Content");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Microsoft::UI::Xaml::UIElement>(arg);

            {
                auto _gil = release_gil();
                self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::Primitives::ScrollPresenter>().Content(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ScrollPresenter_get_HorizontalScrollController(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.ScrollPresenter", L"HorizontalScrollController");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::Primitives::ScrollPresenter>().HorizontalScrollController();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ScrollPresenter_put_HorizontalScrollController(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.ScrollPresenter", L"HorizontalScrollController");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Microsoft::UI::Xaml::Controls::Primitives::IScrollController>(arg);

            {
                auto _gil = release_gil();
                self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::Primitives::ScrollPresenter>().HorizontalScrollController(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ScrollPresenter_get_HorizontalScrollChainMode(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.ScrollPresenter", L"HorizontalScrollChainMode");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::Primitives::ScrollPresenter>().HorizontalScrollChainMode();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ScrollPresenter_put_HorizontalScrollChainMode(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.ScrollPresenter", L"HorizontalScrollChainMode");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Microsoft::UI::Xaml::Controls::ScrollingChainMode>(arg);

            {
                auto _gil = release_gil();
                self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::Primitives::ScrollPresenter>().HorizontalScrollChainMode(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ScrollPresenter_get_MinZoomFactor(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.ScrollPresenter", L"MinZoomFactor");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::Primitives::ScrollPresenter>().MinZoomFactor();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ScrollPresenter_put_MinZoomFactor(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.ScrollPresenter", L"MinZoomFactor");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<double>(arg);

            {
                auto _gil = release_gil();
                self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::Primitives::ScrollPresenter>().MinZoomFactor(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ScrollPresenter_get_Background(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.ScrollPresenter", L"Background");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::Primitives::ScrollPresenter>().Background();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ScrollPresenter_put_Background(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.ScrollPresenter", L"Background");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Microsoft::UI::Xaml::Media::Brush>(arg);

            {
                auto _gil = release_gil();
                self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::Primitives::ScrollPresenter>().Background(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ScrollPresenter_get_ZoomMode(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.ScrollPresenter", L"ZoomMode");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::Primitives::ScrollPresenter>().ZoomMode();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ScrollPresenter_put_ZoomMode(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.ScrollPresenter", L"ZoomMode");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Microsoft::UI::Xaml::Controls::ScrollingZoomMode>(arg);

            {
                auto _gil = release_gil();
                self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::Primitives::ScrollPresenter>().ZoomMode(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ScrollPresenter_get_ZoomChainMode(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.ScrollPresenter", L"ZoomChainMode");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::Primitives::ScrollPresenter>().ZoomChainMode();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ScrollPresenter_put_ZoomChainMode(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.ScrollPresenter", L"ZoomChainMode");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Microsoft::UI::Xaml::Controls::ScrollingChainMode>(arg);

            {
                auto _gil = release_gil();
                self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::Primitives::ScrollPresenter>().ZoomChainMode(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ScrollPresenter_get_VerticalScrollRailMode(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.ScrollPresenter", L"VerticalScrollRailMode");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::Primitives::ScrollPresenter>().VerticalScrollRailMode();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ScrollPresenter_put_VerticalScrollRailMode(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.ScrollPresenter", L"VerticalScrollRailMode");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Microsoft::UI::Xaml::Controls::ScrollingRailMode>(arg);

            {
                auto _gil = release_gil();
                self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::Primitives::ScrollPresenter>().VerticalScrollRailMode(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ScrollPresenter_get_VerticalScrollMode(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.ScrollPresenter", L"VerticalScrollMode");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::Primitives::ScrollPresenter>().VerticalScrollMode();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ScrollPresenter_put_VerticalScrollMode(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.ScrollPresenter", L"VerticalScrollMode");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Microsoft::UI::Xaml::Controls::ScrollingScrollMode>(arg);

            {
                auto _gil = release_gil();
                self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::Primitives::ScrollPresenter>().VerticalScrollMode(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ScrollPresenter_get_VerticalScrollController(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.ScrollPresenter", L"VerticalScrollController");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::Primitives::ScrollPresenter>().VerticalScrollController();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ScrollPresenter_put_VerticalScrollController(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.ScrollPresenter", L"VerticalScrollController");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Microsoft::UI::Xaml::Controls::Primitives::IScrollController>(arg);

            {
                auto _gil = release_gil();
                self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::Primitives::ScrollPresenter>().VerticalScrollController(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ScrollPresenter_get_VerticalScrollChainMode(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.ScrollPresenter", L"VerticalScrollChainMode");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::Primitives::ScrollPresenter>().VerticalScrollChainMode();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ScrollPresenter_put_VerticalScrollChainMode(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.ScrollPresenter", L"VerticalScrollChainMode");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Microsoft::UI::Xaml::Controls::ScrollingChainMode>(arg);

            {
                auto _gil = release_gil();
                self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::Primitives::ScrollPresenter>().VerticalScrollChainMode(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ScrollPresenter_get_VerticalAnchorRatio(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.ScrollPresenter", L"VerticalAnchorRatio");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::Primitives::ScrollPresenter>().VerticalAnchorRatio();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ScrollPresenter_put_VerticalAnchorRatio(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.ScrollPresenter", L"VerticalAnchorRatio");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<double>(arg);

            {
                auto _gil = release_gil();
                self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::Primitives::ScrollPresenter>().VerticalAnchorRatio(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ScrollPresenter_get_ComputedHorizontalScrollMode(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.ScrollPresenter", L"ComputedHorizontalScrollMode");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::Primitives::ScrollPresenter>().ComputedHorizontalScrollMode();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ScrollPresenter_get_ComputedVerticalScrollMode(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.ScrollPresenter", L"ComputedVerticalScrollMode");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::Primitives::ScrollPresenter>().ComputedVerticalScrollMode();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ScrollPresenter_get_ExpressionAnimationSources(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.ScrollPresenter", L"ExpressionAnimationSources");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::Primitives::ScrollPresenter>().ExpressionAnimationSources();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ScrollPresenter_get_ExtentHeight(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.ScrollPresenter", L"ExtentHeight");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::Primitives::ScrollPresenter>().ExtentHeight();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ScrollPresenter_get_ExtentWidth(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.ScrollPresenter", L"ExtentWidth");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::Primitives::ScrollPresenter>().ExtentWidth();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ScrollPresenter_get_HorizontalOffset(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.ScrollPresenter", L"HorizontalOffset");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::Primitives::ScrollPresenter>().HorizontalOffset();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ScrollPresenter_get_HorizontalSnapPoints(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.ScrollPresenter", L"HorizontalSnapPoints");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::Primitives::ScrollPresenter>().HorizontalSnapPoints();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ScrollPresenter_get_ScrollableHeight(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.ScrollPresenter", L"ScrollableHeight");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::Primitives::ScrollPresenter>().ScrollableHeight();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ScrollPresenter_get_ScrollableWidth(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.ScrollPresenter", L"ScrollableWidth");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::Primitives::ScrollPresenter>().ScrollableWidth();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ScrollPresenter_get_State(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.ScrollPresenter", L"State");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::Primitives::ScrollPresenter>().State();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ScrollPresenter_get_VerticalOffset(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.ScrollPresenter", L"VerticalOffset");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::Primitives::ScrollPresenter>().VerticalOffset();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ScrollPresenter_get_VerticalSnapPoints(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.ScrollPresenter", L"VerticalSnapPoints");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::Primitives::ScrollPresenter>().VerticalSnapPoints();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ScrollPresenter_get_ViewportHeight(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.ScrollPresenter", L"ViewportHeight");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::Primitives::ScrollPresenter>().ViewportHeight();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ScrollPresenter_get_ViewportWidth(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.ScrollPresenter", L"ViewportWidth");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::Primitives::ScrollPresenter>().ViewportWidth();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ScrollPresenter_get_ZoomFactor(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.ScrollPresenter", L"ZoomFactor");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::Primitives::ScrollPresenter>().ZoomFactor();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ScrollPresenter_get_ZoomSnapPoints(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.ScrollPresenter", L"ZoomSnapPoints");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::Primitives::ScrollPresenter>().ZoomSnapPoints();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ScrollPresenter_get_BackgroundProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.ScrollPresenter", L"BackgroundProperty");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return winrt::Microsoft::UI::Xaml::Controls::Primitives::ScrollPresenter::BackgroundProperty();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ScrollPresenter_get_ComputedHorizontalScrollModeProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.ScrollPresenter", L"ComputedHorizontalScrollModeProperty");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return winrt::Microsoft::UI::Xaml::Controls::Primitives::ScrollPresenter::ComputedHorizontalScrollModeProperty();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ScrollPresenter_get_ComputedVerticalScrollModeProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.ScrollPresenter", L"ComputedVerticalScrollModeProperty");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return winrt::Microsoft::UI::Xaml::Controls::Primitives::ScrollPresenter::ComputedVerticalScrollModeProperty();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ScrollPresenter_get_ContentOrientationProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.ScrollPresenter", L"ContentOrientationProperty");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return winrt::Microsoft::UI::Xaml::Controls::Primitives::ScrollPresenter::ContentOrientationProperty();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ScrollPresenter_get_ContentProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.ScrollPresenter", L"ContentProperty");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return winrt::Microsoft::UI::Xaml::Controls::Primitives::ScrollPresenter::ContentProperty();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ScrollPresenter_get_HorizontalAnchorRatioProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.ScrollPresenter", L"HorizontalAnchorRatioProperty");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return winrt::Microsoft::UI::Xaml::Controls::Primitives::ScrollPresenter::HorizontalAnchorRatioProperty();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ScrollPresenter_get_HorizontalScrollChainModeProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.ScrollPresenter", L"HorizontalScrollChainModeProperty");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return winrt::Microsoft::UI::Xaml::Controls::Primitives::ScrollPresenter::HorizontalScrollChainModeProperty();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ScrollPresenter_get_HorizontalScrollModeProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.ScrollPresenter", L"HorizontalScrollModeProperty");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return winrt::Microsoft::UI::Xaml::Controls::Primitives::ScrollPresenter::HorizontalScrollModeProperty();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ScrollPresenter_get_HorizontalScrollRailModeProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.ScrollPresenter", L"HorizontalScrollRailModeProperty");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return winrt::Microsoft::UI::Xaml::Controls::Primitives::ScrollPresenter::HorizontalScrollRailModeProperty();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ScrollPresenter_get_IgnoredInputKindsProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.ScrollPresenter", L"IgnoredInputKindsProperty");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return winrt::Microsoft::UI::Xaml::Controls::Primitives::ScrollPresenter::IgnoredInputKindsProperty();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ScrollPresenter_get_MaxZoomFactorProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.ScrollPresenter", L"MaxZoomFactorProperty");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return winrt::Microsoft::UI::Xaml::Controls::Primitives::ScrollPresenter::MaxZoomFactorProperty();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ScrollPresenter_get_MinZoomFactorProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.ScrollPresenter", L"MinZoomFactorProperty");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return winrt::Microsoft::UI::Xaml::Controls::Primitives::ScrollPresenter::MinZoomFactorProperty();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ScrollPresenter_get_VerticalAnchorRatioProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.ScrollPresenter", L"VerticalAnchorRatioProperty");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return winrt::Microsoft::UI::Xaml::Controls::Primitives::ScrollPresenter::VerticalAnchorRatioProperty();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ScrollPresenter_get_VerticalScrollChainModeProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.ScrollPresenter", L"VerticalScrollChainModeProperty");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return winrt::Microsoft::UI::Xaml::Controls::Primitives::ScrollPresenter::VerticalScrollChainModeProperty();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ScrollPresenter_get_VerticalScrollModeProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.ScrollPresenter", L"VerticalScrollModeProperty");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return winrt::Microsoft::UI::Xaml::Controls::Primitives::ScrollPresenter::VerticalScrollModeProperty();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ScrollPresenter_get_VerticalScrollRailModeProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.ScrollPresenter", L"VerticalScrollRailModeProperty");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return winrt::Microsoft::UI::Xaml::Controls::Primitives::ScrollPresenter::VerticalScrollRailModeProperty();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ScrollPresenter_get_ZoomChainModeProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.ScrollPresenter", L"ZoomChainModeProperty");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return winrt::Microsoft::UI::Xaml::Controls::Primitives::ScrollPresenter::ZoomChainModeProperty();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ScrollPresenter_get_ZoomModeProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.ScrollPresenter", L"ZoomModeProperty");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return winrt::Microsoft::UI::Xaml::Controls::Primitives::ScrollPresenter::ZoomModeProperty();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ScrollPresenter_add_AnchorRequested(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, PyObject* arg) noexcept
    {
        try
        {
            static std::optional<bool> is_event_present{};

            if (!is_event_present.has_value())
            {
                is_event_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Microsoft.UI.Xaml.Controls.Primitives.ScrollPresenter", L"AnchorRequested");
            }

            if (!is_event_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Microsoft::UI::Xaml::Controls::Primitives::ScrollPresenter, winrt::Microsoft::UI::Xaml::Controls::ScrollingAnchorRequestedEventArgs>>(arg);

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::Primitives::ScrollPresenter>().AnchorRequested(param0);
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ScrollPresenter_remove_AnchorRequested(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, PyObject* arg) noexcept
    {
        try
        {
            static std::optional<bool> is_event_present{};

            if (!is_event_present.has_value())
            {
                is_event_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Microsoft.UI.Xaml.Controls.Primitives.ScrollPresenter", L"AnchorRequested");
            }

            if (!is_event_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::event_token>(arg);

            {
                auto _gil = release_gil();
                self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::Primitives::ScrollPresenter>().AnchorRequested(param0);
            }

            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ScrollPresenter_add_BringingIntoView(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, PyObject* arg) noexcept
    {
        try
        {
            static std::optional<bool> is_event_present{};

            if (!is_event_present.has_value())
            {
                is_event_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Microsoft.UI.Xaml.Controls.Primitives.ScrollPresenter", L"BringingIntoView");
            }

            if (!is_event_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Microsoft::UI::Xaml::Controls::Primitives::ScrollPresenter, winrt::Microsoft::UI::Xaml::Controls::ScrollingBringingIntoViewEventArgs>>(arg);

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::Primitives::ScrollPresenter>().BringingIntoView(param0);
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ScrollPresenter_remove_BringingIntoView(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, PyObject* arg) noexcept
    {
        try
        {
            static std::optional<bool> is_event_present{};

            if (!is_event_present.has_value())
            {
                is_event_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Microsoft.UI.Xaml.Controls.Primitives.ScrollPresenter", L"BringingIntoView");
            }

            if (!is_event_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::event_token>(arg);

            {
                auto _gil = release_gil();
                self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::Primitives::ScrollPresenter>().BringingIntoView(param0);
            }

            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ScrollPresenter_add_ExtentChanged(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, PyObject* arg) noexcept
    {
        try
        {
            static std::optional<bool> is_event_present{};

            if (!is_event_present.has_value())
            {
                is_event_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Microsoft.UI.Xaml.Controls.Primitives.ScrollPresenter", L"ExtentChanged");
            }

            if (!is_event_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Microsoft::UI::Xaml::Controls::Primitives::ScrollPresenter, winrt::Windows::Foundation::IInspectable>>(arg);

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::Primitives::ScrollPresenter>().ExtentChanged(param0);
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ScrollPresenter_remove_ExtentChanged(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, PyObject* arg) noexcept
    {
        try
        {
            static std::optional<bool> is_event_present{};

            if (!is_event_present.has_value())
            {
                is_event_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Microsoft.UI.Xaml.Controls.Primitives.ScrollPresenter", L"ExtentChanged");
            }

            if (!is_event_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::event_token>(arg);

            {
                auto _gil = release_gil();
                self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::Primitives::ScrollPresenter>().ExtentChanged(param0);
            }

            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ScrollPresenter_add_ScrollAnimationStarting(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, PyObject* arg) noexcept
    {
        try
        {
            static std::optional<bool> is_event_present{};

            if (!is_event_present.has_value())
            {
                is_event_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Microsoft.UI.Xaml.Controls.Primitives.ScrollPresenter", L"ScrollAnimationStarting");
            }

            if (!is_event_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Microsoft::UI::Xaml::Controls::Primitives::ScrollPresenter, winrt::Microsoft::UI::Xaml::Controls::ScrollingScrollAnimationStartingEventArgs>>(arg);

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::Primitives::ScrollPresenter>().ScrollAnimationStarting(param0);
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ScrollPresenter_remove_ScrollAnimationStarting(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, PyObject* arg) noexcept
    {
        try
        {
            static std::optional<bool> is_event_present{};

            if (!is_event_present.has_value())
            {
                is_event_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Microsoft.UI.Xaml.Controls.Primitives.ScrollPresenter", L"ScrollAnimationStarting");
            }

            if (!is_event_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::event_token>(arg);

            {
                auto _gil = release_gil();
                self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::Primitives::ScrollPresenter>().ScrollAnimationStarting(param0);
            }

            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ScrollPresenter_add_ScrollCompleted(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, PyObject* arg) noexcept
    {
        try
        {
            static std::optional<bool> is_event_present{};

            if (!is_event_present.has_value())
            {
                is_event_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Microsoft.UI.Xaml.Controls.Primitives.ScrollPresenter", L"ScrollCompleted");
            }

            if (!is_event_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Microsoft::UI::Xaml::Controls::Primitives::ScrollPresenter, winrt::Microsoft::UI::Xaml::Controls::ScrollingScrollCompletedEventArgs>>(arg);

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::Primitives::ScrollPresenter>().ScrollCompleted(param0);
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ScrollPresenter_remove_ScrollCompleted(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, PyObject* arg) noexcept
    {
        try
        {
            static std::optional<bool> is_event_present{};

            if (!is_event_present.has_value())
            {
                is_event_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Microsoft.UI.Xaml.Controls.Primitives.ScrollPresenter", L"ScrollCompleted");
            }

            if (!is_event_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::event_token>(arg);

            {
                auto _gil = release_gil();
                self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::Primitives::ScrollPresenter>().ScrollCompleted(param0);
            }

            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ScrollPresenter_add_StateChanged(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, PyObject* arg) noexcept
    {
        try
        {
            static std::optional<bool> is_event_present{};

            if (!is_event_present.has_value())
            {
                is_event_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Microsoft.UI.Xaml.Controls.Primitives.ScrollPresenter", L"StateChanged");
            }

            if (!is_event_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Microsoft::UI::Xaml::Controls::Primitives::ScrollPresenter, winrt::Windows::Foundation::IInspectable>>(arg);

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::Primitives::ScrollPresenter>().StateChanged(param0);
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ScrollPresenter_remove_StateChanged(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, PyObject* arg) noexcept
    {
        try
        {
            static std::optional<bool> is_event_present{};

            if (!is_event_present.has_value())
            {
                is_event_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Microsoft.UI.Xaml.Controls.Primitives.ScrollPresenter", L"StateChanged");
            }

            if (!is_event_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::event_token>(arg);

            {
                auto _gil = release_gil();
                self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::Primitives::ScrollPresenter>().StateChanged(param0);
            }

            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ScrollPresenter_add_ViewChanged(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, PyObject* arg) noexcept
    {
        try
        {
            static std::optional<bool> is_event_present{};

            if (!is_event_present.has_value())
            {
                is_event_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Microsoft.UI.Xaml.Controls.Primitives.ScrollPresenter", L"ViewChanged");
            }

            if (!is_event_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Microsoft::UI::Xaml::Controls::Primitives::ScrollPresenter, winrt::Windows::Foundation::IInspectable>>(arg);

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::Primitives::ScrollPresenter>().ViewChanged(param0);
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ScrollPresenter_remove_ViewChanged(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, PyObject* arg) noexcept
    {
        try
        {
            static std::optional<bool> is_event_present{};

            if (!is_event_present.has_value())
            {
                is_event_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Microsoft.UI.Xaml.Controls.Primitives.ScrollPresenter", L"ViewChanged");
            }

            if (!is_event_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::event_token>(arg);

            {
                auto _gil = release_gil();
                self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::Primitives::ScrollPresenter>().ViewChanged(param0);
            }

            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ScrollPresenter_add_ZoomAnimationStarting(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, PyObject* arg) noexcept
    {
        try
        {
            static std::optional<bool> is_event_present{};

            if (!is_event_present.has_value())
            {
                is_event_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Microsoft.UI.Xaml.Controls.Primitives.ScrollPresenter", L"ZoomAnimationStarting");
            }

            if (!is_event_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Microsoft::UI::Xaml::Controls::Primitives::ScrollPresenter, winrt::Microsoft::UI::Xaml::Controls::ScrollingZoomAnimationStartingEventArgs>>(arg);

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::Primitives::ScrollPresenter>().ZoomAnimationStarting(param0);
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ScrollPresenter_remove_ZoomAnimationStarting(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, PyObject* arg) noexcept
    {
        try
        {
            static std::optional<bool> is_event_present{};

            if (!is_event_present.has_value())
            {
                is_event_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Microsoft.UI.Xaml.Controls.Primitives.ScrollPresenter", L"ZoomAnimationStarting");
            }

            if (!is_event_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::event_token>(arg);

            {
                auto _gil = release_gil();
                self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::Primitives::ScrollPresenter>().ZoomAnimationStarting(param0);
            }

            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ScrollPresenter_add_ZoomCompleted(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, PyObject* arg) noexcept
    {
        try
        {
            static std::optional<bool> is_event_present{};

            if (!is_event_present.has_value())
            {
                is_event_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Microsoft.UI.Xaml.Controls.Primitives.ScrollPresenter", L"ZoomCompleted");
            }

            if (!is_event_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Microsoft::UI::Xaml::Controls::Primitives::ScrollPresenter, winrt::Microsoft::UI::Xaml::Controls::ScrollingZoomCompletedEventArgs>>(arg);

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::Primitives::ScrollPresenter>().ZoomCompleted(param0);
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ScrollPresenter_remove_ZoomCompleted(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, PyObject* arg) noexcept
    {
        try
        {
            static std::optional<bool> is_event_present{};

            if (!is_event_present.has_value())
            {
                is_event_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Microsoft.UI.Xaml.Controls.Primitives.ScrollPresenter", L"ZoomCompleted");
            }

            if (!is_event_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::event_token>(arg);

            {
                auto _gil = release_gil();
                self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::Primitives::ScrollPresenter>().ZoomCompleted(param0);
            }

            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_ScrollPresenter(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Microsoft::UI::Xaml::Controls::Primitives::ScrollPresenter>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_ScrollPresenter(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Microsoft::UI::Xaml::Controls::Primitives::ScrollPresenter>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_ScrollPresenter[] = {
        { "add_scroll_velocity", reinterpret_cast<PyCFunction>(ScrollPresenter_AddScrollVelocity), METH_VARARGS, nullptr },
        { "add_zoom_velocity", reinterpret_cast<PyCFunction>(ScrollPresenter_AddZoomVelocity), METH_VARARGS, nullptr },
        { "register_anchor_candidate", reinterpret_cast<PyCFunction>(ScrollPresenter_RegisterAnchorCandidate), METH_VARARGS, nullptr },
        { "scroll_by", reinterpret_cast<PyCFunction>(ScrollPresenter_ScrollBy), METH_VARARGS, nullptr },
        { "scroll_by_with_options", reinterpret_cast<PyCFunction>(ScrollPresenter_ScrollByWithOptions), METH_VARARGS, nullptr },
        { "scroll_to", reinterpret_cast<PyCFunction>(ScrollPresenter_ScrollTo), METH_VARARGS, nullptr },
        { "scroll_to_with_options", reinterpret_cast<PyCFunction>(ScrollPresenter_ScrollToWithOptions), METH_VARARGS, nullptr },
        { "unregister_anchor_candidate", reinterpret_cast<PyCFunction>(ScrollPresenter_UnregisterAnchorCandidate), METH_VARARGS, nullptr },
        { "zoom_by", reinterpret_cast<PyCFunction>(ScrollPresenter_ZoomBy), METH_VARARGS, nullptr },
        { "zoom_by_with_options", reinterpret_cast<PyCFunction>(ScrollPresenter_ZoomByWithOptions), METH_VARARGS, nullptr },
        { "zoom_to", reinterpret_cast<PyCFunction>(ScrollPresenter_ZoomTo), METH_VARARGS, nullptr },
        { "zoom_to_with_options", reinterpret_cast<PyCFunction>(ScrollPresenter_ZoomToWithOptions), METH_VARARGS, nullptr },
        { "add_anchor_requested", reinterpret_cast<PyCFunction>(ScrollPresenter_add_AnchorRequested), METH_O, nullptr },
        { "remove_anchor_requested", reinterpret_cast<PyCFunction>(ScrollPresenter_remove_AnchorRequested), METH_O, nullptr },
        { "add_bringing_into_view", reinterpret_cast<PyCFunction>(ScrollPresenter_add_BringingIntoView), METH_O, nullptr },
        { "remove_bringing_into_view", reinterpret_cast<PyCFunction>(ScrollPresenter_remove_BringingIntoView), METH_O, nullptr },
        { "add_extent_changed", reinterpret_cast<PyCFunction>(ScrollPresenter_add_ExtentChanged), METH_O, nullptr },
        { "remove_extent_changed", reinterpret_cast<PyCFunction>(ScrollPresenter_remove_ExtentChanged), METH_O, nullptr },
        { "add_scroll_animation_starting", reinterpret_cast<PyCFunction>(ScrollPresenter_add_ScrollAnimationStarting), METH_O, nullptr },
        { "remove_scroll_animation_starting", reinterpret_cast<PyCFunction>(ScrollPresenter_remove_ScrollAnimationStarting), METH_O, nullptr },
        { "add_scroll_completed", reinterpret_cast<PyCFunction>(ScrollPresenter_add_ScrollCompleted), METH_O, nullptr },
        { "remove_scroll_completed", reinterpret_cast<PyCFunction>(ScrollPresenter_remove_ScrollCompleted), METH_O, nullptr },
        { "add_state_changed", reinterpret_cast<PyCFunction>(ScrollPresenter_add_StateChanged), METH_O, nullptr },
        { "remove_state_changed", reinterpret_cast<PyCFunction>(ScrollPresenter_remove_StateChanged), METH_O, nullptr },
        { "add_view_changed", reinterpret_cast<PyCFunction>(ScrollPresenter_add_ViewChanged), METH_O, nullptr },
        { "remove_view_changed", reinterpret_cast<PyCFunction>(ScrollPresenter_remove_ViewChanged), METH_O, nullptr },
        { "add_zoom_animation_starting", reinterpret_cast<PyCFunction>(ScrollPresenter_add_ZoomAnimationStarting), METH_O, nullptr },
        { "remove_zoom_animation_starting", reinterpret_cast<PyCFunction>(ScrollPresenter_remove_ZoomAnimationStarting), METH_O, nullptr },
        { "add_zoom_completed", reinterpret_cast<PyCFunction>(ScrollPresenter_add_ZoomCompleted), METH_O, nullptr },
        { "remove_zoom_completed", reinterpret_cast<PyCFunction>(ScrollPresenter_remove_ZoomCompleted), METH_O, nullptr },
        { "_assign_array_", _assign_array_ScrollPresenter, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_ScrollPresenter), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_ScrollPresenter[] = {
        { "current_anchor", reinterpret_cast<getter>(ScrollPresenter_get_CurrentAnchor), nullptr, nullptr, nullptr },
        { "ignored_input_kinds", reinterpret_cast<getter>(ScrollPresenter_get_IgnoredInputKinds), reinterpret_cast<setter>(ScrollPresenter_put_IgnoredInputKinds), nullptr, nullptr },
        { "horizontal_anchor_ratio", reinterpret_cast<getter>(ScrollPresenter_get_HorizontalAnchorRatio), reinterpret_cast<setter>(ScrollPresenter_put_HorizontalAnchorRatio), nullptr, nullptr },
        { "max_zoom_factor", reinterpret_cast<getter>(ScrollPresenter_get_MaxZoomFactor), reinterpret_cast<setter>(ScrollPresenter_put_MaxZoomFactor), nullptr, nullptr },
        { "horizontal_scroll_rail_mode", reinterpret_cast<getter>(ScrollPresenter_get_HorizontalScrollRailMode), reinterpret_cast<setter>(ScrollPresenter_put_HorizontalScrollRailMode), nullptr, nullptr },
        { "horizontal_scroll_mode", reinterpret_cast<getter>(ScrollPresenter_get_HorizontalScrollMode), reinterpret_cast<setter>(ScrollPresenter_put_HorizontalScrollMode), nullptr, nullptr },
        { "content_orientation", reinterpret_cast<getter>(ScrollPresenter_get_ContentOrientation), reinterpret_cast<setter>(ScrollPresenter_put_ContentOrientation), nullptr, nullptr },
        { "content", reinterpret_cast<getter>(ScrollPresenter_get_Content), reinterpret_cast<setter>(ScrollPresenter_put_Content), nullptr, nullptr },
        { "horizontal_scroll_controller", reinterpret_cast<getter>(ScrollPresenter_get_HorizontalScrollController), reinterpret_cast<setter>(ScrollPresenter_put_HorizontalScrollController), nullptr, nullptr },
        { "horizontal_scroll_chain_mode", reinterpret_cast<getter>(ScrollPresenter_get_HorizontalScrollChainMode), reinterpret_cast<setter>(ScrollPresenter_put_HorizontalScrollChainMode), nullptr, nullptr },
        { "min_zoom_factor", reinterpret_cast<getter>(ScrollPresenter_get_MinZoomFactor), reinterpret_cast<setter>(ScrollPresenter_put_MinZoomFactor), nullptr, nullptr },
        { "background", reinterpret_cast<getter>(ScrollPresenter_get_Background), reinterpret_cast<setter>(ScrollPresenter_put_Background), nullptr, nullptr },
        { "zoom_mode", reinterpret_cast<getter>(ScrollPresenter_get_ZoomMode), reinterpret_cast<setter>(ScrollPresenter_put_ZoomMode), nullptr, nullptr },
        { "zoom_chain_mode", reinterpret_cast<getter>(ScrollPresenter_get_ZoomChainMode), reinterpret_cast<setter>(ScrollPresenter_put_ZoomChainMode), nullptr, nullptr },
        { "vertical_scroll_rail_mode", reinterpret_cast<getter>(ScrollPresenter_get_VerticalScrollRailMode), reinterpret_cast<setter>(ScrollPresenter_put_VerticalScrollRailMode), nullptr, nullptr },
        { "vertical_scroll_mode", reinterpret_cast<getter>(ScrollPresenter_get_VerticalScrollMode), reinterpret_cast<setter>(ScrollPresenter_put_VerticalScrollMode), nullptr, nullptr },
        { "vertical_scroll_controller", reinterpret_cast<getter>(ScrollPresenter_get_VerticalScrollController), reinterpret_cast<setter>(ScrollPresenter_put_VerticalScrollController), nullptr, nullptr },
        { "vertical_scroll_chain_mode", reinterpret_cast<getter>(ScrollPresenter_get_VerticalScrollChainMode), reinterpret_cast<setter>(ScrollPresenter_put_VerticalScrollChainMode), nullptr, nullptr },
        { "vertical_anchor_ratio", reinterpret_cast<getter>(ScrollPresenter_get_VerticalAnchorRatio), reinterpret_cast<setter>(ScrollPresenter_put_VerticalAnchorRatio), nullptr, nullptr },
        { "computed_horizontal_scroll_mode", reinterpret_cast<getter>(ScrollPresenter_get_ComputedHorizontalScrollMode), nullptr, nullptr, nullptr },
        { "computed_vertical_scroll_mode", reinterpret_cast<getter>(ScrollPresenter_get_ComputedVerticalScrollMode), nullptr, nullptr, nullptr },
        { "expression_animation_sources", reinterpret_cast<getter>(ScrollPresenter_get_ExpressionAnimationSources), nullptr, nullptr, nullptr },
        { "extent_height", reinterpret_cast<getter>(ScrollPresenter_get_ExtentHeight), nullptr, nullptr, nullptr },
        { "extent_width", reinterpret_cast<getter>(ScrollPresenter_get_ExtentWidth), nullptr, nullptr, nullptr },
        { "horizontal_offset", reinterpret_cast<getter>(ScrollPresenter_get_HorizontalOffset), nullptr, nullptr, nullptr },
        { "horizontal_snap_points", reinterpret_cast<getter>(ScrollPresenter_get_HorizontalSnapPoints), nullptr, nullptr, nullptr },
        { "scrollable_height", reinterpret_cast<getter>(ScrollPresenter_get_ScrollableHeight), nullptr, nullptr, nullptr },
        { "scrollable_width", reinterpret_cast<getter>(ScrollPresenter_get_ScrollableWidth), nullptr, nullptr, nullptr },
        { "state", reinterpret_cast<getter>(ScrollPresenter_get_State), nullptr, nullptr, nullptr },
        { "vertical_offset", reinterpret_cast<getter>(ScrollPresenter_get_VerticalOffset), nullptr, nullptr, nullptr },
        { "vertical_snap_points", reinterpret_cast<getter>(ScrollPresenter_get_VerticalSnapPoints), nullptr, nullptr, nullptr },
        { "viewport_height", reinterpret_cast<getter>(ScrollPresenter_get_ViewportHeight), nullptr, nullptr, nullptr },
        { "viewport_width", reinterpret_cast<getter>(ScrollPresenter_get_ViewportWidth), nullptr, nullptr, nullptr },
        { "zoom_factor", reinterpret_cast<getter>(ScrollPresenter_get_ZoomFactor), nullptr, nullptr, nullptr },
        { "zoom_snap_points", reinterpret_cast<getter>(ScrollPresenter_get_ZoomSnapPoints), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_ScrollPresenter[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_ScrollPresenter) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_ScrollPresenter) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_ScrollPresenter) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_ScrollPresenter) },
        { }
    };

    static PyType_Spec type_spec_ScrollPresenter = {
        "winrt._winrt_microsoft_ui_xaml_controls_primitives.ScrollPresenter",
        sizeof(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>),
        0,
        Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,
        _type_slots_ScrollPresenter};

    static PyGetSetDef getset_ScrollPresenter_Static[] = {
        { "background_property", reinterpret_cast<getter>(ScrollPresenter_get_BackgroundProperty), nullptr, nullptr, nullptr },
        { "computed_horizontal_scroll_mode_property", reinterpret_cast<getter>(ScrollPresenter_get_ComputedHorizontalScrollModeProperty), nullptr, nullptr, nullptr },
        { "computed_vertical_scroll_mode_property", reinterpret_cast<getter>(ScrollPresenter_get_ComputedVerticalScrollModeProperty), nullptr, nullptr, nullptr },
        { "content_orientation_property", reinterpret_cast<getter>(ScrollPresenter_get_ContentOrientationProperty), nullptr, nullptr, nullptr },
        { "content_property", reinterpret_cast<getter>(ScrollPresenter_get_ContentProperty), nullptr, nullptr, nullptr },
        { "horizontal_anchor_ratio_property", reinterpret_cast<getter>(ScrollPresenter_get_HorizontalAnchorRatioProperty), nullptr, nullptr, nullptr },
        { "horizontal_scroll_chain_mode_property", reinterpret_cast<getter>(ScrollPresenter_get_HorizontalScrollChainModeProperty), nullptr, nullptr, nullptr },
        { "horizontal_scroll_mode_property", reinterpret_cast<getter>(ScrollPresenter_get_HorizontalScrollModeProperty), nullptr, nullptr, nullptr },
        { "horizontal_scroll_rail_mode_property", reinterpret_cast<getter>(ScrollPresenter_get_HorizontalScrollRailModeProperty), nullptr, nullptr, nullptr },
        { "ignored_input_kinds_property", reinterpret_cast<getter>(ScrollPresenter_get_IgnoredInputKindsProperty), nullptr, nullptr, nullptr },
        { "max_zoom_factor_property", reinterpret_cast<getter>(ScrollPresenter_get_MaxZoomFactorProperty), nullptr, nullptr, nullptr },
        { "min_zoom_factor_property", reinterpret_cast<getter>(ScrollPresenter_get_MinZoomFactorProperty), nullptr, nullptr, nullptr },
        { "vertical_anchor_ratio_property", reinterpret_cast<getter>(ScrollPresenter_get_VerticalAnchorRatioProperty), nullptr, nullptr, nullptr },
        { "vertical_scroll_chain_mode_property", reinterpret_cast<getter>(ScrollPresenter_get_VerticalScrollChainModeProperty), nullptr, nullptr, nullptr },
        { "vertical_scroll_mode_property", reinterpret_cast<getter>(ScrollPresenter_get_VerticalScrollModeProperty), nullptr, nullptr, nullptr },
        { "vertical_scroll_rail_mode_property", reinterpret_cast<getter>(ScrollPresenter_get_VerticalScrollRailModeProperty), nullptr, nullptr, nullptr },
        { "zoom_chain_mode_property", reinterpret_cast<getter>(ScrollPresenter_get_ZoomChainModeProperty), nullptr, nullptr, nullptr },
        { "zoom_mode_property", reinterpret_cast<getter>(ScrollPresenter_get_ZoomModeProperty), nullptr, nullptr, nullptr },
        { }
    };

    static PyMethodDef methods_ScrollPresenter_Static[] = {
        { }
    };

    static PyType_Slot type_slots_ScrollPresenter_Static[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_ScrollPresenter_Static) },
        { Py_tp_methods, reinterpret_cast<void*>(methods_ScrollPresenter_Static) },
        { }
    };

    static PyType_Spec type_spec_ScrollPresenter_Static =
    {
        "winrt._winrt_microsoft_ui_xaml_controls_primitives.ScrollPresenter_Static",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,
        type_slots_ScrollPresenter_Static
    };

    // ----- ScrollSnapPoint class --------------------

    struct PyWinrtScrollSnapPoint;
    using BasePyWinrtScrollSnapPoint = winrt::Microsoft::UI::Xaml::Controls::Primitives::ScrollSnapPointT<PyWinrtScrollSnapPoint, py::IPywinrtObject>;

    struct PyWinrtScrollSnapPoint : py::py_obj_ref, BasePyWinrtScrollSnapPoint
    {
        PyWinrtScrollSnapPoint(PyObject* py_obj, double snapPointValue, winrt::Microsoft::UI::Xaml::Controls::Primitives::ScrollSnapPointsAlignment alignment) : py::py_obj_ref(py_obj), BasePyWinrtScrollSnapPoint(snapPointValue, alignment) {}

        int32_t __stdcall GetPyObject(PyObject*& obj) override
        {
            obj = py::py_obj_ref::get_py_obj();
            return 0;
        }

        int32_t __stdcall GetComposableInner(winrt::Windows::Foundation::IInspectable& inner) override
        {
            inner = m_inner;
            return winrt::impl::error_ok;
        }

        static void toggle_reference(PyWinrtScrollSnapPoint* instance, bool is_last_reference)
        {
            py::py_obj_ref::toggle_reference(instance, is_last_reference);
        }

        int32_t query_interface_tearoff(winrt::guid const& id, void** result) const noexcept override
        {
            return py::py_obj_ref::query_interface_tearoff(id, result);
        }
    };

    static PyObject* _new_ScrollSnapPoint(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);

        auto self_type = get_python_type_for<winrt::Microsoft::UI::Xaml::Controls::Primitives::ScrollSnapPoint>();
        if (!self_type)
        {
            return nullptr;
        }

        if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<double>(args, 0);
                auto param1 = py::convert_to<winrt::Microsoft::UI::Xaml::Controls::Primitives::ScrollSnapPointsAlignment>(args, 1);

                if (type != self_type)
                {
                    py::pyobj_handle self{type->tp_alloc(type, 0)};
                    if (!self)
                    {
                        return nullptr;
                    }

                    std::construct_at(&reinterpret_cast<py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>*>(self.get())->obj, nullptr);

                    auto obj_impl = winrt::make_self<PyWinrtScrollSnapPoint>(self.get(), param0, param1);

                    auto obj = py::make_py_obj<PyWinrtScrollSnapPoint>(obj_impl, type, self.get());
                    if (!obj)
                    {
                        return nullptr;
                    }

                    reinterpret_cast<py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>*>(self.get())->obj = std::move(obj);

                    return self.detach();
                }

                winrt::Microsoft::UI::Xaml::Controls::Primitives::ScrollSnapPoint instance{param0, param1};
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_ScrollSnapPoint(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* ScrollSnapPoint_get_Value(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.ScrollSnapPoint", L"Value");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::Primitives::ScrollSnapPoint>().Value();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_ScrollSnapPoint(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Microsoft::UI::Xaml::Controls::Primitives::ScrollSnapPoint>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_ScrollSnapPoint(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Microsoft::UI::Xaml::Controls::Primitives::ScrollSnapPoint>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_ScrollSnapPoint[] = {
        { "_assign_array_", _assign_array_ScrollSnapPoint, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_ScrollSnapPoint), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_ScrollSnapPoint[] = {
        { "value", reinterpret_cast<getter>(ScrollSnapPoint_get_Value), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_ScrollSnapPoint[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_ScrollSnapPoint) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_ScrollSnapPoint) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_ScrollSnapPoint) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_ScrollSnapPoint) },
        { }
    };

    static PyType_Spec type_spec_ScrollSnapPoint = {
        "winrt._winrt_microsoft_ui_xaml_controls_primitives.ScrollSnapPoint",
        sizeof(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>),
        0,
        Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,
        _type_slots_ScrollSnapPoint};

    static PyGetSetDef getset_ScrollSnapPoint_Static[] = {
        { }
    };

    static PyMethodDef methods_ScrollSnapPoint_Static[] = {
        { }
    };

    static PyType_Slot type_slots_ScrollSnapPoint_Static[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_ScrollSnapPoint_Static) },
        { Py_tp_methods, reinterpret_cast<void*>(methods_ScrollSnapPoint_Static) },
        { }
    };

    static PyType_Spec type_spec_ScrollSnapPoint_Static =
    {
        "winrt._winrt_microsoft_ui_xaml_controls_primitives.ScrollSnapPoint_Static",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,
        type_slots_ScrollSnapPoint_Static
    };

    // ----- ScrollSnapPointBase class --------------------

    static PyObject* _new_ScrollSnapPointBase(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Microsoft::UI::Xaml::Controls::Primitives::ScrollSnapPointBase>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Microsoft::UI::Xaml::Controls::Primitives::ScrollSnapPointBase>::type_name);
        return nullptr;
    }

    static void _dealloc_ScrollSnapPointBase(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* ScrollSnapPointBase_get_Alignment(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.ScrollSnapPointBase", L"Alignment");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::Primitives::ScrollSnapPointBase>().Alignment();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_ScrollSnapPointBase(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Microsoft::UI::Xaml::Controls::Primitives::ScrollSnapPointBase>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_ScrollSnapPointBase(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Microsoft::UI::Xaml::Controls::Primitives::ScrollSnapPointBase>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_ScrollSnapPointBase[] = {
        { "_assign_array_", _assign_array_ScrollSnapPointBase, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_ScrollSnapPointBase), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_ScrollSnapPointBase[] = {
        { "alignment", reinterpret_cast<getter>(ScrollSnapPointBase_get_Alignment), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_ScrollSnapPointBase[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_ScrollSnapPointBase) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_ScrollSnapPointBase) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_ScrollSnapPointBase) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_ScrollSnapPointBase) },
        { }
    };

    static PyType_Spec type_spec_ScrollSnapPointBase = {
        "winrt._winrt_microsoft_ui_xaml_controls_primitives.ScrollSnapPointBase",
        sizeof(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>),
        0,
        Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,
        _type_slots_ScrollSnapPointBase};

    static PyGetSetDef getset_ScrollSnapPointBase_Static[] = {
        { }
    };

    static PyMethodDef methods_ScrollSnapPointBase_Static[] = {
        { }
    };

    static PyType_Slot type_slots_ScrollSnapPointBase_Static[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_ScrollSnapPointBase_Static) },
        { Py_tp_methods, reinterpret_cast<void*>(methods_ScrollSnapPointBase_Static) },
        { }
    };

    static PyType_Spec type_spec_ScrollSnapPointBase_Static =
    {
        "winrt._winrt_microsoft_ui_xaml_controls_primitives.ScrollSnapPointBase_Static",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,
        type_slots_ScrollSnapPointBase_Static
    };

    // ----- Selector class --------------------

    static PyObject* _new_Selector(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Microsoft::UI::Xaml::Controls::Primitives::Selector>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Microsoft::UI::Xaml::Controls::Primitives::Selector>::type_name);
        return nullptr;
    }

    static void _dealloc_Selector(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* Selector_GetIsSelectionActive(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Xaml.Controls.Primitives.Selector", L"GetIsSelectionActive", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Microsoft::UI::Xaml::DependencyObject>(args, 0);

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return winrt::Microsoft::UI::Xaml::Controls::Primitives::Selector::GetIsSelectionActive(param0);
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* Selector_get_SelectedValuePath(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.Selector", L"SelectedValuePath");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::Primitives::Selector>().SelectedValuePath();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int Selector_put_SelectedValuePath(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.Selector", L"SelectedValuePath");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::hstring>(arg);

            {
                auto _gil = release_gil();
                self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::Primitives::Selector>().SelectedValuePath(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* Selector_get_SelectedValue(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.Selector", L"SelectedValue");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::Primitives::Selector>().SelectedValue();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int Selector_put_SelectedValue(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.Selector", L"SelectedValue");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);

            {
                auto _gil = release_gil();
                self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::Primitives::Selector>().SelectedValue(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* Selector_get_SelectedItem(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.Selector", L"SelectedItem");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::Primitives::Selector>().SelectedItem();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int Selector_put_SelectedItem(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.Selector", L"SelectedItem");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);

            {
                auto _gil = release_gil();
                self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::Primitives::Selector>().SelectedItem(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* Selector_get_SelectedIndex(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.Selector", L"SelectedIndex");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::Primitives::Selector>().SelectedIndex();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int Selector_put_SelectedIndex(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.Selector", L"SelectedIndex");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<int32_t>(arg);

            {
                auto _gil = release_gil();
                self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::Primitives::Selector>().SelectedIndex(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* Selector_get_IsSynchronizedWithCurrentItem(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.Selector", L"IsSynchronizedWithCurrentItem");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::Primitives::Selector>().IsSynchronizedWithCurrentItem();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int Selector_put_IsSynchronizedWithCurrentItem(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.Selector", L"IsSynchronizedWithCurrentItem");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::IReference<bool>>(arg);

            {
                auto _gil = release_gil();
                self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::Primitives::Selector>().IsSynchronizedWithCurrentItem(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* Selector_get_IsSynchronizedWithCurrentItemProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.Selector", L"IsSynchronizedWithCurrentItemProperty");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return winrt::Microsoft::UI::Xaml::Controls::Primitives::Selector::IsSynchronizedWithCurrentItemProperty();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* Selector_get_SelectedIndexProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.Selector", L"SelectedIndexProperty");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return winrt::Microsoft::UI::Xaml::Controls::Primitives::Selector::SelectedIndexProperty();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* Selector_get_SelectedItemProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.Selector", L"SelectedItemProperty");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return winrt::Microsoft::UI::Xaml::Controls::Primitives::Selector::SelectedItemProperty();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* Selector_get_SelectedValuePathProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.Selector", L"SelectedValuePathProperty");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return winrt::Microsoft::UI::Xaml::Controls::Primitives::Selector::SelectedValuePathProperty();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* Selector_get_SelectedValueProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.Selector", L"SelectedValueProperty");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return winrt::Microsoft::UI::Xaml::Controls::Primitives::Selector::SelectedValueProperty();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* Selector_add_SelectionChanged(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, PyObject* arg) noexcept
    {
        try
        {
            static std::optional<bool> is_event_present{};

            if (!is_event_present.has_value())
            {
                is_event_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Microsoft.UI.Xaml.Controls.Primitives.Selector", L"SelectionChanged");
            }

            if (!is_event_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::Microsoft::UI::Xaml::Controls::SelectionChangedEventHandler>(arg);

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::Primitives::Selector>().SelectionChanged(param0);
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* Selector_remove_SelectionChanged(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, PyObject* arg) noexcept
    {
        try
        {
            static std::optional<bool> is_event_present{};

            if (!is_event_present.has_value())
            {
                is_event_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Microsoft.UI.Xaml.Controls.Primitives.Selector", L"SelectionChanged");
            }

            if (!is_event_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::event_token>(arg);

            {
                auto _gil = release_gil();
                self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::Primitives::Selector>().SelectionChanged(param0);
            }

            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_Selector(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Microsoft::UI::Xaml::Controls::Primitives::Selector>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_Selector(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Microsoft::UI::Xaml::Controls::Primitives::Selector>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_Selector[] = {
        { "add_selection_changed", reinterpret_cast<PyCFunction>(Selector_add_SelectionChanged), METH_O, nullptr },
        { "remove_selection_changed", reinterpret_cast<PyCFunction>(Selector_remove_SelectionChanged), METH_O, nullptr },
        { "_assign_array_", _assign_array_Selector, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_Selector), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_Selector[] = {
        { "selected_value_path", reinterpret_cast<getter>(Selector_get_SelectedValuePath), reinterpret_cast<setter>(Selector_put_SelectedValuePath), nullptr, nullptr },
        { "selected_value", reinterpret_cast<getter>(Selector_get_SelectedValue), reinterpret_cast<setter>(Selector_put_SelectedValue), nullptr, nullptr },
        { "selected_item", reinterpret_cast<getter>(Selector_get_SelectedItem), reinterpret_cast<setter>(Selector_put_SelectedItem), nullptr, nullptr },
        { "selected_index", reinterpret_cast<getter>(Selector_get_SelectedIndex), reinterpret_cast<setter>(Selector_put_SelectedIndex), nullptr, nullptr },
        { "is_synchronized_with_current_item", reinterpret_cast<getter>(Selector_get_IsSynchronizedWithCurrentItem), reinterpret_cast<setter>(Selector_put_IsSynchronizedWithCurrentItem), nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_Selector[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_Selector) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_Selector) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_Selector) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_Selector) },
        { }
    };

    static PyType_Spec type_spec_Selector = {
        "winrt._winrt_microsoft_ui_xaml_controls_primitives.Selector",
        sizeof(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>),
        0,
        Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,
        _type_slots_Selector};

    static PyGetSetDef getset_Selector_Static[] = {
        { "is_synchronized_with_current_item_property", reinterpret_cast<getter>(Selector_get_IsSynchronizedWithCurrentItemProperty), nullptr, nullptr, nullptr },
        { "selected_index_property", reinterpret_cast<getter>(Selector_get_SelectedIndexProperty), nullptr, nullptr, nullptr },
        { "selected_item_property", reinterpret_cast<getter>(Selector_get_SelectedItemProperty), nullptr, nullptr, nullptr },
        { "selected_value_path_property", reinterpret_cast<getter>(Selector_get_SelectedValuePathProperty), nullptr, nullptr, nullptr },
        { "selected_value_property", reinterpret_cast<getter>(Selector_get_SelectedValueProperty), nullptr, nullptr, nullptr },
        { }
    };

    static PyMethodDef methods_Selector_Static[] = {
        { "get_is_selection_active", reinterpret_cast<PyCFunction>(Selector_GetIsSelectionActive), METH_VARARGS, nullptr },
        { }
    };

    static PyType_Slot type_slots_Selector_Static[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_Selector_Static) },
        { Py_tp_methods, reinterpret_cast<void*>(methods_Selector_Static) },
        { }
    };

    static PyType_Spec type_spec_Selector_Static =
    {
        "winrt._winrt_microsoft_ui_xaml_controls_primitives.Selector_Static",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,
        type_slots_Selector_Static
    };

    // ----- SelectorItem class --------------------

    struct PyWinrtSelectorItem;
    using BasePyWinrtSelectorItem = winrt::Microsoft::UI::Xaml::Controls::Primitives::SelectorItemT<PyWinrtSelectorItem, py::IPywinrtObject>;

    struct PyWinrtSelectorItem : py::py_obj_ref, BasePyWinrtSelectorItem
    {

        int32_t __stdcall GetPyObject(PyObject*& obj) override
        {
            obj = py::py_obj_ref::get_py_obj();
            return 0;
        }

        int32_t __stdcall GetComposableInner(winrt::Windows::Foundation::IInspectable& inner) override
        {
            inner = m_inner;
            return winrt::impl::error_ok;
        }

        static void toggle_reference(PyWinrtSelectorItem* instance, bool is_last_reference)
        {
            py::py_obj_ref::toggle_reference(instance, is_last_reference);
        }

        int32_t query_interface_tearoff(winrt::guid const& id, void** result) const noexcept override
        {
            return py::py_obj_ref::query_interface_tearoff(id, result);
        }
    };

    static PyObject* _new_SelectorItem(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Microsoft::UI::Xaml::Controls::Primitives::SelectorItem>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Microsoft::UI::Xaml::Controls::Primitives::SelectorItem>::type_name);
        return nullptr;
    }

    static void _dealloc_SelectorItem(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* SelectorItem_get_IsSelected(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.SelectorItem", L"IsSelected");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::Primitives::SelectorItem>().IsSelected();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int SelectorItem_put_IsSelected(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.SelectorItem", L"IsSelected");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<bool>(arg);

            {
                auto _gil = release_gil();
                self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::Primitives::SelectorItem>().IsSelected(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* SelectorItem_get_IsSelectedProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.SelectorItem", L"IsSelectedProperty");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return winrt::Microsoft::UI::Xaml::Controls::Primitives::SelectorItem::IsSelectedProperty();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_SelectorItem(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Microsoft::UI::Xaml::Controls::Primitives::SelectorItem>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_SelectorItem(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Microsoft::UI::Xaml::Controls::Primitives::SelectorItem>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_SelectorItem[] = {
        { "_assign_array_", _assign_array_SelectorItem, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_SelectorItem), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_SelectorItem[] = {
        { "is_selected", reinterpret_cast<getter>(SelectorItem_get_IsSelected), reinterpret_cast<setter>(SelectorItem_put_IsSelected), nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_SelectorItem[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_SelectorItem) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_SelectorItem) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_SelectorItem) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_SelectorItem) },
        { }
    };

    static PyType_Spec type_spec_SelectorItem = {
        "winrt._winrt_microsoft_ui_xaml_controls_primitives.SelectorItem",
        sizeof(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>),
        0,
        Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,
        _type_slots_SelectorItem};

    static PyGetSetDef getset_SelectorItem_Static[] = {
        { "is_selected_property", reinterpret_cast<getter>(SelectorItem_get_IsSelectedProperty), nullptr, nullptr, nullptr },
        { }
    };

    static PyMethodDef methods_SelectorItem_Static[] = {
        { }
    };

    static PyType_Slot type_slots_SelectorItem_Static[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_SelectorItem_Static) },
        { Py_tp_methods, reinterpret_cast<void*>(methods_SelectorItem_Static) },
        { }
    };

    static PyType_Spec type_spec_SelectorItem_Static =
    {
        "winrt._winrt_microsoft_ui_xaml_controls_primitives.SelectorItem_Static",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,
        type_slots_SelectorItem_Static
    };

    // ----- SnapPointBase class --------------------

    static PyObject* _new_SnapPointBase(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Microsoft::UI::Xaml::Controls::Primitives::SnapPointBase>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Microsoft::UI::Xaml::Controls::Primitives::SnapPointBase>::type_name);
        return nullptr;
    }

    static void _dealloc_SnapPointBase(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* _assign_array_SnapPointBase(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Microsoft::UI::Xaml::Controls::Primitives::SnapPointBase>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_SnapPointBase(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Microsoft::UI::Xaml::Controls::Primitives::SnapPointBase>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_SnapPointBase[] = {
        { "_assign_array_", _assign_array_SnapPointBase, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_SnapPointBase), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_SnapPointBase[] = {
        { }
    };

    static PyType_Slot _type_slots_SnapPointBase[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_SnapPointBase) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_SnapPointBase) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_SnapPointBase) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_SnapPointBase) },
        { }
    };

    static PyType_Spec type_spec_SnapPointBase = {
        "winrt._winrt_microsoft_ui_xaml_controls_primitives.SnapPointBase",
        sizeof(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>),
        0,
        Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,
        _type_slots_SnapPointBase};

    static PyGetSetDef getset_SnapPointBase_Static[] = {
        { }
    };

    static PyMethodDef methods_SnapPointBase_Static[] = {
        { }
    };

    static PyType_Slot type_slots_SnapPointBase_Static[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_SnapPointBase_Static) },
        { Py_tp_methods, reinterpret_cast<void*>(methods_SnapPointBase_Static) },
        { }
    };

    static PyType_Spec type_spec_SnapPointBase_Static =
    {
        "winrt._winrt_microsoft_ui_xaml_controls_primitives.SnapPointBase_Static",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,
        type_slots_SnapPointBase_Static
    };

    // ----- SplitViewTemplateSettings class --------------------

    static PyObject* _new_SplitViewTemplateSettings(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Microsoft::UI::Xaml::Controls::Primitives::SplitViewTemplateSettings>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Microsoft::UI::Xaml::Controls::Primitives::SplitViewTemplateSettings>::type_name);
        return nullptr;
    }

    static void _dealloc_SplitViewTemplateSettings(py::wrapper::Microsoft::UI::Xaml::Controls::Primitives::SplitViewTemplateSettings* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* SplitViewTemplateSettings_get_CompactPaneGridLength(py::wrapper::Microsoft::UI::Xaml::Controls::Primitives::SplitViewTemplateSettings* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.SplitViewTemplateSettings", L"CompactPaneGridLength");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.CompactPaneGridLength();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SplitViewTemplateSettings_get_NegativeOpenPaneLength(py::wrapper::Microsoft::UI::Xaml::Controls::Primitives::SplitViewTemplateSettings* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.SplitViewTemplateSettings", L"NegativeOpenPaneLength");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.NegativeOpenPaneLength();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SplitViewTemplateSettings_get_NegativeOpenPaneLengthMinusCompactLength(py::wrapper::Microsoft::UI::Xaml::Controls::Primitives::SplitViewTemplateSettings* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.SplitViewTemplateSettings", L"NegativeOpenPaneLengthMinusCompactLength");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.NegativeOpenPaneLengthMinusCompactLength();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SplitViewTemplateSettings_get_OpenPaneGridLength(py::wrapper::Microsoft::UI::Xaml::Controls::Primitives::SplitViewTemplateSettings* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.SplitViewTemplateSettings", L"OpenPaneGridLength");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.OpenPaneGridLength();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SplitViewTemplateSettings_get_OpenPaneLength(py::wrapper::Microsoft::UI::Xaml::Controls::Primitives::SplitViewTemplateSettings* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.SplitViewTemplateSettings", L"OpenPaneLength");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.OpenPaneLength();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SplitViewTemplateSettings_get_OpenPaneLengthMinusCompactLength(py::wrapper::Microsoft::UI::Xaml::Controls::Primitives::SplitViewTemplateSettings* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.SplitViewTemplateSettings", L"OpenPaneLengthMinusCompactLength");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.OpenPaneLengthMinusCompactLength();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_SplitViewTemplateSettings(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Microsoft::UI::Xaml::Controls::Primitives::SplitViewTemplateSettings>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_SplitViewTemplateSettings(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Microsoft::UI::Xaml::Controls::Primitives::SplitViewTemplateSettings>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_SplitViewTemplateSettings[] = {
        { "_assign_array_", _assign_array_SplitViewTemplateSettings, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_SplitViewTemplateSettings), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_SplitViewTemplateSettings[] = {
        { "compact_pane_grid_length", reinterpret_cast<getter>(SplitViewTemplateSettings_get_CompactPaneGridLength), nullptr, nullptr, nullptr },
        { "negative_open_pane_length", reinterpret_cast<getter>(SplitViewTemplateSettings_get_NegativeOpenPaneLength), nullptr, nullptr, nullptr },
        { "negative_open_pane_length_minus_compact_length", reinterpret_cast<getter>(SplitViewTemplateSettings_get_NegativeOpenPaneLengthMinusCompactLength), nullptr, nullptr, nullptr },
        { "open_pane_grid_length", reinterpret_cast<getter>(SplitViewTemplateSettings_get_OpenPaneGridLength), nullptr, nullptr, nullptr },
        { "open_pane_length", reinterpret_cast<getter>(SplitViewTemplateSettings_get_OpenPaneLength), nullptr, nullptr, nullptr },
        { "open_pane_length_minus_compact_length", reinterpret_cast<getter>(SplitViewTemplateSettings_get_OpenPaneLengthMinusCompactLength), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_SplitViewTemplateSettings[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_SplitViewTemplateSettings) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_SplitViewTemplateSettings) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_SplitViewTemplateSettings) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_SplitViewTemplateSettings) },
        { }
    };

    static PyType_Spec type_spec_SplitViewTemplateSettings = {
        "winrt._winrt_microsoft_ui_xaml_controls_primitives.SplitViewTemplateSettings",
        sizeof(py::wrapper::Microsoft::UI::Xaml::Controls::Primitives::SplitViewTemplateSettings),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_SplitViewTemplateSettings};

    // ----- Thumb class --------------------

    static PyObject* _new_Thumb(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 0)
        {
            try
            {
                winrt::Microsoft::UI::Xaml::Controls::Primitives::Thumb instance{};
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_Thumb(py::wrapper::Microsoft::UI::Xaml::Controls::Primitives::Thumb* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* Thumb_CancelDrag(py::wrapper::Microsoft::UI::Xaml::Controls::Primitives::Thumb* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Xaml.Controls.Primitives.Thumb", L"CancelDrag", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                {
                    auto _gil = release_gil();
                    self->obj.CancelDrag();
                }

                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* Thumb_get_IsDragging(py::wrapper::Microsoft::UI::Xaml::Controls::Primitives::Thumb* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.Thumb", L"IsDragging");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.IsDragging();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* Thumb_get_IsDraggingProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.Thumb", L"IsDraggingProperty");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return winrt::Microsoft::UI::Xaml::Controls::Primitives::Thumb::IsDraggingProperty();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* Thumb_add_DragCompleted(py::wrapper::Microsoft::UI::Xaml::Controls::Primitives::Thumb* self, PyObject* arg) noexcept
    {
        try
        {
            static std::optional<bool> is_event_present{};

            if (!is_event_present.has_value())
            {
                is_event_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Microsoft.UI.Xaml.Controls.Primitives.Thumb", L"DragCompleted");
            }

            if (!is_event_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::Microsoft::UI::Xaml::Controls::Primitives::DragCompletedEventHandler>(arg);

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.DragCompleted(param0);
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* Thumb_remove_DragCompleted(py::wrapper::Microsoft::UI::Xaml::Controls::Primitives::Thumb* self, PyObject* arg) noexcept
    {
        try
        {
            static std::optional<bool> is_event_present{};

            if (!is_event_present.has_value())
            {
                is_event_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Microsoft.UI.Xaml.Controls.Primitives.Thumb", L"DragCompleted");
            }

            if (!is_event_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::event_token>(arg);

            {
                auto _gil = release_gil();
                self->obj.DragCompleted(param0);
            }

            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* Thumb_add_DragDelta(py::wrapper::Microsoft::UI::Xaml::Controls::Primitives::Thumb* self, PyObject* arg) noexcept
    {
        try
        {
            static std::optional<bool> is_event_present{};

            if (!is_event_present.has_value())
            {
                is_event_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Microsoft.UI.Xaml.Controls.Primitives.Thumb", L"DragDelta");
            }

            if (!is_event_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::Microsoft::UI::Xaml::Controls::Primitives::DragDeltaEventHandler>(arg);

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.DragDelta(param0);
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* Thumb_remove_DragDelta(py::wrapper::Microsoft::UI::Xaml::Controls::Primitives::Thumb* self, PyObject* arg) noexcept
    {
        try
        {
            static std::optional<bool> is_event_present{};

            if (!is_event_present.has_value())
            {
                is_event_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Microsoft.UI.Xaml.Controls.Primitives.Thumb", L"DragDelta");
            }

            if (!is_event_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::event_token>(arg);

            {
                auto _gil = release_gil();
                self->obj.DragDelta(param0);
            }

            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* Thumb_add_DragStarted(py::wrapper::Microsoft::UI::Xaml::Controls::Primitives::Thumb* self, PyObject* arg) noexcept
    {
        try
        {
            static std::optional<bool> is_event_present{};

            if (!is_event_present.has_value())
            {
                is_event_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Microsoft.UI.Xaml.Controls.Primitives.Thumb", L"DragStarted");
            }

            if (!is_event_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::Microsoft::UI::Xaml::Controls::Primitives::DragStartedEventHandler>(arg);

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.DragStarted(param0);
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* Thumb_remove_DragStarted(py::wrapper::Microsoft::UI::Xaml::Controls::Primitives::Thumb* self, PyObject* arg) noexcept
    {
        try
        {
            static std::optional<bool> is_event_present{};

            if (!is_event_present.has_value())
            {
                is_event_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Microsoft.UI.Xaml.Controls.Primitives.Thumb", L"DragStarted");
            }

            if (!is_event_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::event_token>(arg);

            {
                auto _gil = release_gil();
                self->obj.DragStarted(param0);
            }

            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_Thumb(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Microsoft::UI::Xaml::Controls::Primitives::Thumb>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_Thumb(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Microsoft::UI::Xaml::Controls::Primitives::Thumb>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_Thumb[] = {
        { "cancel_drag", reinterpret_cast<PyCFunction>(Thumb_CancelDrag), METH_VARARGS, nullptr },
        { "add_drag_completed", reinterpret_cast<PyCFunction>(Thumb_add_DragCompleted), METH_O, nullptr },
        { "remove_drag_completed", reinterpret_cast<PyCFunction>(Thumb_remove_DragCompleted), METH_O, nullptr },
        { "add_drag_delta", reinterpret_cast<PyCFunction>(Thumb_add_DragDelta), METH_O, nullptr },
        { "remove_drag_delta", reinterpret_cast<PyCFunction>(Thumb_remove_DragDelta), METH_O, nullptr },
        { "add_drag_started", reinterpret_cast<PyCFunction>(Thumb_add_DragStarted), METH_O, nullptr },
        { "remove_drag_started", reinterpret_cast<PyCFunction>(Thumb_remove_DragStarted), METH_O, nullptr },
        { "_assign_array_", _assign_array_Thumb, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_Thumb), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_Thumb[] = {
        { "is_dragging", reinterpret_cast<getter>(Thumb_get_IsDragging), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_Thumb[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_Thumb) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_Thumb) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_Thumb) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_Thumb) },
        { }
    };

    static PyType_Spec type_spec_Thumb = {
        "winrt._winrt_microsoft_ui_xaml_controls_primitives.Thumb",
        sizeof(py::wrapper::Microsoft::UI::Xaml::Controls::Primitives::Thumb),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_Thumb};

    static PyGetSetDef getset_Thumb_Static[] = {
        { "is_dragging_property", reinterpret_cast<getter>(Thumb_get_IsDraggingProperty), nullptr, nullptr, nullptr },
        { }
    };

    static PyMethodDef methods_Thumb_Static[] = {
        { }
    };

    static PyType_Slot type_slots_Thumb_Static[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_Thumb_Static) },
        { Py_tp_methods, reinterpret_cast<void*>(methods_Thumb_Static) },
        { }
    };

    static PyType_Spec type_spec_Thumb_Static =
    {
        "winrt._winrt_microsoft_ui_xaml_controls_primitives.Thumb_Static",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT,
        type_slots_Thumb_Static
    };

    // ----- TickBar class --------------------

    static PyObject* _new_TickBar(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 0)
        {
            try
            {
                winrt::Microsoft::UI::Xaml::Controls::Primitives::TickBar instance{};
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_TickBar(py::wrapper::Microsoft::UI::Xaml::Controls::Primitives::TickBar* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* TickBar_get_Fill(py::wrapper::Microsoft::UI::Xaml::Controls::Primitives::TickBar* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.TickBar", L"Fill");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Fill();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int TickBar_put_Fill(py::wrapper::Microsoft::UI::Xaml::Controls::Primitives::TickBar* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.TickBar", L"Fill");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Microsoft::UI::Xaml::Media::Brush>(arg);

            {
                auto _gil = release_gil();
                self->obj.Fill(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* TickBar_get_FillProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.TickBar", L"FillProperty");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return winrt::Microsoft::UI::Xaml::Controls::Primitives::TickBar::FillProperty();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_TickBar(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Microsoft::UI::Xaml::Controls::Primitives::TickBar>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_TickBar(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Microsoft::UI::Xaml::Controls::Primitives::TickBar>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_TickBar[] = {
        { "_assign_array_", _assign_array_TickBar, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_TickBar), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_TickBar[] = {
        { "fill", reinterpret_cast<getter>(TickBar_get_Fill), reinterpret_cast<setter>(TickBar_put_Fill), nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_TickBar[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_TickBar) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_TickBar) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_TickBar) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_TickBar) },
        { }
    };

    static PyType_Spec type_spec_TickBar = {
        "winrt._winrt_microsoft_ui_xaml_controls_primitives.TickBar",
        sizeof(py::wrapper::Microsoft::UI::Xaml::Controls::Primitives::TickBar),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_TickBar};

    static PyGetSetDef getset_TickBar_Static[] = {
        { "fill_property", reinterpret_cast<getter>(TickBar_get_FillProperty), nullptr, nullptr, nullptr },
        { }
    };

    static PyMethodDef methods_TickBar_Static[] = {
        { }
    };

    static PyType_Slot type_slots_TickBar_Static[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_TickBar_Static) },
        { Py_tp_methods, reinterpret_cast<void*>(methods_TickBar_Static) },
        { }
    };

    static PyType_Spec type_spec_TickBar_Static =
    {
        "winrt._winrt_microsoft_ui_xaml_controls_primitives.TickBar_Static",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT,
        type_slots_TickBar_Static
    };

    // ----- ToggleButton class --------------------

    struct PyWinrtToggleButton;
    using BasePyWinrtToggleButton = winrt::Microsoft::UI::Xaml::Controls::Primitives::ToggleButtonT<PyWinrtToggleButton, py::IPywinrtObject>;

    struct PyWinrtToggleButton : py::py_obj_ref, BasePyWinrtToggleButton
    {
        PyWinrtToggleButton(PyObject* py_obj) : py::py_obj_ref(py_obj), BasePyWinrtToggleButton() {}

        int32_t __stdcall GetPyObject(PyObject*& obj) override
        {
            obj = py::py_obj_ref::get_py_obj();
            return 0;
        }

        int32_t __stdcall GetComposableInner(winrt::Windows::Foundation::IInspectable& inner) override
        {
            inner = m_inner;
            return winrt::impl::error_ok;
        }

        static void toggle_reference(PyWinrtToggleButton* instance, bool is_last_reference)
        {
            py::py_obj_ref::toggle_reference(instance, is_last_reference);
        }

        int32_t query_interface_tearoff(winrt::guid const& id, void** result) const noexcept override
        {
            return py::py_obj_ref::query_interface_tearoff(id, result);
        }

        void OnToggle()
        {
            auto gil = py::ensure_gil();

            try
            {
                py::pyobj_handle self{get_py_obj()};

                py::pyobj_handle method{PyObject_GetAttrString(self.get(), "_on_toggle")};
                if (!method)
                {
                    throw python_exception();
                }

                py::pyobj_handle return_value{PyObject_CallNoArgs(method.get())};
                if (!return_value)
                {
                    throw python_exception();
                }
            }
            catch (python_exception)
            {
                py::write_unraisable_and_throw();
            }
        }
    };

    static PyObject* _new_ToggleButton(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);

        auto self_type = get_python_type_for<winrt::Microsoft::UI::Xaml::Controls::Primitives::ToggleButton>();
        if (!self_type)
        {
            return nullptr;
        }

        if (arg_count == 0)
        {
            try
            {
                if (type != self_type)
                {
                    py::pyobj_handle self{type->tp_alloc(type, 0)};
                    if (!self)
                    {
                        return nullptr;
                    }

                    std::construct_at(&reinterpret_cast<py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>*>(self.get())->obj, nullptr);

                    auto obj_impl = winrt::make_self<PyWinrtToggleButton>(self.get());

                    auto obj = py::make_py_obj<PyWinrtToggleButton>(obj_impl, type, self.get());
                    if (!obj)
                    {
                        return nullptr;
                    }

                    reinterpret_cast<py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>*>(self.get())->obj = std::move(obj);

                    return self.detach();
                }

                winrt::Microsoft::UI::Xaml::Controls::Primitives::ToggleButton instance{};
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_ToggleButton(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* ToggleButton_OnToggle(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Xaml.Controls.Primitives.ToggleButton", L"OnToggle", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                {
                    auto _gil = release_gil();
                    py::get_inner_or_self(self->obj).try_as<winrt::Microsoft::UI::Xaml::Controls::Primitives::IToggleButtonOverrides>().OnToggle();
                }

                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ToggleButton_get_IsThreeState(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.ToggleButton", L"IsThreeState");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::Primitives::ToggleButton>().IsThreeState();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ToggleButton_put_IsThreeState(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.ToggleButton", L"IsThreeState");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<bool>(arg);

            {
                auto _gil = release_gil();
                self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::Primitives::ToggleButton>().IsThreeState(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ToggleButton_get_IsChecked(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.ToggleButton", L"IsChecked");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::Primitives::ToggleButton>().IsChecked();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ToggleButton_put_IsChecked(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.ToggleButton", L"IsChecked");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::IReference<bool>>(arg);

            {
                auto _gil = release_gil();
                self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::Primitives::ToggleButton>().IsChecked(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ToggleButton_get_IsCheckedProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.ToggleButton", L"IsCheckedProperty");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return winrt::Microsoft::UI::Xaml::Controls::Primitives::ToggleButton::IsCheckedProperty();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ToggleButton_get_IsThreeStateProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.ToggleButton", L"IsThreeStateProperty");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return winrt::Microsoft::UI::Xaml::Controls::Primitives::ToggleButton::IsThreeStateProperty();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ToggleButton_add_Checked(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, PyObject* arg) noexcept
    {
        try
        {
            static std::optional<bool> is_event_present{};

            if (!is_event_present.has_value())
            {
                is_event_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Microsoft.UI.Xaml.Controls.Primitives.ToggleButton", L"Checked");
            }

            if (!is_event_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::Microsoft::UI::Xaml::RoutedEventHandler>(arg);

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::Primitives::ToggleButton>().Checked(param0);
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ToggleButton_remove_Checked(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, PyObject* arg) noexcept
    {
        try
        {
            static std::optional<bool> is_event_present{};

            if (!is_event_present.has_value())
            {
                is_event_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Microsoft.UI.Xaml.Controls.Primitives.ToggleButton", L"Checked");
            }

            if (!is_event_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::event_token>(arg);

            {
                auto _gil = release_gil();
                self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::Primitives::ToggleButton>().Checked(param0);
            }

            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ToggleButton_add_Indeterminate(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, PyObject* arg) noexcept
    {
        try
        {
            static std::optional<bool> is_event_present{};

            if (!is_event_present.has_value())
            {
                is_event_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Microsoft.UI.Xaml.Controls.Primitives.ToggleButton", L"Indeterminate");
            }

            if (!is_event_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::Microsoft::UI::Xaml::RoutedEventHandler>(arg);

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::Primitives::ToggleButton>().Indeterminate(param0);
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ToggleButton_remove_Indeterminate(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, PyObject* arg) noexcept
    {
        try
        {
            static std::optional<bool> is_event_present{};

            if (!is_event_present.has_value())
            {
                is_event_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Microsoft.UI.Xaml.Controls.Primitives.ToggleButton", L"Indeterminate");
            }

            if (!is_event_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::event_token>(arg);

            {
                auto _gil = release_gil();
                self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::Primitives::ToggleButton>().Indeterminate(param0);
            }

            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ToggleButton_add_Unchecked(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, PyObject* arg) noexcept
    {
        try
        {
            static std::optional<bool> is_event_present{};

            if (!is_event_present.has_value())
            {
                is_event_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Microsoft.UI.Xaml.Controls.Primitives.ToggleButton", L"Unchecked");
            }

            if (!is_event_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::Microsoft::UI::Xaml::RoutedEventHandler>(arg);

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::Primitives::ToggleButton>().Unchecked(param0);
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ToggleButton_remove_Unchecked(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, PyObject* arg) noexcept
    {
        try
        {
            static std::optional<bool> is_event_present{};

            if (!is_event_present.has_value())
            {
                is_event_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Microsoft.UI.Xaml.Controls.Primitives.ToggleButton", L"Unchecked");
            }

            if (!is_event_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::event_token>(arg);

            {
                auto _gil = release_gil();
                self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::Primitives::ToggleButton>().Unchecked(param0);
            }

            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_ToggleButton(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Microsoft::UI::Xaml::Controls::Primitives::ToggleButton>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_ToggleButton(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Microsoft::UI::Xaml::Controls::Primitives::ToggleButton>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_ToggleButton[] = {
        { "_on_toggle", reinterpret_cast<PyCFunction>(ToggleButton_OnToggle), METH_VARARGS, nullptr },
        { "add_checked", reinterpret_cast<PyCFunction>(ToggleButton_add_Checked), METH_O, nullptr },
        { "remove_checked", reinterpret_cast<PyCFunction>(ToggleButton_remove_Checked), METH_O, nullptr },
        { "add_indeterminate", reinterpret_cast<PyCFunction>(ToggleButton_add_Indeterminate), METH_O, nullptr },
        { "remove_indeterminate", reinterpret_cast<PyCFunction>(ToggleButton_remove_Indeterminate), METH_O, nullptr },
        { "add_unchecked", reinterpret_cast<PyCFunction>(ToggleButton_add_Unchecked), METH_O, nullptr },
        { "remove_unchecked", reinterpret_cast<PyCFunction>(ToggleButton_remove_Unchecked), METH_O, nullptr },
        { "_assign_array_", _assign_array_ToggleButton, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_ToggleButton), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_ToggleButton[] = {
        { "is_three_state", reinterpret_cast<getter>(ToggleButton_get_IsThreeState), reinterpret_cast<setter>(ToggleButton_put_IsThreeState), nullptr, nullptr },
        { "is_checked", reinterpret_cast<getter>(ToggleButton_get_IsChecked), reinterpret_cast<setter>(ToggleButton_put_IsChecked), nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_ToggleButton[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_ToggleButton) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_ToggleButton) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_ToggleButton) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_ToggleButton) },
        { }
    };

    static PyType_Spec type_spec_ToggleButton = {
        "winrt._winrt_microsoft_ui_xaml_controls_primitives.ToggleButton",
        sizeof(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>),
        0,
        Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,
        _type_slots_ToggleButton};

    static PyGetSetDef getset_ToggleButton_Static[] = {
        { "is_checked_property", reinterpret_cast<getter>(ToggleButton_get_IsCheckedProperty), nullptr, nullptr, nullptr },
        { "is_three_state_property", reinterpret_cast<getter>(ToggleButton_get_IsThreeStateProperty), nullptr, nullptr, nullptr },
        { }
    };

    static PyMethodDef methods_ToggleButton_Static[] = {
        { }
    };

    static PyType_Slot type_slots_ToggleButton_Static[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_ToggleButton_Static) },
        { Py_tp_methods, reinterpret_cast<void*>(methods_ToggleButton_Static) },
        { }
    };

    static PyType_Spec type_spec_ToggleButton_Static =
    {
        "winrt._winrt_microsoft_ui_xaml_controls_primitives.ToggleButton_Static",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,
        type_slots_ToggleButton_Static
    };

    // ----- ToggleSwitchTemplateSettings class --------------------

    static PyObject* _new_ToggleSwitchTemplateSettings(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Microsoft::UI::Xaml::Controls::Primitives::ToggleSwitchTemplateSettings>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Microsoft::UI::Xaml::Controls::Primitives::ToggleSwitchTemplateSettings>::type_name);
        return nullptr;
    }

    static void _dealloc_ToggleSwitchTemplateSettings(py::wrapper::Microsoft::UI::Xaml::Controls::Primitives::ToggleSwitchTemplateSettings* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* ToggleSwitchTemplateSettings_get_CurtainCurrentToOffOffset(py::wrapper::Microsoft::UI::Xaml::Controls::Primitives::ToggleSwitchTemplateSettings* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.ToggleSwitchTemplateSettings", L"CurtainCurrentToOffOffset");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.CurtainCurrentToOffOffset();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ToggleSwitchTemplateSettings_get_CurtainCurrentToOnOffset(py::wrapper::Microsoft::UI::Xaml::Controls::Primitives::ToggleSwitchTemplateSettings* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.ToggleSwitchTemplateSettings", L"CurtainCurrentToOnOffset");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.CurtainCurrentToOnOffset();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ToggleSwitchTemplateSettings_get_CurtainOffToOnOffset(py::wrapper::Microsoft::UI::Xaml::Controls::Primitives::ToggleSwitchTemplateSettings* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.ToggleSwitchTemplateSettings", L"CurtainOffToOnOffset");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.CurtainOffToOnOffset();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ToggleSwitchTemplateSettings_get_CurtainOnToOffOffset(py::wrapper::Microsoft::UI::Xaml::Controls::Primitives::ToggleSwitchTemplateSettings* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.ToggleSwitchTemplateSettings", L"CurtainOnToOffOffset");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.CurtainOnToOffOffset();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ToggleSwitchTemplateSettings_get_KnobCurrentToOffOffset(py::wrapper::Microsoft::UI::Xaml::Controls::Primitives::ToggleSwitchTemplateSettings* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.ToggleSwitchTemplateSettings", L"KnobCurrentToOffOffset");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.KnobCurrentToOffOffset();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ToggleSwitchTemplateSettings_get_KnobCurrentToOnOffset(py::wrapper::Microsoft::UI::Xaml::Controls::Primitives::ToggleSwitchTemplateSettings* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.ToggleSwitchTemplateSettings", L"KnobCurrentToOnOffset");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.KnobCurrentToOnOffset();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ToggleSwitchTemplateSettings_get_KnobOffToOnOffset(py::wrapper::Microsoft::UI::Xaml::Controls::Primitives::ToggleSwitchTemplateSettings* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.ToggleSwitchTemplateSettings", L"KnobOffToOnOffset");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.KnobOffToOnOffset();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ToggleSwitchTemplateSettings_get_KnobOnToOffOffset(py::wrapper::Microsoft::UI::Xaml::Controls::Primitives::ToggleSwitchTemplateSettings* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.ToggleSwitchTemplateSettings", L"KnobOnToOffOffset");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.KnobOnToOffOffset();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_ToggleSwitchTemplateSettings(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Microsoft::UI::Xaml::Controls::Primitives::ToggleSwitchTemplateSettings>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_ToggleSwitchTemplateSettings(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Microsoft::UI::Xaml::Controls::Primitives::ToggleSwitchTemplateSettings>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_ToggleSwitchTemplateSettings[] = {
        { "_assign_array_", _assign_array_ToggleSwitchTemplateSettings, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_ToggleSwitchTemplateSettings), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_ToggleSwitchTemplateSettings[] = {
        { "curtain_current_to_off_offset", reinterpret_cast<getter>(ToggleSwitchTemplateSettings_get_CurtainCurrentToOffOffset), nullptr, nullptr, nullptr },
        { "curtain_current_to_on_offset", reinterpret_cast<getter>(ToggleSwitchTemplateSettings_get_CurtainCurrentToOnOffset), nullptr, nullptr, nullptr },
        { "curtain_off_to_on_offset", reinterpret_cast<getter>(ToggleSwitchTemplateSettings_get_CurtainOffToOnOffset), nullptr, nullptr, nullptr },
        { "curtain_on_to_off_offset", reinterpret_cast<getter>(ToggleSwitchTemplateSettings_get_CurtainOnToOffOffset), nullptr, nullptr, nullptr },
        { "knob_current_to_off_offset", reinterpret_cast<getter>(ToggleSwitchTemplateSettings_get_KnobCurrentToOffOffset), nullptr, nullptr, nullptr },
        { "knob_current_to_on_offset", reinterpret_cast<getter>(ToggleSwitchTemplateSettings_get_KnobCurrentToOnOffset), nullptr, nullptr, nullptr },
        { "knob_off_to_on_offset", reinterpret_cast<getter>(ToggleSwitchTemplateSettings_get_KnobOffToOnOffset), nullptr, nullptr, nullptr },
        { "knob_on_to_off_offset", reinterpret_cast<getter>(ToggleSwitchTemplateSettings_get_KnobOnToOffOffset), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_ToggleSwitchTemplateSettings[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_ToggleSwitchTemplateSettings) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_ToggleSwitchTemplateSettings) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_ToggleSwitchTemplateSettings) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_ToggleSwitchTemplateSettings) },
        { }
    };

    static PyType_Spec type_spec_ToggleSwitchTemplateSettings = {
        "winrt._winrt_microsoft_ui_xaml_controls_primitives.ToggleSwitchTemplateSettings",
        sizeof(py::wrapper::Microsoft::UI::Xaml::Controls::Primitives::ToggleSwitchTemplateSettings),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_ToggleSwitchTemplateSettings};

    // ----- ToolTipTemplateSettings class --------------------

    static PyObject* _new_ToolTipTemplateSettings(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Microsoft::UI::Xaml::Controls::Primitives::ToolTipTemplateSettings>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Microsoft::UI::Xaml::Controls::Primitives::ToolTipTemplateSettings>::type_name);
        return nullptr;
    }

    static void _dealloc_ToolTipTemplateSettings(py::wrapper::Microsoft::UI::Xaml::Controls::Primitives::ToolTipTemplateSettings* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* ToolTipTemplateSettings_get_FromHorizontalOffset(py::wrapper::Microsoft::UI::Xaml::Controls::Primitives::ToolTipTemplateSettings* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.ToolTipTemplateSettings", L"FromHorizontalOffset");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.FromHorizontalOffset();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ToolTipTemplateSettings_get_FromVerticalOffset(py::wrapper::Microsoft::UI::Xaml::Controls::Primitives::ToolTipTemplateSettings* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.ToolTipTemplateSettings", L"FromVerticalOffset");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.FromVerticalOffset();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_ToolTipTemplateSettings(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Microsoft::UI::Xaml::Controls::Primitives::ToolTipTemplateSettings>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_ToolTipTemplateSettings(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Microsoft::UI::Xaml::Controls::Primitives::ToolTipTemplateSettings>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_ToolTipTemplateSettings[] = {
        { "_assign_array_", _assign_array_ToolTipTemplateSettings, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_ToolTipTemplateSettings), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_ToolTipTemplateSettings[] = {
        { "from_horizontal_offset", reinterpret_cast<getter>(ToolTipTemplateSettings_get_FromHorizontalOffset), nullptr, nullptr, nullptr },
        { "from_vertical_offset", reinterpret_cast<getter>(ToolTipTemplateSettings_get_FromVerticalOffset), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_ToolTipTemplateSettings[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_ToolTipTemplateSettings) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_ToolTipTemplateSettings) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_ToolTipTemplateSettings) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_ToolTipTemplateSettings) },
        { }
    };

    static PyType_Spec type_spec_ToolTipTemplateSettings = {
        "winrt._winrt_microsoft_ui_xaml_controls_primitives.ToolTipTemplateSettings",
        sizeof(py::wrapper::Microsoft::UI::Xaml::Controls::Primitives::ToolTipTemplateSettings),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_ToolTipTemplateSettings};

    // ----- ZoomSnapPoint class --------------------

    struct PyWinrtZoomSnapPoint;
    using BasePyWinrtZoomSnapPoint = winrt::Microsoft::UI::Xaml::Controls::Primitives::ZoomSnapPointT<PyWinrtZoomSnapPoint, py::IPywinrtObject>;

    struct PyWinrtZoomSnapPoint : py::py_obj_ref, BasePyWinrtZoomSnapPoint
    {
        PyWinrtZoomSnapPoint(PyObject* py_obj, double snapPointValue) : py::py_obj_ref(py_obj), BasePyWinrtZoomSnapPoint(snapPointValue) {}

        int32_t __stdcall GetPyObject(PyObject*& obj) override
        {
            obj = py::py_obj_ref::get_py_obj();
            return 0;
        }

        int32_t __stdcall GetComposableInner(winrt::Windows::Foundation::IInspectable& inner) override
        {
            inner = m_inner;
            return winrt::impl::error_ok;
        }

        static void toggle_reference(PyWinrtZoomSnapPoint* instance, bool is_last_reference)
        {
            py::py_obj_ref::toggle_reference(instance, is_last_reference);
        }

        int32_t query_interface_tearoff(winrt::guid const& id, void** result) const noexcept override
        {
            return py::py_obj_ref::query_interface_tearoff(id, result);
        }
    };

    static PyObject* _new_ZoomSnapPoint(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);

        auto self_type = get_python_type_for<winrt::Microsoft::UI::Xaml::Controls::Primitives::ZoomSnapPoint>();
        if (!self_type)
        {
            return nullptr;
        }

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<double>(args, 0);

                if (type != self_type)
                {
                    py::pyobj_handle self{type->tp_alloc(type, 0)};
                    if (!self)
                    {
                        return nullptr;
                    }

                    std::construct_at(&reinterpret_cast<py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>*>(self.get())->obj, nullptr);

                    auto obj_impl = winrt::make_self<PyWinrtZoomSnapPoint>(self.get(), param0);

                    auto obj = py::make_py_obj<PyWinrtZoomSnapPoint>(obj_impl, type, self.get());
                    if (!obj)
                    {
                        return nullptr;
                    }

                    reinterpret_cast<py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>*>(self.get())->obj = std::move(obj);

                    return self.detach();
                }

                winrt::Microsoft::UI::Xaml::Controls::Primitives::ZoomSnapPoint instance{param0};
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_ZoomSnapPoint(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* ZoomSnapPoint_get_Value(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.ZoomSnapPoint", L"Value");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.try_as<winrt::Microsoft::UI::Xaml::Controls::Primitives::ZoomSnapPoint>().Value();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_ZoomSnapPoint(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Microsoft::UI::Xaml::Controls::Primitives::ZoomSnapPoint>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_ZoomSnapPoint(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Microsoft::UI::Xaml::Controls::Primitives::ZoomSnapPoint>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_ZoomSnapPoint[] = {
        { "_assign_array_", _assign_array_ZoomSnapPoint, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_ZoomSnapPoint), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_ZoomSnapPoint[] = {
        { "value", reinterpret_cast<getter>(ZoomSnapPoint_get_Value), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_ZoomSnapPoint[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_ZoomSnapPoint) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_ZoomSnapPoint) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_ZoomSnapPoint) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_ZoomSnapPoint) },
        { }
    };

    static PyType_Spec type_spec_ZoomSnapPoint = {
        "winrt._winrt_microsoft_ui_xaml_controls_primitives.ZoomSnapPoint",
        sizeof(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>),
        0,
        Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,
        _type_slots_ZoomSnapPoint};

    static PyGetSetDef getset_ZoomSnapPoint_Static[] = {
        { }
    };

    static PyMethodDef methods_ZoomSnapPoint_Static[] = {
        { }
    };

    static PyType_Slot type_slots_ZoomSnapPoint_Static[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_ZoomSnapPoint_Static) },
        { Py_tp_methods, reinterpret_cast<void*>(methods_ZoomSnapPoint_Static) },
        { }
    };

    static PyType_Spec type_spec_ZoomSnapPoint_Static =
    {
        "winrt._winrt_microsoft_ui_xaml_controls_primitives.ZoomSnapPoint_Static",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,
        type_slots_ZoomSnapPoint_Static
    };

    // ----- ZoomSnapPointBase class --------------------

    static PyObject* _new_ZoomSnapPointBase(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Microsoft::UI::Xaml::Controls::Primitives::ZoomSnapPointBase>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Microsoft::UI::Xaml::Controls::Primitives::ZoomSnapPointBase>::type_name);
        return nullptr;
    }

    static void _dealloc_ZoomSnapPointBase(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* _assign_array_ZoomSnapPointBase(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Microsoft::UI::Xaml::Controls::Primitives::ZoomSnapPointBase>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_ZoomSnapPointBase(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Microsoft::UI::Xaml::Controls::Primitives::ZoomSnapPointBase>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_ZoomSnapPointBase[] = {
        { "_assign_array_", _assign_array_ZoomSnapPointBase, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_ZoomSnapPointBase), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_ZoomSnapPointBase[] = {
        { }
    };

    static PyType_Slot _type_slots_ZoomSnapPointBase[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_ZoomSnapPointBase) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_ZoomSnapPointBase) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_ZoomSnapPointBase) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_ZoomSnapPointBase) },
        { }
    };

    static PyType_Spec type_spec_ZoomSnapPointBase = {
        "winrt._winrt_microsoft_ui_xaml_controls_primitives.ZoomSnapPointBase",
        sizeof(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>),
        0,
        Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,
        _type_slots_ZoomSnapPointBase};

    static PyGetSetDef getset_ZoomSnapPointBase_Static[] = {
        { }
    };

    static PyMethodDef methods_ZoomSnapPointBase_Static[] = {
        { }
    };

    static PyType_Slot type_slots_ZoomSnapPointBase_Static[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_ZoomSnapPointBase_Static) },
        { Py_tp_methods, reinterpret_cast<void*>(methods_ZoomSnapPointBase_Static) },
        { }
    };

    static PyType_Spec type_spec_ZoomSnapPointBase_Static =
    {
        "winrt._winrt_microsoft_ui_xaml_controls_primitives.ZoomSnapPointBase_Static",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,
        type_slots_ZoomSnapPointBase_Static
    };

    // ----- IScrollController interface --------------------

    static PyObject* _new_IScrollController(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Microsoft::UI::Xaml::Controls::Primitives::IScrollController>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Microsoft::UI::Xaml::Controls::Primitives::IScrollController>::type_name);
        return nullptr;
    }

    static void _dealloc_IScrollController(py::wrapper::Microsoft::UI::Xaml::Controls::Primitives::IScrollController* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* IScrollController_GetScrollAnimation(py::wrapper::Microsoft::UI::Xaml::Controls::Primitives::IScrollController* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 4)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Xaml.Controls.Primitives.IScrollController", L"GetScrollAnimation", 4);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(4);
                    return nullptr;
                }

                auto param0 = py::convert_to<int32_t>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Foundation::Numerics::float2>(args, 1);
                auto param2 = py::convert_to<winrt::Windows::Foundation::Numerics::float2>(args, 2);
                auto param3 = py::convert_to<winrt::Microsoft::UI::Composition::CompositionAnimation>(args, 3);

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return self->obj.GetScrollAnimation(param0, param1, param2, param3);
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* IScrollController_NotifyRequestedScrollCompleted(py::wrapper::Microsoft::UI::Xaml::Controls::Primitives::IScrollController* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Xaml.Controls.Primitives.IScrollController", L"NotifyRequestedScrollCompleted", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<int32_t>(args, 0);

                {
                    auto _gil = release_gil();
                    self->obj.NotifyRequestedScrollCompleted(param0);
                }

                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* IScrollController_SetIsScrollable(py::wrapper::Microsoft::UI::Xaml::Controls::Primitives::IScrollController* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Xaml.Controls.Primitives.IScrollController", L"SetIsScrollable", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<bool>(args, 0);

                {
                    auto _gil = release_gil();
                    self->obj.SetIsScrollable(param0);
                }

                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* IScrollController_SetValues(py::wrapper::Microsoft::UI::Xaml::Controls::Primitives::IScrollController* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 4)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Xaml.Controls.Primitives.IScrollController", L"SetValues", 4);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(4);
                    return nullptr;
                }

                auto param0 = py::convert_to<double>(args, 0);
                auto param1 = py::convert_to<double>(args, 1);
                auto param2 = py::convert_to<double>(args, 2);
                auto param3 = py::convert_to<double>(args, 3);

                {
                    auto _gil = release_gil();
                    self->obj.SetValues(param0, param1, param2, param3);
                }

                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* IScrollController_get_CanScroll(py::wrapper::Microsoft::UI::Xaml::Controls::Primitives::IScrollController* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.IScrollController", L"CanScroll");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.CanScroll();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IScrollController_get_IsScrollingWithMouse(py::wrapper::Microsoft::UI::Xaml::Controls::Primitives::IScrollController* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.IScrollController", L"IsScrollingWithMouse");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.IsScrollingWithMouse();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IScrollController_get_PanningInfo(py::wrapper::Microsoft::UI::Xaml::Controls::Primitives::IScrollController* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.IScrollController", L"PanningInfo");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.PanningInfo();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IScrollController_add_AddScrollVelocityRequested(py::wrapper::Microsoft::UI::Xaml::Controls::Primitives::IScrollController* self, PyObject* arg) noexcept
    {
        try
        {
            static std::optional<bool> is_event_present{};

            if (!is_event_present.has_value())
            {
                is_event_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Microsoft.UI.Xaml.Controls.Primitives.IScrollController", L"AddScrollVelocityRequested");
            }

            if (!is_event_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Microsoft::UI::Xaml::Controls::Primitives::IScrollController, winrt::Microsoft::UI::Xaml::Controls::Primitives::ScrollControllerAddScrollVelocityRequestedEventArgs>>(arg);

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.AddScrollVelocityRequested(param0);
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IScrollController_remove_AddScrollVelocityRequested(py::wrapper::Microsoft::UI::Xaml::Controls::Primitives::IScrollController* self, PyObject* arg) noexcept
    {
        try
        {
            static std::optional<bool> is_event_present{};

            if (!is_event_present.has_value())
            {
                is_event_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Microsoft.UI.Xaml.Controls.Primitives.IScrollController", L"AddScrollVelocityRequested");
            }

            if (!is_event_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::event_token>(arg);

            {
                auto _gil = release_gil();
                self->obj.AddScrollVelocityRequested(param0);
            }

            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IScrollController_add_CanScrollChanged(py::wrapper::Microsoft::UI::Xaml::Controls::Primitives::IScrollController* self, PyObject* arg) noexcept
    {
        try
        {
            static std::optional<bool> is_event_present{};

            if (!is_event_present.has_value())
            {
                is_event_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Microsoft.UI.Xaml.Controls.Primitives.IScrollController", L"CanScrollChanged");
            }

            if (!is_event_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Microsoft::UI::Xaml::Controls::Primitives::IScrollController, winrt::Windows::Foundation::IInspectable>>(arg);

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.CanScrollChanged(param0);
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IScrollController_remove_CanScrollChanged(py::wrapper::Microsoft::UI::Xaml::Controls::Primitives::IScrollController* self, PyObject* arg) noexcept
    {
        try
        {
            static std::optional<bool> is_event_present{};

            if (!is_event_present.has_value())
            {
                is_event_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Microsoft.UI.Xaml.Controls.Primitives.IScrollController", L"CanScrollChanged");
            }

            if (!is_event_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::event_token>(arg);

            {
                auto _gil = release_gil();
                self->obj.CanScrollChanged(param0);
            }

            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IScrollController_add_IsScrollingWithMouseChanged(py::wrapper::Microsoft::UI::Xaml::Controls::Primitives::IScrollController* self, PyObject* arg) noexcept
    {
        try
        {
            static std::optional<bool> is_event_present{};

            if (!is_event_present.has_value())
            {
                is_event_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Microsoft.UI.Xaml.Controls.Primitives.IScrollController", L"IsScrollingWithMouseChanged");
            }

            if (!is_event_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Microsoft::UI::Xaml::Controls::Primitives::IScrollController, winrt::Windows::Foundation::IInspectable>>(arg);

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.IsScrollingWithMouseChanged(param0);
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IScrollController_remove_IsScrollingWithMouseChanged(py::wrapper::Microsoft::UI::Xaml::Controls::Primitives::IScrollController* self, PyObject* arg) noexcept
    {
        try
        {
            static std::optional<bool> is_event_present{};

            if (!is_event_present.has_value())
            {
                is_event_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Microsoft.UI.Xaml.Controls.Primitives.IScrollController", L"IsScrollingWithMouseChanged");
            }

            if (!is_event_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::event_token>(arg);

            {
                auto _gil = release_gil();
                self->obj.IsScrollingWithMouseChanged(param0);
            }

            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IScrollController_add_ScrollByRequested(py::wrapper::Microsoft::UI::Xaml::Controls::Primitives::IScrollController* self, PyObject* arg) noexcept
    {
        try
        {
            static std::optional<bool> is_event_present{};

            if (!is_event_present.has_value())
            {
                is_event_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Microsoft.UI.Xaml.Controls.Primitives.IScrollController", L"ScrollByRequested");
            }

            if (!is_event_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Microsoft::UI::Xaml::Controls::Primitives::IScrollController, winrt::Microsoft::UI::Xaml::Controls::Primitives::ScrollControllerScrollByRequestedEventArgs>>(arg);

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.ScrollByRequested(param0);
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IScrollController_remove_ScrollByRequested(py::wrapper::Microsoft::UI::Xaml::Controls::Primitives::IScrollController* self, PyObject* arg) noexcept
    {
        try
        {
            static std::optional<bool> is_event_present{};

            if (!is_event_present.has_value())
            {
                is_event_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Microsoft.UI.Xaml.Controls.Primitives.IScrollController", L"ScrollByRequested");
            }

            if (!is_event_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::event_token>(arg);

            {
                auto _gil = release_gil();
                self->obj.ScrollByRequested(param0);
            }

            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IScrollController_add_ScrollToRequested(py::wrapper::Microsoft::UI::Xaml::Controls::Primitives::IScrollController* self, PyObject* arg) noexcept
    {
        try
        {
            static std::optional<bool> is_event_present{};

            if (!is_event_present.has_value())
            {
                is_event_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Microsoft.UI.Xaml.Controls.Primitives.IScrollController", L"ScrollToRequested");
            }

            if (!is_event_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Microsoft::UI::Xaml::Controls::Primitives::IScrollController, winrt::Microsoft::UI::Xaml::Controls::Primitives::ScrollControllerScrollToRequestedEventArgs>>(arg);

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.ScrollToRequested(param0);
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IScrollController_remove_ScrollToRequested(py::wrapper::Microsoft::UI::Xaml::Controls::Primitives::IScrollController* self, PyObject* arg) noexcept
    {
        try
        {
            static std::optional<bool> is_event_present{};

            if (!is_event_present.has_value())
            {
                is_event_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Microsoft.UI.Xaml.Controls.Primitives.IScrollController", L"ScrollToRequested");
            }

            if (!is_event_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::event_token>(arg);

            {
                auto _gil = release_gil();
                self->obj.ScrollToRequested(param0);
            }

            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_IScrollController(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Microsoft::UI::Xaml::Controls::Primitives::IScrollController>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_IScrollController(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Microsoft::UI::Xaml::Controls::Primitives::IScrollController>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_IScrollController[] = {
        { "get_scroll_animation", reinterpret_cast<PyCFunction>(IScrollController_GetScrollAnimation), METH_VARARGS, nullptr },
        { "notify_requested_scroll_completed", reinterpret_cast<PyCFunction>(IScrollController_NotifyRequestedScrollCompleted), METH_VARARGS, nullptr },
        { "set_is_scrollable", reinterpret_cast<PyCFunction>(IScrollController_SetIsScrollable), METH_VARARGS, nullptr },
        { "set_values", reinterpret_cast<PyCFunction>(IScrollController_SetValues), METH_VARARGS, nullptr },
        { "add_add_scroll_velocity_requested", reinterpret_cast<PyCFunction>(IScrollController_add_AddScrollVelocityRequested), METH_O, nullptr },
        { "remove_add_scroll_velocity_requested", reinterpret_cast<PyCFunction>(IScrollController_remove_AddScrollVelocityRequested), METH_O, nullptr },
        { "add_can_scroll_changed", reinterpret_cast<PyCFunction>(IScrollController_add_CanScrollChanged), METH_O, nullptr },
        { "remove_can_scroll_changed", reinterpret_cast<PyCFunction>(IScrollController_remove_CanScrollChanged), METH_O, nullptr },
        { "add_is_scrolling_with_mouse_changed", reinterpret_cast<PyCFunction>(IScrollController_add_IsScrollingWithMouseChanged), METH_O, nullptr },
        { "remove_is_scrolling_with_mouse_changed", reinterpret_cast<PyCFunction>(IScrollController_remove_IsScrollingWithMouseChanged), METH_O, nullptr },
        { "add_scroll_by_requested", reinterpret_cast<PyCFunction>(IScrollController_add_ScrollByRequested), METH_O, nullptr },
        { "remove_scroll_by_requested", reinterpret_cast<PyCFunction>(IScrollController_remove_ScrollByRequested), METH_O, nullptr },
        { "add_scroll_to_requested", reinterpret_cast<PyCFunction>(IScrollController_add_ScrollToRequested), METH_O, nullptr },
        { "remove_scroll_to_requested", reinterpret_cast<PyCFunction>(IScrollController_remove_ScrollToRequested), METH_O, nullptr },
        { "_assign_array_", _assign_array_IScrollController, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_IScrollController), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_IScrollController[] = {
        { "can_scroll", reinterpret_cast<getter>(IScrollController_get_CanScroll), nullptr, nullptr, nullptr },
        { "is_scrolling_with_mouse", reinterpret_cast<getter>(IScrollController_get_IsScrollingWithMouse), nullptr, nullptr, nullptr },
        { "panning_info", reinterpret_cast<getter>(IScrollController_get_PanningInfo), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_IScrollController[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_IScrollController) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_IScrollController) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_IScrollController) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_IScrollController) },
        { }
    };

    static PyType_Spec type_spec_IScrollController = {
        "winrt._winrt_microsoft_ui_xaml_controls_primitives.IScrollController",
        sizeof(py::wrapper::Microsoft::UI::Xaml::Controls::Primitives::IScrollController),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_IScrollController};

    struct ImplementsIScrollController : py::ImplementsInterfaceT<ImplementsIScrollController, winrt::Microsoft::UI::Xaml::Controls::Primitives::IScrollController>
    {
        ImplementsIScrollController() = delete;
        ImplementsIScrollController(PyObject* py_obj, winrt::impl::inspectable_abi* runtime_class) : py::ImplementsInterfaceT<ImplementsIScrollController, winrt::Microsoft::UI::Xaml::Controls::Primitives::IScrollController>(py_obj, runtime_class)
        {
        }

        auto GetScrollAnimation(int32_t param0, winrt::Windows::Foundation::Numerics::float2 param1, winrt::Windows::Foundation::Numerics::float2 param2, winrt::Microsoft::UI::Composition::CompositionAnimation const& param3)
        {
            try
            {
                py::pyobj_handle self{this->get_py_obj()};

                py::pyobj_handle method{PyObject_GetAttrString(self.get(), "get_scroll_animation")};
                if (!method)
                {
                    throw python_exception();
                }

                py::pyobj_handle py_param0{py::convert(param0)};
                if (!py_param0)
                {
                    throw python_exception();
                }

                py::pyobj_handle py_param1{py::convert(param1)};
                if (!py_param1)
                {
                    throw python_exception();
                }

                py::pyobj_handle py_param2{py::convert(param2)};
                if (!py_param2)
                {
                    throw python_exception();
                }

                py::pyobj_handle py_param3{py::convert(param3)};
                if (!py_param3)
                {
                    throw python_exception();
                }

                py::pyobj_handle args{PyTuple_Pack(4, py_param0.get(), py_param1.get(), py_param2.get(), py_param3.get())};
                if (!args)
                {
                    throw python_exception();
                }

                py::pyobj_handle return_value{PyObject_CallObject(method.get(), args.get())};
                if (!return_value)
                {
                    throw python_exception();
                }

                return py::convert_to<winrt::Microsoft::UI::Composition::CompositionAnimation>(return_value.get());
            }
            catch (python_exception)
            {
                py::write_unraisable_and_throw();
            }
        }

        auto NotifyRequestedScrollCompleted(int32_t param0)
        {
            try
            {
                py::pyobj_handle self{this->get_py_obj()};

                py::pyobj_handle method{PyObject_GetAttrString(self.get(), "notify_requested_scroll_completed")};
                if (!method)
                {
                    throw python_exception();
                }

                py::pyobj_handle py_param0{py::convert(param0)};
                if (!py_param0)
                {
                    throw python_exception();
                }

                py::pyobj_handle return_value{PyObject_CallOneArg(method.get(), py_param0.get())};
                if (!return_value)
                {
                    throw python_exception();
                }
            }
            catch (python_exception)
            {
                py::write_unraisable_and_throw();
            }
        }

        auto SetIsScrollable(bool param0)
        {
            try
            {
                py::pyobj_handle self{this->get_py_obj()};

                py::pyobj_handle method{PyObject_GetAttrString(self.get(), "set_is_scrollable")};
                if (!method)
                {
                    throw python_exception();
                }

                py::pyobj_handle py_param0{py::convert(param0)};
                if (!py_param0)
                {
                    throw python_exception();
                }

                py::pyobj_handle return_value{PyObject_CallOneArg(method.get(), py_param0.get())};
                if (!return_value)
                {
                    throw python_exception();
                }
            }
            catch (python_exception)
            {
                py::write_unraisable_and_throw();
            }
        }

        auto SetValues(double param0, double param1, double param2, double param3)
        {
            try
            {
                py::pyobj_handle self{this->get_py_obj()};

                py::pyobj_handle method{PyObject_GetAttrString(self.get(), "set_values")};
                if (!method)
                {
                    throw python_exception();
                }

                py::pyobj_handle py_param0{py::convert(param0)};
                if (!py_param0)
                {
                    throw python_exception();
                }

                py::pyobj_handle py_param1{py::convert(param1)};
                if (!py_param1)
                {
                    throw python_exception();
                }

                py::pyobj_handle py_param2{py::convert(param2)};
                if (!py_param2)
                {
                    throw python_exception();
                }

                py::pyobj_handle py_param3{py::convert(param3)};
                if (!py_param3)
                {
                    throw python_exception();
                }

                py::pyobj_handle args{PyTuple_Pack(4, py_param0.get(), py_param1.get(), py_param2.get(), py_param3.get())};
                if (!args)
                {
                    throw python_exception();
                }

                py::pyobj_handle return_value{PyObject_CallObject(method.get(), args.get())};
                if (!return_value)
                {
                    throw python_exception();
                }
            }
            catch (python_exception)
            {
                py::write_unraisable_and_throw();
            }
        }

        auto CanScroll()
        {
            try
            {
                py::pyobj_handle self{this->get_py_obj()};

                py::pyobj_handle value{PyObject_GetAttrString(self.get(), "can_scroll")};
                if (!value)
                {
                    throw python_exception();
                }

                return py::convert_to<bool>(value.get());
            }
            catch (python_exception)
            {
                py::write_unraisable_and_throw();
            }
        }

        auto IsScrollingWithMouse()
        {
            try
            {
                py::pyobj_handle self{this->get_py_obj()};

                py::pyobj_handle value{PyObject_GetAttrString(self.get(), "is_scrolling_with_mouse")};
                if (!value)
                {
                    throw python_exception();
                }

                return py::convert_to<bool>(value.get());
            }
            catch (python_exception)
            {
                py::write_unraisable_and_throw();
            }
        }

        auto PanningInfo()
        {
            try
            {
                py::pyobj_handle self{this->get_py_obj()};

                py::pyobj_handle value{PyObject_GetAttrString(self.get(), "panning_info")};
                if (!value)
                {
                    throw python_exception();
                }

                return py::convert_to<winrt::Microsoft::UI::Xaml::Controls::Primitives::IScrollControllerPanningInfo>(value.get());
            }
            catch (python_exception)
            {
                py::write_unraisable_and_throw();
            }
        }

        auto AddScrollVelocityRequested(winrt::Windows::Foundation::TypedEventHandler<winrt::Microsoft::UI::Xaml::Controls::Primitives::IScrollController, winrt::Microsoft::UI::Xaml::Controls::Primitives::ScrollControllerAddScrollVelocityRequestedEventArgs> const& param0)
        {
            try
            {
                py::pyobj_handle self{this->get_py_obj()};

                py::pyobj_handle method{PyObject_GetAttrString(self.get(), "add_add_scroll_velocity_requested")};
                if (!method)
                {
                    throw python_exception();
                }

                py::pyobj_handle py_param0{py::convert(param0)};
                if (!py_param0)
                {
                    throw python_exception();
                }

                py::pyobj_handle return_value{PyObject_CallOneArg(method.get(), py_param0.get())};
                if (!return_value)
                {
                    throw python_exception();
                }

                return py::convert_to<winrt::event_token>(return_value.get());
            }
            catch (python_exception)
            {
                py::write_unraisable_and_throw();
            }
        }

        auto AddScrollVelocityRequested(winrt::event_token param0)
        {
            try
            {
                py::pyobj_handle self{this->get_py_obj()};

                py::pyobj_handle method{PyObject_GetAttrString(self.get(), "remove_add_scroll_velocity_requested")};
                if (!method)
                {
                    throw python_exception();
                }

                py::pyobj_handle py_param0{py::convert(param0)};
                if (!py_param0)
                {
                    throw python_exception();
                }

                py::pyobj_handle return_value{PyObject_CallOneArg(method.get(), py_param0.get())};
                if (!return_value)
                {
                    throw python_exception();
                }
            }
            catch (python_exception)
            {
                py::write_unraisable_and_throw();
            }
        }

        auto CanScrollChanged(winrt::Windows::Foundation::TypedEventHandler<winrt::Microsoft::UI::Xaml::Controls::Primitives::IScrollController, winrt::Windows::Foundation::IInspectable> const& param0)
        {
            try
            {
                py::pyobj_handle self{this->get_py_obj()};

                py::pyobj_handle method{PyObject_GetAttrString(self.get(), "add_can_scroll_changed")};
                if (!method)
                {
                    throw python_exception();
                }

                py::pyobj_handle py_param0{py::convert(param0)};
                if (!py_param0)
                {
                    throw python_exception();
                }

                py::pyobj_handle return_value{PyObject_CallOneArg(method.get(), py_param0.get())};
                if (!return_value)
                {
                    throw python_exception();
                }

                return py::convert_to<winrt::event_token>(return_value.get());
            }
            catch (python_exception)
            {
                py::write_unraisable_and_throw();
            }
        }

        auto CanScrollChanged(winrt::event_token param0)
        {
            try
            {
                py::pyobj_handle self{this->get_py_obj()};

                py::pyobj_handle method{PyObject_GetAttrString(self.get(), "remove_can_scroll_changed")};
                if (!method)
                {
                    throw python_exception();
                }

                py::pyobj_handle py_param0{py::convert(param0)};
                if (!py_param0)
                {
                    throw python_exception();
                }

                py::pyobj_handle return_value{PyObject_CallOneArg(method.get(), py_param0.get())};
                if (!return_value)
                {
                    throw python_exception();
                }
            }
            catch (python_exception)
            {
                py::write_unraisable_and_throw();
            }
        }

        auto IsScrollingWithMouseChanged(winrt::Windows::Foundation::TypedEventHandler<winrt::Microsoft::UI::Xaml::Controls::Primitives::IScrollController, winrt::Windows::Foundation::IInspectable> const& param0)
        {
            try
            {
                py::pyobj_handle self{this->get_py_obj()};

                py::pyobj_handle method{PyObject_GetAttrString(self.get(), "add_is_scrolling_with_mouse_changed")};
                if (!method)
                {
                    throw python_exception();
                }

                py::pyobj_handle py_param0{py::convert(param0)};
                if (!py_param0)
                {
                    throw python_exception();
                }

                py::pyobj_handle return_value{PyObject_CallOneArg(method.get(), py_param0.get())};
                if (!return_value)
                {
                    throw python_exception();
                }

                return py::convert_to<winrt::event_token>(return_value.get());
            }
            catch (python_exception)
            {
                py::write_unraisable_and_throw();
            }
        }

        auto IsScrollingWithMouseChanged(winrt::event_token param0)
        {
            try
            {
                py::pyobj_handle self{this->get_py_obj()};

                py::pyobj_handle method{PyObject_GetAttrString(self.get(), "remove_is_scrolling_with_mouse_changed")};
                if (!method)
                {
                    throw python_exception();
                }

                py::pyobj_handle py_param0{py::convert(param0)};
                if (!py_param0)
                {
                    throw python_exception();
                }

                py::pyobj_handle return_value{PyObject_CallOneArg(method.get(), py_param0.get())};
                if (!return_value)
                {
                    throw python_exception();
                }
            }
            catch (python_exception)
            {
                py::write_unraisable_and_throw();
            }
        }

        auto ScrollByRequested(winrt::Windows::Foundation::TypedEventHandler<winrt::Microsoft::UI::Xaml::Controls::Primitives::IScrollController, winrt::Microsoft::UI::Xaml::Controls::Primitives::ScrollControllerScrollByRequestedEventArgs> const& param0)
        {
            try
            {
                py::pyobj_handle self{this->get_py_obj()};

                py::pyobj_handle method{PyObject_GetAttrString(self.get(), "add_scroll_by_requested")};
                if (!method)
                {
                    throw python_exception();
                }

                py::pyobj_handle py_param0{py::convert(param0)};
                if (!py_param0)
                {
                    throw python_exception();
                }

                py::pyobj_handle return_value{PyObject_CallOneArg(method.get(), py_param0.get())};
                if (!return_value)
                {
                    throw python_exception();
                }

                return py::convert_to<winrt::event_token>(return_value.get());
            }
            catch (python_exception)
            {
                py::write_unraisable_and_throw();
            }
        }

        auto ScrollByRequested(winrt::event_token param0)
        {
            try
            {
                py::pyobj_handle self{this->get_py_obj()};

                py::pyobj_handle method{PyObject_GetAttrString(self.get(), "remove_scroll_by_requested")};
                if (!method)
                {
                    throw python_exception();
                }

                py::pyobj_handle py_param0{py::convert(param0)};
                if (!py_param0)
                {
                    throw python_exception();
                }

                py::pyobj_handle return_value{PyObject_CallOneArg(method.get(), py_param0.get())};
                if (!return_value)
                {
                    throw python_exception();
                }
            }
            catch (python_exception)
            {
                py::write_unraisable_and_throw();
            }
        }

        auto ScrollToRequested(winrt::Windows::Foundation::TypedEventHandler<winrt::Microsoft::UI::Xaml::Controls::Primitives::IScrollController, winrt::Microsoft::UI::Xaml::Controls::Primitives::ScrollControllerScrollToRequestedEventArgs> const& param0)
        {
            try
            {
                py::pyobj_handle self{this->get_py_obj()};

                py::pyobj_handle method{PyObject_GetAttrString(self.get(), "add_scroll_to_requested")};
                if (!method)
                {
                    throw python_exception();
                }

                py::pyobj_handle py_param0{py::convert(param0)};
                if (!py_param0)
                {
                    throw python_exception();
                }

                py::pyobj_handle return_value{PyObject_CallOneArg(method.get(), py_param0.get())};
                if (!return_value)
                {
                    throw python_exception();
                }

                return py::convert_to<winrt::event_token>(return_value.get());
            }
            catch (python_exception)
            {
                py::write_unraisable_and_throw();
            }
        }

        auto ScrollToRequested(winrt::event_token param0)
        {
            try
            {
                py::pyobj_handle self{this->get_py_obj()};

                py::pyobj_handle method{PyObject_GetAttrString(self.get(), "remove_scroll_to_requested")};
                if (!method)
                {
                    throw python_exception();
                }

                py::pyobj_handle py_param0{py::convert(param0)};
                if (!py_param0)
                {
                    throw python_exception();
                }

                py::pyobj_handle return_value{PyObject_CallOneArg(method.get(), py_param0.get())};
                if (!return_value)
                {
                    throw python_exception();
                }
            }
            catch (python_exception)
            {
                py::write_unraisable_and_throw();
            }
        }
    };

    static PyObject* _guid_ImplementsIScrollController(PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::guid_of<winrt::Microsoft::UI::Xaml::Controls::Primitives::IScrollController>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _make_ImplementsIScrollController(PyObject* /*unused*/, PyObject* args) noexcept
    {
        try
        {
            PyObject* py_obj;
            winrt::impl::inspectable_abi* runtime_class;

            if (!PyArg_ParseTuple(args, "On", &py_obj, &runtime_class))
            {
                return nullptr;
            }

            auto iface{std::make_unique<ImplementsIScrollController>(py_obj, runtime_class)};

            return PyLong_FromVoidPtr(iface.release());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef methods_ImplementsIScrollController[] = {
        { "_guid_", reinterpret_cast<PyCFunction>(_guid_ImplementsIScrollController), METH_NOARGS | METH_STATIC, nullptr },
        { "_make_", reinterpret_cast<PyCFunction>(_make_ImplementsIScrollController), METH_VARARGS | METH_STATIC, nullptr },
        { }
    };

    static PyType_Slot type_slots_ImplementsIScrollController[] = {
        { Py_tp_methods, reinterpret_cast<void*>(methods_ImplementsIScrollController) },
        { }
    };

    static PyType_Spec type_spec_ImplementsIScrollController = {
        "winrt._winrt_microsoft_ui_xaml_controls_primitives.ImplementsIScrollController",
        0,
        0,
        Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,
        type_slots_ImplementsIScrollController};

    // ----- IScrollControllerPanningInfo interface --------------------

    static PyObject* _new_IScrollControllerPanningInfo(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Microsoft::UI::Xaml::Controls::Primitives::IScrollControllerPanningInfo>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Microsoft::UI::Xaml::Controls::Primitives::IScrollControllerPanningInfo>::type_name);
        return nullptr;
    }

    static void _dealloc_IScrollControllerPanningInfo(py::wrapper::Microsoft::UI::Xaml::Controls::Primitives::IScrollControllerPanningInfo* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* IScrollControllerPanningInfo_SetPanningElementExpressionAnimationSources(py::wrapper::Microsoft::UI::Xaml::Controls::Primitives::IScrollControllerPanningInfo* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 5)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Xaml.Controls.Primitives.IScrollControllerPanningInfo", L"SetPanningElementExpressionAnimationSources", 5);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(5);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Microsoft::UI::Composition::CompositionPropertySet>(args, 0);
                auto param1 = py::convert_to<winrt::hstring>(args, 1);
                auto param2 = py::convert_to<winrt::hstring>(args, 2);
                auto param3 = py::convert_to<winrt::hstring>(args, 3);
                auto param4 = py::convert_to<winrt::hstring>(args, 4);

                {
                    auto _gil = release_gil();
                    self->obj.SetPanningElementExpressionAnimationSources(param0, param1, param2, param3, param4);
                }

                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* IScrollControllerPanningInfo_get_IsRailEnabled(py::wrapper::Microsoft::UI::Xaml::Controls::Primitives::IScrollControllerPanningInfo* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.IScrollControllerPanningInfo", L"IsRailEnabled");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.IsRailEnabled();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IScrollControllerPanningInfo_get_PanOrientation(py::wrapper::Microsoft::UI::Xaml::Controls::Primitives::IScrollControllerPanningInfo* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.IScrollControllerPanningInfo", L"PanOrientation");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.PanOrientation();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IScrollControllerPanningInfo_get_PanningElementAncestor(py::wrapper::Microsoft::UI::Xaml::Controls::Primitives::IScrollControllerPanningInfo* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.IScrollControllerPanningInfo", L"PanningElementAncestor");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.PanningElementAncestor();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IScrollControllerPanningInfo_add_Changed(py::wrapper::Microsoft::UI::Xaml::Controls::Primitives::IScrollControllerPanningInfo* self, PyObject* arg) noexcept
    {
        try
        {
            static std::optional<bool> is_event_present{};

            if (!is_event_present.has_value())
            {
                is_event_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Microsoft.UI.Xaml.Controls.Primitives.IScrollControllerPanningInfo", L"Changed");
            }

            if (!is_event_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Microsoft::UI::Xaml::Controls::Primitives::IScrollControllerPanningInfo, winrt::Windows::Foundation::IInspectable>>(arg);

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Changed(param0);
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IScrollControllerPanningInfo_remove_Changed(py::wrapper::Microsoft::UI::Xaml::Controls::Primitives::IScrollControllerPanningInfo* self, PyObject* arg) noexcept
    {
        try
        {
            static std::optional<bool> is_event_present{};

            if (!is_event_present.has_value())
            {
                is_event_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Microsoft.UI.Xaml.Controls.Primitives.IScrollControllerPanningInfo", L"Changed");
            }

            if (!is_event_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::event_token>(arg);

            {
                auto _gil = release_gil();
                self->obj.Changed(param0);
            }

            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IScrollControllerPanningInfo_add_PanRequested(py::wrapper::Microsoft::UI::Xaml::Controls::Primitives::IScrollControllerPanningInfo* self, PyObject* arg) noexcept
    {
        try
        {
            static std::optional<bool> is_event_present{};

            if (!is_event_present.has_value())
            {
                is_event_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Microsoft.UI.Xaml.Controls.Primitives.IScrollControllerPanningInfo", L"PanRequested");
            }

            if (!is_event_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Microsoft::UI::Xaml::Controls::Primitives::IScrollControllerPanningInfo, winrt::Microsoft::UI::Xaml::Controls::Primitives::ScrollControllerPanRequestedEventArgs>>(arg);

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.PanRequested(param0);
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IScrollControllerPanningInfo_remove_PanRequested(py::wrapper::Microsoft::UI::Xaml::Controls::Primitives::IScrollControllerPanningInfo* self, PyObject* arg) noexcept
    {
        try
        {
            static std::optional<bool> is_event_present{};

            if (!is_event_present.has_value())
            {
                is_event_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Microsoft.UI.Xaml.Controls.Primitives.IScrollControllerPanningInfo", L"PanRequested");
            }

            if (!is_event_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::event_token>(arg);

            {
                auto _gil = release_gil();
                self->obj.PanRequested(param0);
            }

            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_IScrollControllerPanningInfo(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Microsoft::UI::Xaml::Controls::Primitives::IScrollControllerPanningInfo>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_IScrollControllerPanningInfo(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Microsoft::UI::Xaml::Controls::Primitives::IScrollControllerPanningInfo>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_IScrollControllerPanningInfo[] = {
        { "set_panning_element_expression_animation_sources", reinterpret_cast<PyCFunction>(IScrollControllerPanningInfo_SetPanningElementExpressionAnimationSources), METH_VARARGS, nullptr },
        { "add_changed", reinterpret_cast<PyCFunction>(IScrollControllerPanningInfo_add_Changed), METH_O, nullptr },
        { "remove_changed", reinterpret_cast<PyCFunction>(IScrollControllerPanningInfo_remove_Changed), METH_O, nullptr },
        { "add_pan_requested", reinterpret_cast<PyCFunction>(IScrollControllerPanningInfo_add_PanRequested), METH_O, nullptr },
        { "remove_pan_requested", reinterpret_cast<PyCFunction>(IScrollControllerPanningInfo_remove_PanRequested), METH_O, nullptr },
        { "_assign_array_", _assign_array_IScrollControllerPanningInfo, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_IScrollControllerPanningInfo), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_IScrollControllerPanningInfo[] = {
        { "is_rail_enabled", reinterpret_cast<getter>(IScrollControllerPanningInfo_get_IsRailEnabled), nullptr, nullptr, nullptr },
        { "pan_orientation", reinterpret_cast<getter>(IScrollControllerPanningInfo_get_PanOrientation), nullptr, nullptr, nullptr },
        { "panning_element_ancestor", reinterpret_cast<getter>(IScrollControllerPanningInfo_get_PanningElementAncestor), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_IScrollControllerPanningInfo[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_IScrollControllerPanningInfo) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_IScrollControllerPanningInfo) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_IScrollControllerPanningInfo) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_IScrollControllerPanningInfo) },
        { }
    };

    static PyType_Spec type_spec_IScrollControllerPanningInfo = {
        "winrt._winrt_microsoft_ui_xaml_controls_primitives.IScrollControllerPanningInfo",
        sizeof(py::wrapper::Microsoft::UI::Xaml::Controls::Primitives::IScrollControllerPanningInfo),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_IScrollControllerPanningInfo};

    struct ImplementsIScrollControllerPanningInfo : py::ImplementsInterfaceT<ImplementsIScrollControllerPanningInfo, winrt::Microsoft::UI::Xaml::Controls::Primitives::IScrollControllerPanningInfo>
    {
        ImplementsIScrollControllerPanningInfo() = delete;
        ImplementsIScrollControllerPanningInfo(PyObject* py_obj, winrt::impl::inspectable_abi* runtime_class) : py::ImplementsInterfaceT<ImplementsIScrollControllerPanningInfo, winrt::Microsoft::UI::Xaml::Controls::Primitives::IScrollControllerPanningInfo>(py_obj, runtime_class)
        {
        }

        auto SetPanningElementExpressionAnimationSources(winrt::Microsoft::UI::Composition::CompositionPropertySet const& param0, winrt::hstring const& param1, winrt::hstring const& param2, winrt::hstring const& param3, winrt::hstring const& param4)
        {
            try
            {
                py::pyobj_handle self{this->get_py_obj()};

                py::pyobj_handle method{PyObject_GetAttrString(self.get(), "set_panning_element_expression_animation_sources")};
                if (!method)
                {
                    throw python_exception();
                }

                py::pyobj_handle py_param0{py::convert(param0)};
                if (!py_param0)
                {
                    throw python_exception();
                }

                py::pyobj_handle py_param1{py::convert(param1)};
                if (!py_param1)
                {
                    throw python_exception();
                }

                py::pyobj_handle py_param2{py::convert(param2)};
                if (!py_param2)
                {
                    throw python_exception();
                }

                py::pyobj_handle py_param3{py::convert(param3)};
                if (!py_param3)
                {
                    throw python_exception();
                }

                py::pyobj_handle py_param4{py::convert(param4)};
                if (!py_param4)
                {
                    throw python_exception();
                }

                py::pyobj_handle args{PyTuple_Pack(5, py_param0.get(), py_param1.get(), py_param2.get(), py_param3.get(), py_param4.get())};
                if (!args)
                {
                    throw python_exception();
                }

                py::pyobj_handle return_value{PyObject_CallObject(method.get(), args.get())};
                if (!return_value)
                {
                    throw python_exception();
                }
            }
            catch (python_exception)
            {
                py::write_unraisable_and_throw();
            }
        }

        auto IsRailEnabled()
        {
            try
            {
                py::pyobj_handle self{this->get_py_obj()};

                py::pyobj_handle value{PyObject_GetAttrString(self.get(), "is_rail_enabled")};
                if (!value)
                {
                    throw python_exception();
                }

                return py::convert_to<bool>(value.get());
            }
            catch (python_exception)
            {
                py::write_unraisable_and_throw();
            }
        }

        auto PanOrientation()
        {
            try
            {
                py::pyobj_handle self{this->get_py_obj()};

                py::pyobj_handle value{PyObject_GetAttrString(self.get(), "pan_orientation")};
                if (!value)
                {
                    throw python_exception();
                }

                return py::convert_to<winrt::Microsoft::UI::Xaml::Controls::Orientation>(value.get());
            }
            catch (python_exception)
            {
                py::write_unraisable_and_throw();
            }
        }

        auto PanningElementAncestor()
        {
            try
            {
                py::pyobj_handle self{this->get_py_obj()};

                py::pyobj_handle value{PyObject_GetAttrString(self.get(), "panning_element_ancestor")};
                if (!value)
                {
                    throw python_exception();
                }

                return py::convert_to<winrt::Microsoft::UI::Xaml::UIElement>(value.get());
            }
            catch (python_exception)
            {
                py::write_unraisable_and_throw();
            }
        }

        auto Changed(winrt::Windows::Foundation::TypedEventHandler<winrt::Microsoft::UI::Xaml::Controls::Primitives::IScrollControllerPanningInfo, winrt::Windows::Foundation::IInspectable> const& param0)
        {
            try
            {
                py::pyobj_handle self{this->get_py_obj()};

                py::pyobj_handle method{PyObject_GetAttrString(self.get(), "add_changed")};
                if (!method)
                {
                    throw python_exception();
                }

                py::pyobj_handle py_param0{py::convert(param0)};
                if (!py_param0)
                {
                    throw python_exception();
                }

                py::pyobj_handle return_value{PyObject_CallOneArg(method.get(), py_param0.get())};
                if (!return_value)
                {
                    throw python_exception();
                }

                return py::convert_to<winrt::event_token>(return_value.get());
            }
            catch (python_exception)
            {
                py::write_unraisable_and_throw();
            }
        }

        auto Changed(winrt::event_token param0)
        {
            try
            {
                py::pyobj_handle self{this->get_py_obj()};

                py::pyobj_handle method{PyObject_GetAttrString(self.get(), "remove_changed")};
                if (!method)
                {
                    throw python_exception();
                }

                py::pyobj_handle py_param0{py::convert(param0)};
                if (!py_param0)
                {
                    throw python_exception();
                }

                py::pyobj_handle return_value{PyObject_CallOneArg(method.get(), py_param0.get())};
                if (!return_value)
                {
                    throw python_exception();
                }
            }
            catch (python_exception)
            {
                py::write_unraisable_and_throw();
            }
        }

        auto PanRequested(winrt::Windows::Foundation::TypedEventHandler<winrt::Microsoft::UI::Xaml::Controls::Primitives::IScrollControllerPanningInfo, winrt::Microsoft::UI::Xaml::Controls::Primitives::ScrollControllerPanRequestedEventArgs> const& param0)
        {
            try
            {
                py::pyobj_handle self{this->get_py_obj()};

                py::pyobj_handle method{PyObject_GetAttrString(self.get(), "add_pan_requested")};
                if (!method)
                {
                    throw python_exception();
                }

                py::pyobj_handle py_param0{py::convert(param0)};
                if (!py_param0)
                {
                    throw python_exception();
                }

                py::pyobj_handle return_value{PyObject_CallOneArg(method.get(), py_param0.get())};
                if (!return_value)
                {
                    throw python_exception();
                }

                return py::convert_to<winrt::event_token>(return_value.get());
            }
            catch (python_exception)
            {
                py::write_unraisable_and_throw();
            }
        }

        auto PanRequested(winrt::event_token param0)
        {
            try
            {
                py::pyobj_handle self{this->get_py_obj()};

                py::pyobj_handle method{PyObject_GetAttrString(self.get(), "remove_pan_requested")};
                if (!method)
                {
                    throw python_exception();
                }

                py::pyobj_handle py_param0{py::convert(param0)};
                if (!py_param0)
                {
                    throw python_exception();
                }

                py::pyobj_handle return_value{PyObject_CallOneArg(method.get(), py_param0.get())};
                if (!return_value)
                {
                    throw python_exception();
                }
            }
            catch (python_exception)
            {
                py::write_unraisable_and_throw();
            }
        }
    };

    static PyObject* _guid_ImplementsIScrollControllerPanningInfo(PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::guid_of<winrt::Microsoft::UI::Xaml::Controls::Primitives::IScrollControllerPanningInfo>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _make_ImplementsIScrollControllerPanningInfo(PyObject* /*unused*/, PyObject* args) noexcept
    {
        try
        {
            PyObject* py_obj;
            winrt::impl::inspectable_abi* runtime_class;

            if (!PyArg_ParseTuple(args, "On", &py_obj, &runtime_class))
            {
                return nullptr;
            }

            auto iface{std::make_unique<ImplementsIScrollControllerPanningInfo>(py_obj, runtime_class)};

            return PyLong_FromVoidPtr(iface.release());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef methods_ImplementsIScrollControllerPanningInfo[] = {
        { "_guid_", reinterpret_cast<PyCFunction>(_guid_ImplementsIScrollControllerPanningInfo), METH_NOARGS | METH_STATIC, nullptr },
        { "_make_", reinterpret_cast<PyCFunction>(_make_ImplementsIScrollControllerPanningInfo), METH_VARARGS | METH_STATIC, nullptr },
        { }
    };

    static PyType_Slot type_slots_ImplementsIScrollControllerPanningInfo[] = {
        { Py_tp_methods, reinterpret_cast<void*>(methods_ImplementsIScrollControllerPanningInfo) },
        { }
    };

    static PyType_Spec type_spec_ImplementsIScrollControllerPanningInfo = {
        "winrt._winrt_microsoft_ui_xaml_controls_primitives.ImplementsIScrollControllerPanningInfo",
        0,
        0,
        Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,
        type_slots_ImplementsIScrollControllerPanningInfo};

    // ----- IScrollSnapPointsInfo interface --------------------

    static PyObject* _new_IScrollSnapPointsInfo(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Microsoft::UI::Xaml::Controls::Primitives::IScrollSnapPointsInfo>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Microsoft::UI::Xaml::Controls::Primitives::IScrollSnapPointsInfo>::type_name);
        return nullptr;
    }

    static void _dealloc_IScrollSnapPointsInfo(py::wrapper::Microsoft::UI::Xaml::Controls::Primitives::IScrollSnapPointsInfo* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* IScrollSnapPointsInfo_GetIrregularSnapPoints(py::wrapper::Microsoft::UI::Xaml::Controls::Primitives::IScrollSnapPointsInfo* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Xaml.Controls.Primitives.IScrollSnapPointsInfo", L"GetIrregularSnapPoints", 2);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(2);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Microsoft::UI::Xaml::Controls::Orientation>(args, 0);
                auto param1 = py::convert_to<winrt::Microsoft::UI::Xaml::Controls::Primitives::SnapPointsAlignment>(args, 1);

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return self->obj.GetIrregularSnapPoints(param0, param1);
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* IScrollSnapPointsInfo_GetRegularSnapPoints(py::wrapper::Microsoft::UI::Xaml::Controls::Primitives::IScrollSnapPointsInfo* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Xaml.Controls.Primitives.IScrollSnapPointsInfo", L"GetRegularSnapPoints", 2);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(2);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Microsoft::UI::Xaml::Controls::Orientation>(args, 0);
                auto param1 = py::convert_to<winrt::Microsoft::UI::Xaml::Controls::Primitives::SnapPointsAlignment>(args, 1);
                float param2{};

                auto return_value = [&]()
                {
                    auto _gil = release_gil();
                    return self->obj.GetRegularSnapPoints(param0, param1, param2);
                }();

                py::pyobj_handle out_return_value{ py::convert(return_value) };
                if (!out_return_value)
                {
                    return nullptr;
                }
                py::pyobj_handle out2{ py::convert(param2) };
                if (!out2)
                {
                    return nullptr;
                }

                return PyTuple_Pack(2, out_return_value.get(), out2.get());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* IScrollSnapPointsInfo_get_AreHorizontalSnapPointsRegular(py::wrapper::Microsoft::UI::Xaml::Controls::Primitives::IScrollSnapPointsInfo* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.IScrollSnapPointsInfo", L"AreHorizontalSnapPointsRegular");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.AreHorizontalSnapPointsRegular();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IScrollSnapPointsInfo_get_AreVerticalSnapPointsRegular(py::wrapper::Microsoft::UI::Xaml::Controls::Primitives::IScrollSnapPointsInfo* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Controls.Primitives.IScrollSnapPointsInfo", L"AreVerticalSnapPointsRegular");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.AreVerticalSnapPointsRegular();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IScrollSnapPointsInfo_add_HorizontalSnapPointsChanged(py::wrapper::Microsoft::UI::Xaml::Controls::Primitives::IScrollSnapPointsInfo* self, PyObject* arg) noexcept
    {
        try
        {
            static std::optional<bool> is_event_present{};

            if (!is_event_present.has_value())
            {
                is_event_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Microsoft.UI.Xaml.Controls.Primitives.IScrollSnapPointsInfo", L"HorizontalSnapPointsChanged");
            }

            if (!is_event_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::EventHandler<winrt::Windows::Foundation::IInspectable>>(arg);

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.HorizontalSnapPointsChanged(param0);
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IScrollSnapPointsInfo_remove_HorizontalSnapPointsChanged(py::wrapper::Microsoft::UI::Xaml::Controls::Primitives::IScrollSnapPointsInfo* self, PyObject* arg) noexcept
    {
        try
        {
            static std::optional<bool> is_event_present{};

            if (!is_event_present.has_value())
            {
                is_event_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Microsoft.UI.Xaml.Controls.Primitives.IScrollSnapPointsInfo", L"HorizontalSnapPointsChanged");
            }

            if (!is_event_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::event_token>(arg);

            {
                auto _gil = release_gil();
                self->obj.HorizontalSnapPointsChanged(param0);
            }

            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IScrollSnapPointsInfo_add_VerticalSnapPointsChanged(py::wrapper::Microsoft::UI::Xaml::Controls::Primitives::IScrollSnapPointsInfo* self, PyObject* arg) noexcept
    {
        try
        {
            static std::optional<bool> is_event_present{};

            if (!is_event_present.has_value())
            {
                is_event_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Microsoft.UI.Xaml.Controls.Primitives.IScrollSnapPointsInfo", L"VerticalSnapPointsChanged");
            }

            if (!is_event_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::EventHandler<winrt::Windows::Foundation::IInspectable>>(arg);

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.VerticalSnapPointsChanged(param0);
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IScrollSnapPointsInfo_remove_VerticalSnapPointsChanged(py::wrapper::Microsoft::UI::Xaml::Controls::Primitives::IScrollSnapPointsInfo* self, PyObject* arg) noexcept
    {
        try
        {
            static std::optional<bool> is_event_present{};

            if (!is_event_present.has_value())
            {
                is_event_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Microsoft.UI.Xaml.Controls.Primitives.IScrollSnapPointsInfo", L"VerticalSnapPointsChanged");
            }

            if (!is_event_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::event_token>(arg);

            {
                auto _gil = release_gil();
                self->obj.VerticalSnapPointsChanged(param0);
            }

            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_IScrollSnapPointsInfo(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Microsoft::UI::Xaml::Controls::Primitives::IScrollSnapPointsInfo>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_IScrollSnapPointsInfo(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Microsoft::UI::Xaml::Controls::Primitives::IScrollSnapPointsInfo>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_IScrollSnapPointsInfo[] = {
        { "get_irregular_snap_points", reinterpret_cast<PyCFunction>(IScrollSnapPointsInfo_GetIrregularSnapPoints), METH_VARARGS, nullptr },
        { "get_regular_snap_points", reinterpret_cast<PyCFunction>(IScrollSnapPointsInfo_GetRegularSnapPoints), METH_VARARGS, nullptr },
        { "add_horizontal_snap_points_changed", reinterpret_cast<PyCFunction>(IScrollSnapPointsInfo_add_HorizontalSnapPointsChanged), METH_O, nullptr },
        { "remove_horizontal_snap_points_changed", reinterpret_cast<PyCFunction>(IScrollSnapPointsInfo_remove_HorizontalSnapPointsChanged), METH_O, nullptr },
        { "add_vertical_snap_points_changed", reinterpret_cast<PyCFunction>(IScrollSnapPointsInfo_add_VerticalSnapPointsChanged), METH_O, nullptr },
        { "remove_vertical_snap_points_changed", reinterpret_cast<PyCFunction>(IScrollSnapPointsInfo_remove_VerticalSnapPointsChanged), METH_O, nullptr },
        { "_assign_array_", _assign_array_IScrollSnapPointsInfo, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_IScrollSnapPointsInfo), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_IScrollSnapPointsInfo[] = {
        { "are_horizontal_snap_points_regular", reinterpret_cast<getter>(IScrollSnapPointsInfo_get_AreHorizontalSnapPointsRegular), nullptr, nullptr, nullptr },
        { "are_vertical_snap_points_regular", reinterpret_cast<getter>(IScrollSnapPointsInfo_get_AreVerticalSnapPointsRegular), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_IScrollSnapPointsInfo[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_IScrollSnapPointsInfo) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_IScrollSnapPointsInfo) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_IScrollSnapPointsInfo) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_IScrollSnapPointsInfo) },
        { }
    };

    static PyType_Spec type_spec_IScrollSnapPointsInfo = {
        "winrt._winrt_microsoft_ui_xaml_controls_primitives.IScrollSnapPointsInfo",
        sizeof(py::wrapper::Microsoft::UI::Xaml::Controls::Primitives::IScrollSnapPointsInfo),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_IScrollSnapPointsInfo};

    struct ImplementsIScrollSnapPointsInfo : py::ImplementsInterfaceT<ImplementsIScrollSnapPointsInfo, winrt::Microsoft::UI::Xaml::Controls::Primitives::IScrollSnapPointsInfo>
    {
        ImplementsIScrollSnapPointsInfo() = delete;
        ImplementsIScrollSnapPointsInfo(PyObject* py_obj, winrt::impl::inspectable_abi* runtime_class) : py::ImplementsInterfaceT<ImplementsIScrollSnapPointsInfo, winrt::Microsoft::UI::Xaml::Controls::Primitives::IScrollSnapPointsInfo>(py_obj, runtime_class)
        {
        }

        auto GetIrregularSnapPoints(winrt::Microsoft::UI::Xaml::Controls::Orientation param0, winrt::Microsoft::UI::Xaml::Controls::Primitives::SnapPointsAlignment param1)
        {
            try
            {
                py::pyobj_handle self{this->get_py_obj()};

                py::pyobj_handle method{PyObject_GetAttrString(self.get(), "get_irregular_snap_points")};
                if (!method)
                {
                    throw python_exception();
                }

                py::pyobj_handle py_param0{py::convert(param0)};
                if (!py_param0)
                {
                    throw python_exception();
                }

                py::pyobj_handle py_param1{py::convert(param1)};
                if (!py_param1)
                {
                    throw python_exception();
                }

                py::pyobj_handle args{PyTuple_Pack(2, py_param0.get(), py_param1.get())};
                if (!args)
                {
                    throw python_exception();
                }

                py::pyobj_handle return_value{PyObject_CallObject(method.get(), args.get())};
                if (!return_value)
                {
                    throw python_exception();
                }

                return py::convert_to<winrt::Windows::Foundation::Collections::IVectorView<float>>(return_value.get());
            }
            catch (python_exception)
            {
                py::write_unraisable_and_throw();
            }
        }

        auto GetRegularSnapPoints(winrt::Microsoft::UI::Xaml::Controls::Orientation param0, winrt::Microsoft::UI::Xaml::Controls::Primitives::SnapPointsAlignment param1, float& param2)
        {
            try
            {
                py::pyobj_handle self{this->get_py_obj()};

                py::pyobj_handle method{PyObject_GetAttrString(self.get(), "get_regular_snap_points")};
                if (!method)
                {
                    throw python_exception();
                }

                py::pyobj_handle py_param0{py::convert(param0)};
                if (!py_param0)
                {
                    throw python_exception();
                }

                py::pyobj_handle py_param1{py::convert(param1)};
                if (!py_param1)
                {
                    throw python_exception();
                }

                py::pyobj_handle args{PyTuple_Pack(2, py_param0.get(), py_param1.get())};
                if (!args)
                {
                    throw python_exception();
                }

                py::pyobj_handle return_value{PyObject_CallObject(method.get(), args.get())};
                if (!return_value)
                {
                    throw python_exception();
                }

                param2 = py::convert_to<float>(return_value.get(), 1);

                return py::convert_to<float>(return_value.get(), 0);
            }
            catch (python_exception)
            {
                py::write_unraisable_and_throw();
            }
        }

        auto AreHorizontalSnapPointsRegular()
        {
            try
            {
                py::pyobj_handle self{this->get_py_obj()};

                py::pyobj_handle value{PyObject_GetAttrString(self.get(), "are_horizontal_snap_points_regular")};
                if (!value)
                {
                    throw python_exception();
                }

                return py::convert_to<bool>(value.get());
            }
            catch (python_exception)
            {
                py::write_unraisable_and_throw();
            }
        }

        auto AreVerticalSnapPointsRegular()
        {
            try
            {
                py::pyobj_handle self{this->get_py_obj()};

                py::pyobj_handle value{PyObject_GetAttrString(self.get(), "are_vertical_snap_points_regular")};
                if (!value)
                {
                    throw python_exception();
                }

                return py::convert_to<bool>(value.get());
            }
            catch (python_exception)
            {
                py::write_unraisable_and_throw();
            }
        }

        auto HorizontalSnapPointsChanged(winrt::Windows::Foundation::EventHandler<winrt::Windows::Foundation::IInspectable> const& param0)
        {
            try
            {
                py::pyobj_handle self{this->get_py_obj()};

                py::pyobj_handle method{PyObject_GetAttrString(self.get(), "add_horizontal_snap_points_changed")};
                if (!method)
                {
                    throw python_exception();
                }

                py::pyobj_handle py_param0{py::convert(param0)};
                if (!py_param0)
                {
                    throw python_exception();
                }

                py::pyobj_handle return_value{PyObject_CallOneArg(method.get(), py_param0.get())};
                if (!return_value)
                {
                    throw python_exception();
                }

                return py::convert_to<winrt::event_token>(return_value.get());
            }
            catch (python_exception)
            {
                py::write_unraisable_and_throw();
            }
        }

        auto HorizontalSnapPointsChanged(winrt::event_token param0)
        {
            try
            {
                py::pyobj_handle self{this->get_py_obj()};

                py::pyobj_handle method{PyObject_GetAttrString(self.get(), "remove_horizontal_snap_points_changed")};
                if (!method)
                {
                    throw python_exception();
                }

                py::pyobj_handle py_param0{py::convert(param0)};
                if (!py_param0)
                {
                    throw python_exception();
                }

                py::pyobj_handle return_value{PyObject_CallOneArg(method.get(), py_param0.get())};
                if (!return_value)
                {
                    throw python_exception();
                }
            }
            catch (python_exception)
            {
                py::write_unraisable_and_throw();
            }
        }

        auto VerticalSnapPointsChanged(winrt::Windows::Foundation::EventHandler<winrt::Windows::Foundation::IInspectable> const& param0)
        {
            try
            {
                py::pyobj_handle self{this->get_py_obj()};

                py::pyobj_handle method{PyObject_GetAttrString(self.get(), "add_vertical_snap_points_changed")};
                if (!method)
                {
                    throw python_exception();
                }

                py::pyobj_handle py_param0{py::convert(param0)};
                if (!py_param0)
                {
                    throw python_exception();
                }

                py::pyobj_handle return_value{PyObject_CallOneArg(method.get(), py_param0.get())};
                if (!return_value)
                {
                    throw python_exception();
                }

                return py::convert_to<winrt::event_token>(return_value.get());
            }
            catch (python_exception)
            {
                py::write_unraisable_and_throw();
            }
        }

        auto VerticalSnapPointsChanged(winrt::event_token param0)
        {
            try
            {
                py::pyobj_handle self{this->get_py_obj()};

                py::pyobj_handle method{PyObject_GetAttrString(self.get(), "remove_vertical_snap_points_changed")};
                if (!method)
                {
                    throw python_exception();
                }

                py::pyobj_handle py_param0{py::convert(param0)};
                if (!py_param0)
                {
                    throw python_exception();
                }

                py::pyobj_handle return_value{PyObject_CallOneArg(method.get(), py_param0.get())};
                if (!return_value)
                {
                    throw python_exception();
                }
            }
            catch (python_exception)
            {
                py::write_unraisable_and_throw();
            }
        }
    };

    static PyObject* _guid_ImplementsIScrollSnapPointsInfo(PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::guid_of<winrt::Microsoft::UI::Xaml::Controls::Primitives::IScrollSnapPointsInfo>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _make_ImplementsIScrollSnapPointsInfo(PyObject* /*unused*/, PyObject* args) noexcept
    {
        try
        {
            PyObject* py_obj;
            winrt::impl::inspectable_abi* runtime_class;

            if (!PyArg_ParseTuple(args, "On", &py_obj, &runtime_class))
            {
                return nullptr;
            }

            auto iface{std::make_unique<ImplementsIScrollSnapPointsInfo>(py_obj, runtime_class)};

            return PyLong_FromVoidPtr(iface.release());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef methods_ImplementsIScrollSnapPointsInfo[] = {
        { "_guid_", reinterpret_cast<PyCFunction>(_guid_ImplementsIScrollSnapPointsInfo), METH_NOARGS | METH_STATIC, nullptr },
        { "_make_", reinterpret_cast<PyCFunction>(_make_ImplementsIScrollSnapPointsInfo), METH_VARARGS | METH_STATIC, nullptr },
        { }
    };

    static PyType_Slot type_slots_ImplementsIScrollSnapPointsInfo[] = {
        { Py_tp_methods, reinterpret_cast<void*>(methods_ImplementsIScrollSnapPointsInfo) },
        { }
    };

    static PyType_Spec type_spec_ImplementsIScrollSnapPointsInfo = {
        "winrt._winrt_microsoft_ui_xaml_controls_primitives.ImplementsIScrollSnapPointsInfo",
        0,
        0,
        Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,
        type_slots_ImplementsIScrollSnapPointsInfo};

    // ----- GeneratorPosition struct --------------------

    winrt_struct_wrapper<winrt::Microsoft::UI::Xaml::Controls::Primitives::GeneratorPosition>* _new_GeneratorPosition(PyTypeObject* subclass, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        auto self = reinterpret_cast<winrt_struct_wrapper<winrt::Microsoft::UI::Xaml::Controls::Primitives::GeneratorPosition>*>(subclass->tp_alloc(subclass, 0));

        if (!self)
        {
            return nullptr;
        }

        std::construct_at(&self->obj);

        return self;
    }

    int _init_GeneratorPosition(winrt_struct_wrapper<winrt::Microsoft::UI::Xaml::Controls::Primitives::GeneratorPosition>* self, PyObject* args, PyObject* kwds) noexcept
    {
        auto tuple_size = PyTuple_Size(args);

        if ((tuple_size == 0) && (!kwds))
        {
            self->obj = {};
            return 0;
        }

        int32_t _Index{};
        int32_t _Offset{};

        static const char* kwlist[] = {"index", "offset", nullptr};
        if (!PyArg_ParseTupleAndKeywords(args, kwds, "ii", const_cast<char**>(kwlist), &_Index, &_Offset))
        {
            return -1;
        }

        try
        {
            self->obj.Index = _Index;
            self->obj.Offset = _Offset;

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static void _dealloc_GeneratorPosition(py::wrapper::Microsoft::UI::Xaml::Controls::Primitives::GeneratorPosition* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* _assign_array_GeneratorPosition(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Microsoft::UI::Xaml::Controls::Primitives::GeneratorPosition>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyMethodDef _methods_GeneratorPosition[] = {
        { "_assign_array_", _assign_array_GeneratorPosition, METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyObject* GeneratorPosition_get_Index(py::wrapper::Microsoft::UI::Xaml::Controls::Primitives::GeneratorPosition* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Index);
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int GeneratorPosition_set_Index(py::wrapper::Microsoft::UI::Xaml::Controls::Primitives::GeneratorPosition* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            self->obj.Index = py::convert_to<int32_t>(arg);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* GeneratorPosition_get_Offset(py::wrapper::Microsoft::UI::Xaml::Controls::Primitives::GeneratorPosition* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Offset);
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int GeneratorPosition_set_Offset(py::wrapper::Microsoft::UI::Xaml::Controls::Primitives::GeneratorPosition* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            self->obj.Offset = py::convert_to<int32_t>(arg);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyGetSetDef _getset_GeneratorPosition[] = {
        { "index", reinterpret_cast<getter>(GeneratorPosition_get_Index), reinterpret_cast<setter>(GeneratorPosition_set_Index), nullptr, nullptr },
        { "offset", reinterpret_cast<getter>(GeneratorPosition_get_Offset), reinterpret_cast<setter>(GeneratorPosition_set_Offset), nullptr, nullptr },
        { }
    };

    static PyObject* _richcompare_GeneratorPosition(py::wrapper::Microsoft::UI::Xaml::Controls::Primitives::GeneratorPosition* self, PyObject* other, int op) noexcept
    {
        try
        {
            auto _other = py::convert_to<winrt::Microsoft::UI::Xaml::Controls::Primitives::GeneratorPosition>(other);

            if (op == Py_EQ)
            {
                if (self->obj == _other)
                {
                    Py_RETURN_TRUE;
                }

                Py_RETURN_FALSE;
            }

            if (op == Py_NE)
            {
                if (self->obj != _other)
                {
                    Py_RETURN_TRUE;
                }

                Py_RETURN_FALSE;
            }

            Py_RETURN_NOTIMPLEMENTED;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _repr_GeneratorPosition(PyObject* self) noexcept
    {
        py::pyobj_handle Index{PyObject_GetAttrString(self, "index")};
        if (!Index)
        {
            return nullptr;
        }

        py::pyobj_handle Offset{PyObject_GetAttrString(self, "offset")};
        if (!Offset)
        {
            return nullptr;
        }

        return PyUnicode_FromFormat("GeneratorPosition(index=%R, offset=%R)", Index.get(), Offset.get());
    }

    static PyType_Slot _type_slots_GeneratorPosition[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_GeneratorPosition) },
        { Py_tp_init, reinterpret_cast<void*>(_init_GeneratorPosition) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_GeneratorPosition) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_GeneratorPosition) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_GeneratorPosition) },
        { Py_tp_richcompare, reinterpret_cast<void*>(_richcompare_GeneratorPosition) },
        { Py_tp_repr, reinterpret_cast<void*>(_repr_GeneratorPosition) },
        { }
    };

    static PyType_Spec type_spec_GeneratorPosition = {
        "winrt._winrt_microsoft_ui_xaml_controls_primitives.GeneratorPosition",
        sizeof(py::wrapper::Microsoft::UI::Xaml::Controls::Primitives::GeneratorPosition),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_GeneratorPosition};

    // ----- Microsoft.UI.Xaml.Controls.Primitives Initialization --------------------

    PyDoc_STRVAR(module_doc, "Microsoft.UI.Xaml.Controls.Primitives");

    static PyModuleDef module_def = {
        PyModuleDef_HEAD_INIT,
        "_winrt_microsoft_ui_xaml_controls_primitives",
        module_doc,
        0,
        nullptr,
        nullptr,
        nullptr,
        nullptr,
        nullptr};
} // py::cpp::Microsoft::UI::Xaml::Controls::Primitives

PyMODINIT_FUNC PyInit__winrt_microsoft_ui_xaml_controls_primitives(void) noexcept
{
    using namespace py::cpp::Microsoft::UI::Xaml::Controls::Primitives;

    if (py::import_winrt_runtime() == -1)
    {
        return nullptr;
    }

    py::pyobj_handle module{PyModule_Create(&module_def)};

    if (!module)
    {
        return nullptr;
    }

    auto object_type = py::get_object_type();
    if (!object_type)
    {
        return nullptr;
    }

    py::pyobj_handle object_bases{PyTuple_Pack(1, object_type)};

    if (!object_bases)
    {
        return nullptr;
    }

    py::pyobj_handle microsoft_ui_xaml_module{PyImport_ImportModule("winrt._winrt_microsoft_ui_xaml")};
    if (!microsoft_ui_xaml_module)
    {
        return nullptr;
    }

    py::pyobj_handle microsoft_ui_xaml_DependencyObject_type{PyObject_GetAttrString(microsoft_ui_xaml_module.get(), "DependencyObject")};
    if (!microsoft_ui_xaml_DependencyObject_type)
    {
        return nullptr;
    }

    py::pyobj_handle microsoft_ui_xaml_RoutedEventArgs_type{PyObject_GetAttrString(microsoft_ui_xaml_module.get(), "RoutedEventArgs")};
    if (!microsoft_ui_xaml_RoutedEventArgs_type)
    {
        return nullptr;
    }

    py::pyobj_handle microsoft_ui_xaml_FrameworkElement_type{PyObject_GetAttrString(microsoft_ui_xaml_module.get(), "FrameworkElement")};
    if (!microsoft_ui_xaml_FrameworkElement_type)
    {
        return nullptr;
    }

    py::pyobj_handle microsoft_ui_xaml_controls_module{PyImport_ImportModule("winrt._winrt_microsoft_ui_xaml_controls")};
    if (!microsoft_ui_xaml_controls_module)
    {
        return nullptr;
    }

    py::pyobj_handle microsoft_ui_xaml_controls_ContentControl_type{PyObject_GetAttrString(microsoft_ui_xaml_controls_module.get(), "ContentControl")};
    if (!microsoft_ui_xaml_controls_ContentControl_type)
    {
        return nullptr;
    }

    py::pyobj_handle microsoft_ui_xaml_controls_Panel_type{PyObject_GetAttrString(microsoft_ui_xaml_controls_module.get(), "Panel")};
    if (!microsoft_ui_xaml_controls_Panel_type)
    {
        return nullptr;
    }

    py::pyobj_handle microsoft_ui_xaml_controls_VirtualizingPanel_type{PyObject_GetAttrString(microsoft_ui_xaml_controls_module.get(), "VirtualizingPanel")};
    if (!microsoft_ui_xaml_controls_VirtualizingPanel_type)
    {
        return nullptr;
    }

    py::pyobj_handle microsoft_ui_xaml_controls_Control_type{PyObject_GetAttrString(microsoft_ui_xaml_controls_module.get(), "Control")};
    if (!microsoft_ui_xaml_controls_Control_type)
    {
        return nullptr;
    }

    py::pyobj_handle microsoft_ui_xaml_controls_NonVirtualizingLayout_type{PyObject_GetAttrString(microsoft_ui_xaml_controls_module.get(), "NonVirtualizingLayout")};
    if (!microsoft_ui_xaml_controls_NonVirtualizingLayout_type)
    {
        return nullptr;
    }

    py::pyobj_handle microsoft_ui_xaml_controls_CommandBar_type{PyObject_GetAttrString(microsoft_ui_xaml_controls_module.get(), "CommandBar")};
    if (!microsoft_ui_xaml_controls_CommandBar_type)
    {
        return nullptr;
    }

    py::pyobj_handle microsoft_ui_xaml_controls_ContentPresenter_type{PyObject_GetAttrString(microsoft_ui_xaml_controls_module.get(), "ContentPresenter")};
    if (!microsoft_ui_xaml_controls_ContentPresenter_type)
    {
        return nullptr;
    }

    py::pyobj_handle microsoft_ui_xaml_controls_Canvas_type{PyObject_GetAttrString(microsoft_ui_xaml_controls_module.get(), "Canvas")};
    if (!microsoft_ui_xaml_controls_Canvas_type)
    {
        return nullptr;
    }

    py::pyobj_handle microsoft_ui_xaml_controls_Grid_type{PyObject_GetAttrString(microsoft_ui_xaml_controls_module.get(), "Grid")};
    if (!microsoft_ui_xaml_controls_Grid_type)
    {
        return nullptr;
    }

    py::pyobj_handle microsoft_ui_xaml_controls_ItemsControl_type{PyObject_GetAttrString(microsoft_ui_xaml_controls_module.get(), "ItemsControl")};
    if (!microsoft_ui_xaml_controls_ItemsControl_type)
    {
        return nullptr;
    }

    py::pyobj_handle AppBarButtonTemplateSettings_bases{PyTuple_Pack(1, microsoft_ui_xaml_DependencyObject_type.get())};
    if (!AppBarButtonTemplateSettings_bases)
    {
        return nullptr;
    }

    py::pytype_handle AppBarButtonTemplateSettings_type{py::register_python_type(module.get(), &type_spec_AppBarButtonTemplateSettings, AppBarButtonTemplateSettings_bases.get(), nullptr)};
    if (!AppBarButtonTemplateSettings_type)
    {
        return nullptr;
    }

    py::pyobj_handle AppBarTemplateSettings_bases{PyTuple_Pack(1, microsoft_ui_xaml_DependencyObject_type.get())};
    if (!AppBarTemplateSettings_bases)
    {
        return nullptr;
    }

    py::pytype_handle AppBarTemplateSettings_type{py::register_python_type(module.get(), &type_spec_AppBarTemplateSettings, AppBarTemplateSettings_bases.get(), nullptr)};
    if (!AppBarTemplateSettings_type)
    {
        return nullptr;
    }

    py::pyobj_handle AppBarToggleButtonTemplateSettings_bases{PyTuple_Pack(1, microsoft_ui_xaml_DependencyObject_type.get())};
    if (!AppBarToggleButtonTemplateSettings_bases)
    {
        return nullptr;
    }

    py::pytype_handle AppBarToggleButtonTemplateSettings_type{py::register_python_type(module.get(), &type_spec_AppBarToggleButtonTemplateSettings, AppBarToggleButtonTemplateSettings_bases.get(), nullptr)};
    if (!AppBarToggleButtonTemplateSettings_type)
    {
        return nullptr;
    }

    py::pyobj_handle type_AutoSuggestBoxHelper_Static{PyType_FromSpec(&type_spec_AutoSuggestBoxHelper_Static)};
    if (!type_AutoSuggestBoxHelper_Static)
    {
        return nullptr;
    }

    py::pytype_handle AutoSuggestBoxHelper_type{py::register_python_type(module.get(), &type_spec_AutoSuggestBoxHelper, object_bases.get(), reinterpret_cast<PyTypeObject*>(type_AutoSuggestBoxHelper_Static.get()))};
    if (!AutoSuggestBoxHelper_type)
    {
        return nullptr;
    }

    py::pyobj_handle ButtonBase_Static_bases{PyTuple_Pack(1, reinterpret_cast<PyObject*>(Py_TYPE(microsoft_ui_xaml_controls_ContentControl_type.get())))};
    if (!ButtonBase_Static_bases)
    {
        return nullptr;
    }

    py::pyobj_handle type_ButtonBase_Static{PyType_FromSpecWithBases(&type_spec_ButtonBase_Static, ButtonBase_Static_bases.get())};
    if (!type_ButtonBase_Static)
    {
        return nullptr;
    }

    py::pyobj_handle ButtonBase_bases{PyTuple_Pack(1, microsoft_ui_xaml_controls_ContentControl_type.get())};
    if (!ButtonBase_bases)
    {
        return nullptr;
    }

    py::pytype_handle ButtonBase_type{py::register_python_type(module.get(), &type_spec_ButtonBase, ButtonBase_bases.get(), reinterpret_cast<PyTypeObject*>(type_ButtonBase_Static.get()))};
    if (!ButtonBase_type)
    {
        return nullptr;
    }

    py::pyobj_handle CalendarPanel_bases{PyTuple_Pack(1, microsoft_ui_xaml_controls_Panel_type.get())};
    if (!CalendarPanel_bases)
    {
        return nullptr;
    }

    py::pytype_handle CalendarPanel_type{py::register_python_type(module.get(), &type_spec_CalendarPanel, CalendarPanel_bases.get(), nullptr)};
    if (!CalendarPanel_type)
    {
        return nullptr;
    }

    py::pyobj_handle CalendarViewTemplateSettings_bases{PyTuple_Pack(1, microsoft_ui_xaml_DependencyObject_type.get())};
    if (!CalendarViewTemplateSettings_bases)
    {
        return nullptr;
    }

    py::pytype_handle CalendarViewTemplateSettings_type{py::register_python_type(module.get(), &type_spec_CalendarViewTemplateSettings, CalendarViewTemplateSettings_bases.get(), nullptr)};
    if (!CalendarViewTemplateSettings_type)
    {
        return nullptr;
    }

    py::pyobj_handle CarouselPanel_Static_bases{PyTuple_Pack(1, reinterpret_cast<PyObject*>(Py_TYPE(microsoft_ui_xaml_controls_VirtualizingPanel_type.get())))};
    if (!CarouselPanel_Static_bases)
    {
        return nullptr;
    }

    py::pyobj_handle type_CarouselPanel_Static{PyType_FromSpecWithBases(&type_spec_CarouselPanel_Static, CarouselPanel_Static_bases.get())};
    if (!type_CarouselPanel_Static)
    {
        return nullptr;
    }

    py::pyobj_handle CarouselPanel_bases{PyTuple_Pack(1, microsoft_ui_xaml_controls_VirtualizingPanel_type.get())};
    if (!CarouselPanel_bases)
    {
        return nullptr;
    }

    py::pytype_handle CarouselPanel_type{py::register_python_type(module.get(), &type_spec_CarouselPanel, CarouselPanel_bases.get(), reinterpret_cast<PyTypeObject*>(type_CarouselPanel_Static.get()))};
    if (!CarouselPanel_type)
    {
        return nullptr;
    }

    py::pyobj_handle RangeBase_Static_bases{PyTuple_Pack(1, reinterpret_cast<PyObject*>(Py_TYPE(microsoft_ui_xaml_controls_Control_type.get())))};
    if (!RangeBase_Static_bases)
    {
        return nullptr;
    }

    py::pyobj_handle type_RangeBase_Static{PyType_FromSpecWithBases(&type_spec_RangeBase_Static, RangeBase_Static_bases.get())};
    if (!type_RangeBase_Static)
    {
        return nullptr;
    }

    py::pyobj_handle RangeBase_bases{PyTuple_Pack(1, microsoft_ui_xaml_controls_Control_type.get())};
    if (!RangeBase_bases)
    {
        return nullptr;
    }

    py::pytype_handle RangeBase_type{py::register_python_type(module.get(), &type_spec_RangeBase, RangeBase_bases.get(), reinterpret_cast<PyTypeObject*>(type_RangeBase_Static.get()))};
    if (!RangeBase_type)
    {
        return nullptr;
    }

    py::pyobj_handle ColorSpectrum_Static_bases{PyTuple_Pack(1, reinterpret_cast<PyObject*>(Py_TYPE(microsoft_ui_xaml_controls_Control_type.get())))};
    if (!ColorSpectrum_Static_bases)
    {
        return nullptr;
    }

    py::pyobj_handle type_ColorSpectrum_Static{PyType_FromSpecWithBases(&type_spec_ColorSpectrum_Static, ColorSpectrum_Static_bases.get())};
    if (!type_ColorSpectrum_Static)
    {
        return nullptr;
    }

    py::pyobj_handle ColorSpectrum_bases{PyTuple_Pack(1, microsoft_ui_xaml_controls_Control_type.get())};
    if (!ColorSpectrum_bases)
    {
        return nullptr;
    }

    py::pytype_handle ColorSpectrum_type{py::register_python_type(module.get(), &type_spec_ColorSpectrum, ColorSpectrum_bases.get(), reinterpret_cast<PyTypeObject*>(type_ColorSpectrum_Static.get()))};
    if (!ColorSpectrum_type)
    {
        return nullptr;
    }

    py::pyobj_handle ColumnMajorUniformToLargestGridLayout_Static_bases{PyTuple_Pack(1, reinterpret_cast<PyObject*>(Py_TYPE(microsoft_ui_xaml_controls_NonVirtualizingLayout_type.get())))};
    if (!ColumnMajorUniformToLargestGridLayout_Static_bases)
    {
        return nullptr;
    }

    py::pyobj_handle type_ColumnMajorUniformToLargestGridLayout_Static{PyType_FromSpecWithBases(&type_spec_ColumnMajorUniformToLargestGridLayout_Static, ColumnMajorUniformToLargestGridLayout_Static_bases.get())};
    if (!type_ColumnMajorUniformToLargestGridLayout_Static)
    {
        return nullptr;
    }

    py::pyobj_handle ColumnMajorUniformToLargestGridLayout_bases{PyTuple_Pack(1, microsoft_ui_xaml_controls_NonVirtualizingLayout_type.get())};
    if (!ColumnMajorUniformToLargestGridLayout_bases)
    {
        return nullptr;
    }

    py::pytype_handle ColumnMajorUniformToLargestGridLayout_type{py::register_python_type(module.get(), &type_spec_ColumnMajorUniformToLargestGridLayout, ColumnMajorUniformToLargestGridLayout_bases.get(), reinterpret_cast<PyTypeObject*>(type_ColumnMajorUniformToLargestGridLayout_Static.get()))};
    if (!ColumnMajorUniformToLargestGridLayout_type)
    {
        return nullptr;
    }

    py::pyobj_handle type_ComboBoxHelper_Static{PyType_FromSpec(&type_spec_ComboBoxHelper_Static)};
    if (!type_ComboBoxHelper_Static)
    {
        return nullptr;
    }

    py::pytype_handle ComboBoxHelper_type{py::register_python_type(module.get(), &type_spec_ComboBoxHelper, object_bases.get(), reinterpret_cast<PyTypeObject*>(type_ComboBoxHelper_Static.get()))};
    if (!ComboBoxHelper_type)
    {
        return nullptr;
    }

    py::pyobj_handle ComboBoxTemplateSettings_bases{PyTuple_Pack(1, microsoft_ui_xaml_DependencyObject_type.get())};
    if (!ComboBoxTemplateSettings_bases)
    {
        return nullptr;
    }

    py::pytype_handle ComboBoxTemplateSettings_type{py::register_python_type(module.get(), &type_spec_ComboBoxTemplateSettings, ComboBoxTemplateSettings_bases.get(), nullptr)};
    if (!ComboBoxTemplateSettings_type)
    {
        return nullptr;
    }

    py::pyobj_handle CommandBarFlyoutCommandBar_Static_bases{PyTuple_Pack(1, reinterpret_cast<PyObject*>(Py_TYPE(microsoft_ui_xaml_controls_CommandBar_type.get())))};
    if (!CommandBarFlyoutCommandBar_Static_bases)
    {
        return nullptr;
    }

    py::pyobj_handle type_CommandBarFlyoutCommandBar_Static{PyType_FromSpecWithBases(&type_spec_CommandBarFlyoutCommandBar_Static, CommandBarFlyoutCommandBar_Static_bases.get())};
    if (!type_CommandBarFlyoutCommandBar_Static)
    {
        return nullptr;
    }

    py::pyobj_handle CommandBarFlyoutCommandBar_bases{PyTuple_Pack(1, microsoft_ui_xaml_controls_CommandBar_type.get())};
    if (!CommandBarFlyoutCommandBar_bases)
    {
        return nullptr;
    }

    py::pytype_handle CommandBarFlyoutCommandBar_type{py::register_python_type(module.get(), &type_spec_CommandBarFlyoutCommandBar, CommandBarFlyoutCommandBar_bases.get(), reinterpret_cast<PyTypeObject*>(type_CommandBarFlyoutCommandBar_Static.get()))};
    if (!CommandBarFlyoutCommandBar_type)
    {
        return nullptr;
    }

    py::pyobj_handle type_CommandBarFlyoutCommandBarAutomationProperties_Static{PyType_FromSpec(&type_spec_CommandBarFlyoutCommandBarAutomationProperties_Static)};
    if (!type_CommandBarFlyoutCommandBarAutomationProperties_Static)
    {
        return nullptr;
    }

    py::pytype_handle CommandBarFlyoutCommandBarAutomationProperties_type{py::register_python_type(module.get(), &type_spec_CommandBarFlyoutCommandBarAutomationProperties, object_bases.get(), reinterpret_cast<PyTypeObject*>(type_CommandBarFlyoutCommandBarAutomationProperties_Static.get()))};
    if (!CommandBarFlyoutCommandBarAutomationProperties_type)
    {
        return nullptr;
    }

    py::pyobj_handle CommandBarFlyoutCommandBarTemplateSettings_bases{PyTuple_Pack(1, microsoft_ui_xaml_DependencyObject_type.get())};
    if (!CommandBarFlyoutCommandBarTemplateSettings_bases)
    {
        return nullptr;
    }

    py::pytype_handle CommandBarFlyoutCommandBarTemplateSettings_type{py::register_python_type(module.get(), &type_spec_CommandBarFlyoutCommandBarTemplateSettings, CommandBarFlyoutCommandBarTemplateSettings_bases.get(), nullptr)};
    if (!CommandBarFlyoutCommandBarTemplateSettings_type)
    {
        return nullptr;
    }

    py::pyobj_handle CommandBarTemplateSettings_bases{PyTuple_Pack(1, microsoft_ui_xaml_DependencyObject_type.get())};
    if (!CommandBarTemplateSettings_bases)
    {
        return nullptr;
    }

    py::pytype_handle CommandBarTemplateSettings_type{py::register_python_type(module.get(), &type_spec_CommandBarTemplateSettings, CommandBarTemplateSettings_bases.get(), nullptr)};
    if (!CommandBarTemplateSettings_type)
    {
        return nullptr;
    }

    py::pyobj_handle CornerRadiusFilterConverter_Static_bases{PyTuple_Pack(1, reinterpret_cast<PyObject*>(Py_TYPE(microsoft_ui_xaml_DependencyObject_type.get())))};
    if (!CornerRadiusFilterConverter_Static_bases)
    {
        return nullptr;
    }

    py::pyobj_handle type_CornerRadiusFilterConverter_Static{PyType_FromSpecWithBases(&type_spec_CornerRadiusFilterConverter_Static, CornerRadiusFilterConverter_Static_bases.get())};
    if (!type_CornerRadiusFilterConverter_Static)
    {
        return nullptr;
    }

    py::pyobj_handle CornerRadiusFilterConverter_bases{PyTuple_Pack(1, microsoft_ui_xaml_DependencyObject_type.get())};
    if (!CornerRadiusFilterConverter_bases)
    {
        return nullptr;
    }

    py::pytype_handle CornerRadiusFilterConverter_type{py::register_python_type(module.get(), &type_spec_CornerRadiusFilterConverter, CornerRadiusFilterConverter_bases.get(), reinterpret_cast<PyTypeObject*>(type_CornerRadiusFilterConverter_Static.get()))};
    if (!CornerRadiusFilterConverter_type)
    {
        return nullptr;
    }

    py::pyobj_handle CornerRadiusToThicknessConverter_Static_bases{PyTuple_Pack(1, reinterpret_cast<PyObject*>(Py_TYPE(microsoft_ui_xaml_DependencyObject_type.get())))};
    if (!CornerRadiusToThicknessConverter_Static_bases)
    {
        return nullptr;
    }

    py::pyobj_handle type_CornerRadiusToThicknessConverter_Static{PyType_FromSpecWithBases(&type_spec_CornerRadiusToThicknessConverter_Static, CornerRadiusToThicknessConverter_Static_bases.get())};
    if (!type_CornerRadiusToThicknessConverter_Static)
    {
        return nullptr;
    }

    py::pyobj_handle CornerRadiusToThicknessConverter_bases{PyTuple_Pack(1, microsoft_ui_xaml_DependencyObject_type.get())};
    if (!CornerRadiusToThicknessConverter_bases)
    {
        return nullptr;
    }

    py::pytype_handle CornerRadiusToThicknessConverter_type{py::register_python_type(module.get(), &type_spec_CornerRadiusToThicknessConverter, CornerRadiusToThicknessConverter_bases.get(), reinterpret_cast<PyTypeObject*>(type_CornerRadiusToThicknessConverter_Static.get()))};
    if (!CornerRadiusToThicknessConverter_type)
    {
        return nullptr;
    }

    py::pyobj_handle DragCompletedEventArgs_Static_bases{PyTuple_Pack(1, reinterpret_cast<PyObject*>(Py_TYPE(microsoft_ui_xaml_RoutedEventArgs_type.get())))};
    if (!DragCompletedEventArgs_Static_bases)
    {
        return nullptr;
    }

    py::pyobj_handle type_DragCompletedEventArgs_Static{PyType_FromSpecWithBases(&type_spec_DragCompletedEventArgs_Static, DragCompletedEventArgs_Static_bases.get())};
    if (!type_DragCompletedEventArgs_Static)
    {
        return nullptr;
    }

    py::pyobj_handle DragCompletedEventArgs_bases{PyTuple_Pack(1, microsoft_ui_xaml_RoutedEventArgs_type.get())};
    if (!DragCompletedEventArgs_bases)
    {
        return nullptr;
    }

    py::pytype_handle DragCompletedEventArgs_type{py::register_python_type(module.get(), &type_spec_DragCompletedEventArgs, DragCompletedEventArgs_bases.get(), reinterpret_cast<PyTypeObject*>(type_DragCompletedEventArgs_Static.get()))};
    if (!DragCompletedEventArgs_type)
    {
        return nullptr;
    }

    py::pyobj_handle DragDeltaEventArgs_Static_bases{PyTuple_Pack(1, reinterpret_cast<PyObject*>(Py_TYPE(microsoft_ui_xaml_RoutedEventArgs_type.get())))};
    if (!DragDeltaEventArgs_Static_bases)
    {
        return nullptr;
    }

    py::pyobj_handle type_DragDeltaEventArgs_Static{PyType_FromSpecWithBases(&type_spec_DragDeltaEventArgs_Static, DragDeltaEventArgs_Static_bases.get())};
    if (!type_DragDeltaEventArgs_Static)
    {
        return nullptr;
    }

    py::pyobj_handle DragDeltaEventArgs_bases{PyTuple_Pack(1, microsoft_ui_xaml_RoutedEventArgs_type.get())};
    if (!DragDeltaEventArgs_bases)
    {
        return nullptr;
    }

    py::pytype_handle DragDeltaEventArgs_type{py::register_python_type(module.get(), &type_spec_DragDeltaEventArgs, DragDeltaEventArgs_bases.get(), reinterpret_cast<PyTypeObject*>(type_DragDeltaEventArgs_Static.get()))};
    if (!DragDeltaEventArgs_type)
    {
        return nullptr;
    }

    py::pyobj_handle DragStartedEventArgs_Static_bases{PyTuple_Pack(1, reinterpret_cast<PyObject*>(Py_TYPE(microsoft_ui_xaml_RoutedEventArgs_type.get())))};
    if (!DragStartedEventArgs_Static_bases)
    {
        return nullptr;
    }

    py::pyobj_handle type_DragStartedEventArgs_Static{PyType_FromSpecWithBases(&type_spec_DragStartedEventArgs_Static, DragStartedEventArgs_Static_bases.get())};
    if (!type_DragStartedEventArgs_Static)
    {
        return nullptr;
    }

    py::pyobj_handle DragStartedEventArgs_bases{PyTuple_Pack(1, microsoft_ui_xaml_RoutedEventArgs_type.get())};
    if (!DragStartedEventArgs_bases)
    {
        return nullptr;
    }

    py::pytype_handle DragStartedEventArgs_type{py::register_python_type(module.get(), &type_spec_DragStartedEventArgs, DragStartedEventArgs_bases.get(), reinterpret_cast<PyTypeObject*>(type_DragStartedEventArgs_Static.get()))};
    if (!DragStartedEventArgs_type)
    {
        return nullptr;
    }

    py::pyobj_handle FlyoutBase_Static_bases{PyTuple_Pack(1, reinterpret_cast<PyObject*>(Py_TYPE(microsoft_ui_xaml_DependencyObject_type.get())))};
    if (!FlyoutBase_Static_bases)
    {
        return nullptr;
    }

    py::pyobj_handle type_FlyoutBase_Static{PyType_FromSpecWithBases(&type_spec_FlyoutBase_Static, FlyoutBase_Static_bases.get())};
    if (!type_FlyoutBase_Static)
    {
        return nullptr;
    }

    py::pyobj_handle FlyoutBase_bases{PyTuple_Pack(1, microsoft_ui_xaml_DependencyObject_type.get())};
    if (!FlyoutBase_bases)
    {
        return nullptr;
    }

    py::pytype_handle FlyoutBase_type{py::register_python_type(module.get(), &type_spec_FlyoutBase, FlyoutBase_bases.get(), reinterpret_cast<PyTypeObject*>(type_FlyoutBase_Static.get()))};
    if (!FlyoutBase_type)
    {
        return nullptr;
    }

    py::pytype_handle FlyoutBaseClosingEventArgs_type{py::register_python_type(module.get(), &type_spec_FlyoutBaseClosingEventArgs, object_bases.get(), nullptr)};
    if (!FlyoutBaseClosingEventArgs_type)
    {
        return nullptr;
    }

    py::pyobj_handle type_FlyoutShowOptions_Static{PyType_FromSpec(&type_spec_FlyoutShowOptions_Static)};
    if (!type_FlyoutShowOptions_Static)
    {
        return nullptr;
    }

    py::pytype_handle FlyoutShowOptions_type{py::register_python_type(module.get(), &type_spec_FlyoutShowOptions, object_bases.get(), reinterpret_cast<PyTypeObject*>(type_FlyoutShowOptions_Static.get()))};
    if (!FlyoutShowOptions_type)
    {
        return nullptr;
    }

    py::pyobj_handle type_GeneratorPositionHelper_Static{PyType_FromSpec(&type_spec_GeneratorPositionHelper_Static)};
    if (!type_GeneratorPositionHelper_Static)
    {
        return nullptr;
    }

    py::pytype_handle GeneratorPositionHelper_type{py::register_python_type(module.get(), &type_spec_GeneratorPositionHelper, object_bases.get(), reinterpret_cast<PyTypeObject*>(type_GeneratorPositionHelper_Static.get()))};
    if (!GeneratorPositionHelper_type)
    {
        return nullptr;
    }

    py::pyobj_handle GridViewItemPresenter_Static_bases{PyTuple_Pack(1, reinterpret_cast<PyObject*>(Py_TYPE(microsoft_ui_xaml_controls_ContentPresenter_type.get())))};
    if (!GridViewItemPresenter_Static_bases)
    {
        return nullptr;
    }

    py::pyobj_handle type_GridViewItemPresenter_Static{PyType_FromSpecWithBases(&type_spec_GridViewItemPresenter_Static, GridViewItemPresenter_Static_bases.get())};
    if (!type_GridViewItemPresenter_Static)
    {
        return nullptr;
    }

    py::pyobj_handle GridViewItemPresenter_bases{PyTuple_Pack(1, microsoft_ui_xaml_controls_ContentPresenter_type.get())};
    if (!GridViewItemPresenter_bases)
    {
        return nullptr;
    }

    py::pytype_handle GridViewItemPresenter_type{py::register_python_type(module.get(), &type_spec_GridViewItemPresenter, GridViewItemPresenter_bases.get(), reinterpret_cast<PyTypeObject*>(type_GridViewItemPresenter_Static.get()))};
    if (!GridViewItemPresenter_type)
    {
        return nullptr;
    }

    py::pyobj_handle GridViewItemTemplateSettings_bases{PyTuple_Pack(1, microsoft_ui_xaml_DependencyObject_type.get())};
    if (!GridViewItemTemplateSettings_bases)
    {
        return nullptr;
    }

    py::pytype_handle GridViewItemTemplateSettings_type{py::register_python_type(module.get(), &type_spec_GridViewItemTemplateSettings, GridViewItemTemplateSettings_bases.get(), nullptr)};
    if (!GridViewItemTemplateSettings_type)
    {
        return nullptr;
    }

    py::pyobj_handle InfoBarPanel_Static_bases{PyTuple_Pack(1, reinterpret_cast<PyObject*>(Py_TYPE(microsoft_ui_xaml_controls_Panel_type.get())))};
    if (!InfoBarPanel_Static_bases)
    {
        return nullptr;
    }

    py::pyobj_handle type_InfoBarPanel_Static{PyType_FromSpecWithBases(&type_spec_InfoBarPanel_Static, InfoBarPanel_Static_bases.get())};
    if (!type_InfoBarPanel_Static)
    {
        return nullptr;
    }

    py::pyobj_handle InfoBarPanel_bases{PyTuple_Pack(1, microsoft_ui_xaml_controls_Panel_type.get())};
    if (!InfoBarPanel_bases)
    {
        return nullptr;
    }

    py::pytype_handle InfoBarPanel_type{py::register_python_type(module.get(), &type_spec_InfoBarPanel, InfoBarPanel_bases.get(), reinterpret_cast<PyTypeObject*>(type_InfoBarPanel_Static.get()))};
    if (!InfoBarPanel_type)
    {
        return nullptr;
    }

    py::pytype_handle ItemsChangedEventArgs_type{py::register_python_type(module.get(), &type_spec_ItemsChangedEventArgs, object_bases.get(), nullptr)};
    if (!ItemsChangedEventArgs_type)
    {
        return nullptr;
    }

    py::pyobj_handle JumpListItemBackgroundConverter_Static_bases{PyTuple_Pack(1, reinterpret_cast<PyObject*>(Py_TYPE(microsoft_ui_xaml_DependencyObject_type.get())))};
    if (!JumpListItemBackgroundConverter_Static_bases)
    {
        return nullptr;
    }

    py::pyobj_handle type_JumpListItemBackgroundConverter_Static{PyType_FromSpecWithBases(&type_spec_JumpListItemBackgroundConverter_Static, JumpListItemBackgroundConverter_Static_bases.get())};
    if (!type_JumpListItemBackgroundConverter_Static)
    {
        return nullptr;
    }

    py::pyobj_handle JumpListItemBackgroundConverter_bases{PyTuple_Pack(1, microsoft_ui_xaml_DependencyObject_type.get())};
    if (!JumpListItemBackgroundConverter_bases)
    {
        return nullptr;
    }

    py::pytype_handle JumpListItemBackgroundConverter_type{py::register_python_type(module.get(), &type_spec_JumpListItemBackgroundConverter, JumpListItemBackgroundConverter_bases.get(), reinterpret_cast<PyTypeObject*>(type_JumpListItemBackgroundConverter_Static.get()))};
    if (!JumpListItemBackgroundConverter_type)
    {
        return nullptr;
    }

    py::pyobj_handle JumpListItemForegroundConverter_Static_bases{PyTuple_Pack(1, reinterpret_cast<PyObject*>(Py_TYPE(microsoft_ui_xaml_DependencyObject_type.get())))};
    if (!JumpListItemForegroundConverter_Static_bases)
    {
        return nullptr;
    }

    py::pyobj_handle type_JumpListItemForegroundConverter_Static{PyType_FromSpecWithBases(&type_spec_JumpListItemForegroundConverter_Static, JumpListItemForegroundConverter_Static_bases.get())};
    if (!type_JumpListItemForegroundConverter_Static)
    {
        return nullptr;
    }

    py::pyobj_handle JumpListItemForegroundConverter_bases{PyTuple_Pack(1, microsoft_ui_xaml_DependencyObject_type.get())};
    if (!JumpListItemForegroundConverter_bases)
    {
        return nullptr;
    }

    py::pytype_handle JumpListItemForegroundConverter_type{py::register_python_type(module.get(), &type_spec_JumpListItemForegroundConverter, JumpListItemForegroundConverter_bases.get(), reinterpret_cast<PyTypeObject*>(type_JumpListItemForegroundConverter_Static.get()))};
    if (!JumpListItemForegroundConverter_type)
    {
        return nullptr;
    }

    py::pyobj_handle type_LayoutInformation_Static{PyType_FromSpec(&type_spec_LayoutInformation_Static)};
    if (!type_LayoutInformation_Static)
    {
        return nullptr;
    }

    py::pytype_handle LayoutInformation_type{py::register_python_type(module.get(), &type_spec_LayoutInformation, object_bases.get(), reinterpret_cast<PyTypeObject*>(type_LayoutInformation_Static.get()))};
    if (!LayoutInformation_type)
    {
        return nullptr;
    }

    py::pyobj_handle ListViewItemPresenter_Static_bases{PyTuple_Pack(1, reinterpret_cast<PyObject*>(Py_TYPE(microsoft_ui_xaml_controls_ContentPresenter_type.get())))};
    if (!ListViewItemPresenter_Static_bases)
    {
        return nullptr;
    }

    py::pyobj_handle type_ListViewItemPresenter_Static{PyType_FromSpecWithBases(&type_spec_ListViewItemPresenter_Static, ListViewItemPresenter_Static_bases.get())};
    if (!type_ListViewItemPresenter_Static)
    {
        return nullptr;
    }

    py::pyobj_handle ListViewItemPresenter_bases{PyTuple_Pack(1, microsoft_ui_xaml_controls_ContentPresenter_type.get())};
    if (!ListViewItemPresenter_bases)
    {
        return nullptr;
    }

    py::pytype_handle ListViewItemPresenter_type{py::register_python_type(module.get(), &type_spec_ListViewItemPresenter, ListViewItemPresenter_bases.get(), reinterpret_cast<PyTypeObject*>(type_ListViewItemPresenter_Static.get()))};
    if (!ListViewItemPresenter_type)
    {
        return nullptr;
    }

    py::pyobj_handle ListViewItemTemplateSettings_bases{PyTuple_Pack(1, microsoft_ui_xaml_DependencyObject_type.get())};
    if (!ListViewItemTemplateSettings_bases)
    {
        return nullptr;
    }

    py::pytype_handle ListViewItemTemplateSettings_type{py::register_python_type(module.get(), &type_spec_ListViewItemTemplateSettings, ListViewItemTemplateSettings_bases.get(), nullptr)};
    if (!ListViewItemTemplateSettings_type)
    {
        return nullptr;
    }

    py::pyobj_handle LoopingSelector_Static_bases{PyTuple_Pack(1, reinterpret_cast<PyObject*>(Py_TYPE(microsoft_ui_xaml_controls_Control_type.get())))};
    if (!LoopingSelector_Static_bases)
    {
        return nullptr;
    }

    py::pyobj_handle type_LoopingSelector_Static{PyType_FromSpecWithBases(&type_spec_LoopingSelector_Static, LoopingSelector_Static_bases.get())};
    if (!type_LoopingSelector_Static)
    {
        return nullptr;
    }

    py::pyobj_handle LoopingSelector_bases{PyTuple_Pack(1, microsoft_ui_xaml_controls_Control_type.get())};
    if (!LoopingSelector_bases)
    {
        return nullptr;
    }

    py::pytype_handle LoopingSelector_type{py::register_python_type(module.get(), &type_spec_LoopingSelector, LoopingSelector_bases.get(), reinterpret_cast<PyTypeObject*>(type_LoopingSelector_Static.get()))};
    if (!LoopingSelector_type)
    {
        return nullptr;
    }

    py::pyobj_handle LoopingSelectorItem_bases{PyTuple_Pack(1, microsoft_ui_xaml_controls_ContentControl_type.get())};
    if (!LoopingSelectorItem_bases)
    {
        return nullptr;
    }

    py::pytype_handle LoopingSelectorItem_type{py::register_python_type(module.get(), &type_spec_LoopingSelectorItem, LoopingSelectorItem_bases.get(), nullptr)};
    if (!LoopingSelectorItem_type)
    {
        return nullptr;
    }

    py::pyobj_handle LoopingSelectorPanel_bases{PyTuple_Pack(1, microsoft_ui_xaml_controls_Canvas_type.get())};
    if (!LoopingSelectorPanel_bases)
    {
        return nullptr;
    }

    py::pytype_handle LoopingSelectorPanel_type{py::register_python_type(module.get(), &type_spec_LoopingSelectorPanel, LoopingSelectorPanel_bases.get(), nullptr)};
    if (!LoopingSelectorPanel_type)
    {
        return nullptr;
    }

    py::pyobj_handle MenuFlyoutItemTemplateSettings_bases{PyTuple_Pack(1, microsoft_ui_xaml_DependencyObject_type.get())};
    if (!MenuFlyoutItemTemplateSettings_bases)
    {
        return nullptr;
    }

    py::pytype_handle MenuFlyoutItemTemplateSettings_type{py::register_python_type(module.get(), &type_spec_MenuFlyoutItemTemplateSettings, MenuFlyoutItemTemplateSettings_bases.get(), nullptr)};
    if (!MenuFlyoutItemTemplateSettings_type)
    {
        return nullptr;
    }

    py::pyobj_handle MenuFlyoutPresenterTemplateSettings_bases{PyTuple_Pack(1, microsoft_ui_xaml_DependencyObject_type.get())};
    if (!MenuFlyoutPresenterTemplateSettings_bases)
    {
        return nullptr;
    }

    py::pytype_handle MenuFlyoutPresenterTemplateSettings_type{py::register_python_type(module.get(), &type_spec_MenuFlyoutPresenterTemplateSettings, MenuFlyoutPresenterTemplateSettings_bases.get(), nullptr)};
    if (!MenuFlyoutPresenterTemplateSettings_type)
    {
        return nullptr;
    }

    py::pyobj_handle MonochromaticOverlayPresenter_Static_bases{PyTuple_Pack(1, reinterpret_cast<PyObject*>(Py_TYPE(microsoft_ui_xaml_controls_Grid_type.get())))};
    if (!MonochromaticOverlayPresenter_Static_bases)
    {
        return nullptr;
    }

    py::pyobj_handle type_MonochromaticOverlayPresenter_Static{PyType_FromSpecWithBases(&type_spec_MonochromaticOverlayPresenter_Static, MonochromaticOverlayPresenter_Static_bases.get())};
    if (!type_MonochromaticOverlayPresenter_Static)
    {
        return nullptr;
    }

    py::pyobj_handle MonochromaticOverlayPresenter_bases{PyTuple_Pack(1, microsoft_ui_xaml_controls_Grid_type.get())};
    if (!MonochromaticOverlayPresenter_bases)
    {
        return nullptr;
    }

    py::pytype_handle MonochromaticOverlayPresenter_type{py::register_python_type(module.get(), &type_spec_MonochromaticOverlayPresenter, MonochromaticOverlayPresenter_bases.get(), reinterpret_cast<PyTypeObject*>(type_MonochromaticOverlayPresenter_Static.get()))};
    if (!MonochromaticOverlayPresenter_type)
    {
        return nullptr;
    }

    py::pyobj_handle NavigationViewItemPresenter_Static_bases{PyTuple_Pack(1, reinterpret_cast<PyObject*>(Py_TYPE(microsoft_ui_xaml_controls_ContentControl_type.get())))};
    if (!NavigationViewItemPresenter_Static_bases)
    {
        return nullptr;
    }

    py::pyobj_handle type_NavigationViewItemPresenter_Static{PyType_FromSpecWithBases(&type_spec_NavigationViewItemPresenter_Static, NavigationViewItemPresenter_Static_bases.get())};
    if (!type_NavigationViewItemPresenter_Static)
    {
        return nullptr;
    }

    py::pyobj_handle NavigationViewItemPresenter_bases{PyTuple_Pack(1, microsoft_ui_xaml_controls_ContentControl_type.get())};
    if (!NavigationViewItemPresenter_bases)
    {
        return nullptr;
    }

    py::pytype_handle NavigationViewItemPresenter_type{py::register_python_type(module.get(), &type_spec_NavigationViewItemPresenter, NavigationViewItemPresenter_bases.get(), reinterpret_cast<PyTypeObject*>(type_NavigationViewItemPresenter_Static.get()))};
    if (!NavigationViewItemPresenter_type)
    {
        return nullptr;
    }

    py::pyobj_handle NavigationViewItemPresenterTemplateSettings_Static_bases{PyTuple_Pack(1, reinterpret_cast<PyObject*>(Py_TYPE(microsoft_ui_xaml_DependencyObject_type.get())))};
    if (!NavigationViewItemPresenterTemplateSettings_Static_bases)
    {
        return nullptr;
    }

    py::pyobj_handle type_NavigationViewItemPresenterTemplateSettings_Static{PyType_FromSpecWithBases(&type_spec_NavigationViewItemPresenterTemplateSettings_Static, NavigationViewItemPresenterTemplateSettings_Static_bases.get())};
    if (!type_NavigationViewItemPresenterTemplateSettings_Static)
    {
        return nullptr;
    }

    py::pyobj_handle NavigationViewItemPresenterTemplateSettings_bases{PyTuple_Pack(1, microsoft_ui_xaml_DependencyObject_type.get())};
    if (!NavigationViewItemPresenterTemplateSettings_bases)
    {
        return nullptr;
    }

    py::pytype_handle NavigationViewItemPresenterTemplateSettings_type{py::register_python_type(module.get(), &type_spec_NavigationViewItemPresenterTemplateSettings, NavigationViewItemPresenterTemplateSettings_bases.get(), reinterpret_cast<PyTypeObject*>(type_NavigationViewItemPresenterTemplateSettings_Static.get()))};
    if (!NavigationViewItemPresenterTemplateSettings_type)
    {
        return nullptr;
    }

    py::pyobj_handle OrientedVirtualizingPanel_Static_bases{PyTuple_Pack(1, reinterpret_cast<PyObject*>(Py_TYPE(microsoft_ui_xaml_controls_VirtualizingPanel_type.get())))};
    if (!OrientedVirtualizingPanel_Static_bases)
    {
        return nullptr;
    }

    py::pyobj_handle type_OrientedVirtualizingPanel_Static{PyType_FromSpecWithBases(&type_spec_OrientedVirtualizingPanel_Static, OrientedVirtualizingPanel_Static_bases.get())};
    if (!type_OrientedVirtualizingPanel_Static)
    {
        return nullptr;
    }

    py::pyobj_handle OrientedVirtualizingPanel_bases{PyTuple_Pack(1, microsoft_ui_xaml_controls_VirtualizingPanel_type.get())};
    if (!OrientedVirtualizingPanel_bases)
    {
        return nullptr;
    }

    py::pytype_handle OrientedVirtualizingPanel_type{py::register_python_type(module.get(), &type_spec_OrientedVirtualizingPanel, OrientedVirtualizingPanel_bases.get(), reinterpret_cast<PyTypeObject*>(type_OrientedVirtualizingPanel_Static.get()))};
    if (!OrientedVirtualizingPanel_type)
    {
        return nullptr;
    }

    py::pyobj_handle PickerFlyoutBase_Static_bases{PyTuple_Pack(1, reinterpret_cast<PyObject*>(Py_TYPE(FlyoutBase_type.get())))};
    if (!PickerFlyoutBase_Static_bases)
    {
        return nullptr;
    }

    py::pyobj_handle type_PickerFlyoutBase_Static{PyType_FromSpecWithBases(&type_spec_PickerFlyoutBase_Static, PickerFlyoutBase_Static_bases.get())};
    if (!type_PickerFlyoutBase_Static)
    {
        return nullptr;
    }

    py::pyobj_handle PickerFlyoutBase_bases{PyTuple_Pack(1, FlyoutBase_type.get())};
    if (!PickerFlyoutBase_bases)
    {
        return nullptr;
    }

    py::pytype_handle PickerFlyoutBase_type{py::register_python_type(module.get(), &type_spec_PickerFlyoutBase, PickerFlyoutBase_bases.get(), reinterpret_cast<PyTypeObject*>(type_PickerFlyoutBase_Static.get()))};
    if (!PickerFlyoutBase_type)
    {
        return nullptr;
    }

    py::pyobj_handle PivotHeaderItem_Static_bases{PyTuple_Pack(1, reinterpret_cast<PyObject*>(Py_TYPE(microsoft_ui_xaml_controls_ContentControl_type.get())))};
    if (!PivotHeaderItem_Static_bases)
    {
        return nullptr;
    }

    py::pyobj_handle type_PivotHeaderItem_Static{PyType_FromSpecWithBases(&type_spec_PivotHeaderItem_Static, PivotHeaderItem_Static_bases.get())};
    if (!type_PivotHeaderItem_Static)
    {
        return nullptr;
    }

    py::pyobj_handle PivotHeaderItem_bases{PyTuple_Pack(1, microsoft_ui_xaml_controls_ContentControl_type.get())};
    if (!PivotHeaderItem_bases)
    {
        return nullptr;
    }

    py::pytype_handle PivotHeaderItem_type{py::register_python_type(module.get(), &type_spec_PivotHeaderItem, PivotHeaderItem_bases.get(), reinterpret_cast<PyTypeObject*>(type_PivotHeaderItem_Static.get()))};
    if (!PivotHeaderItem_type)
    {
        return nullptr;
    }

    py::pyobj_handle PivotHeaderPanel_bases{PyTuple_Pack(1, microsoft_ui_xaml_controls_Canvas_type.get())};
    if (!PivotHeaderPanel_bases)
    {
        return nullptr;
    }

    py::pytype_handle PivotHeaderPanel_type{py::register_python_type(module.get(), &type_spec_PivotHeaderPanel, PivotHeaderPanel_bases.get(), nullptr)};
    if (!PivotHeaderPanel_type)
    {
        return nullptr;
    }

    py::pyobj_handle PivotPanel_bases{PyTuple_Pack(1, microsoft_ui_xaml_controls_Panel_type.get())};
    if (!PivotPanel_bases)
    {
        return nullptr;
    }

    py::pytype_handle PivotPanel_type{py::register_python_type(module.get(), &type_spec_PivotPanel, PivotPanel_bases.get(), nullptr)};
    if (!PivotPanel_type)
    {
        return nullptr;
    }

    py::pyobj_handle Popup_Static_bases{PyTuple_Pack(1, reinterpret_cast<PyObject*>(Py_TYPE(microsoft_ui_xaml_FrameworkElement_type.get())))};
    if (!Popup_Static_bases)
    {
        return nullptr;
    }

    py::pyobj_handle type_Popup_Static{PyType_FromSpecWithBases(&type_spec_Popup_Static, Popup_Static_bases.get())};
    if (!type_Popup_Static)
    {
        return nullptr;
    }

    py::pyobj_handle Popup_bases{PyTuple_Pack(1, microsoft_ui_xaml_FrameworkElement_type.get())};
    if (!Popup_bases)
    {
        return nullptr;
    }

    py::pytype_handle Popup_type{py::register_python_type(module.get(), &type_spec_Popup, Popup_bases.get(), reinterpret_cast<PyTypeObject*>(type_Popup_Static.get()))};
    if (!Popup_type)
    {
        return nullptr;
    }

    py::pyobj_handle RangeBaseValueChangedEventArgs_bases{PyTuple_Pack(1, microsoft_ui_xaml_RoutedEventArgs_type.get())};
    if (!RangeBaseValueChangedEventArgs_bases)
    {
        return nullptr;
    }

    py::pytype_handle RangeBaseValueChangedEventArgs_type{py::register_python_type(module.get(), &type_spec_RangeBaseValueChangedEventArgs, RangeBaseValueChangedEventArgs_bases.get(), nullptr)};
    if (!RangeBaseValueChangedEventArgs_type)
    {
        return nullptr;
    }

    py::pyobj_handle RepeatButton_Static_bases{PyTuple_Pack(1, reinterpret_cast<PyObject*>(Py_TYPE(ButtonBase_type.get())))};
    if (!RepeatButton_Static_bases)
    {
        return nullptr;
    }

    py::pyobj_handle type_RepeatButton_Static{PyType_FromSpecWithBases(&type_spec_RepeatButton_Static, RepeatButton_Static_bases.get())};
    if (!type_RepeatButton_Static)
    {
        return nullptr;
    }

    py::pyobj_handle RepeatButton_bases{PyTuple_Pack(1, ButtonBase_type.get())};
    if (!RepeatButton_bases)
    {
        return nullptr;
    }

    py::pytype_handle RepeatButton_type{py::register_python_type(module.get(), &type_spec_RepeatButton, RepeatButton_bases.get(), reinterpret_cast<PyTypeObject*>(type_RepeatButton_Static.get()))};
    if (!RepeatButton_type)
    {
        return nullptr;
    }

    py::pyobj_handle type_SnapPointBase_Static{PyType_FromSpec(&type_spec_SnapPointBase_Static)};
    if (!type_SnapPointBase_Static)
    {
        return nullptr;
    }

    py::pytype_handle SnapPointBase_type{py::register_python_type(module.get(), &type_spec_SnapPointBase, object_bases.get(), reinterpret_cast<PyTypeObject*>(type_SnapPointBase_Static.get()))};
    if (!SnapPointBase_type)
    {
        return nullptr;
    }

    py::pyobj_handle ScrollSnapPointBase_Static_bases{PyTuple_Pack(1, reinterpret_cast<PyObject*>(Py_TYPE(SnapPointBase_type.get())))};
    if (!ScrollSnapPointBase_Static_bases)
    {
        return nullptr;
    }

    py::pyobj_handle type_ScrollSnapPointBase_Static{PyType_FromSpecWithBases(&type_spec_ScrollSnapPointBase_Static, ScrollSnapPointBase_Static_bases.get())};
    if (!type_ScrollSnapPointBase_Static)
    {
        return nullptr;
    }

    py::pyobj_handle ScrollSnapPointBase_bases{PyTuple_Pack(1, SnapPointBase_type.get())};
    if (!ScrollSnapPointBase_bases)
    {
        return nullptr;
    }

    py::pytype_handle ScrollSnapPointBase_type{py::register_python_type(module.get(), &type_spec_ScrollSnapPointBase, ScrollSnapPointBase_bases.get(), reinterpret_cast<PyTypeObject*>(type_ScrollSnapPointBase_Static.get()))};
    if (!ScrollSnapPointBase_type)
    {
        return nullptr;
    }

    py::pyobj_handle RepeatedScrollSnapPoint_Static_bases{PyTuple_Pack(1, reinterpret_cast<PyObject*>(Py_TYPE(ScrollSnapPointBase_type.get())))};
    if (!RepeatedScrollSnapPoint_Static_bases)
    {
        return nullptr;
    }

    py::pyobj_handle type_RepeatedScrollSnapPoint_Static{PyType_FromSpecWithBases(&type_spec_RepeatedScrollSnapPoint_Static, RepeatedScrollSnapPoint_Static_bases.get())};
    if (!type_RepeatedScrollSnapPoint_Static)
    {
        return nullptr;
    }

    py::pyobj_handle RepeatedScrollSnapPoint_bases{PyTuple_Pack(1, ScrollSnapPointBase_type.get())};
    if (!RepeatedScrollSnapPoint_bases)
    {
        return nullptr;
    }

    py::pytype_handle RepeatedScrollSnapPoint_type{py::register_python_type(module.get(), &type_spec_RepeatedScrollSnapPoint, RepeatedScrollSnapPoint_bases.get(), reinterpret_cast<PyTypeObject*>(type_RepeatedScrollSnapPoint_Static.get()))};
    if (!RepeatedScrollSnapPoint_type)
    {
        return nullptr;
    }

    py::pyobj_handle ZoomSnapPointBase_Static_bases{PyTuple_Pack(1, reinterpret_cast<PyObject*>(Py_TYPE(SnapPointBase_type.get())))};
    if (!ZoomSnapPointBase_Static_bases)
    {
        return nullptr;
    }

    py::pyobj_handle type_ZoomSnapPointBase_Static{PyType_FromSpecWithBases(&type_spec_ZoomSnapPointBase_Static, ZoomSnapPointBase_Static_bases.get())};
    if (!type_ZoomSnapPointBase_Static)
    {
        return nullptr;
    }

    py::pyobj_handle ZoomSnapPointBase_bases{PyTuple_Pack(1, SnapPointBase_type.get())};
    if (!ZoomSnapPointBase_bases)
    {
        return nullptr;
    }

    py::pytype_handle ZoomSnapPointBase_type{py::register_python_type(module.get(), &type_spec_ZoomSnapPointBase, ZoomSnapPointBase_bases.get(), reinterpret_cast<PyTypeObject*>(type_ZoomSnapPointBase_Static.get()))};
    if (!ZoomSnapPointBase_type)
    {
        return nullptr;
    }

    py::pyobj_handle RepeatedZoomSnapPoint_Static_bases{PyTuple_Pack(1, reinterpret_cast<PyObject*>(Py_TYPE(ZoomSnapPointBase_type.get())))};
    if (!RepeatedZoomSnapPoint_Static_bases)
    {
        return nullptr;
    }

    py::pyobj_handle type_RepeatedZoomSnapPoint_Static{PyType_FromSpecWithBases(&type_spec_RepeatedZoomSnapPoint_Static, RepeatedZoomSnapPoint_Static_bases.get())};
    if (!type_RepeatedZoomSnapPoint_Static)
    {
        return nullptr;
    }

    py::pyobj_handle RepeatedZoomSnapPoint_bases{PyTuple_Pack(1, ZoomSnapPointBase_type.get())};
    if (!RepeatedZoomSnapPoint_bases)
    {
        return nullptr;
    }

    py::pytype_handle RepeatedZoomSnapPoint_type{py::register_python_type(module.get(), &type_spec_RepeatedZoomSnapPoint, RepeatedZoomSnapPoint_bases.get(), reinterpret_cast<PyTypeObject*>(type_RepeatedZoomSnapPoint_Static.get()))};
    if (!RepeatedZoomSnapPoint_type)
    {
        return nullptr;
    }

    py::pyobj_handle ScrollBar_Static_bases{PyTuple_Pack(1, reinterpret_cast<PyObject*>(Py_TYPE(RangeBase_type.get())))};
    if (!ScrollBar_Static_bases)
    {
        return nullptr;
    }

    py::pyobj_handle type_ScrollBar_Static{PyType_FromSpecWithBases(&type_spec_ScrollBar_Static, ScrollBar_Static_bases.get())};
    if (!type_ScrollBar_Static)
    {
        return nullptr;
    }

    py::pyobj_handle ScrollBar_bases{PyTuple_Pack(1, RangeBase_type.get())};
    if (!ScrollBar_bases)
    {
        return nullptr;
    }

    py::pytype_handle ScrollBar_type{py::register_python_type(module.get(), &type_spec_ScrollBar, ScrollBar_bases.get(), reinterpret_cast<PyTypeObject*>(type_ScrollBar_Static.get()))};
    if (!ScrollBar_type)
    {
        return nullptr;
    }

    py::pytype_handle ScrollControllerAddScrollVelocityRequestedEventArgs_type{py::register_python_type(module.get(), &type_spec_ScrollControllerAddScrollVelocityRequestedEventArgs, object_bases.get(), nullptr)};
    if (!ScrollControllerAddScrollVelocityRequestedEventArgs_type)
    {
        return nullptr;
    }

    py::pytype_handle ScrollControllerPanRequestedEventArgs_type{py::register_python_type(module.get(), &type_spec_ScrollControllerPanRequestedEventArgs, object_bases.get(), nullptr)};
    if (!ScrollControllerPanRequestedEventArgs_type)
    {
        return nullptr;
    }

    py::pytype_handle ScrollControllerScrollByRequestedEventArgs_type{py::register_python_type(module.get(), &type_spec_ScrollControllerScrollByRequestedEventArgs, object_bases.get(), nullptr)};
    if (!ScrollControllerScrollByRequestedEventArgs_type)
    {
        return nullptr;
    }

    py::pytype_handle ScrollControllerScrollToRequestedEventArgs_type{py::register_python_type(module.get(), &type_spec_ScrollControllerScrollToRequestedEventArgs, object_bases.get(), nullptr)};
    if (!ScrollControllerScrollToRequestedEventArgs_type)
    {
        return nullptr;
    }

    py::pyobj_handle ScrollEventArgs_bases{PyTuple_Pack(1, microsoft_ui_xaml_RoutedEventArgs_type.get())};
    if (!ScrollEventArgs_bases)
    {
        return nullptr;
    }

    py::pytype_handle ScrollEventArgs_type{py::register_python_type(module.get(), &type_spec_ScrollEventArgs, ScrollEventArgs_bases.get(), nullptr)};
    if (!ScrollEventArgs_type)
    {
        return nullptr;
    }

    py::pyobj_handle ScrollPresenter_Static_bases{PyTuple_Pack(1, reinterpret_cast<PyObject*>(Py_TYPE(microsoft_ui_xaml_FrameworkElement_type.get())))};
    if (!ScrollPresenter_Static_bases)
    {
        return nullptr;
    }

    py::pyobj_handle type_ScrollPresenter_Static{PyType_FromSpecWithBases(&type_spec_ScrollPresenter_Static, ScrollPresenter_Static_bases.get())};
    if (!type_ScrollPresenter_Static)
    {
        return nullptr;
    }

    py::pyobj_handle ScrollPresenter_bases{PyTuple_Pack(1, microsoft_ui_xaml_FrameworkElement_type.get())};
    if (!ScrollPresenter_bases)
    {
        return nullptr;
    }

    py::pytype_handle ScrollPresenter_type{py::register_python_type(module.get(), &type_spec_ScrollPresenter, ScrollPresenter_bases.get(), reinterpret_cast<PyTypeObject*>(type_ScrollPresenter_Static.get()))};
    if (!ScrollPresenter_type)
    {
        return nullptr;
    }

    py::pyobj_handle ScrollSnapPoint_Static_bases{PyTuple_Pack(1, reinterpret_cast<PyObject*>(Py_TYPE(ScrollSnapPointBase_type.get())))};
    if (!ScrollSnapPoint_Static_bases)
    {
        return nullptr;
    }

    py::pyobj_handle type_ScrollSnapPoint_Static{PyType_FromSpecWithBases(&type_spec_ScrollSnapPoint_Static, ScrollSnapPoint_Static_bases.get())};
    if (!type_ScrollSnapPoint_Static)
    {
        return nullptr;
    }

    py::pyobj_handle ScrollSnapPoint_bases{PyTuple_Pack(1, ScrollSnapPointBase_type.get())};
    if (!ScrollSnapPoint_bases)
    {
        return nullptr;
    }

    py::pytype_handle ScrollSnapPoint_type{py::register_python_type(module.get(), &type_spec_ScrollSnapPoint, ScrollSnapPoint_bases.get(), reinterpret_cast<PyTypeObject*>(type_ScrollSnapPoint_Static.get()))};
    if (!ScrollSnapPoint_type)
    {
        return nullptr;
    }

    py::pyobj_handle Selector_Static_bases{PyTuple_Pack(1, reinterpret_cast<PyObject*>(Py_TYPE(microsoft_ui_xaml_controls_ItemsControl_type.get())))};
    if (!Selector_Static_bases)
    {
        return nullptr;
    }

    py::pyobj_handle type_Selector_Static{PyType_FromSpecWithBases(&type_spec_Selector_Static, Selector_Static_bases.get())};
    if (!type_Selector_Static)
    {
        return nullptr;
    }

    py::pyobj_handle Selector_bases{PyTuple_Pack(1, microsoft_ui_xaml_controls_ItemsControl_type.get())};
    if (!Selector_bases)
    {
        return nullptr;
    }

    py::pytype_handle Selector_type{py::register_python_type(module.get(), &type_spec_Selector, Selector_bases.get(), reinterpret_cast<PyTypeObject*>(type_Selector_Static.get()))};
    if (!Selector_type)
    {
        return nullptr;
    }

    py::pyobj_handle SelectorItem_Static_bases{PyTuple_Pack(1, reinterpret_cast<PyObject*>(Py_TYPE(microsoft_ui_xaml_controls_ContentControl_type.get())))};
    if (!SelectorItem_Static_bases)
    {
        return nullptr;
    }

    py::pyobj_handle type_SelectorItem_Static{PyType_FromSpecWithBases(&type_spec_SelectorItem_Static, SelectorItem_Static_bases.get())};
    if (!type_SelectorItem_Static)
    {
        return nullptr;
    }

    py::pyobj_handle SelectorItem_bases{PyTuple_Pack(1, microsoft_ui_xaml_controls_ContentControl_type.get())};
    if (!SelectorItem_bases)
    {
        return nullptr;
    }

    py::pytype_handle SelectorItem_type{py::register_python_type(module.get(), &type_spec_SelectorItem, SelectorItem_bases.get(), reinterpret_cast<PyTypeObject*>(type_SelectorItem_Static.get()))};
    if (!SelectorItem_type)
    {
        return nullptr;
    }

    py::pyobj_handle SplitViewTemplateSettings_bases{PyTuple_Pack(1, microsoft_ui_xaml_DependencyObject_type.get())};
    if (!SplitViewTemplateSettings_bases)
    {
        return nullptr;
    }

    py::pytype_handle SplitViewTemplateSettings_type{py::register_python_type(module.get(), &type_spec_SplitViewTemplateSettings, SplitViewTemplateSettings_bases.get(), nullptr)};
    if (!SplitViewTemplateSettings_type)
    {
        return nullptr;
    }

    py::pyobj_handle Thumb_Static_bases{PyTuple_Pack(1, reinterpret_cast<PyObject*>(Py_TYPE(microsoft_ui_xaml_controls_Control_type.get())))};
    if (!Thumb_Static_bases)
    {
        return nullptr;
    }

    py::pyobj_handle type_Thumb_Static{PyType_FromSpecWithBases(&type_spec_Thumb_Static, Thumb_Static_bases.get())};
    if (!type_Thumb_Static)
    {
        return nullptr;
    }

    py::pyobj_handle Thumb_bases{PyTuple_Pack(1, microsoft_ui_xaml_controls_Control_type.get())};
    if (!Thumb_bases)
    {
        return nullptr;
    }

    py::pytype_handle Thumb_type{py::register_python_type(module.get(), &type_spec_Thumb, Thumb_bases.get(), reinterpret_cast<PyTypeObject*>(type_Thumb_Static.get()))};
    if (!Thumb_type)
    {
        return nullptr;
    }

    py::pyobj_handle TickBar_Static_bases{PyTuple_Pack(1, reinterpret_cast<PyObject*>(Py_TYPE(microsoft_ui_xaml_FrameworkElement_type.get())))};
    if (!TickBar_Static_bases)
    {
        return nullptr;
    }

    py::pyobj_handle type_TickBar_Static{PyType_FromSpecWithBases(&type_spec_TickBar_Static, TickBar_Static_bases.get())};
    if (!type_TickBar_Static)
    {
        return nullptr;
    }

    py::pyobj_handle TickBar_bases{PyTuple_Pack(1, microsoft_ui_xaml_FrameworkElement_type.get())};
    if (!TickBar_bases)
    {
        return nullptr;
    }

    py::pytype_handle TickBar_type{py::register_python_type(module.get(), &type_spec_TickBar, TickBar_bases.get(), reinterpret_cast<PyTypeObject*>(type_TickBar_Static.get()))};
    if (!TickBar_type)
    {
        return nullptr;
    }

    py::pyobj_handle ToggleButton_Static_bases{PyTuple_Pack(1, reinterpret_cast<PyObject*>(Py_TYPE(ButtonBase_type.get())))};
    if (!ToggleButton_Static_bases)
    {
        return nullptr;
    }

    py::pyobj_handle type_ToggleButton_Static{PyType_FromSpecWithBases(&type_spec_ToggleButton_Static, ToggleButton_Static_bases.get())};
    if (!type_ToggleButton_Static)
    {
        return nullptr;
    }

    py::pyobj_handle ToggleButton_bases{PyTuple_Pack(1, ButtonBase_type.get())};
    if (!ToggleButton_bases)
    {
        return nullptr;
    }

    py::pytype_handle ToggleButton_type{py::register_python_type(module.get(), &type_spec_ToggleButton, ToggleButton_bases.get(), reinterpret_cast<PyTypeObject*>(type_ToggleButton_Static.get()))};
    if (!ToggleButton_type)
    {
        return nullptr;
    }

    py::pyobj_handle ToggleSwitchTemplateSettings_bases{PyTuple_Pack(1, microsoft_ui_xaml_DependencyObject_type.get())};
    if (!ToggleSwitchTemplateSettings_bases)
    {
        return nullptr;
    }

    py::pytype_handle ToggleSwitchTemplateSettings_type{py::register_python_type(module.get(), &type_spec_ToggleSwitchTemplateSettings, ToggleSwitchTemplateSettings_bases.get(), nullptr)};
    if (!ToggleSwitchTemplateSettings_type)
    {
        return nullptr;
    }

    py::pyobj_handle ToolTipTemplateSettings_bases{PyTuple_Pack(1, microsoft_ui_xaml_DependencyObject_type.get())};
    if (!ToolTipTemplateSettings_bases)
    {
        return nullptr;
    }

    py::pytype_handle ToolTipTemplateSettings_type{py::register_python_type(module.get(), &type_spec_ToolTipTemplateSettings, ToolTipTemplateSettings_bases.get(), nullptr)};
    if (!ToolTipTemplateSettings_type)
    {
        return nullptr;
    }

    py::pyobj_handle ZoomSnapPoint_Static_bases{PyTuple_Pack(1, reinterpret_cast<PyObject*>(Py_TYPE(ZoomSnapPointBase_type.get())))};
    if (!ZoomSnapPoint_Static_bases)
    {
        return nullptr;
    }

    py::pyobj_handle type_ZoomSnapPoint_Static{PyType_FromSpecWithBases(&type_spec_ZoomSnapPoint_Static, ZoomSnapPoint_Static_bases.get())};
    if (!type_ZoomSnapPoint_Static)
    {
        return nullptr;
    }

    py::pyobj_handle ZoomSnapPoint_bases{PyTuple_Pack(1, ZoomSnapPointBase_type.get())};
    if (!ZoomSnapPoint_bases)
    {
        return nullptr;
    }

    py::pytype_handle ZoomSnapPoint_type{py::register_python_type(module.get(), &type_spec_ZoomSnapPoint, ZoomSnapPoint_bases.get(), reinterpret_cast<PyTypeObject*>(type_ZoomSnapPoint_Static.get()))};
    if (!ZoomSnapPoint_type)
    {
        return nullptr;
    }

    py::pytype_handle IScrollController_type{py::register_python_type(module.get(), &type_spec_IScrollController, object_bases.get(), nullptr)};
    if (!IScrollController_type)
    {
        return nullptr;
    }

    py::pytype_handle ImplementsIScrollController_type{reinterpret_cast<PyTypeObject*>(PyType_FromModuleAndSpec(module.get(), &type_spec_ImplementsIScrollController, nullptr))};
    if (!ImplementsIScrollController_type)
    {
        return nullptr;
    }

    if (PyModule_AddType(module.get(), ImplementsIScrollController_type.get()) == -1)
    {
        return nullptr;
    }

    py::pytype_handle IScrollControllerPanningInfo_type{py::register_python_type(module.get(), &type_spec_IScrollControllerPanningInfo, object_bases.get(), nullptr)};
    if (!IScrollControllerPanningInfo_type)
    {
        return nullptr;
    }

    py::pytype_handle ImplementsIScrollControllerPanningInfo_type{reinterpret_cast<PyTypeObject*>(PyType_FromModuleAndSpec(module.get(), &type_spec_ImplementsIScrollControllerPanningInfo, nullptr))};
    if (!ImplementsIScrollControllerPanningInfo_type)
    {
        return nullptr;
    }

    if (PyModule_AddType(module.get(), ImplementsIScrollControllerPanningInfo_type.get()) == -1)
    {
        return nullptr;
    }

    py::pytype_handle IScrollSnapPointsInfo_type{py::register_python_type(module.get(), &type_spec_IScrollSnapPointsInfo, object_bases.get(), nullptr)};
    if (!IScrollSnapPointsInfo_type)
    {
        return nullptr;
    }

    py::pytype_handle ImplementsIScrollSnapPointsInfo_type{reinterpret_cast<PyTypeObject*>(PyType_FromModuleAndSpec(module.get(), &type_spec_ImplementsIScrollSnapPointsInfo, nullptr))};
    if (!ImplementsIScrollSnapPointsInfo_type)
    {
        return nullptr;
    }

    if (PyModule_AddType(module.get(), ImplementsIScrollSnapPointsInfo_type.get()) == -1)
    {
        return nullptr;
    }

    py::pytype_handle GeneratorPosition_type{py::register_python_type(module.get(), &type_spec_GeneratorPosition, nullptr, nullptr)};
    if (!GeneratorPosition_type)
    {
        return nullptr;
    }


    return module.detach();
}
