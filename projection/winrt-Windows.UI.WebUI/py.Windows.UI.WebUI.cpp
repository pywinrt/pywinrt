// WARNING: Please don't edit this file. It was generated by Python/WinRT v0.0.0

#include "py.Windows.UI.WebUI.h"

namespace py::cpp::Windows::UI::WebUI
{
    // ----- ActivatedDeferral class --------------------

    static PyObject* _new_ActivatedDeferral(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::UI::WebUI::ActivatedDeferral>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::UI::WebUI::ActivatedDeferral>::type_name);
        return nullptr;
    }

    static void _dealloc_ActivatedDeferral(py::wrapper::Windows::UI::WebUI::ActivatedDeferral* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* ActivatedDeferral_Complete(py::wrapper::Windows::UI::WebUI::ActivatedDeferral* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.WebUI.ActivatedDeferral", L"Complete", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                {
                    auto _gil = release_gil();
                    self->obj.Complete();
                }

                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* _assign_array_ActivatedDeferral(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::WebUI::ActivatedDeferral>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_ActivatedDeferral(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::WebUI::ActivatedDeferral>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_ActivatedDeferral[] = {
        { "complete", reinterpret_cast<PyCFunction>(ActivatedDeferral_Complete), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_ActivatedDeferral, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_ActivatedDeferral), METH_O | METH_STATIC, nullptr },
        { }};

    static PyGetSetDef _getset_ActivatedDeferral[] = {
        { }};

    static PyType_Slot _type_slots_ActivatedDeferral[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_ActivatedDeferral) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_ActivatedDeferral) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_ActivatedDeferral) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_ActivatedDeferral) },
        { }};

    static PyType_Spec type_spec_ActivatedDeferral = {
        "winrt._winrt_windows_ui_webui.ActivatedDeferral",
        sizeof(py::wrapper::Windows::UI::WebUI::ActivatedDeferral),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_ActivatedDeferral};

    // ----- ActivatedOperation class --------------------

    static PyObject* _new_ActivatedOperation(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::UI::WebUI::ActivatedOperation>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::UI::WebUI::ActivatedOperation>::type_name);
        return nullptr;
    }

    static void _dealloc_ActivatedOperation(py::wrapper::Windows::UI::WebUI::ActivatedOperation* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* ActivatedOperation_GetDeferral(py::wrapper::Windows::UI::WebUI::ActivatedOperation* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.WebUI.ActivatedOperation", L"GetDeferral", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return self->obj.GetDeferral();
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* _assign_array_ActivatedOperation(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::WebUI::ActivatedOperation>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_ActivatedOperation(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::WebUI::ActivatedOperation>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_ActivatedOperation[] = {
        { "get_deferral", reinterpret_cast<PyCFunction>(ActivatedOperation_GetDeferral), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_ActivatedOperation, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_ActivatedOperation), METH_O | METH_STATIC, nullptr },
        { }};

    static PyGetSetDef _getset_ActivatedOperation[] = {
        { }};

    static PyType_Slot _type_slots_ActivatedOperation[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_ActivatedOperation) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_ActivatedOperation) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_ActivatedOperation) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_ActivatedOperation) },
        { }};

    static PyType_Spec type_spec_ActivatedOperation = {
        "winrt._winrt_windows_ui_webui.ActivatedOperation",
        sizeof(py::wrapper::Windows::UI::WebUI::ActivatedOperation),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_ActivatedOperation};

    // ----- BackgroundActivatedEventArgs class --------------------

    static PyObject* _new_BackgroundActivatedEventArgs(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::UI::WebUI::BackgroundActivatedEventArgs>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::UI::WebUI::BackgroundActivatedEventArgs>::type_name);
        return nullptr;
    }

    static void _dealloc_BackgroundActivatedEventArgs(py::wrapper::Windows::UI::WebUI::BackgroundActivatedEventArgs* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* BackgroundActivatedEventArgs_get_TaskInstance(py::wrapper::Windows::UI::WebUI::BackgroundActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.WebUI.BackgroundActivatedEventArgs", L"TaskInstance");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.TaskInstance();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_BackgroundActivatedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::WebUI::BackgroundActivatedEventArgs>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_BackgroundActivatedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::WebUI::BackgroundActivatedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_BackgroundActivatedEventArgs[] = {
        { "_assign_array_", _assign_array_BackgroundActivatedEventArgs, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_BackgroundActivatedEventArgs), METH_O | METH_STATIC, nullptr },
        { }};

    static PyGetSetDef _getset_BackgroundActivatedEventArgs[] = {
        { "task_instance", reinterpret_cast<getter>(BackgroundActivatedEventArgs_get_TaskInstance), nullptr, nullptr, nullptr },
        { }};

    static PyType_Slot _type_slots_BackgroundActivatedEventArgs[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_BackgroundActivatedEventArgs) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_BackgroundActivatedEventArgs) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_BackgroundActivatedEventArgs) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_BackgroundActivatedEventArgs) },
        { }};

    static PyType_Spec type_spec_BackgroundActivatedEventArgs = {
        "winrt._winrt_windows_ui_webui.BackgroundActivatedEventArgs",
        sizeof(py::wrapper::Windows::UI::WebUI::BackgroundActivatedEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_BackgroundActivatedEventArgs};

    // ----- EnteredBackgroundEventArgs class --------------------

    static PyObject* _new_EnteredBackgroundEventArgs(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::UI::WebUI::EnteredBackgroundEventArgs>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::UI::WebUI::EnteredBackgroundEventArgs>::type_name);
        return nullptr;
    }

    static void _dealloc_EnteredBackgroundEventArgs(py::wrapper::Windows::UI::WebUI::EnteredBackgroundEventArgs* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* EnteredBackgroundEventArgs_GetDeferral(py::wrapper::Windows::UI::WebUI::EnteredBackgroundEventArgs* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.WebUI.EnteredBackgroundEventArgs", L"GetDeferral", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return self->obj.GetDeferral();
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* _assign_array_EnteredBackgroundEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::WebUI::EnteredBackgroundEventArgs>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_EnteredBackgroundEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::WebUI::EnteredBackgroundEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_EnteredBackgroundEventArgs[] = {
        { "get_deferral", reinterpret_cast<PyCFunction>(EnteredBackgroundEventArgs_GetDeferral), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_EnteredBackgroundEventArgs, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_EnteredBackgroundEventArgs), METH_O | METH_STATIC, nullptr },
        { }};

    static PyGetSetDef _getset_EnteredBackgroundEventArgs[] = {
        { }};

    static PyType_Slot _type_slots_EnteredBackgroundEventArgs[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_EnteredBackgroundEventArgs) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_EnteredBackgroundEventArgs) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_EnteredBackgroundEventArgs) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_EnteredBackgroundEventArgs) },
        { }};

    static PyType_Spec type_spec_EnteredBackgroundEventArgs = {
        "winrt._winrt_windows_ui_webui.EnteredBackgroundEventArgs",
        sizeof(py::wrapper::Windows::UI::WebUI::EnteredBackgroundEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_EnteredBackgroundEventArgs};

    // ----- HtmlPrintDocumentSource class --------------------

    static PyObject* _new_HtmlPrintDocumentSource(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::UI::WebUI::HtmlPrintDocumentSource>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::UI::WebUI::HtmlPrintDocumentSource>::type_name);
        return nullptr;
    }

    static void _dealloc_HtmlPrintDocumentSource(py::wrapper::Windows::UI::WebUI::HtmlPrintDocumentSource* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* HtmlPrintDocumentSource_Close(py::wrapper::Windows::UI::WebUI::HtmlPrintDocumentSource* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.WebUI.HtmlPrintDocumentSource", L"Close", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                {
                    auto _gil = release_gil();
                    self->obj.Close();
                }

                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* HtmlPrintDocumentSource_TrySetPageRange(py::wrapper::Windows::UI::WebUI::HtmlPrintDocumentSource* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.WebUI.HtmlPrintDocumentSource", L"TrySetPageRange", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return self->obj.TrySetPageRange(param0);
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* HtmlPrintDocumentSource_get_TopMargin(py::wrapper::Windows::UI::WebUI::HtmlPrintDocumentSource* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.WebUI.HtmlPrintDocumentSource", L"TopMargin");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.TopMargin();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int HtmlPrintDocumentSource_put_TopMargin(py::wrapper::Windows::UI::WebUI::HtmlPrintDocumentSource* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.WebUI.HtmlPrintDocumentSource", L"TopMargin");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<float>(arg);

            {
                auto _gil = release_gil();
                self->obj.TopMargin(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* HtmlPrintDocumentSource_get_ShrinkToFit(py::wrapper::Windows::UI::WebUI::HtmlPrintDocumentSource* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.WebUI.HtmlPrintDocumentSource", L"ShrinkToFit");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.ShrinkToFit();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int HtmlPrintDocumentSource_put_ShrinkToFit(py::wrapper::Windows::UI::WebUI::HtmlPrintDocumentSource* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.WebUI.HtmlPrintDocumentSource", L"ShrinkToFit");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<bool>(arg);

            {
                auto _gil = release_gil();
                self->obj.ShrinkToFit(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* HtmlPrintDocumentSource_get_RightMargin(py::wrapper::Windows::UI::WebUI::HtmlPrintDocumentSource* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.WebUI.HtmlPrintDocumentSource", L"RightMargin");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.RightMargin();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int HtmlPrintDocumentSource_put_RightMargin(py::wrapper::Windows::UI::WebUI::HtmlPrintDocumentSource* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.WebUI.HtmlPrintDocumentSource", L"RightMargin");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<float>(arg);

            {
                auto _gil = release_gil();
                self->obj.RightMargin(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* HtmlPrintDocumentSource_get_PercentScale(py::wrapper::Windows::UI::WebUI::HtmlPrintDocumentSource* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.WebUI.HtmlPrintDocumentSource", L"PercentScale");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.PercentScale();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int HtmlPrintDocumentSource_put_PercentScale(py::wrapper::Windows::UI::WebUI::HtmlPrintDocumentSource* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.WebUI.HtmlPrintDocumentSource", L"PercentScale");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<float>(arg);

            {
                auto _gil = release_gil();
                self->obj.PercentScale(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* HtmlPrintDocumentSource_get_LeftMargin(py::wrapper::Windows::UI::WebUI::HtmlPrintDocumentSource* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.WebUI.HtmlPrintDocumentSource", L"LeftMargin");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.LeftMargin();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int HtmlPrintDocumentSource_put_LeftMargin(py::wrapper::Windows::UI::WebUI::HtmlPrintDocumentSource* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.WebUI.HtmlPrintDocumentSource", L"LeftMargin");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<float>(arg);

            {
                auto _gil = release_gil();
                self->obj.LeftMargin(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* HtmlPrintDocumentSource_get_EnableHeaderFooter(py::wrapper::Windows::UI::WebUI::HtmlPrintDocumentSource* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.WebUI.HtmlPrintDocumentSource", L"EnableHeaderFooter");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.EnableHeaderFooter();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int HtmlPrintDocumentSource_put_EnableHeaderFooter(py::wrapper::Windows::UI::WebUI::HtmlPrintDocumentSource* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.WebUI.HtmlPrintDocumentSource", L"EnableHeaderFooter");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<bool>(arg);

            {
                auto _gil = release_gil();
                self->obj.EnableHeaderFooter(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* HtmlPrintDocumentSource_get_Content(py::wrapper::Windows::UI::WebUI::HtmlPrintDocumentSource* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.WebUI.HtmlPrintDocumentSource", L"Content");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Content();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int HtmlPrintDocumentSource_put_Content(py::wrapper::Windows::UI::WebUI::HtmlPrintDocumentSource* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.WebUI.HtmlPrintDocumentSource", L"Content");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::UI::WebUI::PrintContent>(arg);

            {
                auto _gil = release_gil();
                self->obj.Content(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* HtmlPrintDocumentSource_get_BottomMargin(py::wrapper::Windows::UI::WebUI::HtmlPrintDocumentSource* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.WebUI.HtmlPrintDocumentSource", L"BottomMargin");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.BottomMargin();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int HtmlPrintDocumentSource_put_BottomMargin(py::wrapper::Windows::UI::WebUI::HtmlPrintDocumentSource* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.WebUI.HtmlPrintDocumentSource", L"BottomMargin");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<float>(arg);

            {
                auto _gil = release_gil();
                self->obj.BottomMargin(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* HtmlPrintDocumentSource_get_PageRange(py::wrapper::Windows::UI::WebUI::HtmlPrintDocumentSource* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.WebUI.HtmlPrintDocumentSource", L"PageRange");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.PageRange();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_HtmlPrintDocumentSource(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::WebUI::HtmlPrintDocumentSource>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_HtmlPrintDocumentSource(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::WebUI::HtmlPrintDocumentSource>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _enter_HtmlPrintDocumentSource(py::wrapper::Windows::UI::WebUI::HtmlPrintDocumentSource* self, PyObject* /*unused*/) noexcept
    {
        return Py_NewRef(self);
    }

    static PyObject* _exit_HtmlPrintDocumentSource(py::wrapper::Windows::UI::WebUI::HtmlPrintDocumentSource* self, PyObject* /*unused*/) noexcept
    {
        try
        {
            {
                auto _gil = py::release_gil();
                self->obj.Close();
            }

            Py_RETURN_FALSE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_HtmlPrintDocumentSource[] = {
        { "close", reinterpret_cast<PyCFunction>(HtmlPrintDocumentSource_Close), METH_VARARGS, nullptr },
        { "try_set_page_range", reinterpret_cast<PyCFunction>(HtmlPrintDocumentSource_TrySetPageRange), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_HtmlPrintDocumentSource, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_HtmlPrintDocumentSource), METH_O | METH_STATIC, nullptr },
        { "__enter__", reinterpret_cast<PyCFunction>(_enter_HtmlPrintDocumentSource), METH_NOARGS, nullptr },
        { "__exit__", reinterpret_cast<PyCFunction>(_exit_HtmlPrintDocumentSource), METH_VARARGS, nullptr },
        { }};

    static PyGetSetDef _getset_HtmlPrintDocumentSource[] = {
        { "top_margin", reinterpret_cast<getter>(HtmlPrintDocumentSource_get_TopMargin), reinterpret_cast<setter>(HtmlPrintDocumentSource_put_TopMargin), nullptr, nullptr },
        { "shrink_to_fit", reinterpret_cast<getter>(HtmlPrintDocumentSource_get_ShrinkToFit), reinterpret_cast<setter>(HtmlPrintDocumentSource_put_ShrinkToFit), nullptr, nullptr },
        { "right_margin", reinterpret_cast<getter>(HtmlPrintDocumentSource_get_RightMargin), reinterpret_cast<setter>(HtmlPrintDocumentSource_put_RightMargin), nullptr, nullptr },
        { "percent_scale", reinterpret_cast<getter>(HtmlPrintDocumentSource_get_PercentScale), reinterpret_cast<setter>(HtmlPrintDocumentSource_put_PercentScale), nullptr, nullptr },
        { "left_margin", reinterpret_cast<getter>(HtmlPrintDocumentSource_get_LeftMargin), reinterpret_cast<setter>(HtmlPrintDocumentSource_put_LeftMargin), nullptr, nullptr },
        { "enable_header_footer", reinterpret_cast<getter>(HtmlPrintDocumentSource_get_EnableHeaderFooter), reinterpret_cast<setter>(HtmlPrintDocumentSource_put_EnableHeaderFooter), nullptr, nullptr },
        { "content", reinterpret_cast<getter>(HtmlPrintDocumentSource_get_Content), reinterpret_cast<setter>(HtmlPrintDocumentSource_put_Content), nullptr, nullptr },
        { "bottom_margin", reinterpret_cast<getter>(HtmlPrintDocumentSource_get_BottomMargin), reinterpret_cast<setter>(HtmlPrintDocumentSource_put_BottomMargin), nullptr, nullptr },
        { "page_range", reinterpret_cast<getter>(HtmlPrintDocumentSource_get_PageRange), nullptr, nullptr, nullptr },
        { }};

    static PyType_Slot _type_slots_HtmlPrintDocumentSource[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_HtmlPrintDocumentSource) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_HtmlPrintDocumentSource) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_HtmlPrintDocumentSource) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_HtmlPrintDocumentSource) },
        { }};

    static PyType_Spec type_spec_HtmlPrintDocumentSource = {
        "winrt._winrt_windows_ui_webui.HtmlPrintDocumentSource",
        sizeof(py::wrapper::Windows::UI::WebUI::HtmlPrintDocumentSource),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_HtmlPrintDocumentSource};

    // ----- LeavingBackgroundEventArgs class --------------------

    static PyObject* _new_LeavingBackgroundEventArgs(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::UI::WebUI::LeavingBackgroundEventArgs>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::UI::WebUI::LeavingBackgroundEventArgs>::type_name);
        return nullptr;
    }

    static void _dealloc_LeavingBackgroundEventArgs(py::wrapper::Windows::UI::WebUI::LeavingBackgroundEventArgs* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* LeavingBackgroundEventArgs_GetDeferral(py::wrapper::Windows::UI::WebUI::LeavingBackgroundEventArgs* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.WebUI.LeavingBackgroundEventArgs", L"GetDeferral", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return self->obj.GetDeferral();
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* _assign_array_LeavingBackgroundEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::WebUI::LeavingBackgroundEventArgs>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_LeavingBackgroundEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::WebUI::LeavingBackgroundEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_LeavingBackgroundEventArgs[] = {
        { "get_deferral", reinterpret_cast<PyCFunction>(LeavingBackgroundEventArgs_GetDeferral), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_LeavingBackgroundEventArgs, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_LeavingBackgroundEventArgs), METH_O | METH_STATIC, nullptr },
        { }};

    static PyGetSetDef _getset_LeavingBackgroundEventArgs[] = {
        { }};

    static PyType_Slot _type_slots_LeavingBackgroundEventArgs[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_LeavingBackgroundEventArgs) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_LeavingBackgroundEventArgs) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_LeavingBackgroundEventArgs) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_LeavingBackgroundEventArgs) },
        { }};

    static PyType_Spec type_spec_LeavingBackgroundEventArgs = {
        "winrt._winrt_windows_ui_webui.LeavingBackgroundEventArgs",
        sizeof(py::wrapper::Windows::UI::WebUI::LeavingBackgroundEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_LeavingBackgroundEventArgs};

    // ----- NewWebUIViewCreatedEventArgs class --------------------

    static PyObject* _new_NewWebUIViewCreatedEventArgs(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::UI::WebUI::NewWebUIViewCreatedEventArgs>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::UI::WebUI::NewWebUIViewCreatedEventArgs>::type_name);
        return nullptr;
    }

    static void _dealloc_NewWebUIViewCreatedEventArgs(py::wrapper::Windows::UI::WebUI::NewWebUIViewCreatedEventArgs* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* NewWebUIViewCreatedEventArgs_GetDeferral(py::wrapper::Windows::UI::WebUI::NewWebUIViewCreatedEventArgs* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.WebUI.NewWebUIViewCreatedEventArgs", L"GetDeferral", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return self->obj.GetDeferral();
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* NewWebUIViewCreatedEventArgs_get_ActivatedEventArgs(py::wrapper::Windows::UI::WebUI::NewWebUIViewCreatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.WebUI.NewWebUIViewCreatedEventArgs", L"ActivatedEventArgs");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.ActivatedEventArgs();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* NewWebUIViewCreatedEventArgs_get_HasPendingNavigate(py::wrapper::Windows::UI::WebUI::NewWebUIViewCreatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.WebUI.NewWebUIViewCreatedEventArgs", L"HasPendingNavigate");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.HasPendingNavigate();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* NewWebUIViewCreatedEventArgs_get_WebUIView(py::wrapper::Windows::UI::WebUI::NewWebUIViewCreatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.WebUI.NewWebUIViewCreatedEventArgs", L"WebUIView");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.WebUIView();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_NewWebUIViewCreatedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::WebUI::NewWebUIViewCreatedEventArgs>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_NewWebUIViewCreatedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::WebUI::NewWebUIViewCreatedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_NewWebUIViewCreatedEventArgs[] = {
        { "get_deferral", reinterpret_cast<PyCFunction>(NewWebUIViewCreatedEventArgs_GetDeferral), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_NewWebUIViewCreatedEventArgs, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_NewWebUIViewCreatedEventArgs), METH_O | METH_STATIC, nullptr },
        { }};

    static PyGetSetDef _getset_NewWebUIViewCreatedEventArgs[] = {
        { "activated_event_args", reinterpret_cast<getter>(NewWebUIViewCreatedEventArgs_get_ActivatedEventArgs), nullptr, nullptr, nullptr },
        { "has_pending_navigate", reinterpret_cast<getter>(NewWebUIViewCreatedEventArgs_get_HasPendingNavigate), nullptr, nullptr, nullptr },
        { "web_ui_view", reinterpret_cast<getter>(NewWebUIViewCreatedEventArgs_get_WebUIView), nullptr, nullptr, nullptr },
        { }};

    static PyType_Slot _type_slots_NewWebUIViewCreatedEventArgs[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_NewWebUIViewCreatedEventArgs) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_NewWebUIViewCreatedEventArgs) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_NewWebUIViewCreatedEventArgs) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_NewWebUIViewCreatedEventArgs) },
        { }};

    static PyType_Spec type_spec_NewWebUIViewCreatedEventArgs = {
        "winrt._winrt_windows_ui_webui.NewWebUIViewCreatedEventArgs",
        sizeof(py::wrapper::Windows::UI::WebUI::NewWebUIViewCreatedEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_NewWebUIViewCreatedEventArgs};

    // ----- SuspendingDeferral class --------------------

    static PyObject* _new_SuspendingDeferral(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::UI::WebUI::SuspendingDeferral>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::UI::WebUI::SuspendingDeferral>::type_name);
        return nullptr;
    }

    static void _dealloc_SuspendingDeferral(py::wrapper::Windows::UI::WebUI::SuspendingDeferral* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* SuspendingDeferral_Complete(py::wrapper::Windows::UI::WebUI::SuspendingDeferral* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.WebUI.SuspendingDeferral", L"Complete", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                {
                    auto _gil = release_gil();
                    self->obj.Complete();
                }

                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* _assign_array_SuspendingDeferral(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::WebUI::SuspendingDeferral>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_SuspendingDeferral(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::WebUI::SuspendingDeferral>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_SuspendingDeferral[] = {
        { "complete", reinterpret_cast<PyCFunction>(SuspendingDeferral_Complete), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_SuspendingDeferral, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_SuspendingDeferral), METH_O | METH_STATIC, nullptr },
        { }};

    static PyGetSetDef _getset_SuspendingDeferral[] = {
        { }};

    static PyType_Slot _type_slots_SuspendingDeferral[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_SuspendingDeferral) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_SuspendingDeferral) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_SuspendingDeferral) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_SuspendingDeferral) },
        { }};

    static PyType_Spec type_spec_SuspendingDeferral = {
        "winrt._winrt_windows_ui_webui.SuspendingDeferral",
        sizeof(py::wrapper::Windows::UI::WebUI::SuspendingDeferral),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_SuspendingDeferral};

    // ----- SuspendingEventArgs class --------------------

    static PyObject* _new_SuspendingEventArgs(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::UI::WebUI::SuspendingEventArgs>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::UI::WebUI::SuspendingEventArgs>::type_name);
        return nullptr;
    }

    static void _dealloc_SuspendingEventArgs(py::wrapper::Windows::UI::WebUI::SuspendingEventArgs* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* SuspendingEventArgs_get_SuspendingOperation(py::wrapper::Windows::UI::WebUI::SuspendingEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.WebUI.SuspendingEventArgs", L"SuspendingOperation");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.SuspendingOperation();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_SuspendingEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::WebUI::SuspendingEventArgs>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_SuspendingEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::WebUI::SuspendingEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_SuspendingEventArgs[] = {
        { "_assign_array_", _assign_array_SuspendingEventArgs, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_SuspendingEventArgs), METH_O | METH_STATIC, nullptr },
        { }};

    static PyGetSetDef _getset_SuspendingEventArgs[] = {
        { "suspending_operation", reinterpret_cast<getter>(SuspendingEventArgs_get_SuspendingOperation), nullptr, nullptr, nullptr },
        { }};

    static PyType_Slot _type_slots_SuspendingEventArgs[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_SuspendingEventArgs) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_SuspendingEventArgs) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_SuspendingEventArgs) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_SuspendingEventArgs) },
        { }};

    static PyType_Spec type_spec_SuspendingEventArgs = {
        "winrt._winrt_windows_ui_webui.SuspendingEventArgs",
        sizeof(py::wrapper::Windows::UI::WebUI::SuspendingEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_SuspendingEventArgs};

    // ----- SuspendingOperation class --------------------

    static PyObject* _new_SuspendingOperation(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::UI::WebUI::SuspendingOperation>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::UI::WebUI::SuspendingOperation>::type_name);
        return nullptr;
    }

    static void _dealloc_SuspendingOperation(py::wrapper::Windows::UI::WebUI::SuspendingOperation* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* SuspendingOperation_GetDeferral(py::wrapper::Windows::UI::WebUI::SuspendingOperation* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.WebUI.SuspendingOperation", L"GetDeferral", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return self->obj.GetDeferral();
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* SuspendingOperation_get_Deadline(py::wrapper::Windows::UI::WebUI::SuspendingOperation* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.WebUI.SuspendingOperation", L"Deadline");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Deadline();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_SuspendingOperation(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::WebUI::SuspendingOperation>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_SuspendingOperation(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::WebUI::SuspendingOperation>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_SuspendingOperation[] = {
        { "get_deferral", reinterpret_cast<PyCFunction>(SuspendingOperation_GetDeferral), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_SuspendingOperation, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_SuspendingOperation), METH_O | METH_STATIC, nullptr },
        { }};

    static PyGetSetDef _getset_SuspendingOperation[] = {
        { "deadline", reinterpret_cast<getter>(SuspendingOperation_get_Deadline), nullptr, nullptr, nullptr },
        { }};

    static PyType_Slot _type_slots_SuspendingOperation[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_SuspendingOperation) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_SuspendingOperation) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_SuspendingOperation) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_SuspendingOperation) },
        { }};

    static PyType_Spec type_spec_SuspendingOperation = {
        "winrt._winrt_windows_ui_webui.SuspendingOperation",
        sizeof(py::wrapper::Windows::UI::WebUI::SuspendingOperation),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_SuspendingOperation};

    // ----- WebUIApplication class --------------------

    static PyObject* _new_WebUIApplication(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::UI::WebUI::WebUIApplication>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::UI::WebUI::WebUIApplication>::type_name);
        return nullptr;
    }

    static PyObject* WebUIApplication_EnablePrelaunch(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.WebUI.WebUIApplication", L"EnablePrelaunch", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<bool>(args, 0);

                {
                    auto _gil = release_gil();
                    winrt::Windows::UI::WebUI::WebUIApplication::EnablePrelaunch(param0);
                }

                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* WebUIApplication_RequestRestartAsync(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.WebUI.WebUIApplication", L"RequestRestartAsync", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return winrt::Windows::UI::WebUI::WebUIApplication::RequestRestartAsync(param0);
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* WebUIApplication_RequestRestartForUserAsync(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.WebUI.WebUIApplication", L"RequestRestartForUserAsync", 2);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(2);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::System::User>(args, 0);
                auto param1 = py::convert_to<winrt::hstring>(args, 1);

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return winrt::Windows::UI::WebUI::WebUIApplication::RequestRestartForUserAsync(param0, param1);
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* WebUIApplication_add_BackgroundActivated(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            static std::optional<bool> is_event_present{};

            if (!is_event_present.has_value())
            {
                is_event_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.UI.WebUI.WebUIApplication", L"BackgroundActivated");
            }

            if (!is_event_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::Windows::UI::WebUI::BackgroundActivatedEventHandler>(arg);

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return winrt::Windows::UI::WebUI::WebUIApplication::BackgroundActivated(param0);
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* WebUIApplication_remove_BackgroundActivated(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            static std::optional<bool> is_event_present{};

            if (!is_event_present.has_value())
            {
                is_event_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.UI.WebUI.WebUIApplication", L"BackgroundActivated");
            }

            if (!is_event_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::event_token>(arg);

            {
                auto _gil = release_gil();
                winrt::Windows::UI::WebUI::WebUIApplication::BackgroundActivated(param0);
            }

            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* WebUIApplication_add_NewWebUIViewCreated(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            static std::optional<bool> is_event_present{};

            if (!is_event_present.has_value())
            {
                is_event_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.UI.WebUI.WebUIApplication", L"NewWebUIViewCreated");
            }

            if (!is_event_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::EventHandler<winrt::Windows::UI::WebUI::NewWebUIViewCreatedEventArgs>>(arg);

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return winrt::Windows::UI::WebUI::WebUIApplication::NewWebUIViewCreated(param0);
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* WebUIApplication_remove_NewWebUIViewCreated(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            static std::optional<bool> is_event_present{};

            if (!is_event_present.has_value())
            {
                is_event_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.UI.WebUI.WebUIApplication", L"NewWebUIViewCreated");
            }

            if (!is_event_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::event_token>(arg);

            {
                auto _gil = release_gil();
                winrt::Windows::UI::WebUI::WebUIApplication::NewWebUIViewCreated(param0);
            }

            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* WebUIApplication_add_EnteredBackground(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            static std::optional<bool> is_event_present{};

            if (!is_event_present.has_value())
            {
                is_event_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.UI.WebUI.WebUIApplication", L"EnteredBackground");
            }

            if (!is_event_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::Windows::UI::WebUI::EnteredBackgroundEventHandler>(arg);

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return winrt::Windows::UI::WebUI::WebUIApplication::EnteredBackground(param0);
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* WebUIApplication_remove_EnteredBackground(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            static std::optional<bool> is_event_present{};

            if (!is_event_present.has_value())
            {
                is_event_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.UI.WebUI.WebUIApplication", L"EnteredBackground");
            }

            if (!is_event_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::event_token>(arg);

            {
                auto _gil = release_gil();
                winrt::Windows::UI::WebUI::WebUIApplication::EnteredBackground(param0);
            }

            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* WebUIApplication_add_LeavingBackground(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            static std::optional<bool> is_event_present{};

            if (!is_event_present.has_value())
            {
                is_event_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.UI.WebUI.WebUIApplication", L"LeavingBackground");
            }

            if (!is_event_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::Windows::UI::WebUI::LeavingBackgroundEventHandler>(arg);

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return winrt::Windows::UI::WebUI::WebUIApplication::LeavingBackground(param0);
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* WebUIApplication_remove_LeavingBackground(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            static std::optional<bool> is_event_present{};

            if (!is_event_present.has_value())
            {
                is_event_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.UI.WebUI.WebUIApplication", L"LeavingBackground");
            }

            if (!is_event_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::event_token>(arg);

            {
                auto _gil = release_gil();
                winrt::Windows::UI::WebUI::WebUIApplication::LeavingBackground(param0);
            }

            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* WebUIApplication_add_Activated(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            static std::optional<bool> is_event_present{};

            if (!is_event_present.has_value())
            {
                is_event_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.UI.WebUI.WebUIApplication", L"Activated");
            }

            if (!is_event_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::Windows::UI::WebUI::ActivatedEventHandler>(arg);

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return winrt::Windows::UI::WebUI::WebUIApplication::Activated(param0);
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* WebUIApplication_remove_Activated(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            static std::optional<bool> is_event_present{};

            if (!is_event_present.has_value())
            {
                is_event_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.UI.WebUI.WebUIApplication", L"Activated");
            }

            if (!is_event_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::event_token>(arg);

            {
                auto _gil = release_gil();
                winrt::Windows::UI::WebUI::WebUIApplication::Activated(param0);
            }

            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* WebUIApplication_add_Navigated(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            static std::optional<bool> is_event_present{};

            if (!is_event_present.has_value())
            {
                is_event_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.UI.WebUI.WebUIApplication", L"Navigated");
            }

            if (!is_event_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::Windows::UI::WebUI::NavigatedEventHandler>(arg);

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return winrt::Windows::UI::WebUI::WebUIApplication::Navigated(param0);
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* WebUIApplication_remove_Navigated(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            static std::optional<bool> is_event_present{};

            if (!is_event_present.has_value())
            {
                is_event_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.UI.WebUI.WebUIApplication", L"Navigated");
            }

            if (!is_event_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::event_token>(arg);

            {
                auto _gil = release_gil();
                winrt::Windows::UI::WebUI::WebUIApplication::Navigated(param0);
            }

            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* WebUIApplication_add_Resuming(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            static std::optional<bool> is_event_present{};

            if (!is_event_present.has_value())
            {
                is_event_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.UI.WebUI.WebUIApplication", L"Resuming");
            }

            if (!is_event_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::Windows::UI::WebUI::ResumingEventHandler>(arg);

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return winrt::Windows::UI::WebUI::WebUIApplication::Resuming(param0);
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* WebUIApplication_remove_Resuming(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            static std::optional<bool> is_event_present{};

            if (!is_event_present.has_value())
            {
                is_event_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.UI.WebUI.WebUIApplication", L"Resuming");
            }

            if (!is_event_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::event_token>(arg);

            {
                auto _gil = release_gil();
                winrt::Windows::UI::WebUI::WebUIApplication::Resuming(param0);
            }

            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* WebUIApplication_add_Suspending(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            static std::optional<bool> is_event_present{};

            if (!is_event_present.has_value())
            {
                is_event_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.UI.WebUI.WebUIApplication", L"Suspending");
            }

            if (!is_event_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::Windows::UI::WebUI::SuspendingEventHandler>(arg);

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return winrt::Windows::UI::WebUI::WebUIApplication::Suspending(param0);
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* WebUIApplication_remove_Suspending(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            static std::optional<bool> is_event_present{};

            if (!is_event_present.has_value())
            {
                is_event_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.UI.WebUI.WebUIApplication", L"Suspending");
            }

            if (!is_event_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::event_token>(arg);

            {
                auto _gil = release_gil();
                winrt::Windows::UI::WebUI::WebUIApplication::Suspending(param0);
            }

            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_WebUIApplication[] = {
        { }};

    static PyGetSetDef _getset_WebUIApplication[] = {
        { }};

    static PyType_Slot _type_slots_WebUIApplication[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_WebUIApplication) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_WebUIApplication) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_WebUIApplication) },
        { }};

    static PyType_Spec type_spec_WebUIApplication = {
        "winrt._winrt_windows_ui_webui.WebUIApplication",
        0,
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_WebUIApplication};

    static PyGetSetDef getset_WebUIApplication_Static[] = {
        { }};

    static PyMethodDef methods_WebUIApplication_Static[] = {
        { "enable_prelaunch", reinterpret_cast<PyCFunction>(WebUIApplication_EnablePrelaunch), METH_VARARGS, nullptr },
        { "request_restart_async", reinterpret_cast<PyCFunction>(WebUIApplication_RequestRestartAsync), METH_VARARGS, nullptr },
        { "request_restart_for_user_async", reinterpret_cast<PyCFunction>(WebUIApplication_RequestRestartForUserAsync), METH_VARARGS, nullptr },
        { "add_background_activated", reinterpret_cast<PyCFunction>(WebUIApplication_add_BackgroundActivated), METH_O, nullptr },
        { "remove_background_activated", reinterpret_cast<PyCFunction>(WebUIApplication_remove_BackgroundActivated), METH_O, nullptr },
        { "add_new_web_ui_view_created", reinterpret_cast<PyCFunction>(WebUIApplication_add_NewWebUIViewCreated), METH_O, nullptr },
        { "remove_new_web_ui_view_created", reinterpret_cast<PyCFunction>(WebUIApplication_remove_NewWebUIViewCreated), METH_O, nullptr },
        { "add_entered_background", reinterpret_cast<PyCFunction>(WebUIApplication_add_EnteredBackground), METH_O, nullptr },
        { "remove_entered_background", reinterpret_cast<PyCFunction>(WebUIApplication_remove_EnteredBackground), METH_O, nullptr },
        { "add_leaving_background", reinterpret_cast<PyCFunction>(WebUIApplication_add_LeavingBackground), METH_O, nullptr },
        { "remove_leaving_background", reinterpret_cast<PyCFunction>(WebUIApplication_remove_LeavingBackground), METH_O, nullptr },
        { "add_activated", reinterpret_cast<PyCFunction>(WebUIApplication_add_Activated), METH_O, nullptr },
        { "remove_activated", reinterpret_cast<PyCFunction>(WebUIApplication_remove_Activated), METH_O, nullptr },
        { "add_navigated", reinterpret_cast<PyCFunction>(WebUIApplication_add_Navigated), METH_O, nullptr },
        { "remove_navigated", reinterpret_cast<PyCFunction>(WebUIApplication_remove_Navigated), METH_O, nullptr },
        { "add_resuming", reinterpret_cast<PyCFunction>(WebUIApplication_add_Resuming), METH_O, nullptr },
        { "remove_resuming", reinterpret_cast<PyCFunction>(WebUIApplication_remove_Resuming), METH_O, nullptr },
        { "add_suspending", reinterpret_cast<PyCFunction>(WebUIApplication_add_Suspending), METH_O, nullptr },
        { "remove_suspending", reinterpret_cast<PyCFunction>(WebUIApplication_remove_Suspending), METH_O, nullptr },
        { }};

    static PyType_Slot type_slots_WebUIApplication_Static[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_WebUIApplication_Static) },
        { Py_tp_methods, reinterpret_cast<void*>(methods_WebUIApplication_Static) },
        { }
    };

    static PyType_Spec type_spec_WebUIApplication_Static = {
        "winrt._winrt_windows_ui_webui.WebUIApplication_Static",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT,
        type_slots_WebUIApplication_Static};

    // ----- WebUIAppointmentsProviderAddAppointmentActivatedEventArgs class --------------------

    static PyObject* _new_WebUIAppointmentsProviderAddAppointmentActivatedEventArgs(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::UI::WebUI::WebUIAppointmentsProviderAddAppointmentActivatedEventArgs>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::UI::WebUI::WebUIAppointmentsProviderAddAppointmentActivatedEventArgs>::type_name);
        return nullptr;
    }

    static void _dealloc_WebUIAppointmentsProviderAddAppointmentActivatedEventArgs(py::wrapper::Windows::UI::WebUI::WebUIAppointmentsProviderAddAppointmentActivatedEventArgs* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* WebUIAppointmentsProviderAddAppointmentActivatedEventArgs_get_Kind(py::wrapper::Windows::UI::WebUI::WebUIAppointmentsProviderAddAppointmentActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.WebUI.WebUIAppointmentsProviderAddAppointmentActivatedEventArgs", L"Kind");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Kind();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* WebUIAppointmentsProviderAddAppointmentActivatedEventArgs_get_PreviousExecutionState(py::wrapper::Windows::UI::WebUI::WebUIAppointmentsProviderAddAppointmentActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.WebUI.WebUIAppointmentsProviderAddAppointmentActivatedEventArgs", L"PreviousExecutionState");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.PreviousExecutionState();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* WebUIAppointmentsProviderAddAppointmentActivatedEventArgs_get_SplashScreen(py::wrapper::Windows::UI::WebUI::WebUIAppointmentsProviderAddAppointmentActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.WebUI.WebUIAppointmentsProviderAddAppointmentActivatedEventArgs", L"SplashScreen");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.SplashScreen();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* WebUIAppointmentsProviderAddAppointmentActivatedEventArgs_get_User(py::wrapper::Windows::UI::WebUI::WebUIAppointmentsProviderAddAppointmentActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.WebUI.WebUIAppointmentsProviderAddAppointmentActivatedEventArgs", L"User");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.User();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* WebUIAppointmentsProviderAddAppointmentActivatedEventArgs_get_Verb(py::wrapper::Windows::UI::WebUI::WebUIAppointmentsProviderAddAppointmentActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.WebUI.WebUIAppointmentsProviderAddAppointmentActivatedEventArgs", L"Verb");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Verb();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* WebUIAppointmentsProviderAddAppointmentActivatedEventArgs_get_AddAppointmentOperation(py::wrapper::Windows::UI::WebUI::WebUIAppointmentsProviderAddAppointmentActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.WebUI.WebUIAppointmentsProviderAddAppointmentActivatedEventArgs", L"AddAppointmentOperation");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.AddAppointmentOperation();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* WebUIAppointmentsProviderAddAppointmentActivatedEventArgs_get_ActivatedOperation(py::wrapper::Windows::UI::WebUI::WebUIAppointmentsProviderAddAppointmentActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.WebUI.WebUIAppointmentsProviderAddAppointmentActivatedEventArgs", L"ActivatedOperation");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.ActivatedOperation();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_WebUIAppointmentsProviderAddAppointmentActivatedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::WebUI::WebUIAppointmentsProviderAddAppointmentActivatedEventArgs>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_WebUIAppointmentsProviderAddAppointmentActivatedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::WebUI::WebUIAppointmentsProviderAddAppointmentActivatedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_WebUIAppointmentsProviderAddAppointmentActivatedEventArgs[] = {
        { "_assign_array_", _assign_array_WebUIAppointmentsProviderAddAppointmentActivatedEventArgs, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_WebUIAppointmentsProviderAddAppointmentActivatedEventArgs), METH_O | METH_STATIC, nullptr },
        { }};

    static PyGetSetDef _getset_WebUIAppointmentsProviderAddAppointmentActivatedEventArgs[] = {
        { "kind", reinterpret_cast<getter>(WebUIAppointmentsProviderAddAppointmentActivatedEventArgs_get_Kind), nullptr, nullptr, nullptr },
        { "previous_execution_state", reinterpret_cast<getter>(WebUIAppointmentsProviderAddAppointmentActivatedEventArgs_get_PreviousExecutionState), nullptr, nullptr, nullptr },
        { "splash_screen", reinterpret_cast<getter>(WebUIAppointmentsProviderAddAppointmentActivatedEventArgs_get_SplashScreen), nullptr, nullptr, nullptr },
        { "user", reinterpret_cast<getter>(WebUIAppointmentsProviderAddAppointmentActivatedEventArgs_get_User), nullptr, nullptr, nullptr },
        { "verb", reinterpret_cast<getter>(WebUIAppointmentsProviderAddAppointmentActivatedEventArgs_get_Verb), nullptr, nullptr, nullptr },
        { "add_appointment_operation", reinterpret_cast<getter>(WebUIAppointmentsProviderAddAppointmentActivatedEventArgs_get_AddAppointmentOperation), nullptr, nullptr, nullptr },
        { "activated_operation", reinterpret_cast<getter>(WebUIAppointmentsProviderAddAppointmentActivatedEventArgs_get_ActivatedOperation), nullptr, nullptr, nullptr },
        { }};

    static PyType_Slot _type_slots_WebUIAppointmentsProviderAddAppointmentActivatedEventArgs[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_WebUIAppointmentsProviderAddAppointmentActivatedEventArgs) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_WebUIAppointmentsProviderAddAppointmentActivatedEventArgs) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_WebUIAppointmentsProviderAddAppointmentActivatedEventArgs) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_WebUIAppointmentsProviderAddAppointmentActivatedEventArgs) },
        { }};

    static PyType_Spec type_spec_WebUIAppointmentsProviderAddAppointmentActivatedEventArgs = {
        "winrt._winrt_windows_ui_webui.WebUIAppointmentsProviderAddAppointmentActivatedEventArgs",
        sizeof(py::wrapper::Windows::UI::WebUI::WebUIAppointmentsProviderAddAppointmentActivatedEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_WebUIAppointmentsProviderAddAppointmentActivatedEventArgs};

    // ----- WebUIAppointmentsProviderRemoveAppointmentActivatedEventArgs class --------------------

    static PyObject* _new_WebUIAppointmentsProviderRemoveAppointmentActivatedEventArgs(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::UI::WebUI::WebUIAppointmentsProviderRemoveAppointmentActivatedEventArgs>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::UI::WebUI::WebUIAppointmentsProviderRemoveAppointmentActivatedEventArgs>::type_name);
        return nullptr;
    }

    static void _dealloc_WebUIAppointmentsProviderRemoveAppointmentActivatedEventArgs(py::wrapper::Windows::UI::WebUI::WebUIAppointmentsProviderRemoveAppointmentActivatedEventArgs* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* WebUIAppointmentsProviderRemoveAppointmentActivatedEventArgs_get_Kind(py::wrapper::Windows::UI::WebUI::WebUIAppointmentsProviderRemoveAppointmentActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.WebUI.WebUIAppointmentsProviderRemoveAppointmentActivatedEventArgs", L"Kind");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Kind();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* WebUIAppointmentsProviderRemoveAppointmentActivatedEventArgs_get_PreviousExecutionState(py::wrapper::Windows::UI::WebUI::WebUIAppointmentsProviderRemoveAppointmentActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.WebUI.WebUIAppointmentsProviderRemoveAppointmentActivatedEventArgs", L"PreviousExecutionState");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.PreviousExecutionState();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* WebUIAppointmentsProviderRemoveAppointmentActivatedEventArgs_get_SplashScreen(py::wrapper::Windows::UI::WebUI::WebUIAppointmentsProviderRemoveAppointmentActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.WebUI.WebUIAppointmentsProviderRemoveAppointmentActivatedEventArgs", L"SplashScreen");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.SplashScreen();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* WebUIAppointmentsProviderRemoveAppointmentActivatedEventArgs_get_User(py::wrapper::Windows::UI::WebUI::WebUIAppointmentsProviderRemoveAppointmentActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.WebUI.WebUIAppointmentsProviderRemoveAppointmentActivatedEventArgs", L"User");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.User();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* WebUIAppointmentsProviderRemoveAppointmentActivatedEventArgs_get_Verb(py::wrapper::Windows::UI::WebUI::WebUIAppointmentsProviderRemoveAppointmentActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.WebUI.WebUIAppointmentsProviderRemoveAppointmentActivatedEventArgs", L"Verb");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Verb();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* WebUIAppointmentsProviderRemoveAppointmentActivatedEventArgs_get_RemoveAppointmentOperation(py::wrapper::Windows::UI::WebUI::WebUIAppointmentsProviderRemoveAppointmentActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.WebUI.WebUIAppointmentsProviderRemoveAppointmentActivatedEventArgs", L"RemoveAppointmentOperation");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.RemoveAppointmentOperation();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* WebUIAppointmentsProviderRemoveAppointmentActivatedEventArgs_get_ActivatedOperation(py::wrapper::Windows::UI::WebUI::WebUIAppointmentsProviderRemoveAppointmentActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.WebUI.WebUIAppointmentsProviderRemoveAppointmentActivatedEventArgs", L"ActivatedOperation");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.ActivatedOperation();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_WebUIAppointmentsProviderRemoveAppointmentActivatedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::WebUI::WebUIAppointmentsProviderRemoveAppointmentActivatedEventArgs>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_WebUIAppointmentsProviderRemoveAppointmentActivatedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::WebUI::WebUIAppointmentsProviderRemoveAppointmentActivatedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_WebUIAppointmentsProviderRemoveAppointmentActivatedEventArgs[] = {
        { "_assign_array_", _assign_array_WebUIAppointmentsProviderRemoveAppointmentActivatedEventArgs, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_WebUIAppointmentsProviderRemoveAppointmentActivatedEventArgs), METH_O | METH_STATIC, nullptr },
        { }};

    static PyGetSetDef _getset_WebUIAppointmentsProviderRemoveAppointmentActivatedEventArgs[] = {
        { "kind", reinterpret_cast<getter>(WebUIAppointmentsProviderRemoveAppointmentActivatedEventArgs_get_Kind), nullptr, nullptr, nullptr },
        { "previous_execution_state", reinterpret_cast<getter>(WebUIAppointmentsProviderRemoveAppointmentActivatedEventArgs_get_PreviousExecutionState), nullptr, nullptr, nullptr },
        { "splash_screen", reinterpret_cast<getter>(WebUIAppointmentsProviderRemoveAppointmentActivatedEventArgs_get_SplashScreen), nullptr, nullptr, nullptr },
        { "user", reinterpret_cast<getter>(WebUIAppointmentsProviderRemoveAppointmentActivatedEventArgs_get_User), nullptr, nullptr, nullptr },
        { "verb", reinterpret_cast<getter>(WebUIAppointmentsProviderRemoveAppointmentActivatedEventArgs_get_Verb), nullptr, nullptr, nullptr },
        { "remove_appointment_operation", reinterpret_cast<getter>(WebUIAppointmentsProviderRemoveAppointmentActivatedEventArgs_get_RemoveAppointmentOperation), nullptr, nullptr, nullptr },
        { "activated_operation", reinterpret_cast<getter>(WebUIAppointmentsProviderRemoveAppointmentActivatedEventArgs_get_ActivatedOperation), nullptr, nullptr, nullptr },
        { }};

    static PyType_Slot _type_slots_WebUIAppointmentsProviderRemoveAppointmentActivatedEventArgs[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_WebUIAppointmentsProviderRemoveAppointmentActivatedEventArgs) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_WebUIAppointmentsProviderRemoveAppointmentActivatedEventArgs) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_WebUIAppointmentsProviderRemoveAppointmentActivatedEventArgs) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_WebUIAppointmentsProviderRemoveAppointmentActivatedEventArgs) },
        { }};

    static PyType_Spec type_spec_WebUIAppointmentsProviderRemoveAppointmentActivatedEventArgs = {
        "winrt._winrt_windows_ui_webui.WebUIAppointmentsProviderRemoveAppointmentActivatedEventArgs",
        sizeof(py::wrapper::Windows::UI::WebUI::WebUIAppointmentsProviderRemoveAppointmentActivatedEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_WebUIAppointmentsProviderRemoveAppointmentActivatedEventArgs};

    // ----- WebUIAppointmentsProviderReplaceAppointmentActivatedEventArgs class --------------------

    static PyObject* _new_WebUIAppointmentsProviderReplaceAppointmentActivatedEventArgs(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::UI::WebUI::WebUIAppointmentsProviderReplaceAppointmentActivatedEventArgs>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::UI::WebUI::WebUIAppointmentsProviderReplaceAppointmentActivatedEventArgs>::type_name);
        return nullptr;
    }

    static void _dealloc_WebUIAppointmentsProviderReplaceAppointmentActivatedEventArgs(py::wrapper::Windows::UI::WebUI::WebUIAppointmentsProviderReplaceAppointmentActivatedEventArgs* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* WebUIAppointmentsProviderReplaceAppointmentActivatedEventArgs_get_Kind(py::wrapper::Windows::UI::WebUI::WebUIAppointmentsProviderReplaceAppointmentActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.WebUI.WebUIAppointmentsProviderReplaceAppointmentActivatedEventArgs", L"Kind");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Kind();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* WebUIAppointmentsProviderReplaceAppointmentActivatedEventArgs_get_PreviousExecutionState(py::wrapper::Windows::UI::WebUI::WebUIAppointmentsProviderReplaceAppointmentActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.WebUI.WebUIAppointmentsProviderReplaceAppointmentActivatedEventArgs", L"PreviousExecutionState");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.PreviousExecutionState();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* WebUIAppointmentsProviderReplaceAppointmentActivatedEventArgs_get_SplashScreen(py::wrapper::Windows::UI::WebUI::WebUIAppointmentsProviderReplaceAppointmentActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.WebUI.WebUIAppointmentsProviderReplaceAppointmentActivatedEventArgs", L"SplashScreen");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.SplashScreen();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* WebUIAppointmentsProviderReplaceAppointmentActivatedEventArgs_get_User(py::wrapper::Windows::UI::WebUI::WebUIAppointmentsProviderReplaceAppointmentActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.WebUI.WebUIAppointmentsProviderReplaceAppointmentActivatedEventArgs", L"User");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.User();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* WebUIAppointmentsProviderReplaceAppointmentActivatedEventArgs_get_Verb(py::wrapper::Windows::UI::WebUI::WebUIAppointmentsProviderReplaceAppointmentActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.WebUI.WebUIAppointmentsProviderReplaceAppointmentActivatedEventArgs", L"Verb");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Verb();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* WebUIAppointmentsProviderReplaceAppointmentActivatedEventArgs_get_ReplaceAppointmentOperation(py::wrapper::Windows::UI::WebUI::WebUIAppointmentsProviderReplaceAppointmentActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.WebUI.WebUIAppointmentsProviderReplaceAppointmentActivatedEventArgs", L"ReplaceAppointmentOperation");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.ReplaceAppointmentOperation();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* WebUIAppointmentsProviderReplaceAppointmentActivatedEventArgs_get_ActivatedOperation(py::wrapper::Windows::UI::WebUI::WebUIAppointmentsProviderReplaceAppointmentActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.WebUI.WebUIAppointmentsProviderReplaceAppointmentActivatedEventArgs", L"ActivatedOperation");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.ActivatedOperation();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_WebUIAppointmentsProviderReplaceAppointmentActivatedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::WebUI::WebUIAppointmentsProviderReplaceAppointmentActivatedEventArgs>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_WebUIAppointmentsProviderReplaceAppointmentActivatedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::WebUI::WebUIAppointmentsProviderReplaceAppointmentActivatedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_WebUIAppointmentsProviderReplaceAppointmentActivatedEventArgs[] = {
        { "_assign_array_", _assign_array_WebUIAppointmentsProviderReplaceAppointmentActivatedEventArgs, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_WebUIAppointmentsProviderReplaceAppointmentActivatedEventArgs), METH_O | METH_STATIC, nullptr },
        { }};

    static PyGetSetDef _getset_WebUIAppointmentsProviderReplaceAppointmentActivatedEventArgs[] = {
        { "kind", reinterpret_cast<getter>(WebUIAppointmentsProviderReplaceAppointmentActivatedEventArgs_get_Kind), nullptr, nullptr, nullptr },
        { "previous_execution_state", reinterpret_cast<getter>(WebUIAppointmentsProviderReplaceAppointmentActivatedEventArgs_get_PreviousExecutionState), nullptr, nullptr, nullptr },
        { "splash_screen", reinterpret_cast<getter>(WebUIAppointmentsProviderReplaceAppointmentActivatedEventArgs_get_SplashScreen), nullptr, nullptr, nullptr },
        { "user", reinterpret_cast<getter>(WebUIAppointmentsProviderReplaceAppointmentActivatedEventArgs_get_User), nullptr, nullptr, nullptr },
        { "verb", reinterpret_cast<getter>(WebUIAppointmentsProviderReplaceAppointmentActivatedEventArgs_get_Verb), nullptr, nullptr, nullptr },
        { "replace_appointment_operation", reinterpret_cast<getter>(WebUIAppointmentsProviderReplaceAppointmentActivatedEventArgs_get_ReplaceAppointmentOperation), nullptr, nullptr, nullptr },
        { "activated_operation", reinterpret_cast<getter>(WebUIAppointmentsProviderReplaceAppointmentActivatedEventArgs_get_ActivatedOperation), nullptr, nullptr, nullptr },
        { }};

    static PyType_Slot _type_slots_WebUIAppointmentsProviderReplaceAppointmentActivatedEventArgs[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_WebUIAppointmentsProviderReplaceAppointmentActivatedEventArgs) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_WebUIAppointmentsProviderReplaceAppointmentActivatedEventArgs) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_WebUIAppointmentsProviderReplaceAppointmentActivatedEventArgs) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_WebUIAppointmentsProviderReplaceAppointmentActivatedEventArgs) },
        { }};

    static PyType_Spec type_spec_WebUIAppointmentsProviderReplaceAppointmentActivatedEventArgs = {
        "winrt._winrt_windows_ui_webui.WebUIAppointmentsProviderReplaceAppointmentActivatedEventArgs",
        sizeof(py::wrapper::Windows::UI::WebUI::WebUIAppointmentsProviderReplaceAppointmentActivatedEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_WebUIAppointmentsProviderReplaceAppointmentActivatedEventArgs};

    // ----- WebUIAppointmentsProviderShowAppointmentDetailsActivatedEventArgs class --------------------

    static PyObject* _new_WebUIAppointmentsProviderShowAppointmentDetailsActivatedEventArgs(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::UI::WebUI::WebUIAppointmentsProviderShowAppointmentDetailsActivatedEventArgs>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::UI::WebUI::WebUIAppointmentsProviderShowAppointmentDetailsActivatedEventArgs>::type_name);
        return nullptr;
    }

    static void _dealloc_WebUIAppointmentsProviderShowAppointmentDetailsActivatedEventArgs(py::wrapper::Windows::UI::WebUI::WebUIAppointmentsProviderShowAppointmentDetailsActivatedEventArgs* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* WebUIAppointmentsProviderShowAppointmentDetailsActivatedEventArgs_get_Kind(py::wrapper::Windows::UI::WebUI::WebUIAppointmentsProviderShowAppointmentDetailsActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.WebUI.WebUIAppointmentsProviderShowAppointmentDetailsActivatedEventArgs", L"Kind");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Kind();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* WebUIAppointmentsProviderShowAppointmentDetailsActivatedEventArgs_get_PreviousExecutionState(py::wrapper::Windows::UI::WebUI::WebUIAppointmentsProviderShowAppointmentDetailsActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.WebUI.WebUIAppointmentsProviderShowAppointmentDetailsActivatedEventArgs", L"PreviousExecutionState");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.PreviousExecutionState();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* WebUIAppointmentsProviderShowAppointmentDetailsActivatedEventArgs_get_SplashScreen(py::wrapper::Windows::UI::WebUI::WebUIAppointmentsProviderShowAppointmentDetailsActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.WebUI.WebUIAppointmentsProviderShowAppointmentDetailsActivatedEventArgs", L"SplashScreen");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.SplashScreen();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* WebUIAppointmentsProviderShowAppointmentDetailsActivatedEventArgs_get_User(py::wrapper::Windows::UI::WebUI::WebUIAppointmentsProviderShowAppointmentDetailsActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.WebUI.WebUIAppointmentsProviderShowAppointmentDetailsActivatedEventArgs", L"User");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.User();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* WebUIAppointmentsProviderShowAppointmentDetailsActivatedEventArgs_get_Verb(py::wrapper::Windows::UI::WebUI::WebUIAppointmentsProviderShowAppointmentDetailsActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.WebUI.WebUIAppointmentsProviderShowAppointmentDetailsActivatedEventArgs", L"Verb");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Verb();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* WebUIAppointmentsProviderShowAppointmentDetailsActivatedEventArgs_get_InstanceStartDate(py::wrapper::Windows::UI::WebUI::WebUIAppointmentsProviderShowAppointmentDetailsActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.WebUI.WebUIAppointmentsProviderShowAppointmentDetailsActivatedEventArgs", L"InstanceStartDate");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.InstanceStartDate();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* WebUIAppointmentsProviderShowAppointmentDetailsActivatedEventArgs_get_LocalId(py::wrapper::Windows::UI::WebUI::WebUIAppointmentsProviderShowAppointmentDetailsActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.WebUI.WebUIAppointmentsProviderShowAppointmentDetailsActivatedEventArgs", L"LocalId");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.LocalId();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* WebUIAppointmentsProviderShowAppointmentDetailsActivatedEventArgs_get_RoamingId(py::wrapper::Windows::UI::WebUI::WebUIAppointmentsProviderShowAppointmentDetailsActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.WebUI.WebUIAppointmentsProviderShowAppointmentDetailsActivatedEventArgs", L"RoamingId");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.RoamingId();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* WebUIAppointmentsProviderShowAppointmentDetailsActivatedEventArgs_get_ActivatedOperation(py::wrapper::Windows::UI::WebUI::WebUIAppointmentsProviderShowAppointmentDetailsActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.WebUI.WebUIAppointmentsProviderShowAppointmentDetailsActivatedEventArgs", L"ActivatedOperation");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.ActivatedOperation();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_WebUIAppointmentsProviderShowAppointmentDetailsActivatedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::WebUI::WebUIAppointmentsProviderShowAppointmentDetailsActivatedEventArgs>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_WebUIAppointmentsProviderShowAppointmentDetailsActivatedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::WebUI::WebUIAppointmentsProviderShowAppointmentDetailsActivatedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_WebUIAppointmentsProviderShowAppointmentDetailsActivatedEventArgs[] = {
        { "_assign_array_", _assign_array_WebUIAppointmentsProviderShowAppointmentDetailsActivatedEventArgs, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_WebUIAppointmentsProviderShowAppointmentDetailsActivatedEventArgs), METH_O | METH_STATIC, nullptr },
        { }};

    static PyGetSetDef _getset_WebUIAppointmentsProviderShowAppointmentDetailsActivatedEventArgs[] = {
        { "kind", reinterpret_cast<getter>(WebUIAppointmentsProviderShowAppointmentDetailsActivatedEventArgs_get_Kind), nullptr, nullptr, nullptr },
        { "previous_execution_state", reinterpret_cast<getter>(WebUIAppointmentsProviderShowAppointmentDetailsActivatedEventArgs_get_PreviousExecutionState), nullptr, nullptr, nullptr },
        { "splash_screen", reinterpret_cast<getter>(WebUIAppointmentsProviderShowAppointmentDetailsActivatedEventArgs_get_SplashScreen), nullptr, nullptr, nullptr },
        { "user", reinterpret_cast<getter>(WebUIAppointmentsProviderShowAppointmentDetailsActivatedEventArgs_get_User), nullptr, nullptr, nullptr },
        { "verb", reinterpret_cast<getter>(WebUIAppointmentsProviderShowAppointmentDetailsActivatedEventArgs_get_Verb), nullptr, nullptr, nullptr },
        { "instance_start_date", reinterpret_cast<getter>(WebUIAppointmentsProviderShowAppointmentDetailsActivatedEventArgs_get_InstanceStartDate), nullptr, nullptr, nullptr },
        { "local_id", reinterpret_cast<getter>(WebUIAppointmentsProviderShowAppointmentDetailsActivatedEventArgs_get_LocalId), nullptr, nullptr, nullptr },
        { "roaming_id", reinterpret_cast<getter>(WebUIAppointmentsProviderShowAppointmentDetailsActivatedEventArgs_get_RoamingId), nullptr, nullptr, nullptr },
        { "activated_operation", reinterpret_cast<getter>(WebUIAppointmentsProviderShowAppointmentDetailsActivatedEventArgs_get_ActivatedOperation), nullptr, nullptr, nullptr },
        { }};

    static PyType_Slot _type_slots_WebUIAppointmentsProviderShowAppointmentDetailsActivatedEventArgs[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_WebUIAppointmentsProviderShowAppointmentDetailsActivatedEventArgs) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_WebUIAppointmentsProviderShowAppointmentDetailsActivatedEventArgs) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_WebUIAppointmentsProviderShowAppointmentDetailsActivatedEventArgs) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_WebUIAppointmentsProviderShowAppointmentDetailsActivatedEventArgs) },
        { }};

    static PyType_Spec type_spec_WebUIAppointmentsProviderShowAppointmentDetailsActivatedEventArgs = {
        "winrt._winrt_windows_ui_webui.WebUIAppointmentsProviderShowAppointmentDetailsActivatedEventArgs",
        sizeof(py::wrapper::Windows::UI::WebUI::WebUIAppointmentsProviderShowAppointmentDetailsActivatedEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_WebUIAppointmentsProviderShowAppointmentDetailsActivatedEventArgs};

    // ----- WebUIAppointmentsProviderShowTimeFrameActivatedEventArgs class --------------------

    static PyObject* _new_WebUIAppointmentsProviderShowTimeFrameActivatedEventArgs(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::UI::WebUI::WebUIAppointmentsProviderShowTimeFrameActivatedEventArgs>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::UI::WebUI::WebUIAppointmentsProviderShowTimeFrameActivatedEventArgs>::type_name);
        return nullptr;
    }

    static void _dealloc_WebUIAppointmentsProviderShowTimeFrameActivatedEventArgs(py::wrapper::Windows::UI::WebUI::WebUIAppointmentsProviderShowTimeFrameActivatedEventArgs* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* WebUIAppointmentsProviderShowTimeFrameActivatedEventArgs_get_Kind(py::wrapper::Windows::UI::WebUI::WebUIAppointmentsProviderShowTimeFrameActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.WebUI.WebUIAppointmentsProviderShowTimeFrameActivatedEventArgs", L"Kind");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Kind();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* WebUIAppointmentsProviderShowTimeFrameActivatedEventArgs_get_PreviousExecutionState(py::wrapper::Windows::UI::WebUI::WebUIAppointmentsProviderShowTimeFrameActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.WebUI.WebUIAppointmentsProviderShowTimeFrameActivatedEventArgs", L"PreviousExecutionState");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.PreviousExecutionState();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* WebUIAppointmentsProviderShowTimeFrameActivatedEventArgs_get_SplashScreen(py::wrapper::Windows::UI::WebUI::WebUIAppointmentsProviderShowTimeFrameActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.WebUI.WebUIAppointmentsProviderShowTimeFrameActivatedEventArgs", L"SplashScreen");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.SplashScreen();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* WebUIAppointmentsProviderShowTimeFrameActivatedEventArgs_get_User(py::wrapper::Windows::UI::WebUI::WebUIAppointmentsProviderShowTimeFrameActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.WebUI.WebUIAppointmentsProviderShowTimeFrameActivatedEventArgs", L"User");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.User();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* WebUIAppointmentsProviderShowTimeFrameActivatedEventArgs_get_Verb(py::wrapper::Windows::UI::WebUI::WebUIAppointmentsProviderShowTimeFrameActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.WebUI.WebUIAppointmentsProviderShowTimeFrameActivatedEventArgs", L"Verb");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Verb();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* WebUIAppointmentsProviderShowTimeFrameActivatedEventArgs_get_Duration(py::wrapper::Windows::UI::WebUI::WebUIAppointmentsProviderShowTimeFrameActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.WebUI.WebUIAppointmentsProviderShowTimeFrameActivatedEventArgs", L"Duration");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Duration();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* WebUIAppointmentsProviderShowTimeFrameActivatedEventArgs_get_TimeToShow(py::wrapper::Windows::UI::WebUI::WebUIAppointmentsProviderShowTimeFrameActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.WebUI.WebUIAppointmentsProviderShowTimeFrameActivatedEventArgs", L"TimeToShow");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.TimeToShow();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* WebUIAppointmentsProviderShowTimeFrameActivatedEventArgs_get_ActivatedOperation(py::wrapper::Windows::UI::WebUI::WebUIAppointmentsProviderShowTimeFrameActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.WebUI.WebUIAppointmentsProviderShowTimeFrameActivatedEventArgs", L"ActivatedOperation");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.ActivatedOperation();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_WebUIAppointmentsProviderShowTimeFrameActivatedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::WebUI::WebUIAppointmentsProviderShowTimeFrameActivatedEventArgs>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_WebUIAppointmentsProviderShowTimeFrameActivatedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::WebUI::WebUIAppointmentsProviderShowTimeFrameActivatedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_WebUIAppointmentsProviderShowTimeFrameActivatedEventArgs[] = {
        { "_assign_array_", _assign_array_WebUIAppointmentsProviderShowTimeFrameActivatedEventArgs, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_WebUIAppointmentsProviderShowTimeFrameActivatedEventArgs), METH_O | METH_STATIC, nullptr },
        { }};

    static PyGetSetDef _getset_WebUIAppointmentsProviderShowTimeFrameActivatedEventArgs[] = {
        { "kind", reinterpret_cast<getter>(WebUIAppointmentsProviderShowTimeFrameActivatedEventArgs_get_Kind), nullptr, nullptr, nullptr },
        { "previous_execution_state", reinterpret_cast<getter>(WebUIAppointmentsProviderShowTimeFrameActivatedEventArgs_get_PreviousExecutionState), nullptr, nullptr, nullptr },
        { "splash_screen", reinterpret_cast<getter>(WebUIAppointmentsProviderShowTimeFrameActivatedEventArgs_get_SplashScreen), nullptr, nullptr, nullptr },
        { "user", reinterpret_cast<getter>(WebUIAppointmentsProviderShowTimeFrameActivatedEventArgs_get_User), nullptr, nullptr, nullptr },
        { "verb", reinterpret_cast<getter>(WebUIAppointmentsProviderShowTimeFrameActivatedEventArgs_get_Verb), nullptr, nullptr, nullptr },
        { "duration", reinterpret_cast<getter>(WebUIAppointmentsProviderShowTimeFrameActivatedEventArgs_get_Duration), nullptr, nullptr, nullptr },
        { "time_to_show", reinterpret_cast<getter>(WebUIAppointmentsProviderShowTimeFrameActivatedEventArgs_get_TimeToShow), nullptr, nullptr, nullptr },
        { "activated_operation", reinterpret_cast<getter>(WebUIAppointmentsProviderShowTimeFrameActivatedEventArgs_get_ActivatedOperation), nullptr, nullptr, nullptr },
        { }};

    static PyType_Slot _type_slots_WebUIAppointmentsProviderShowTimeFrameActivatedEventArgs[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_WebUIAppointmentsProviderShowTimeFrameActivatedEventArgs) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_WebUIAppointmentsProviderShowTimeFrameActivatedEventArgs) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_WebUIAppointmentsProviderShowTimeFrameActivatedEventArgs) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_WebUIAppointmentsProviderShowTimeFrameActivatedEventArgs) },
        { }};

    static PyType_Spec type_spec_WebUIAppointmentsProviderShowTimeFrameActivatedEventArgs = {
        "winrt._winrt_windows_ui_webui.WebUIAppointmentsProviderShowTimeFrameActivatedEventArgs",
        sizeof(py::wrapper::Windows::UI::WebUI::WebUIAppointmentsProviderShowTimeFrameActivatedEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_WebUIAppointmentsProviderShowTimeFrameActivatedEventArgs};

    // ----- WebUIBackgroundTaskInstance class --------------------

    static PyObject* _new_WebUIBackgroundTaskInstance(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::UI::WebUI::WebUIBackgroundTaskInstance>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::UI::WebUI::WebUIBackgroundTaskInstance>::type_name);
        return nullptr;
    }

    static PyObject* WebUIBackgroundTaskInstance_get_Current(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.WebUI.WebUIBackgroundTaskInstance", L"Current");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return winrt::Windows::UI::WebUI::WebUIBackgroundTaskInstance::Current();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_WebUIBackgroundTaskInstance[] = {
        { }};

    static PyGetSetDef _getset_WebUIBackgroundTaskInstance[] = {
        { }};

    static PyType_Slot _type_slots_WebUIBackgroundTaskInstance[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_WebUIBackgroundTaskInstance) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_WebUIBackgroundTaskInstance) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_WebUIBackgroundTaskInstance) },
        { }};

    static PyType_Spec type_spec_WebUIBackgroundTaskInstance = {
        "winrt._winrt_windows_ui_webui.WebUIBackgroundTaskInstance",
        0,
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_WebUIBackgroundTaskInstance};

    static PyGetSetDef getset_WebUIBackgroundTaskInstance_Static[] = {
        { "current", reinterpret_cast<getter>(WebUIBackgroundTaskInstance_get_Current), nullptr, nullptr, nullptr },
        { }};

    static PyMethodDef methods_WebUIBackgroundTaskInstance_Static[] = {
        { }};

    static PyType_Slot type_slots_WebUIBackgroundTaskInstance_Static[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_WebUIBackgroundTaskInstance_Static) },
        { Py_tp_methods, reinterpret_cast<void*>(methods_WebUIBackgroundTaskInstance_Static) },
        { }
    };

    static PyType_Spec type_spec_WebUIBackgroundTaskInstance_Static = {
        "winrt._winrt_windows_ui_webui.WebUIBackgroundTaskInstance_Static",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT,
        type_slots_WebUIBackgroundTaskInstance_Static};

    // ----- WebUIBackgroundTaskInstanceRuntimeClass class --------------------

    static PyObject* _new_WebUIBackgroundTaskInstanceRuntimeClass(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::UI::WebUI::WebUIBackgroundTaskInstanceRuntimeClass>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::UI::WebUI::WebUIBackgroundTaskInstanceRuntimeClass>::type_name);
        return nullptr;
    }

    static void _dealloc_WebUIBackgroundTaskInstanceRuntimeClass(py::wrapper::Windows::UI::WebUI::WebUIBackgroundTaskInstanceRuntimeClass* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* WebUIBackgroundTaskInstanceRuntimeClass_GetDeferral(py::wrapper::Windows::UI::WebUI::WebUIBackgroundTaskInstanceRuntimeClass* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.WebUI.WebUIBackgroundTaskInstanceRuntimeClass", L"GetDeferral", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return self->obj.GetDeferral();
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* WebUIBackgroundTaskInstanceRuntimeClass_get_Progress(py::wrapper::Windows::UI::WebUI::WebUIBackgroundTaskInstanceRuntimeClass* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.WebUI.WebUIBackgroundTaskInstanceRuntimeClass", L"Progress");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Progress();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int WebUIBackgroundTaskInstanceRuntimeClass_put_Progress(py::wrapper::Windows::UI::WebUI::WebUIBackgroundTaskInstanceRuntimeClass* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.WebUI.WebUIBackgroundTaskInstanceRuntimeClass", L"Progress");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<uint32_t>(arg);

            {
                auto _gil = release_gil();
                self->obj.Progress(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* WebUIBackgroundTaskInstanceRuntimeClass_get_InstanceId(py::wrapper::Windows::UI::WebUI::WebUIBackgroundTaskInstanceRuntimeClass* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.WebUI.WebUIBackgroundTaskInstanceRuntimeClass", L"InstanceId");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.InstanceId();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* WebUIBackgroundTaskInstanceRuntimeClass_get_SuspendedCount(py::wrapper::Windows::UI::WebUI::WebUIBackgroundTaskInstanceRuntimeClass* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.WebUI.WebUIBackgroundTaskInstanceRuntimeClass", L"SuspendedCount");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.SuspendedCount();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* WebUIBackgroundTaskInstanceRuntimeClass_get_Task(py::wrapper::Windows::UI::WebUI::WebUIBackgroundTaskInstanceRuntimeClass* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.WebUI.WebUIBackgroundTaskInstanceRuntimeClass", L"Task");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Task();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* WebUIBackgroundTaskInstanceRuntimeClass_get_TriggerDetails(py::wrapper::Windows::UI::WebUI::WebUIBackgroundTaskInstanceRuntimeClass* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.WebUI.WebUIBackgroundTaskInstanceRuntimeClass", L"TriggerDetails");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.TriggerDetails();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* WebUIBackgroundTaskInstanceRuntimeClass_get_Succeeded(py::wrapper::Windows::UI::WebUI::WebUIBackgroundTaskInstanceRuntimeClass* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.WebUI.WebUIBackgroundTaskInstanceRuntimeClass", L"Succeeded");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Succeeded();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int WebUIBackgroundTaskInstanceRuntimeClass_put_Succeeded(py::wrapper::Windows::UI::WebUI::WebUIBackgroundTaskInstanceRuntimeClass* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.WebUI.WebUIBackgroundTaskInstanceRuntimeClass", L"Succeeded");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<bool>(arg);

            {
                auto _gil = release_gil();
                self->obj.Succeeded(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* WebUIBackgroundTaskInstanceRuntimeClass_add_Canceled(py::wrapper::Windows::UI::WebUI::WebUIBackgroundTaskInstanceRuntimeClass* self, PyObject* arg) noexcept
    {
        try
        {
            static std::optional<bool> is_event_present{};

            if (!is_event_present.has_value())
            {
                is_event_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.UI.WebUI.WebUIBackgroundTaskInstanceRuntimeClass", L"Canceled");
            }

            if (!is_event_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::Windows::ApplicationModel::Background::BackgroundTaskCanceledEventHandler>(arg);

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Canceled(param0);
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* WebUIBackgroundTaskInstanceRuntimeClass_remove_Canceled(py::wrapper::Windows::UI::WebUI::WebUIBackgroundTaskInstanceRuntimeClass* self, PyObject* arg) noexcept
    {
        try
        {
            static std::optional<bool> is_event_present{};

            if (!is_event_present.has_value())
            {
                is_event_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.UI.WebUI.WebUIBackgroundTaskInstanceRuntimeClass", L"Canceled");
            }

            if (!is_event_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::event_token>(arg);

            {
                auto _gil = release_gil();
                self->obj.Canceled(param0);
            }

            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_WebUIBackgroundTaskInstanceRuntimeClass(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::WebUI::WebUIBackgroundTaskInstanceRuntimeClass>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_WebUIBackgroundTaskInstanceRuntimeClass(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::WebUI::WebUIBackgroundTaskInstanceRuntimeClass>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_WebUIBackgroundTaskInstanceRuntimeClass[] = {
        { "get_deferral", reinterpret_cast<PyCFunction>(WebUIBackgroundTaskInstanceRuntimeClass_GetDeferral), METH_VARARGS, nullptr },
        { "add_canceled", reinterpret_cast<PyCFunction>(WebUIBackgroundTaskInstanceRuntimeClass_add_Canceled), METH_O, nullptr },
        { "remove_canceled", reinterpret_cast<PyCFunction>(WebUIBackgroundTaskInstanceRuntimeClass_remove_Canceled), METH_O, nullptr },
        { "_assign_array_", _assign_array_WebUIBackgroundTaskInstanceRuntimeClass, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_WebUIBackgroundTaskInstanceRuntimeClass), METH_O | METH_STATIC, nullptr },
        { }};

    static PyGetSetDef _getset_WebUIBackgroundTaskInstanceRuntimeClass[] = {
        { "progress", reinterpret_cast<getter>(WebUIBackgroundTaskInstanceRuntimeClass_get_Progress), reinterpret_cast<setter>(WebUIBackgroundTaskInstanceRuntimeClass_put_Progress), nullptr, nullptr },
        { "instance_id", reinterpret_cast<getter>(WebUIBackgroundTaskInstanceRuntimeClass_get_InstanceId), nullptr, nullptr, nullptr },
        { "suspended_count", reinterpret_cast<getter>(WebUIBackgroundTaskInstanceRuntimeClass_get_SuspendedCount), nullptr, nullptr, nullptr },
        { "task", reinterpret_cast<getter>(WebUIBackgroundTaskInstanceRuntimeClass_get_Task), nullptr, nullptr, nullptr },
        { "trigger_details", reinterpret_cast<getter>(WebUIBackgroundTaskInstanceRuntimeClass_get_TriggerDetails), nullptr, nullptr, nullptr },
        { "succeeded", reinterpret_cast<getter>(WebUIBackgroundTaskInstanceRuntimeClass_get_Succeeded), reinterpret_cast<setter>(WebUIBackgroundTaskInstanceRuntimeClass_put_Succeeded), nullptr, nullptr },
        { }};

    static PyType_Slot _type_slots_WebUIBackgroundTaskInstanceRuntimeClass[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_WebUIBackgroundTaskInstanceRuntimeClass) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_WebUIBackgroundTaskInstanceRuntimeClass) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_WebUIBackgroundTaskInstanceRuntimeClass) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_WebUIBackgroundTaskInstanceRuntimeClass) },
        { }};

    static PyType_Spec type_spec_WebUIBackgroundTaskInstanceRuntimeClass = {
        "winrt._winrt_windows_ui_webui.WebUIBackgroundTaskInstanceRuntimeClass",
        sizeof(py::wrapper::Windows::UI::WebUI::WebUIBackgroundTaskInstanceRuntimeClass),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_WebUIBackgroundTaskInstanceRuntimeClass};

    // ----- WebUIBarcodeScannerPreviewActivatedEventArgs class --------------------

    static PyObject* _new_WebUIBarcodeScannerPreviewActivatedEventArgs(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::UI::WebUI::WebUIBarcodeScannerPreviewActivatedEventArgs>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::UI::WebUI::WebUIBarcodeScannerPreviewActivatedEventArgs>::type_name);
        return nullptr;
    }

    static void _dealloc_WebUIBarcodeScannerPreviewActivatedEventArgs(py::wrapper::Windows::UI::WebUI::WebUIBarcodeScannerPreviewActivatedEventArgs* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* WebUIBarcodeScannerPreviewActivatedEventArgs_get_Kind(py::wrapper::Windows::UI::WebUI::WebUIBarcodeScannerPreviewActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.WebUI.WebUIBarcodeScannerPreviewActivatedEventArgs", L"Kind");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Kind();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* WebUIBarcodeScannerPreviewActivatedEventArgs_get_PreviousExecutionState(py::wrapper::Windows::UI::WebUI::WebUIBarcodeScannerPreviewActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.WebUI.WebUIBarcodeScannerPreviewActivatedEventArgs", L"PreviousExecutionState");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.PreviousExecutionState();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* WebUIBarcodeScannerPreviewActivatedEventArgs_get_SplashScreen(py::wrapper::Windows::UI::WebUI::WebUIBarcodeScannerPreviewActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.WebUI.WebUIBarcodeScannerPreviewActivatedEventArgs", L"SplashScreen");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.SplashScreen();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* WebUIBarcodeScannerPreviewActivatedEventArgs_get_User(py::wrapper::Windows::UI::WebUI::WebUIBarcodeScannerPreviewActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.WebUI.WebUIBarcodeScannerPreviewActivatedEventArgs", L"User");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.User();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* WebUIBarcodeScannerPreviewActivatedEventArgs_get_ConnectionId(py::wrapper::Windows::UI::WebUI::WebUIBarcodeScannerPreviewActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.WebUI.WebUIBarcodeScannerPreviewActivatedEventArgs", L"ConnectionId");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.ConnectionId();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* WebUIBarcodeScannerPreviewActivatedEventArgs_get_ActivatedOperation(py::wrapper::Windows::UI::WebUI::WebUIBarcodeScannerPreviewActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.WebUI.WebUIBarcodeScannerPreviewActivatedEventArgs", L"ActivatedOperation");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.ActivatedOperation();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_WebUIBarcodeScannerPreviewActivatedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::WebUI::WebUIBarcodeScannerPreviewActivatedEventArgs>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_WebUIBarcodeScannerPreviewActivatedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::WebUI::WebUIBarcodeScannerPreviewActivatedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_WebUIBarcodeScannerPreviewActivatedEventArgs[] = {
        { "_assign_array_", _assign_array_WebUIBarcodeScannerPreviewActivatedEventArgs, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_WebUIBarcodeScannerPreviewActivatedEventArgs), METH_O | METH_STATIC, nullptr },
        { }};

    static PyGetSetDef _getset_WebUIBarcodeScannerPreviewActivatedEventArgs[] = {
        { "kind", reinterpret_cast<getter>(WebUIBarcodeScannerPreviewActivatedEventArgs_get_Kind), nullptr, nullptr, nullptr },
        { "previous_execution_state", reinterpret_cast<getter>(WebUIBarcodeScannerPreviewActivatedEventArgs_get_PreviousExecutionState), nullptr, nullptr, nullptr },
        { "splash_screen", reinterpret_cast<getter>(WebUIBarcodeScannerPreviewActivatedEventArgs_get_SplashScreen), nullptr, nullptr, nullptr },
        { "user", reinterpret_cast<getter>(WebUIBarcodeScannerPreviewActivatedEventArgs_get_User), nullptr, nullptr, nullptr },
        { "connection_id", reinterpret_cast<getter>(WebUIBarcodeScannerPreviewActivatedEventArgs_get_ConnectionId), nullptr, nullptr, nullptr },
        { "activated_operation", reinterpret_cast<getter>(WebUIBarcodeScannerPreviewActivatedEventArgs_get_ActivatedOperation), nullptr, nullptr, nullptr },
        { }};

    static PyType_Slot _type_slots_WebUIBarcodeScannerPreviewActivatedEventArgs[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_WebUIBarcodeScannerPreviewActivatedEventArgs) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_WebUIBarcodeScannerPreviewActivatedEventArgs) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_WebUIBarcodeScannerPreviewActivatedEventArgs) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_WebUIBarcodeScannerPreviewActivatedEventArgs) },
        { }};

    static PyType_Spec type_spec_WebUIBarcodeScannerPreviewActivatedEventArgs = {
        "winrt._winrt_windows_ui_webui.WebUIBarcodeScannerPreviewActivatedEventArgs",
        sizeof(py::wrapper::Windows::UI::WebUI::WebUIBarcodeScannerPreviewActivatedEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_WebUIBarcodeScannerPreviewActivatedEventArgs};

    // ----- WebUICachedFileUpdaterActivatedEventArgs class --------------------

    static PyObject* _new_WebUICachedFileUpdaterActivatedEventArgs(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::UI::WebUI::WebUICachedFileUpdaterActivatedEventArgs>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::UI::WebUI::WebUICachedFileUpdaterActivatedEventArgs>::type_name);
        return nullptr;
    }

    static void _dealloc_WebUICachedFileUpdaterActivatedEventArgs(py::wrapper::Windows::UI::WebUI::WebUICachedFileUpdaterActivatedEventArgs* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* WebUICachedFileUpdaterActivatedEventArgs_get_Kind(py::wrapper::Windows::UI::WebUI::WebUICachedFileUpdaterActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.WebUI.WebUICachedFileUpdaterActivatedEventArgs", L"Kind");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Kind();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* WebUICachedFileUpdaterActivatedEventArgs_get_PreviousExecutionState(py::wrapper::Windows::UI::WebUI::WebUICachedFileUpdaterActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.WebUI.WebUICachedFileUpdaterActivatedEventArgs", L"PreviousExecutionState");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.PreviousExecutionState();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* WebUICachedFileUpdaterActivatedEventArgs_get_SplashScreen(py::wrapper::Windows::UI::WebUI::WebUICachedFileUpdaterActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.WebUI.WebUICachedFileUpdaterActivatedEventArgs", L"SplashScreen");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.SplashScreen();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* WebUICachedFileUpdaterActivatedEventArgs_get_User(py::wrapper::Windows::UI::WebUI::WebUICachedFileUpdaterActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.WebUI.WebUICachedFileUpdaterActivatedEventArgs", L"User");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.User();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* WebUICachedFileUpdaterActivatedEventArgs_get_CachedFileUpdaterUI(py::wrapper::Windows::UI::WebUI::WebUICachedFileUpdaterActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.WebUI.WebUICachedFileUpdaterActivatedEventArgs", L"CachedFileUpdaterUI");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.CachedFileUpdaterUI();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* WebUICachedFileUpdaterActivatedEventArgs_get_ActivatedOperation(py::wrapper::Windows::UI::WebUI::WebUICachedFileUpdaterActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.WebUI.WebUICachedFileUpdaterActivatedEventArgs", L"ActivatedOperation");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.ActivatedOperation();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_WebUICachedFileUpdaterActivatedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::WebUI::WebUICachedFileUpdaterActivatedEventArgs>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_WebUICachedFileUpdaterActivatedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::WebUI::WebUICachedFileUpdaterActivatedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_WebUICachedFileUpdaterActivatedEventArgs[] = {
        { "_assign_array_", _assign_array_WebUICachedFileUpdaterActivatedEventArgs, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_WebUICachedFileUpdaterActivatedEventArgs), METH_O | METH_STATIC, nullptr },
        { }};

    static PyGetSetDef _getset_WebUICachedFileUpdaterActivatedEventArgs[] = {
        { "kind", reinterpret_cast<getter>(WebUICachedFileUpdaterActivatedEventArgs_get_Kind), nullptr, nullptr, nullptr },
        { "previous_execution_state", reinterpret_cast<getter>(WebUICachedFileUpdaterActivatedEventArgs_get_PreviousExecutionState), nullptr, nullptr, nullptr },
        { "splash_screen", reinterpret_cast<getter>(WebUICachedFileUpdaterActivatedEventArgs_get_SplashScreen), nullptr, nullptr, nullptr },
        { "user", reinterpret_cast<getter>(WebUICachedFileUpdaterActivatedEventArgs_get_User), nullptr, nullptr, nullptr },
        { "cached_file_updater_ui", reinterpret_cast<getter>(WebUICachedFileUpdaterActivatedEventArgs_get_CachedFileUpdaterUI), nullptr, nullptr, nullptr },
        { "activated_operation", reinterpret_cast<getter>(WebUICachedFileUpdaterActivatedEventArgs_get_ActivatedOperation), nullptr, nullptr, nullptr },
        { }};

    static PyType_Slot _type_slots_WebUICachedFileUpdaterActivatedEventArgs[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_WebUICachedFileUpdaterActivatedEventArgs) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_WebUICachedFileUpdaterActivatedEventArgs) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_WebUICachedFileUpdaterActivatedEventArgs) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_WebUICachedFileUpdaterActivatedEventArgs) },
        { }};

    static PyType_Spec type_spec_WebUICachedFileUpdaterActivatedEventArgs = {
        "winrt._winrt_windows_ui_webui.WebUICachedFileUpdaterActivatedEventArgs",
        sizeof(py::wrapper::Windows::UI::WebUI::WebUICachedFileUpdaterActivatedEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_WebUICachedFileUpdaterActivatedEventArgs};

    // ----- WebUICameraSettingsActivatedEventArgs class --------------------

    static PyObject* _new_WebUICameraSettingsActivatedEventArgs(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::UI::WebUI::WebUICameraSettingsActivatedEventArgs>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::UI::WebUI::WebUICameraSettingsActivatedEventArgs>::type_name);
        return nullptr;
    }

    static void _dealloc_WebUICameraSettingsActivatedEventArgs(py::wrapper::Windows::UI::WebUI::WebUICameraSettingsActivatedEventArgs* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* WebUICameraSettingsActivatedEventArgs_get_Kind(py::wrapper::Windows::UI::WebUI::WebUICameraSettingsActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.WebUI.WebUICameraSettingsActivatedEventArgs", L"Kind");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Kind();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* WebUICameraSettingsActivatedEventArgs_get_PreviousExecutionState(py::wrapper::Windows::UI::WebUI::WebUICameraSettingsActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.WebUI.WebUICameraSettingsActivatedEventArgs", L"PreviousExecutionState");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.PreviousExecutionState();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* WebUICameraSettingsActivatedEventArgs_get_SplashScreen(py::wrapper::Windows::UI::WebUI::WebUICameraSettingsActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.WebUI.WebUICameraSettingsActivatedEventArgs", L"SplashScreen");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.SplashScreen();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* WebUICameraSettingsActivatedEventArgs_get_VideoDeviceController(py::wrapper::Windows::UI::WebUI::WebUICameraSettingsActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.WebUI.WebUICameraSettingsActivatedEventArgs", L"VideoDeviceController");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.VideoDeviceController();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* WebUICameraSettingsActivatedEventArgs_get_VideoDeviceExtension(py::wrapper::Windows::UI::WebUI::WebUICameraSettingsActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.WebUI.WebUICameraSettingsActivatedEventArgs", L"VideoDeviceExtension");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.VideoDeviceExtension();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* WebUICameraSettingsActivatedEventArgs_get_ActivatedOperation(py::wrapper::Windows::UI::WebUI::WebUICameraSettingsActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.WebUI.WebUICameraSettingsActivatedEventArgs", L"ActivatedOperation");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.ActivatedOperation();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_WebUICameraSettingsActivatedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::WebUI::WebUICameraSettingsActivatedEventArgs>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_WebUICameraSettingsActivatedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::WebUI::WebUICameraSettingsActivatedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_WebUICameraSettingsActivatedEventArgs[] = {
        { "_assign_array_", _assign_array_WebUICameraSettingsActivatedEventArgs, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_WebUICameraSettingsActivatedEventArgs), METH_O | METH_STATIC, nullptr },
        { }};

    static PyGetSetDef _getset_WebUICameraSettingsActivatedEventArgs[] = {
        { "kind", reinterpret_cast<getter>(WebUICameraSettingsActivatedEventArgs_get_Kind), nullptr, nullptr, nullptr },
        { "previous_execution_state", reinterpret_cast<getter>(WebUICameraSettingsActivatedEventArgs_get_PreviousExecutionState), nullptr, nullptr, nullptr },
        { "splash_screen", reinterpret_cast<getter>(WebUICameraSettingsActivatedEventArgs_get_SplashScreen), nullptr, nullptr, nullptr },
        { "video_device_controller", reinterpret_cast<getter>(WebUICameraSettingsActivatedEventArgs_get_VideoDeviceController), nullptr, nullptr, nullptr },
        { "video_device_extension", reinterpret_cast<getter>(WebUICameraSettingsActivatedEventArgs_get_VideoDeviceExtension), nullptr, nullptr, nullptr },
        { "activated_operation", reinterpret_cast<getter>(WebUICameraSettingsActivatedEventArgs_get_ActivatedOperation), nullptr, nullptr, nullptr },
        { }};

    static PyType_Slot _type_slots_WebUICameraSettingsActivatedEventArgs[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_WebUICameraSettingsActivatedEventArgs) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_WebUICameraSettingsActivatedEventArgs) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_WebUICameraSettingsActivatedEventArgs) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_WebUICameraSettingsActivatedEventArgs) },
        { }};

    static PyType_Spec type_spec_WebUICameraSettingsActivatedEventArgs = {
        "winrt._winrt_windows_ui_webui.WebUICameraSettingsActivatedEventArgs",
        sizeof(py::wrapper::Windows::UI::WebUI::WebUICameraSettingsActivatedEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_WebUICameraSettingsActivatedEventArgs};

    // ----- WebUICommandLineActivatedEventArgs class --------------------

    static PyObject* _new_WebUICommandLineActivatedEventArgs(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::UI::WebUI::WebUICommandLineActivatedEventArgs>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::UI::WebUI::WebUICommandLineActivatedEventArgs>::type_name);
        return nullptr;
    }

    static void _dealloc_WebUICommandLineActivatedEventArgs(py::wrapper::Windows::UI::WebUI::WebUICommandLineActivatedEventArgs* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* WebUICommandLineActivatedEventArgs_get_Kind(py::wrapper::Windows::UI::WebUI::WebUICommandLineActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.WebUI.WebUICommandLineActivatedEventArgs", L"Kind");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Kind();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* WebUICommandLineActivatedEventArgs_get_PreviousExecutionState(py::wrapper::Windows::UI::WebUI::WebUICommandLineActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.WebUI.WebUICommandLineActivatedEventArgs", L"PreviousExecutionState");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.PreviousExecutionState();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* WebUICommandLineActivatedEventArgs_get_SplashScreen(py::wrapper::Windows::UI::WebUI::WebUICommandLineActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.WebUI.WebUICommandLineActivatedEventArgs", L"SplashScreen");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.SplashScreen();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* WebUICommandLineActivatedEventArgs_get_User(py::wrapper::Windows::UI::WebUI::WebUICommandLineActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.WebUI.WebUICommandLineActivatedEventArgs", L"User");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.User();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* WebUICommandLineActivatedEventArgs_get_Operation(py::wrapper::Windows::UI::WebUI::WebUICommandLineActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.WebUI.WebUICommandLineActivatedEventArgs", L"Operation");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Operation();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* WebUICommandLineActivatedEventArgs_get_ActivatedOperation(py::wrapper::Windows::UI::WebUI::WebUICommandLineActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.WebUI.WebUICommandLineActivatedEventArgs", L"ActivatedOperation");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.ActivatedOperation();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_WebUICommandLineActivatedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::WebUI::WebUICommandLineActivatedEventArgs>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_WebUICommandLineActivatedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::WebUI::WebUICommandLineActivatedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_WebUICommandLineActivatedEventArgs[] = {
        { "_assign_array_", _assign_array_WebUICommandLineActivatedEventArgs, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_WebUICommandLineActivatedEventArgs), METH_O | METH_STATIC, nullptr },
        { }};

    static PyGetSetDef _getset_WebUICommandLineActivatedEventArgs[] = {
        { "kind", reinterpret_cast<getter>(WebUICommandLineActivatedEventArgs_get_Kind), nullptr, nullptr, nullptr },
        { "previous_execution_state", reinterpret_cast<getter>(WebUICommandLineActivatedEventArgs_get_PreviousExecutionState), nullptr, nullptr, nullptr },
        { "splash_screen", reinterpret_cast<getter>(WebUICommandLineActivatedEventArgs_get_SplashScreen), nullptr, nullptr, nullptr },
        { "user", reinterpret_cast<getter>(WebUICommandLineActivatedEventArgs_get_User), nullptr, nullptr, nullptr },
        { "operation", reinterpret_cast<getter>(WebUICommandLineActivatedEventArgs_get_Operation), nullptr, nullptr, nullptr },
        { "activated_operation", reinterpret_cast<getter>(WebUICommandLineActivatedEventArgs_get_ActivatedOperation), nullptr, nullptr, nullptr },
        { }};

    static PyType_Slot _type_slots_WebUICommandLineActivatedEventArgs[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_WebUICommandLineActivatedEventArgs) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_WebUICommandLineActivatedEventArgs) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_WebUICommandLineActivatedEventArgs) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_WebUICommandLineActivatedEventArgs) },
        { }};

    static PyType_Spec type_spec_WebUICommandLineActivatedEventArgs = {
        "winrt._winrt_windows_ui_webui.WebUICommandLineActivatedEventArgs",
        sizeof(py::wrapper::Windows::UI::WebUI::WebUICommandLineActivatedEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_WebUICommandLineActivatedEventArgs};

    // ----- WebUIContactCallActivatedEventArgs class --------------------

    static PyObject* _new_WebUIContactCallActivatedEventArgs(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::UI::WebUI::WebUIContactCallActivatedEventArgs>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::UI::WebUI::WebUIContactCallActivatedEventArgs>::type_name);
        return nullptr;
    }

    static void _dealloc_WebUIContactCallActivatedEventArgs(py::wrapper::Windows::UI::WebUI::WebUIContactCallActivatedEventArgs* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* WebUIContactCallActivatedEventArgs_get_Kind(py::wrapper::Windows::UI::WebUI::WebUIContactCallActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.WebUI.WebUIContactCallActivatedEventArgs", L"Kind");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Kind();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* WebUIContactCallActivatedEventArgs_get_PreviousExecutionState(py::wrapper::Windows::UI::WebUI::WebUIContactCallActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.WebUI.WebUIContactCallActivatedEventArgs", L"PreviousExecutionState");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.PreviousExecutionState();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* WebUIContactCallActivatedEventArgs_get_SplashScreen(py::wrapper::Windows::UI::WebUI::WebUIContactCallActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.WebUI.WebUIContactCallActivatedEventArgs", L"SplashScreen");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.SplashScreen();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* WebUIContactCallActivatedEventArgs_get_Verb(py::wrapper::Windows::UI::WebUI::WebUIContactCallActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.WebUI.WebUIContactCallActivatedEventArgs", L"Verb");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Verb();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* WebUIContactCallActivatedEventArgs_get_Contact(py::wrapper::Windows::UI::WebUI::WebUIContactCallActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.WebUI.WebUIContactCallActivatedEventArgs", L"Contact");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Contact();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* WebUIContactCallActivatedEventArgs_get_ServiceId(py::wrapper::Windows::UI::WebUI::WebUIContactCallActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.WebUI.WebUIContactCallActivatedEventArgs", L"ServiceId");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.ServiceId();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* WebUIContactCallActivatedEventArgs_get_ServiceUserId(py::wrapper::Windows::UI::WebUI::WebUIContactCallActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.WebUI.WebUIContactCallActivatedEventArgs", L"ServiceUserId");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.ServiceUserId();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* WebUIContactCallActivatedEventArgs_get_ActivatedOperation(py::wrapper::Windows::UI::WebUI::WebUIContactCallActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.WebUI.WebUIContactCallActivatedEventArgs", L"ActivatedOperation");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.ActivatedOperation();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_WebUIContactCallActivatedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::WebUI::WebUIContactCallActivatedEventArgs>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_WebUIContactCallActivatedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::WebUI::WebUIContactCallActivatedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_WebUIContactCallActivatedEventArgs[] = {
        { "_assign_array_", _assign_array_WebUIContactCallActivatedEventArgs, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_WebUIContactCallActivatedEventArgs), METH_O | METH_STATIC, nullptr },
        { }};

    static PyGetSetDef _getset_WebUIContactCallActivatedEventArgs[] = {
        { "kind", reinterpret_cast<getter>(WebUIContactCallActivatedEventArgs_get_Kind), nullptr, nullptr, nullptr },
        { "previous_execution_state", reinterpret_cast<getter>(WebUIContactCallActivatedEventArgs_get_PreviousExecutionState), nullptr, nullptr, nullptr },
        { "splash_screen", reinterpret_cast<getter>(WebUIContactCallActivatedEventArgs_get_SplashScreen), nullptr, nullptr, nullptr },
        { "verb", reinterpret_cast<getter>(WebUIContactCallActivatedEventArgs_get_Verb), nullptr, nullptr, nullptr },
        { "contact", reinterpret_cast<getter>(WebUIContactCallActivatedEventArgs_get_Contact), nullptr, nullptr, nullptr },
        { "service_id", reinterpret_cast<getter>(WebUIContactCallActivatedEventArgs_get_ServiceId), nullptr, nullptr, nullptr },
        { "service_user_id", reinterpret_cast<getter>(WebUIContactCallActivatedEventArgs_get_ServiceUserId), nullptr, nullptr, nullptr },
        { "activated_operation", reinterpret_cast<getter>(WebUIContactCallActivatedEventArgs_get_ActivatedOperation), nullptr, nullptr, nullptr },
        { }};

    static PyType_Slot _type_slots_WebUIContactCallActivatedEventArgs[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_WebUIContactCallActivatedEventArgs) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_WebUIContactCallActivatedEventArgs) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_WebUIContactCallActivatedEventArgs) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_WebUIContactCallActivatedEventArgs) },
        { }};

    static PyType_Spec type_spec_WebUIContactCallActivatedEventArgs = {
        "winrt._winrt_windows_ui_webui.WebUIContactCallActivatedEventArgs",
        sizeof(py::wrapper::Windows::UI::WebUI::WebUIContactCallActivatedEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_WebUIContactCallActivatedEventArgs};

    // ----- WebUIContactMapActivatedEventArgs class --------------------

    static PyObject* _new_WebUIContactMapActivatedEventArgs(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::UI::WebUI::WebUIContactMapActivatedEventArgs>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::UI::WebUI::WebUIContactMapActivatedEventArgs>::type_name);
        return nullptr;
    }

    static void _dealloc_WebUIContactMapActivatedEventArgs(py::wrapper::Windows::UI::WebUI::WebUIContactMapActivatedEventArgs* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* WebUIContactMapActivatedEventArgs_get_Kind(py::wrapper::Windows::UI::WebUI::WebUIContactMapActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.WebUI.WebUIContactMapActivatedEventArgs", L"Kind");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Kind();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* WebUIContactMapActivatedEventArgs_get_PreviousExecutionState(py::wrapper::Windows::UI::WebUI::WebUIContactMapActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.WebUI.WebUIContactMapActivatedEventArgs", L"PreviousExecutionState");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.PreviousExecutionState();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* WebUIContactMapActivatedEventArgs_get_SplashScreen(py::wrapper::Windows::UI::WebUI::WebUIContactMapActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.WebUI.WebUIContactMapActivatedEventArgs", L"SplashScreen");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.SplashScreen();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* WebUIContactMapActivatedEventArgs_get_Verb(py::wrapper::Windows::UI::WebUI::WebUIContactMapActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.WebUI.WebUIContactMapActivatedEventArgs", L"Verb");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Verb();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* WebUIContactMapActivatedEventArgs_get_Address(py::wrapper::Windows::UI::WebUI::WebUIContactMapActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.WebUI.WebUIContactMapActivatedEventArgs", L"Address");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Address();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* WebUIContactMapActivatedEventArgs_get_Contact(py::wrapper::Windows::UI::WebUI::WebUIContactMapActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.WebUI.WebUIContactMapActivatedEventArgs", L"Contact");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Contact();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* WebUIContactMapActivatedEventArgs_get_ActivatedOperation(py::wrapper::Windows::UI::WebUI::WebUIContactMapActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.WebUI.WebUIContactMapActivatedEventArgs", L"ActivatedOperation");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.ActivatedOperation();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_WebUIContactMapActivatedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::WebUI::WebUIContactMapActivatedEventArgs>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_WebUIContactMapActivatedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::WebUI::WebUIContactMapActivatedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_WebUIContactMapActivatedEventArgs[] = {
        { "_assign_array_", _assign_array_WebUIContactMapActivatedEventArgs, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_WebUIContactMapActivatedEventArgs), METH_O | METH_STATIC, nullptr },
        { }};

    static PyGetSetDef _getset_WebUIContactMapActivatedEventArgs[] = {
        { "kind", reinterpret_cast<getter>(WebUIContactMapActivatedEventArgs_get_Kind), nullptr, nullptr, nullptr },
        { "previous_execution_state", reinterpret_cast<getter>(WebUIContactMapActivatedEventArgs_get_PreviousExecutionState), nullptr, nullptr, nullptr },
        { "splash_screen", reinterpret_cast<getter>(WebUIContactMapActivatedEventArgs_get_SplashScreen), nullptr, nullptr, nullptr },
        { "verb", reinterpret_cast<getter>(WebUIContactMapActivatedEventArgs_get_Verb), nullptr, nullptr, nullptr },
        { "address", reinterpret_cast<getter>(WebUIContactMapActivatedEventArgs_get_Address), nullptr, nullptr, nullptr },
        { "contact", reinterpret_cast<getter>(WebUIContactMapActivatedEventArgs_get_Contact), nullptr, nullptr, nullptr },
        { "activated_operation", reinterpret_cast<getter>(WebUIContactMapActivatedEventArgs_get_ActivatedOperation), nullptr, nullptr, nullptr },
        { }};

    static PyType_Slot _type_slots_WebUIContactMapActivatedEventArgs[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_WebUIContactMapActivatedEventArgs) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_WebUIContactMapActivatedEventArgs) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_WebUIContactMapActivatedEventArgs) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_WebUIContactMapActivatedEventArgs) },
        { }};

    static PyType_Spec type_spec_WebUIContactMapActivatedEventArgs = {
        "winrt._winrt_windows_ui_webui.WebUIContactMapActivatedEventArgs",
        sizeof(py::wrapper::Windows::UI::WebUI::WebUIContactMapActivatedEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_WebUIContactMapActivatedEventArgs};

    // ----- WebUIContactMessageActivatedEventArgs class --------------------

    static PyObject* _new_WebUIContactMessageActivatedEventArgs(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::UI::WebUI::WebUIContactMessageActivatedEventArgs>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::UI::WebUI::WebUIContactMessageActivatedEventArgs>::type_name);
        return nullptr;
    }

    static void _dealloc_WebUIContactMessageActivatedEventArgs(py::wrapper::Windows::UI::WebUI::WebUIContactMessageActivatedEventArgs* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* WebUIContactMessageActivatedEventArgs_get_Kind(py::wrapper::Windows::UI::WebUI::WebUIContactMessageActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.WebUI.WebUIContactMessageActivatedEventArgs", L"Kind");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Kind();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* WebUIContactMessageActivatedEventArgs_get_PreviousExecutionState(py::wrapper::Windows::UI::WebUI::WebUIContactMessageActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.WebUI.WebUIContactMessageActivatedEventArgs", L"PreviousExecutionState");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.PreviousExecutionState();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* WebUIContactMessageActivatedEventArgs_get_SplashScreen(py::wrapper::Windows::UI::WebUI::WebUIContactMessageActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.WebUI.WebUIContactMessageActivatedEventArgs", L"SplashScreen");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.SplashScreen();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* WebUIContactMessageActivatedEventArgs_get_Verb(py::wrapper::Windows::UI::WebUI::WebUIContactMessageActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.WebUI.WebUIContactMessageActivatedEventArgs", L"Verb");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Verb();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* WebUIContactMessageActivatedEventArgs_get_Contact(py::wrapper::Windows::UI::WebUI::WebUIContactMessageActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.WebUI.WebUIContactMessageActivatedEventArgs", L"Contact");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Contact();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* WebUIContactMessageActivatedEventArgs_get_ServiceId(py::wrapper::Windows::UI::WebUI::WebUIContactMessageActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.WebUI.WebUIContactMessageActivatedEventArgs", L"ServiceId");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.ServiceId();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* WebUIContactMessageActivatedEventArgs_get_ServiceUserId(py::wrapper::Windows::UI::WebUI::WebUIContactMessageActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.WebUI.WebUIContactMessageActivatedEventArgs", L"ServiceUserId");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.ServiceUserId();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* WebUIContactMessageActivatedEventArgs_get_ActivatedOperation(py::wrapper::Windows::UI::WebUI::WebUIContactMessageActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.WebUI.WebUIContactMessageActivatedEventArgs", L"ActivatedOperation");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.ActivatedOperation();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_WebUIContactMessageActivatedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::WebUI::WebUIContactMessageActivatedEventArgs>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_WebUIContactMessageActivatedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::WebUI::WebUIContactMessageActivatedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_WebUIContactMessageActivatedEventArgs[] = {
        { "_assign_array_", _assign_array_WebUIContactMessageActivatedEventArgs, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_WebUIContactMessageActivatedEventArgs), METH_O | METH_STATIC, nullptr },
        { }};

    static PyGetSetDef _getset_WebUIContactMessageActivatedEventArgs[] = {
        { "kind", reinterpret_cast<getter>(WebUIContactMessageActivatedEventArgs_get_Kind), nullptr, nullptr, nullptr },
        { "previous_execution_state", reinterpret_cast<getter>(WebUIContactMessageActivatedEventArgs_get_PreviousExecutionState), nullptr, nullptr, nullptr },
        { "splash_screen", reinterpret_cast<getter>(WebUIContactMessageActivatedEventArgs_get_SplashScreen), nullptr, nullptr, nullptr },
        { "verb", reinterpret_cast<getter>(WebUIContactMessageActivatedEventArgs_get_Verb), nullptr, nullptr, nullptr },
        { "contact", reinterpret_cast<getter>(WebUIContactMessageActivatedEventArgs_get_Contact), nullptr, nullptr, nullptr },
        { "service_id", reinterpret_cast<getter>(WebUIContactMessageActivatedEventArgs_get_ServiceId), nullptr, nullptr, nullptr },
        { "service_user_id", reinterpret_cast<getter>(WebUIContactMessageActivatedEventArgs_get_ServiceUserId), nullptr, nullptr, nullptr },
        { "activated_operation", reinterpret_cast<getter>(WebUIContactMessageActivatedEventArgs_get_ActivatedOperation), nullptr, nullptr, nullptr },
        { }};

    static PyType_Slot _type_slots_WebUIContactMessageActivatedEventArgs[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_WebUIContactMessageActivatedEventArgs) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_WebUIContactMessageActivatedEventArgs) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_WebUIContactMessageActivatedEventArgs) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_WebUIContactMessageActivatedEventArgs) },
        { }};

    static PyType_Spec type_spec_WebUIContactMessageActivatedEventArgs = {
        "winrt._winrt_windows_ui_webui.WebUIContactMessageActivatedEventArgs",
        sizeof(py::wrapper::Windows::UI::WebUI::WebUIContactMessageActivatedEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_WebUIContactMessageActivatedEventArgs};

    // ----- WebUIContactPanelActivatedEventArgs class --------------------

    static PyObject* _new_WebUIContactPanelActivatedEventArgs(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::UI::WebUI::WebUIContactPanelActivatedEventArgs>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::UI::WebUI::WebUIContactPanelActivatedEventArgs>::type_name);
        return nullptr;
    }

    static void _dealloc_WebUIContactPanelActivatedEventArgs(py::wrapper::Windows::UI::WebUI::WebUIContactPanelActivatedEventArgs* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* WebUIContactPanelActivatedEventArgs_get_Kind(py::wrapper::Windows::UI::WebUI::WebUIContactPanelActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.WebUI.WebUIContactPanelActivatedEventArgs", L"Kind");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Kind();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* WebUIContactPanelActivatedEventArgs_get_PreviousExecutionState(py::wrapper::Windows::UI::WebUI::WebUIContactPanelActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.WebUI.WebUIContactPanelActivatedEventArgs", L"PreviousExecutionState");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.PreviousExecutionState();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* WebUIContactPanelActivatedEventArgs_get_SplashScreen(py::wrapper::Windows::UI::WebUI::WebUIContactPanelActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.WebUI.WebUIContactPanelActivatedEventArgs", L"SplashScreen");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.SplashScreen();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* WebUIContactPanelActivatedEventArgs_get_User(py::wrapper::Windows::UI::WebUI::WebUIContactPanelActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.WebUI.WebUIContactPanelActivatedEventArgs", L"User");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.User();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* WebUIContactPanelActivatedEventArgs_get_Contact(py::wrapper::Windows::UI::WebUI::WebUIContactPanelActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.WebUI.WebUIContactPanelActivatedEventArgs", L"Contact");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Contact();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* WebUIContactPanelActivatedEventArgs_get_ContactPanel(py::wrapper::Windows::UI::WebUI::WebUIContactPanelActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.WebUI.WebUIContactPanelActivatedEventArgs", L"ContactPanel");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.ContactPanel();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* WebUIContactPanelActivatedEventArgs_get_ActivatedOperation(py::wrapper::Windows::UI::WebUI::WebUIContactPanelActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.WebUI.WebUIContactPanelActivatedEventArgs", L"ActivatedOperation");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.ActivatedOperation();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_WebUIContactPanelActivatedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::WebUI::WebUIContactPanelActivatedEventArgs>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_WebUIContactPanelActivatedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::WebUI::WebUIContactPanelActivatedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_WebUIContactPanelActivatedEventArgs[] = {
        { "_assign_array_", _assign_array_WebUIContactPanelActivatedEventArgs, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_WebUIContactPanelActivatedEventArgs), METH_O | METH_STATIC, nullptr },
        { }};

    static PyGetSetDef _getset_WebUIContactPanelActivatedEventArgs[] = {
        { "kind", reinterpret_cast<getter>(WebUIContactPanelActivatedEventArgs_get_Kind), nullptr, nullptr, nullptr },
        { "previous_execution_state", reinterpret_cast<getter>(WebUIContactPanelActivatedEventArgs_get_PreviousExecutionState), nullptr, nullptr, nullptr },
        { "splash_screen", reinterpret_cast<getter>(WebUIContactPanelActivatedEventArgs_get_SplashScreen), nullptr, nullptr, nullptr },
        { "user", reinterpret_cast<getter>(WebUIContactPanelActivatedEventArgs_get_User), nullptr, nullptr, nullptr },
        { "contact", reinterpret_cast<getter>(WebUIContactPanelActivatedEventArgs_get_Contact), nullptr, nullptr, nullptr },
        { "contact_panel", reinterpret_cast<getter>(WebUIContactPanelActivatedEventArgs_get_ContactPanel), nullptr, nullptr, nullptr },
        { "activated_operation", reinterpret_cast<getter>(WebUIContactPanelActivatedEventArgs_get_ActivatedOperation), nullptr, nullptr, nullptr },
        { }};

    static PyType_Slot _type_slots_WebUIContactPanelActivatedEventArgs[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_WebUIContactPanelActivatedEventArgs) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_WebUIContactPanelActivatedEventArgs) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_WebUIContactPanelActivatedEventArgs) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_WebUIContactPanelActivatedEventArgs) },
        { }};

    static PyType_Spec type_spec_WebUIContactPanelActivatedEventArgs = {
        "winrt._winrt_windows_ui_webui.WebUIContactPanelActivatedEventArgs",
        sizeof(py::wrapper::Windows::UI::WebUI::WebUIContactPanelActivatedEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_WebUIContactPanelActivatedEventArgs};

    // ----- WebUIContactPickerActivatedEventArgs class --------------------

    static PyObject* _new_WebUIContactPickerActivatedEventArgs(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::UI::WebUI::WebUIContactPickerActivatedEventArgs>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::UI::WebUI::WebUIContactPickerActivatedEventArgs>::type_name);
        return nullptr;
    }

    static void _dealloc_WebUIContactPickerActivatedEventArgs(py::wrapper::Windows::UI::WebUI::WebUIContactPickerActivatedEventArgs* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* WebUIContactPickerActivatedEventArgs_get_Kind(py::wrapper::Windows::UI::WebUI::WebUIContactPickerActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.WebUI.WebUIContactPickerActivatedEventArgs", L"Kind");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Kind();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* WebUIContactPickerActivatedEventArgs_get_PreviousExecutionState(py::wrapper::Windows::UI::WebUI::WebUIContactPickerActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.WebUI.WebUIContactPickerActivatedEventArgs", L"PreviousExecutionState");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.PreviousExecutionState();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* WebUIContactPickerActivatedEventArgs_get_SplashScreen(py::wrapper::Windows::UI::WebUI::WebUIContactPickerActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.WebUI.WebUIContactPickerActivatedEventArgs", L"SplashScreen");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.SplashScreen();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* WebUIContactPickerActivatedEventArgs_get_ContactPickerUI(py::wrapper::Windows::UI::WebUI::WebUIContactPickerActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.WebUI.WebUIContactPickerActivatedEventArgs", L"ContactPickerUI");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.ContactPickerUI();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* WebUIContactPickerActivatedEventArgs_get_ActivatedOperation(py::wrapper::Windows::UI::WebUI::WebUIContactPickerActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.WebUI.WebUIContactPickerActivatedEventArgs", L"ActivatedOperation");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.ActivatedOperation();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_WebUIContactPickerActivatedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::WebUI::WebUIContactPickerActivatedEventArgs>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_WebUIContactPickerActivatedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::WebUI::WebUIContactPickerActivatedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_WebUIContactPickerActivatedEventArgs[] = {
        { "_assign_array_", _assign_array_WebUIContactPickerActivatedEventArgs, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_WebUIContactPickerActivatedEventArgs), METH_O | METH_STATIC, nullptr },
        { }};

    static PyGetSetDef _getset_WebUIContactPickerActivatedEventArgs[] = {
        { "kind", reinterpret_cast<getter>(WebUIContactPickerActivatedEventArgs_get_Kind), nullptr, nullptr, nullptr },
        { "previous_execution_state", reinterpret_cast<getter>(WebUIContactPickerActivatedEventArgs_get_PreviousExecutionState), nullptr, nullptr, nullptr },
        { "splash_screen", reinterpret_cast<getter>(WebUIContactPickerActivatedEventArgs_get_SplashScreen), nullptr, nullptr, nullptr },
        { "contact_picker_ui", reinterpret_cast<getter>(WebUIContactPickerActivatedEventArgs_get_ContactPickerUI), nullptr, nullptr, nullptr },
        { "activated_operation", reinterpret_cast<getter>(WebUIContactPickerActivatedEventArgs_get_ActivatedOperation), nullptr, nullptr, nullptr },
        { }};

    static PyType_Slot _type_slots_WebUIContactPickerActivatedEventArgs[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_WebUIContactPickerActivatedEventArgs) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_WebUIContactPickerActivatedEventArgs) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_WebUIContactPickerActivatedEventArgs) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_WebUIContactPickerActivatedEventArgs) },
        { }};

    static PyType_Spec type_spec_WebUIContactPickerActivatedEventArgs = {
        "winrt._winrt_windows_ui_webui.WebUIContactPickerActivatedEventArgs",
        sizeof(py::wrapper::Windows::UI::WebUI::WebUIContactPickerActivatedEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_WebUIContactPickerActivatedEventArgs};

    // ----- WebUIContactPostActivatedEventArgs class --------------------

    static PyObject* _new_WebUIContactPostActivatedEventArgs(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::UI::WebUI::WebUIContactPostActivatedEventArgs>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::UI::WebUI::WebUIContactPostActivatedEventArgs>::type_name);
        return nullptr;
    }

    static void _dealloc_WebUIContactPostActivatedEventArgs(py::wrapper::Windows::UI::WebUI::WebUIContactPostActivatedEventArgs* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* WebUIContactPostActivatedEventArgs_get_Kind(py::wrapper::Windows::UI::WebUI::WebUIContactPostActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.WebUI.WebUIContactPostActivatedEventArgs", L"Kind");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Kind();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* WebUIContactPostActivatedEventArgs_get_PreviousExecutionState(py::wrapper::Windows::UI::WebUI::WebUIContactPostActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.WebUI.WebUIContactPostActivatedEventArgs", L"PreviousExecutionState");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.PreviousExecutionState();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* WebUIContactPostActivatedEventArgs_get_SplashScreen(py::wrapper::Windows::UI::WebUI::WebUIContactPostActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.WebUI.WebUIContactPostActivatedEventArgs", L"SplashScreen");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.SplashScreen();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* WebUIContactPostActivatedEventArgs_get_Verb(py::wrapper::Windows::UI::WebUI::WebUIContactPostActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.WebUI.WebUIContactPostActivatedEventArgs", L"Verb");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Verb();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* WebUIContactPostActivatedEventArgs_get_Contact(py::wrapper::Windows::UI::WebUI::WebUIContactPostActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.WebUI.WebUIContactPostActivatedEventArgs", L"Contact");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Contact();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* WebUIContactPostActivatedEventArgs_get_ServiceId(py::wrapper::Windows::UI::WebUI::WebUIContactPostActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.WebUI.WebUIContactPostActivatedEventArgs", L"ServiceId");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.ServiceId();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* WebUIContactPostActivatedEventArgs_get_ServiceUserId(py::wrapper::Windows::UI::WebUI::WebUIContactPostActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.WebUI.WebUIContactPostActivatedEventArgs", L"ServiceUserId");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.ServiceUserId();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* WebUIContactPostActivatedEventArgs_get_ActivatedOperation(py::wrapper::Windows::UI::WebUI::WebUIContactPostActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.WebUI.WebUIContactPostActivatedEventArgs", L"ActivatedOperation");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.ActivatedOperation();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_WebUIContactPostActivatedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::WebUI::WebUIContactPostActivatedEventArgs>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_WebUIContactPostActivatedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::WebUI::WebUIContactPostActivatedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_WebUIContactPostActivatedEventArgs[] = {
        { "_assign_array_", _assign_array_WebUIContactPostActivatedEventArgs, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_WebUIContactPostActivatedEventArgs), METH_O | METH_STATIC, nullptr },
        { }};

    static PyGetSetDef _getset_WebUIContactPostActivatedEventArgs[] = {
        { "kind", reinterpret_cast<getter>(WebUIContactPostActivatedEventArgs_get_Kind), nullptr, nullptr, nullptr },
        { "previous_execution_state", reinterpret_cast<getter>(WebUIContactPostActivatedEventArgs_get_PreviousExecutionState), nullptr, nullptr, nullptr },
        { "splash_screen", reinterpret_cast<getter>(WebUIContactPostActivatedEventArgs_get_SplashScreen), nullptr, nullptr, nullptr },
        { "verb", reinterpret_cast<getter>(WebUIContactPostActivatedEventArgs_get_Verb), nullptr, nullptr, nullptr },
        { "contact", reinterpret_cast<getter>(WebUIContactPostActivatedEventArgs_get_Contact), nullptr, nullptr, nullptr },
        { "service_id", reinterpret_cast<getter>(WebUIContactPostActivatedEventArgs_get_ServiceId), nullptr, nullptr, nullptr },
        { "service_user_id", reinterpret_cast<getter>(WebUIContactPostActivatedEventArgs_get_ServiceUserId), nullptr, nullptr, nullptr },
        { "activated_operation", reinterpret_cast<getter>(WebUIContactPostActivatedEventArgs_get_ActivatedOperation), nullptr, nullptr, nullptr },
        { }};

    static PyType_Slot _type_slots_WebUIContactPostActivatedEventArgs[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_WebUIContactPostActivatedEventArgs) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_WebUIContactPostActivatedEventArgs) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_WebUIContactPostActivatedEventArgs) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_WebUIContactPostActivatedEventArgs) },
        { }};

    static PyType_Spec type_spec_WebUIContactPostActivatedEventArgs = {
        "winrt._winrt_windows_ui_webui.WebUIContactPostActivatedEventArgs",
        sizeof(py::wrapper::Windows::UI::WebUI::WebUIContactPostActivatedEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_WebUIContactPostActivatedEventArgs};

    // ----- WebUIContactVideoCallActivatedEventArgs class --------------------

    static PyObject* _new_WebUIContactVideoCallActivatedEventArgs(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::UI::WebUI::WebUIContactVideoCallActivatedEventArgs>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::UI::WebUI::WebUIContactVideoCallActivatedEventArgs>::type_name);
        return nullptr;
    }

    static void _dealloc_WebUIContactVideoCallActivatedEventArgs(py::wrapper::Windows::UI::WebUI::WebUIContactVideoCallActivatedEventArgs* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* WebUIContactVideoCallActivatedEventArgs_get_Kind(py::wrapper::Windows::UI::WebUI::WebUIContactVideoCallActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.WebUI.WebUIContactVideoCallActivatedEventArgs", L"Kind");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Kind();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* WebUIContactVideoCallActivatedEventArgs_get_PreviousExecutionState(py::wrapper::Windows::UI::WebUI::WebUIContactVideoCallActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.WebUI.WebUIContactVideoCallActivatedEventArgs", L"PreviousExecutionState");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.PreviousExecutionState();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* WebUIContactVideoCallActivatedEventArgs_get_SplashScreen(py::wrapper::Windows::UI::WebUI::WebUIContactVideoCallActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.WebUI.WebUIContactVideoCallActivatedEventArgs", L"SplashScreen");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.SplashScreen();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* WebUIContactVideoCallActivatedEventArgs_get_Verb(py::wrapper::Windows::UI::WebUI::WebUIContactVideoCallActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.WebUI.WebUIContactVideoCallActivatedEventArgs", L"Verb");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Verb();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* WebUIContactVideoCallActivatedEventArgs_get_Contact(py::wrapper::Windows::UI::WebUI::WebUIContactVideoCallActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.WebUI.WebUIContactVideoCallActivatedEventArgs", L"Contact");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Contact();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* WebUIContactVideoCallActivatedEventArgs_get_ServiceId(py::wrapper::Windows::UI::WebUI::WebUIContactVideoCallActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.WebUI.WebUIContactVideoCallActivatedEventArgs", L"ServiceId");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.ServiceId();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* WebUIContactVideoCallActivatedEventArgs_get_ServiceUserId(py::wrapper::Windows::UI::WebUI::WebUIContactVideoCallActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.WebUI.WebUIContactVideoCallActivatedEventArgs", L"ServiceUserId");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.ServiceUserId();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* WebUIContactVideoCallActivatedEventArgs_get_ActivatedOperation(py::wrapper::Windows::UI::WebUI::WebUIContactVideoCallActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.WebUI.WebUIContactVideoCallActivatedEventArgs", L"ActivatedOperation");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.ActivatedOperation();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_WebUIContactVideoCallActivatedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::WebUI::WebUIContactVideoCallActivatedEventArgs>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_WebUIContactVideoCallActivatedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::WebUI::WebUIContactVideoCallActivatedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_WebUIContactVideoCallActivatedEventArgs[] = {
        { "_assign_array_", _assign_array_WebUIContactVideoCallActivatedEventArgs, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_WebUIContactVideoCallActivatedEventArgs), METH_O | METH_STATIC, nullptr },
        { }};

    static PyGetSetDef _getset_WebUIContactVideoCallActivatedEventArgs[] = {
        { "kind", reinterpret_cast<getter>(WebUIContactVideoCallActivatedEventArgs_get_Kind), nullptr, nullptr, nullptr },
        { "previous_execution_state", reinterpret_cast<getter>(WebUIContactVideoCallActivatedEventArgs_get_PreviousExecutionState), nullptr, nullptr, nullptr },
        { "splash_screen", reinterpret_cast<getter>(WebUIContactVideoCallActivatedEventArgs_get_SplashScreen), nullptr, nullptr, nullptr },
        { "verb", reinterpret_cast<getter>(WebUIContactVideoCallActivatedEventArgs_get_Verb), nullptr, nullptr, nullptr },
        { "contact", reinterpret_cast<getter>(WebUIContactVideoCallActivatedEventArgs_get_Contact), nullptr, nullptr, nullptr },
        { "service_id", reinterpret_cast<getter>(WebUIContactVideoCallActivatedEventArgs_get_ServiceId), nullptr, nullptr, nullptr },
        { "service_user_id", reinterpret_cast<getter>(WebUIContactVideoCallActivatedEventArgs_get_ServiceUserId), nullptr, nullptr, nullptr },
        { "activated_operation", reinterpret_cast<getter>(WebUIContactVideoCallActivatedEventArgs_get_ActivatedOperation), nullptr, nullptr, nullptr },
        { }};

    static PyType_Slot _type_slots_WebUIContactVideoCallActivatedEventArgs[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_WebUIContactVideoCallActivatedEventArgs) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_WebUIContactVideoCallActivatedEventArgs) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_WebUIContactVideoCallActivatedEventArgs) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_WebUIContactVideoCallActivatedEventArgs) },
        { }};

    static PyType_Spec type_spec_WebUIContactVideoCallActivatedEventArgs = {
        "winrt._winrt_windows_ui_webui.WebUIContactVideoCallActivatedEventArgs",
        sizeof(py::wrapper::Windows::UI::WebUI::WebUIContactVideoCallActivatedEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_WebUIContactVideoCallActivatedEventArgs};

    // ----- WebUIDeviceActivatedEventArgs class --------------------

    static PyObject* _new_WebUIDeviceActivatedEventArgs(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::UI::WebUI::WebUIDeviceActivatedEventArgs>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::UI::WebUI::WebUIDeviceActivatedEventArgs>::type_name);
        return nullptr;
    }

    static void _dealloc_WebUIDeviceActivatedEventArgs(py::wrapper::Windows::UI::WebUI::WebUIDeviceActivatedEventArgs* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* WebUIDeviceActivatedEventArgs_get_Kind(py::wrapper::Windows::UI::WebUI::WebUIDeviceActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.WebUI.WebUIDeviceActivatedEventArgs", L"Kind");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Kind();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* WebUIDeviceActivatedEventArgs_get_PreviousExecutionState(py::wrapper::Windows::UI::WebUI::WebUIDeviceActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.WebUI.WebUIDeviceActivatedEventArgs", L"PreviousExecutionState");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.PreviousExecutionState();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* WebUIDeviceActivatedEventArgs_get_SplashScreen(py::wrapper::Windows::UI::WebUI::WebUIDeviceActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.WebUI.WebUIDeviceActivatedEventArgs", L"SplashScreen");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.SplashScreen();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* WebUIDeviceActivatedEventArgs_get_User(py::wrapper::Windows::UI::WebUI::WebUIDeviceActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.WebUI.WebUIDeviceActivatedEventArgs", L"User");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.User();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* WebUIDeviceActivatedEventArgs_get_CurrentlyShownApplicationViewId(py::wrapper::Windows::UI::WebUI::WebUIDeviceActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.WebUI.WebUIDeviceActivatedEventArgs", L"CurrentlyShownApplicationViewId");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.CurrentlyShownApplicationViewId();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* WebUIDeviceActivatedEventArgs_get_DeviceInformationId(py::wrapper::Windows::UI::WebUI::WebUIDeviceActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.WebUI.WebUIDeviceActivatedEventArgs", L"DeviceInformationId");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.DeviceInformationId();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* WebUIDeviceActivatedEventArgs_get_Verb(py::wrapper::Windows::UI::WebUI::WebUIDeviceActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.WebUI.WebUIDeviceActivatedEventArgs", L"Verb");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Verb();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* WebUIDeviceActivatedEventArgs_get_ActivatedOperation(py::wrapper::Windows::UI::WebUI::WebUIDeviceActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.WebUI.WebUIDeviceActivatedEventArgs", L"ActivatedOperation");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.ActivatedOperation();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_WebUIDeviceActivatedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::WebUI::WebUIDeviceActivatedEventArgs>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_WebUIDeviceActivatedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::WebUI::WebUIDeviceActivatedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_WebUIDeviceActivatedEventArgs[] = {
        { "_assign_array_", _assign_array_WebUIDeviceActivatedEventArgs, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_WebUIDeviceActivatedEventArgs), METH_O | METH_STATIC, nullptr },
        { }};

    static PyGetSetDef _getset_WebUIDeviceActivatedEventArgs[] = {
        { "kind", reinterpret_cast<getter>(WebUIDeviceActivatedEventArgs_get_Kind), nullptr, nullptr, nullptr },
        { "previous_execution_state", reinterpret_cast<getter>(WebUIDeviceActivatedEventArgs_get_PreviousExecutionState), nullptr, nullptr, nullptr },
        { "splash_screen", reinterpret_cast<getter>(WebUIDeviceActivatedEventArgs_get_SplashScreen), nullptr, nullptr, nullptr },
        { "user", reinterpret_cast<getter>(WebUIDeviceActivatedEventArgs_get_User), nullptr, nullptr, nullptr },
        { "currently_shown_application_view_id", reinterpret_cast<getter>(WebUIDeviceActivatedEventArgs_get_CurrentlyShownApplicationViewId), nullptr, nullptr, nullptr },
        { "device_information_id", reinterpret_cast<getter>(WebUIDeviceActivatedEventArgs_get_DeviceInformationId), nullptr, nullptr, nullptr },
        { "verb", reinterpret_cast<getter>(WebUIDeviceActivatedEventArgs_get_Verb), nullptr, nullptr, nullptr },
        { "activated_operation", reinterpret_cast<getter>(WebUIDeviceActivatedEventArgs_get_ActivatedOperation), nullptr, nullptr, nullptr },
        { }};

    static PyType_Slot _type_slots_WebUIDeviceActivatedEventArgs[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_WebUIDeviceActivatedEventArgs) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_WebUIDeviceActivatedEventArgs) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_WebUIDeviceActivatedEventArgs) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_WebUIDeviceActivatedEventArgs) },
        { }};

    static PyType_Spec type_spec_WebUIDeviceActivatedEventArgs = {
        "winrt._winrt_windows_ui_webui.WebUIDeviceActivatedEventArgs",
        sizeof(py::wrapper::Windows::UI::WebUI::WebUIDeviceActivatedEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_WebUIDeviceActivatedEventArgs};

    // ----- WebUIDevicePairingActivatedEventArgs class --------------------

    static PyObject* _new_WebUIDevicePairingActivatedEventArgs(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::UI::WebUI::WebUIDevicePairingActivatedEventArgs>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::UI::WebUI::WebUIDevicePairingActivatedEventArgs>::type_name);
        return nullptr;
    }

    static void _dealloc_WebUIDevicePairingActivatedEventArgs(py::wrapper::Windows::UI::WebUI::WebUIDevicePairingActivatedEventArgs* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* WebUIDevicePairingActivatedEventArgs_get_Kind(py::wrapper::Windows::UI::WebUI::WebUIDevicePairingActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.WebUI.WebUIDevicePairingActivatedEventArgs", L"Kind");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Kind();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* WebUIDevicePairingActivatedEventArgs_get_PreviousExecutionState(py::wrapper::Windows::UI::WebUI::WebUIDevicePairingActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.WebUI.WebUIDevicePairingActivatedEventArgs", L"PreviousExecutionState");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.PreviousExecutionState();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* WebUIDevicePairingActivatedEventArgs_get_SplashScreen(py::wrapper::Windows::UI::WebUI::WebUIDevicePairingActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.WebUI.WebUIDevicePairingActivatedEventArgs", L"SplashScreen");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.SplashScreen();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* WebUIDevicePairingActivatedEventArgs_get_User(py::wrapper::Windows::UI::WebUI::WebUIDevicePairingActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.WebUI.WebUIDevicePairingActivatedEventArgs", L"User");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.User();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* WebUIDevicePairingActivatedEventArgs_get_DeviceInformation(py::wrapper::Windows::UI::WebUI::WebUIDevicePairingActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.WebUI.WebUIDevicePairingActivatedEventArgs", L"DeviceInformation");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.DeviceInformation();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* WebUIDevicePairingActivatedEventArgs_get_ActivatedOperation(py::wrapper::Windows::UI::WebUI::WebUIDevicePairingActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.WebUI.WebUIDevicePairingActivatedEventArgs", L"ActivatedOperation");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.ActivatedOperation();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_WebUIDevicePairingActivatedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::WebUI::WebUIDevicePairingActivatedEventArgs>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_WebUIDevicePairingActivatedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::WebUI::WebUIDevicePairingActivatedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_WebUIDevicePairingActivatedEventArgs[] = {
        { "_assign_array_", _assign_array_WebUIDevicePairingActivatedEventArgs, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_WebUIDevicePairingActivatedEventArgs), METH_O | METH_STATIC, nullptr },
        { }};

    static PyGetSetDef _getset_WebUIDevicePairingActivatedEventArgs[] = {
        { "kind", reinterpret_cast<getter>(WebUIDevicePairingActivatedEventArgs_get_Kind), nullptr, nullptr, nullptr },
        { "previous_execution_state", reinterpret_cast<getter>(WebUIDevicePairingActivatedEventArgs_get_PreviousExecutionState), nullptr, nullptr, nullptr },
        { "splash_screen", reinterpret_cast<getter>(WebUIDevicePairingActivatedEventArgs_get_SplashScreen), nullptr, nullptr, nullptr },
        { "user", reinterpret_cast<getter>(WebUIDevicePairingActivatedEventArgs_get_User), nullptr, nullptr, nullptr },
        { "device_information", reinterpret_cast<getter>(WebUIDevicePairingActivatedEventArgs_get_DeviceInformation), nullptr, nullptr, nullptr },
        { "activated_operation", reinterpret_cast<getter>(WebUIDevicePairingActivatedEventArgs_get_ActivatedOperation), nullptr, nullptr, nullptr },
        { }};

    static PyType_Slot _type_slots_WebUIDevicePairingActivatedEventArgs[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_WebUIDevicePairingActivatedEventArgs) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_WebUIDevicePairingActivatedEventArgs) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_WebUIDevicePairingActivatedEventArgs) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_WebUIDevicePairingActivatedEventArgs) },
        { }};

    static PyType_Spec type_spec_WebUIDevicePairingActivatedEventArgs = {
        "winrt._winrt_windows_ui_webui.WebUIDevicePairingActivatedEventArgs",
        sizeof(py::wrapper::Windows::UI::WebUI::WebUIDevicePairingActivatedEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_WebUIDevicePairingActivatedEventArgs};

    // ----- WebUIDialReceiverActivatedEventArgs class --------------------

    static PyObject* _new_WebUIDialReceiverActivatedEventArgs(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::UI::WebUI::WebUIDialReceiverActivatedEventArgs>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::UI::WebUI::WebUIDialReceiverActivatedEventArgs>::type_name);
        return nullptr;
    }

    static void _dealloc_WebUIDialReceiverActivatedEventArgs(py::wrapper::Windows::UI::WebUI::WebUIDialReceiverActivatedEventArgs* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* WebUIDialReceiverActivatedEventArgs_get_Kind(py::wrapper::Windows::UI::WebUI::WebUIDialReceiverActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.WebUI.WebUIDialReceiverActivatedEventArgs", L"Kind");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Kind();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* WebUIDialReceiverActivatedEventArgs_get_PreviousExecutionState(py::wrapper::Windows::UI::WebUI::WebUIDialReceiverActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.WebUI.WebUIDialReceiverActivatedEventArgs", L"PreviousExecutionState");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.PreviousExecutionState();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* WebUIDialReceiverActivatedEventArgs_get_SplashScreen(py::wrapper::Windows::UI::WebUI::WebUIDialReceiverActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.WebUI.WebUIDialReceiverActivatedEventArgs", L"SplashScreen");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.SplashScreen();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* WebUIDialReceiverActivatedEventArgs_get_User(py::wrapper::Windows::UI::WebUI::WebUIDialReceiverActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.WebUI.WebUIDialReceiverActivatedEventArgs", L"User");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.User();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* WebUIDialReceiverActivatedEventArgs_get_CurrentlyShownApplicationViewId(py::wrapper::Windows::UI::WebUI::WebUIDialReceiverActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.WebUI.WebUIDialReceiverActivatedEventArgs", L"CurrentlyShownApplicationViewId");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.CurrentlyShownApplicationViewId();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* WebUIDialReceiverActivatedEventArgs_get_AppName(py::wrapper::Windows::UI::WebUI::WebUIDialReceiverActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.WebUI.WebUIDialReceiverActivatedEventArgs", L"AppName");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.AppName();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* WebUIDialReceiverActivatedEventArgs_get_Arguments(py::wrapper::Windows::UI::WebUI::WebUIDialReceiverActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.WebUI.WebUIDialReceiverActivatedEventArgs", L"Arguments");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Arguments();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* WebUIDialReceiverActivatedEventArgs_get_TileId(py::wrapper::Windows::UI::WebUI::WebUIDialReceiverActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.WebUI.WebUIDialReceiverActivatedEventArgs", L"TileId");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.TileId();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* WebUIDialReceiverActivatedEventArgs_get_ActivatedOperation(py::wrapper::Windows::UI::WebUI::WebUIDialReceiverActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.WebUI.WebUIDialReceiverActivatedEventArgs", L"ActivatedOperation");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.ActivatedOperation();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_WebUIDialReceiverActivatedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::WebUI::WebUIDialReceiverActivatedEventArgs>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_WebUIDialReceiverActivatedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::WebUI::WebUIDialReceiverActivatedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_WebUIDialReceiverActivatedEventArgs[] = {
        { "_assign_array_", _assign_array_WebUIDialReceiverActivatedEventArgs, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_WebUIDialReceiverActivatedEventArgs), METH_O | METH_STATIC, nullptr },
        { }};

    static PyGetSetDef _getset_WebUIDialReceiverActivatedEventArgs[] = {
        { "kind", reinterpret_cast<getter>(WebUIDialReceiverActivatedEventArgs_get_Kind), nullptr, nullptr, nullptr },
        { "previous_execution_state", reinterpret_cast<getter>(WebUIDialReceiverActivatedEventArgs_get_PreviousExecutionState), nullptr, nullptr, nullptr },
        { "splash_screen", reinterpret_cast<getter>(WebUIDialReceiverActivatedEventArgs_get_SplashScreen), nullptr, nullptr, nullptr },
        { "user", reinterpret_cast<getter>(WebUIDialReceiverActivatedEventArgs_get_User), nullptr, nullptr, nullptr },
        { "currently_shown_application_view_id", reinterpret_cast<getter>(WebUIDialReceiverActivatedEventArgs_get_CurrentlyShownApplicationViewId), nullptr, nullptr, nullptr },
        { "app_name", reinterpret_cast<getter>(WebUIDialReceiverActivatedEventArgs_get_AppName), nullptr, nullptr, nullptr },
        { "arguments", reinterpret_cast<getter>(WebUIDialReceiverActivatedEventArgs_get_Arguments), nullptr, nullptr, nullptr },
        { "tile_id", reinterpret_cast<getter>(WebUIDialReceiverActivatedEventArgs_get_TileId), nullptr, nullptr, nullptr },
        { "activated_operation", reinterpret_cast<getter>(WebUIDialReceiverActivatedEventArgs_get_ActivatedOperation), nullptr, nullptr, nullptr },
        { }};

    static PyType_Slot _type_slots_WebUIDialReceiverActivatedEventArgs[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_WebUIDialReceiverActivatedEventArgs) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_WebUIDialReceiverActivatedEventArgs) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_WebUIDialReceiverActivatedEventArgs) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_WebUIDialReceiverActivatedEventArgs) },
        { }};

    static PyType_Spec type_spec_WebUIDialReceiverActivatedEventArgs = {
        "winrt._winrt_windows_ui_webui.WebUIDialReceiverActivatedEventArgs",
        sizeof(py::wrapper::Windows::UI::WebUI::WebUIDialReceiverActivatedEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_WebUIDialReceiverActivatedEventArgs};

    // ----- WebUIFileActivatedEventArgs class --------------------

    static PyObject* _new_WebUIFileActivatedEventArgs(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::UI::WebUI::WebUIFileActivatedEventArgs>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::UI::WebUI::WebUIFileActivatedEventArgs>::type_name);
        return nullptr;
    }

    static void _dealloc_WebUIFileActivatedEventArgs(py::wrapper::Windows::UI::WebUI::WebUIFileActivatedEventArgs* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* WebUIFileActivatedEventArgs_get_Kind(py::wrapper::Windows::UI::WebUI::WebUIFileActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.WebUI.WebUIFileActivatedEventArgs", L"Kind");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Kind();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* WebUIFileActivatedEventArgs_get_PreviousExecutionState(py::wrapper::Windows::UI::WebUI::WebUIFileActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.WebUI.WebUIFileActivatedEventArgs", L"PreviousExecutionState");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.PreviousExecutionState();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* WebUIFileActivatedEventArgs_get_SplashScreen(py::wrapper::Windows::UI::WebUI::WebUIFileActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.WebUI.WebUIFileActivatedEventArgs", L"SplashScreen");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.SplashScreen();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* WebUIFileActivatedEventArgs_get_User(py::wrapper::Windows::UI::WebUI::WebUIFileActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.WebUI.WebUIFileActivatedEventArgs", L"User");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.User();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* WebUIFileActivatedEventArgs_get_CurrentlyShownApplicationViewId(py::wrapper::Windows::UI::WebUI::WebUIFileActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.WebUI.WebUIFileActivatedEventArgs", L"CurrentlyShownApplicationViewId");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.CurrentlyShownApplicationViewId();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* WebUIFileActivatedEventArgs_get_Files(py::wrapper::Windows::UI::WebUI::WebUIFileActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.WebUI.WebUIFileActivatedEventArgs", L"Files");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Files();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* WebUIFileActivatedEventArgs_get_Verb(py::wrapper::Windows::UI::WebUI::WebUIFileActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.WebUI.WebUIFileActivatedEventArgs", L"Verb");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Verb();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* WebUIFileActivatedEventArgs_get_NeighboringFilesQuery(py::wrapper::Windows::UI::WebUI::WebUIFileActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.WebUI.WebUIFileActivatedEventArgs", L"NeighboringFilesQuery");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.NeighboringFilesQuery();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* WebUIFileActivatedEventArgs_get_ActivatedOperation(py::wrapper::Windows::UI::WebUI::WebUIFileActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.WebUI.WebUIFileActivatedEventArgs", L"ActivatedOperation");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.ActivatedOperation();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_WebUIFileActivatedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::WebUI::WebUIFileActivatedEventArgs>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_WebUIFileActivatedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::WebUI::WebUIFileActivatedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_WebUIFileActivatedEventArgs[] = {
        { "_assign_array_", _assign_array_WebUIFileActivatedEventArgs, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_WebUIFileActivatedEventArgs), METH_O | METH_STATIC, nullptr },
        { }};

    static PyGetSetDef _getset_WebUIFileActivatedEventArgs[] = {
        { "kind", reinterpret_cast<getter>(WebUIFileActivatedEventArgs_get_Kind), nullptr, nullptr, nullptr },
        { "previous_execution_state", reinterpret_cast<getter>(WebUIFileActivatedEventArgs_get_PreviousExecutionState), nullptr, nullptr, nullptr },
        { "splash_screen", reinterpret_cast<getter>(WebUIFileActivatedEventArgs_get_SplashScreen), nullptr, nullptr, nullptr },
        { "user", reinterpret_cast<getter>(WebUIFileActivatedEventArgs_get_User), nullptr, nullptr, nullptr },
        { "currently_shown_application_view_id", reinterpret_cast<getter>(WebUIFileActivatedEventArgs_get_CurrentlyShownApplicationViewId), nullptr, nullptr, nullptr },
        { "files", reinterpret_cast<getter>(WebUIFileActivatedEventArgs_get_Files), nullptr, nullptr, nullptr },
        { "verb", reinterpret_cast<getter>(WebUIFileActivatedEventArgs_get_Verb), nullptr, nullptr, nullptr },
        { "neighboring_files_query", reinterpret_cast<getter>(WebUIFileActivatedEventArgs_get_NeighboringFilesQuery), nullptr, nullptr, nullptr },
        { "activated_operation", reinterpret_cast<getter>(WebUIFileActivatedEventArgs_get_ActivatedOperation), nullptr, nullptr, nullptr },
        { }};

    static PyType_Slot _type_slots_WebUIFileActivatedEventArgs[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_WebUIFileActivatedEventArgs) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_WebUIFileActivatedEventArgs) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_WebUIFileActivatedEventArgs) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_WebUIFileActivatedEventArgs) },
        { }};

    static PyType_Spec type_spec_WebUIFileActivatedEventArgs = {
        "winrt._winrt_windows_ui_webui.WebUIFileActivatedEventArgs",
        sizeof(py::wrapper::Windows::UI::WebUI::WebUIFileActivatedEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_WebUIFileActivatedEventArgs};

    // ----- WebUIFileOpenPickerActivatedEventArgs class --------------------

    static PyObject* _new_WebUIFileOpenPickerActivatedEventArgs(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::UI::WebUI::WebUIFileOpenPickerActivatedEventArgs>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::UI::WebUI::WebUIFileOpenPickerActivatedEventArgs>::type_name);
        return nullptr;
    }

    static void _dealloc_WebUIFileOpenPickerActivatedEventArgs(py::wrapper::Windows::UI::WebUI::WebUIFileOpenPickerActivatedEventArgs* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* WebUIFileOpenPickerActivatedEventArgs_get_Kind(py::wrapper::Windows::UI::WebUI::WebUIFileOpenPickerActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.WebUI.WebUIFileOpenPickerActivatedEventArgs", L"Kind");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Kind();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* WebUIFileOpenPickerActivatedEventArgs_get_PreviousExecutionState(py::wrapper::Windows::UI::WebUI::WebUIFileOpenPickerActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.WebUI.WebUIFileOpenPickerActivatedEventArgs", L"PreviousExecutionState");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.PreviousExecutionState();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* WebUIFileOpenPickerActivatedEventArgs_get_SplashScreen(py::wrapper::Windows::UI::WebUI::WebUIFileOpenPickerActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.WebUI.WebUIFileOpenPickerActivatedEventArgs", L"SplashScreen");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.SplashScreen();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* WebUIFileOpenPickerActivatedEventArgs_get_User(py::wrapper::Windows::UI::WebUI::WebUIFileOpenPickerActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.WebUI.WebUIFileOpenPickerActivatedEventArgs", L"User");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.User();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* WebUIFileOpenPickerActivatedEventArgs_get_FileOpenPickerUI(py::wrapper::Windows::UI::WebUI::WebUIFileOpenPickerActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.WebUI.WebUIFileOpenPickerActivatedEventArgs", L"FileOpenPickerUI");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.FileOpenPickerUI();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* WebUIFileOpenPickerActivatedEventArgs_get_CallerPackageFamilyName(py::wrapper::Windows::UI::WebUI::WebUIFileOpenPickerActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.WebUI.WebUIFileOpenPickerActivatedEventArgs", L"CallerPackageFamilyName");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.CallerPackageFamilyName();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* WebUIFileOpenPickerActivatedEventArgs_get_ActivatedOperation(py::wrapper::Windows::UI::WebUI::WebUIFileOpenPickerActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.WebUI.WebUIFileOpenPickerActivatedEventArgs", L"ActivatedOperation");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.ActivatedOperation();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_WebUIFileOpenPickerActivatedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::WebUI::WebUIFileOpenPickerActivatedEventArgs>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_WebUIFileOpenPickerActivatedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::WebUI::WebUIFileOpenPickerActivatedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_WebUIFileOpenPickerActivatedEventArgs[] = {
        { "_assign_array_", _assign_array_WebUIFileOpenPickerActivatedEventArgs, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_WebUIFileOpenPickerActivatedEventArgs), METH_O | METH_STATIC, nullptr },
        { }};

    static PyGetSetDef _getset_WebUIFileOpenPickerActivatedEventArgs[] = {
        { "kind", reinterpret_cast<getter>(WebUIFileOpenPickerActivatedEventArgs_get_Kind), nullptr, nullptr, nullptr },
        { "previous_execution_state", reinterpret_cast<getter>(WebUIFileOpenPickerActivatedEventArgs_get_PreviousExecutionState), nullptr, nullptr, nullptr },
        { "splash_screen", reinterpret_cast<getter>(WebUIFileOpenPickerActivatedEventArgs_get_SplashScreen), nullptr, nullptr, nullptr },
        { "user", reinterpret_cast<getter>(WebUIFileOpenPickerActivatedEventArgs_get_User), nullptr, nullptr, nullptr },
        { "file_open_picker_ui", reinterpret_cast<getter>(WebUIFileOpenPickerActivatedEventArgs_get_FileOpenPickerUI), nullptr, nullptr, nullptr },
        { "caller_package_family_name", reinterpret_cast<getter>(WebUIFileOpenPickerActivatedEventArgs_get_CallerPackageFamilyName), nullptr, nullptr, nullptr },
        { "activated_operation", reinterpret_cast<getter>(WebUIFileOpenPickerActivatedEventArgs_get_ActivatedOperation), nullptr, nullptr, nullptr },
        { }};

    static PyType_Slot _type_slots_WebUIFileOpenPickerActivatedEventArgs[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_WebUIFileOpenPickerActivatedEventArgs) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_WebUIFileOpenPickerActivatedEventArgs) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_WebUIFileOpenPickerActivatedEventArgs) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_WebUIFileOpenPickerActivatedEventArgs) },
        { }};

    static PyType_Spec type_spec_WebUIFileOpenPickerActivatedEventArgs = {
        "winrt._winrt_windows_ui_webui.WebUIFileOpenPickerActivatedEventArgs",
        sizeof(py::wrapper::Windows::UI::WebUI::WebUIFileOpenPickerActivatedEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_WebUIFileOpenPickerActivatedEventArgs};

    // ----- WebUIFileOpenPickerContinuationEventArgs class --------------------

    static PyObject* _new_WebUIFileOpenPickerContinuationEventArgs(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::UI::WebUI::WebUIFileOpenPickerContinuationEventArgs>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::UI::WebUI::WebUIFileOpenPickerContinuationEventArgs>::type_name);
        return nullptr;
    }

    static void _dealloc_WebUIFileOpenPickerContinuationEventArgs(py::wrapper::Windows::UI::WebUI::WebUIFileOpenPickerContinuationEventArgs* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* WebUIFileOpenPickerContinuationEventArgs_get_Kind(py::wrapper::Windows::UI::WebUI::WebUIFileOpenPickerContinuationEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.WebUI.WebUIFileOpenPickerContinuationEventArgs", L"Kind");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Kind();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* WebUIFileOpenPickerContinuationEventArgs_get_PreviousExecutionState(py::wrapper::Windows::UI::WebUI::WebUIFileOpenPickerContinuationEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.WebUI.WebUIFileOpenPickerContinuationEventArgs", L"PreviousExecutionState");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.PreviousExecutionState();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* WebUIFileOpenPickerContinuationEventArgs_get_SplashScreen(py::wrapper::Windows::UI::WebUI::WebUIFileOpenPickerContinuationEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.WebUI.WebUIFileOpenPickerContinuationEventArgs", L"SplashScreen");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.SplashScreen();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* WebUIFileOpenPickerContinuationEventArgs_get_User(py::wrapper::Windows::UI::WebUI::WebUIFileOpenPickerContinuationEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.WebUI.WebUIFileOpenPickerContinuationEventArgs", L"User");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.User();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* WebUIFileOpenPickerContinuationEventArgs_get_ContinuationData(py::wrapper::Windows::UI::WebUI::WebUIFileOpenPickerContinuationEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.WebUI.WebUIFileOpenPickerContinuationEventArgs", L"ContinuationData");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.ContinuationData();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* WebUIFileOpenPickerContinuationEventArgs_get_Files(py::wrapper::Windows::UI::WebUI::WebUIFileOpenPickerContinuationEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.WebUI.WebUIFileOpenPickerContinuationEventArgs", L"Files");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Files();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* WebUIFileOpenPickerContinuationEventArgs_get_ActivatedOperation(py::wrapper::Windows::UI::WebUI::WebUIFileOpenPickerContinuationEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.WebUI.WebUIFileOpenPickerContinuationEventArgs", L"ActivatedOperation");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.ActivatedOperation();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_WebUIFileOpenPickerContinuationEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::WebUI::WebUIFileOpenPickerContinuationEventArgs>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_WebUIFileOpenPickerContinuationEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::WebUI::WebUIFileOpenPickerContinuationEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_WebUIFileOpenPickerContinuationEventArgs[] = {
        { "_assign_array_", _assign_array_WebUIFileOpenPickerContinuationEventArgs, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_WebUIFileOpenPickerContinuationEventArgs), METH_O | METH_STATIC, nullptr },
        { }};

    static PyGetSetDef _getset_WebUIFileOpenPickerContinuationEventArgs[] = {
        { "kind", reinterpret_cast<getter>(WebUIFileOpenPickerContinuationEventArgs_get_Kind), nullptr, nullptr, nullptr },
        { "previous_execution_state", reinterpret_cast<getter>(WebUIFileOpenPickerContinuationEventArgs_get_PreviousExecutionState), nullptr, nullptr, nullptr },
        { "splash_screen", reinterpret_cast<getter>(WebUIFileOpenPickerContinuationEventArgs_get_SplashScreen), nullptr, nullptr, nullptr },
        { "user", reinterpret_cast<getter>(WebUIFileOpenPickerContinuationEventArgs_get_User), nullptr, nullptr, nullptr },
        { "continuation_data", reinterpret_cast<getter>(WebUIFileOpenPickerContinuationEventArgs_get_ContinuationData), nullptr, nullptr, nullptr },
        { "files", reinterpret_cast<getter>(WebUIFileOpenPickerContinuationEventArgs_get_Files), nullptr, nullptr, nullptr },
        { "activated_operation", reinterpret_cast<getter>(WebUIFileOpenPickerContinuationEventArgs_get_ActivatedOperation), nullptr, nullptr, nullptr },
        { }};

    static PyType_Slot _type_slots_WebUIFileOpenPickerContinuationEventArgs[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_WebUIFileOpenPickerContinuationEventArgs) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_WebUIFileOpenPickerContinuationEventArgs) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_WebUIFileOpenPickerContinuationEventArgs) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_WebUIFileOpenPickerContinuationEventArgs) },
        { }};

    static PyType_Spec type_spec_WebUIFileOpenPickerContinuationEventArgs = {
        "winrt._winrt_windows_ui_webui.WebUIFileOpenPickerContinuationEventArgs",
        sizeof(py::wrapper::Windows::UI::WebUI::WebUIFileOpenPickerContinuationEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_WebUIFileOpenPickerContinuationEventArgs};

    // ----- WebUIFileSavePickerActivatedEventArgs class --------------------

    static PyObject* _new_WebUIFileSavePickerActivatedEventArgs(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::UI::WebUI::WebUIFileSavePickerActivatedEventArgs>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::UI::WebUI::WebUIFileSavePickerActivatedEventArgs>::type_name);
        return nullptr;
    }

    static void _dealloc_WebUIFileSavePickerActivatedEventArgs(py::wrapper::Windows::UI::WebUI::WebUIFileSavePickerActivatedEventArgs* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* WebUIFileSavePickerActivatedEventArgs_get_Kind(py::wrapper::Windows::UI::WebUI::WebUIFileSavePickerActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.WebUI.WebUIFileSavePickerActivatedEventArgs", L"Kind");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Kind();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* WebUIFileSavePickerActivatedEventArgs_get_PreviousExecutionState(py::wrapper::Windows::UI::WebUI::WebUIFileSavePickerActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.WebUI.WebUIFileSavePickerActivatedEventArgs", L"PreviousExecutionState");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.PreviousExecutionState();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* WebUIFileSavePickerActivatedEventArgs_get_SplashScreen(py::wrapper::Windows::UI::WebUI::WebUIFileSavePickerActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.WebUI.WebUIFileSavePickerActivatedEventArgs", L"SplashScreen");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.SplashScreen();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* WebUIFileSavePickerActivatedEventArgs_get_User(py::wrapper::Windows::UI::WebUI::WebUIFileSavePickerActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.WebUI.WebUIFileSavePickerActivatedEventArgs", L"User");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.User();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* WebUIFileSavePickerActivatedEventArgs_get_FileSavePickerUI(py::wrapper::Windows::UI::WebUI::WebUIFileSavePickerActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.WebUI.WebUIFileSavePickerActivatedEventArgs", L"FileSavePickerUI");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.FileSavePickerUI();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* WebUIFileSavePickerActivatedEventArgs_get_CallerPackageFamilyName(py::wrapper::Windows::UI::WebUI::WebUIFileSavePickerActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.WebUI.WebUIFileSavePickerActivatedEventArgs", L"CallerPackageFamilyName");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.CallerPackageFamilyName();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* WebUIFileSavePickerActivatedEventArgs_get_EnterpriseId(py::wrapper::Windows::UI::WebUI::WebUIFileSavePickerActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.WebUI.WebUIFileSavePickerActivatedEventArgs", L"EnterpriseId");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.EnterpriseId();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* WebUIFileSavePickerActivatedEventArgs_get_ActivatedOperation(py::wrapper::Windows::UI::WebUI::WebUIFileSavePickerActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.WebUI.WebUIFileSavePickerActivatedEventArgs", L"ActivatedOperation");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.ActivatedOperation();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_WebUIFileSavePickerActivatedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::WebUI::WebUIFileSavePickerActivatedEventArgs>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_WebUIFileSavePickerActivatedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::WebUI::WebUIFileSavePickerActivatedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_WebUIFileSavePickerActivatedEventArgs[] = {
        { "_assign_array_", _assign_array_WebUIFileSavePickerActivatedEventArgs, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_WebUIFileSavePickerActivatedEventArgs), METH_O | METH_STATIC, nullptr },
        { }};

    static PyGetSetDef _getset_WebUIFileSavePickerActivatedEventArgs[] = {
        { "kind", reinterpret_cast<getter>(WebUIFileSavePickerActivatedEventArgs_get_Kind), nullptr, nullptr, nullptr },
        { "previous_execution_state", reinterpret_cast<getter>(WebUIFileSavePickerActivatedEventArgs_get_PreviousExecutionState), nullptr, nullptr, nullptr },
        { "splash_screen", reinterpret_cast<getter>(WebUIFileSavePickerActivatedEventArgs_get_SplashScreen), nullptr, nullptr, nullptr },
        { "user", reinterpret_cast<getter>(WebUIFileSavePickerActivatedEventArgs_get_User), nullptr, nullptr, nullptr },
        { "file_save_picker_ui", reinterpret_cast<getter>(WebUIFileSavePickerActivatedEventArgs_get_FileSavePickerUI), nullptr, nullptr, nullptr },
        { "caller_package_family_name", reinterpret_cast<getter>(WebUIFileSavePickerActivatedEventArgs_get_CallerPackageFamilyName), nullptr, nullptr, nullptr },
        { "enterprise_id", reinterpret_cast<getter>(WebUIFileSavePickerActivatedEventArgs_get_EnterpriseId), nullptr, nullptr, nullptr },
        { "activated_operation", reinterpret_cast<getter>(WebUIFileSavePickerActivatedEventArgs_get_ActivatedOperation), nullptr, nullptr, nullptr },
        { }};

    static PyType_Slot _type_slots_WebUIFileSavePickerActivatedEventArgs[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_WebUIFileSavePickerActivatedEventArgs) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_WebUIFileSavePickerActivatedEventArgs) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_WebUIFileSavePickerActivatedEventArgs) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_WebUIFileSavePickerActivatedEventArgs) },
        { }};

    static PyType_Spec type_spec_WebUIFileSavePickerActivatedEventArgs = {
        "winrt._winrt_windows_ui_webui.WebUIFileSavePickerActivatedEventArgs",
        sizeof(py::wrapper::Windows::UI::WebUI::WebUIFileSavePickerActivatedEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_WebUIFileSavePickerActivatedEventArgs};

    // ----- WebUIFileSavePickerContinuationEventArgs class --------------------

    static PyObject* _new_WebUIFileSavePickerContinuationEventArgs(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::UI::WebUI::WebUIFileSavePickerContinuationEventArgs>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::UI::WebUI::WebUIFileSavePickerContinuationEventArgs>::type_name);
        return nullptr;
    }

    static void _dealloc_WebUIFileSavePickerContinuationEventArgs(py::wrapper::Windows::UI::WebUI::WebUIFileSavePickerContinuationEventArgs* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* WebUIFileSavePickerContinuationEventArgs_get_Kind(py::wrapper::Windows::UI::WebUI::WebUIFileSavePickerContinuationEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.WebUI.WebUIFileSavePickerContinuationEventArgs", L"Kind");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Kind();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* WebUIFileSavePickerContinuationEventArgs_get_PreviousExecutionState(py::wrapper::Windows::UI::WebUI::WebUIFileSavePickerContinuationEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.WebUI.WebUIFileSavePickerContinuationEventArgs", L"PreviousExecutionState");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.PreviousExecutionState();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* WebUIFileSavePickerContinuationEventArgs_get_SplashScreen(py::wrapper::Windows::UI::WebUI::WebUIFileSavePickerContinuationEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.WebUI.WebUIFileSavePickerContinuationEventArgs", L"SplashScreen");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.SplashScreen();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* WebUIFileSavePickerContinuationEventArgs_get_User(py::wrapper::Windows::UI::WebUI::WebUIFileSavePickerContinuationEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.WebUI.WebUIFileSavePickerContinuationEventArgs", L"User");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.User();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* WebUIFileSavePickerContinuationEventArgs_get_ContinuationData(py::wrapper::Windows::UI::WebUI::WebUIFileSavePickerContinuationEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.WebUI.WebUIFileSavePickerContinuationEventArgs", L"ContinuationData");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.ContinuationData();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* WebUIFileSavePickerContinuationEventArgs_get_File(py::wrapper::Windows::UI::WebUI::WebUIFileSavePickerContinuationEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.WebUI.WebUIFileSavePickerContinuationEventArgs", L"File");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.File();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* WebUIFileSavePickerContinuationEventArgs_get_ActivatedOperation(py::wrapper::Windows::UI::WebUI::WebUIFileSavePickerContinuationEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.WebUI.WebUIFileSavePickerContinuationEventArgs", L"ActivatedOperation");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.ActivatedOperation();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_WebUIFileSavePickerContinuationEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::WebUI::WebUIFileSavePickerContinuationEventArgs>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_WebUIFileSavePickerContinuationEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::WebUI::WebUIFileSavePickerContinuationEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_WebUIFileSavePickerContinuationEventArgs[] = {
        { "_assign_array_", _assign_array_WebUIFileSavePickerContinuationEventArgs, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_WebUIFileSavePickerContinuationEventArgs), METH_O | METH_STATIC, nullptr },
        { }};

    static PyGetSetDef _getset_WebUIFileSavePickerContinuationEventArgs[] = {
        { "kind", reinterpret_cast<getter>(WebUIFileSavePickerContinuationEventArgs_get_Kind), nullptr, nullptr, nullptr },
        { "previous_execution_state", reinterpret_cast<getter>(WebUIFileSavePickerContinuationEventArgs_get_PreviousExecutionState), nullptr, nullptr, nullptr },
        { "splash_screen", reinterpret_cast<getter>(WebUIFileSavePickerContinuationEventArgs_get_SplashScreen), nullptr, nullptr, nullptr },
        { "user", reinterpret_cast<getter>(WebUIFileSavePickerContinuationEventArgs_get_User), nullptr, nullptr, nullptr },
        { "continuation_data", reinterpret_cast<getter>(WebUIFileSavePickerContinuationEventArgs_get_ContinuationData), nullptr, nullptr, nullptr },
        { "file", reinterpret_cast<getter>(WebUIFileSavePickerContinuationEventArgs_get_File), nullptr, nullptr, nullptr },
        { "activated_operation", reinterpret_cast<getter>(WebUIFileSavePickerContinuationEventArgs_get_ActivatedOperation), nullptr, nullptr, nullptr },
        { }};

    static PyType_Slot _type_slots_WebUIFileSavePickerContinuationEventArgs[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_WebUIFileSavePickerContinuationEventArgs) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_WebUIFileSavePickerContinuationEventArgs) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_WebUIFileSavePickerContinuationEventArgs) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_WebUIFileSavePickerContinuationEventArgs) },
        { }};

    static PyType_Spec type_spec_WebUIFileSavePickerContinuationEventArgs = {
        "winrt._winrt_windows_ui_webui.WebUIFileSavePickerContinuationEventArgs",
        sizeof(py::wrapper::Windows::UI::WebUI::WebUIFileSavePickerContinuationEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_WebUIFileSavePickerContinuationEventArgs};

    // ----- WebUIFolderPickerContinuationEventArgs class --------------------

    static PyObject* _new_WebUIFolderPickerContinuationEventArgs(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::UI::WebUI::WebUIFolderPickerContinuationEventArgs>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::UI::WebUI::WebUIFolderPickerContinuationEventArgs>::type_name);
        return nullptr;
    }

    static void _dealloc_WebUIFolderPickerContinuationEventArgs(py::wrapper::Windows::UI::WebUI::WebUIFolderPickerContinuationEventArgs* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* WebUIFolderPickerContinuationEventArgs_get_Kind(py::wrapper::Windows::UI::WebUI::WebUIFolderPickerContinuationEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.WebUI.WebUIFolderPickerContinuationEventArgs", L"Kind");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Kind();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* WebUIFolderPickerContinuationEventArgs_get_PreviousExecutionState(py::wrapper::Windows::UI::WebUI::WebUIFolderPickerContinuationEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.WebUI.WebUIFolderPickerContinuationEventArgs", L"PreviousExecutionState");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.PreviousExecutionState();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* WebUIFolderPickerContinuationEventArgs_get_SplashScreen(py::wrapper::Windows::UI::WebUI::WebUIFolderPickerContinuationEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.WebUI.WebUIFolderPickerContinuationEventArgs", L"SplashScreen");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.SplashScreen();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* WebUIFolderPickerContinuationEventArgs_get_User(py::wrapper::Windows::UI::WebUI::WebUIFolderPickerContinuationEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.WebUI.WebUIFolderPickerContinuationEventArgs", L"User");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.User();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* WebUIFolderPickerContinuationEventArgs_get_ContinuationData(py::wrapper::Windows::UI::WebUI::WebUIFolderPickerContinuationEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.WebUI.WebUIFolderPickerContinuationEventArgs", L"ContinuationData");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.ContinuationData();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* WebUIFolderPickerContinuationEventArgs_get_Folder(py::wrapper::Windows::UI::WebUI::WebUIFolderPickerContinuationEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.WebUI.WebUIFolderPickerContinuationEventArgs", L"Folder");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Folder();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* WebUIFolderPickerContinuationEventArgs_get_ActivatedOperation(py::wrapper::Windows::UI::WebUI::WebUIFolderPickerContinuationEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.WebUI.WebUIFolderPickerContinuationEventArgs", L"ActivatedOperation");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.ActivatedOperation();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_WebUIFolderPickerContinuationEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::WebUI::WebUIFolderPickerContinuationEventArgs>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_WebUIFolderPickerContinuationEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::WebUI::WebUIFolderPickerContinuationEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_WebUIFolderPickerContinuationEventArgs[] = {
        { "_assign_array_", _assign_array_WebUIFolderPickerContinuationEventArgs, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_WebUIFolderPickerContinuationEventArgs), METH_O | METH_STATIC, nullptr },
        { }};

    static PyGetSetDef _getset_WebUIFolderPickerContinuationEventArgs[] = {
        { "kind", reinterpret_cast<getter>(WebUIFolderPickerContinuationEventArgs_get_Kind), nullptr, nullptr, nullptr },
        { "previous_execution_state", reinterpret_cast<getter>(WebUIFolderPickerContinuationEventArgs_get_PreviousExecutionState), nullptr, nullptr, nullptr },
        { "splash_screen", reinterpret_cast<getter>(WebUIFolderPickerContinuationEventArgs_get_SplashScreen), nullptr, nullptr, nullptr },
        { "user", reinterpret_cast<getter>(WebUIFolderPickerContinuationEventArgs_get_User), nullptr, nullptr, nullptr },
        { "continuation_data", reinterpret_cast<getter>(WebUIFolderPickerContinuationEventArgs_get_ContinuationData), nullptr, nullptr, nullptr },
        { "folder", reinterpret_cast<getter>(WebUIFolderPickerContinuationEventArgs_get_Folder), nullptr, nullptr, nullptr },
        { "activated_operation", reinterpret_cast<getter>(WebUIFolderPickerContinuationEventArgs_get_ActivatedOperation), nullptr, nullptr, nullptr },
        { }};

    static PyType_Slot _type_slots_WebUIFolderPickerContinuationEventArgs[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_WebUIFolderPickerContinuationEventArgs) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_WebUIFolderPickerContinuationEventArgs) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_WebUIFolderPickerContinuationEventArgs) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_WebUIFolderPickerContinuationEventArgs) },
        { }};

    static PyType_Spec type_spec_WebUIFolderPickerContinuationEventArgs = {
        "winrt._winrt_windows_ui_webui.WebUIFolderPickerContinuationEventArgs",
        sizeof(py::wrapper::Windows::UI::WebUI::WebUIFolderPickerContinuationEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_WebUIFolderPickerContinuationEventArgs};

    // ----- WebUILaunchActivatedEventArgs class --------------------

    static PyObject* _new_WebUILaunchActivatedEventArgs(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::UI::WebUI::WebUILaunchActivatedEventArgs>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::UI::WebUI::WebUILaunchActivatedEventArgs>::type_name);
        return nullptr;
    }

    static void _dealloc_WebUILaunchActivatedEventArgs(py::wrapper::Windows::UI::WebUI::WebUILaunchActivatedEventArgs* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* WebUILaunchActivatedEventArgs_get_Kind(py::wrapper::Windows::UI::WebUI::WebUILaunchActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.WebUI.WebUILaunchActivatedEventArgs", L"Kind");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Kind();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* WebUILaunchActivatedEventArgs_get_PreviousExecutionState(py::wrapper::Windows::UI::WebUI::WebUILaunchActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.WebUI.WebUILaunchActivatedEventArgs", L"PreviousExecutionState");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.PreviousExecutionState();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* WebUILaunchActivatedEventArgs_get_SplashScreen(py::wrapper::Windows::UI::WebUI::WebUILaunchActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.WebUI.WebUILaunchActivatedEventArgs", L"SplashScreen");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.SplashScreen();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* WebUILaunchActivatedEventArgs_get_User(py::wrapper::Windows::UI::WebUI::WebUILaunchActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.WebUI.WebUILaunchActivatedEventArgs", L"User");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.User();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* WebUILaunchActivatedEventArgs_get_CurrentlyShownApplicationViewId(py::wrapper::Windows::UI::WebUI::WebUILaunchActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.WebUI.WebUILaunchActivatedEventArgs", L"CurrentlyShownApplicationViewId");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.CurrentlyShownApplicationViewId();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* WebUILaunchActivatedEventArgs_get_Arguments(py::wrapper::Windows::UI::WebUI::WebUILaunchActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.WebUI.WebUILaunchActivatedEventArgs", L"Arguments");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Arguments();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* WebUILaunchActivatedEventArgs_get_TileId(py::wrapper::Windows::UI::WebUI::WebUILaunchActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.WebUI.WebUILaunchActivatedEventArgs", L"TileId");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.TileId();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* WebUILaunchActivatedEventArgs_get_TileActivatedInfo(py::wrapper::Windows::UI::WebUI::WebUILaunchActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.WebUI.WebUILaunchActivatedEventArgs", L"TileActivatedInfo");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.TileActivatedInfo();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* WebUILaunchActivatedEventArgs_get_PrelaunchActivated(py::wrapper::Windows::UI::WebUI::WebUILaunchActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.WebUI.WebUILaunchActivatedEventArgs", L"PrelaunchActivated");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.PrelaunchActivated();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* WebUILaunchActivatedEventArgs_get_ActivatedOperation(py::wrapper::Windows::UI::WebUI::WebUILaunchActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.WebUI.WebUILaunchActivatedEventArgs", L"ActivatedOperation");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.ActivatedOperation();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_WebUILaunchActivatedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::WebUI::WebUILaunchActivatedEventArgs>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_WebUILaunchActivatedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::WebUI::WebUILaunchActivatedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_WebUILaunchActivatedEventArgs[] = {
        { "_assign_array_", _assign_array_WebUILaunchActivatedEventArgs, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_WebUILaunchActivatedEventArgs), METH_O | METH_STATIC, nullptr },
        { }};

    static PyGetSetDef _getset_WebUILaunchActivatedEventArgs[] = {
        { "kind", reinterpret_cast<getter>(WebUILaunchActivatedEventArgs_get_Kind), nullptr, nullptr, nullptr },
        { "previous_execution_state", reinterpret_cast<getter>(WebUILaunchActivatedEventArgs_get_PreviousExecutionState), nullptr, nullptr, nullptr },
        { "splash_screen", reinterpret_cast<getter>(WebUILaunchActivatedEventArgs_get_SplashScreen), nullptr, nullptr, nullptr },
        { "user", reinterpret_cast<getter>(WebUILaunchActivatedEventArgs_get_User), nullptr, nullptr, nullptr },
        { "currently_shown_application_view_id", reinterpret_cast<getter>(WebUILaunchActivatedEventArgs_get_CurrentlyShownApplicationViewId), nullptr, nullptr, nullptr },
        { "arguments", reinterpret_cast<getter>(WebUILaunchActivatedEventArgs_get_Arguments), nullptr, nullptr, nullptr },
        { "tile_id", reinterpret_cast<getter>(WebUILaunchActivatedEventArgs_get_TileId), nullptr, nullptr, nullptr },
        { "tile_activated_info", reinterpret_cast<getter>(WebUILaunchActivatedEventArgs_get_TileActivatedInfo), nullptr, nullptr, nullptr },
        { "prelaunch_activated", reinterpret_cast<getter>(WebUILaunchActivatedEventArgs_get_PrelaunchActivated), nullptr, nullptr, nullptr },
        { "activated_operation", reinterpret_cast<getter>(WebUILaunchActivatedEventArgs_get_ActivatedOperation), nullptr, nullptr, nullptr },
        { }};

    static PyType_Slot _type_slots_WebUILaunchActivatedEventArgs[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_WebUILaunchActivatedEventArgs) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_WebUILaunchActivatedEventArgs) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_WebUILaunchActivatedEventArgs) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_WebUILaunchActivatedEventArgs) },
        { }};

    static PyType_Spec type_spec_WebUILaunchActivatedEventArgs = {
        "winrt._winrt_windows_ui_webui.WebUILaunchActivatedEventArgs",
        sizeof(py::wrapper::Windows::UI::WebUI::WebUILaunchActivatedEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_WebUILaunchActivatedEventArgs};

    // ----- WebUILockScreenActivatedEventArgs class --------------------

    static PyObject* _new_WebUILockScreenActivatedEventArgs(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::UI::WebUI::WebUILockScreenActivatedEventArgs>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::UI::WebUI::WebUILockScreenActivatedEventArgs>::type_name);
        return nullptr;
    }

    static void _dealloc_WebUILockScreenActivatedEventArgs(py::wrapper::Windows::UI::WebUI::WebUILockScreenActivatedEventArgs* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* WebUILockScreenActivatedEventArgs_get_Kind(py::wrapper::Windows::UI::WebUI::WebUILockScreenActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.WebUI.WebUILockScreenActivatedEventArgs", L"Kind");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Kind();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* WebUILockScreenActivatedEventArgs_get_PreviousExecutionState(py::wrapper::Windows::UI::WebUI::WebUILockScreenActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.WebUI.WebUILockScreenActivatedEventArgs", L"PreviousExecutionState");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.PreviousExecutionState();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* WebUILockScreenActivatedEventArgs_get_SplashScreen(py::wrapper::Windows::UI::WebUI::WebUILockScreenActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.WebUI.WebUILockScreenActivatedEventArgs", L"SplashScreen");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.SplashScreen();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* WebUILockScreenActivatedEventArgs_get_User(py::wrapper::Windows::UI::WebUI::WebUILockScreenActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.WebUI.WebUILockScreenActivatedEventArgs", L"User");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.User();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* WebUILockScreenActivatedEventArgs_get_CurrentlyShownApplicationViewId(py::wrapper::Windows::UI::WebUI::WebUILockScreenActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.WebUI.WebUILockScreenActivatedEventArgs", L"CurrentlyShownApplicationViewId");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.CurrentlyShownApplicationViewId();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* WebUILockScreenActivatedEventArgs_get_Info(py::wrapper::Windows::UI::WebUI::WebUILockScreenActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.WebUI.WebUILockScreenActivatedEventArgs", L"Info");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Info();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* WebUILockScreenActivatedEventArgs_get_ActivatedOperation(py::wrapper::Windows::UI::WebUI::WebUILockScreenActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.WebUI.WebUILockScreenActivatedEventArgs", L"ActivatedOperation");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.ActivatedOperation();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_WebUILockScreenActivatedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::WebUI::WebUILockScreenActivatedEventArgs>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_WebUILockScreenActivatedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::WebUI::WebUILockScreenActivatedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_WebUILockScreenActivatedEventArgs[] = {
        { "_assign_array_", _assign_array_WebUILockScreenActivatedEventArgs, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_WebUILockScreenActivatedEventArgs), METH_O | METH_STATIC, nullptr },
        { }};

    static PyGetSetDef _getset_WebUILockScreenActivatedEventArgs[] = {
        { "kind", reinterpret_cast<getter>(WebUILockScreenActivatedEventArgs_get_Kind), nullptr, nullptr, nullptr },
        { "previous_execution_state", reinterpret_cast<getter>(WebUILockScreenActivatedEventArgs_get_PreviousExecutionState), nullptr, nullptr, nullptr },
        { "splash_screen", reinterpret_cast<getter>(WebUILockScreenActivatedEventArgs_get_SplashScreen), nullptr, nullptr, nullptr },
        { "user", reinterpret_cast<getter>(WebUILockScreenActivatedEventArgs_get_User), nullptr, nullptr, nullptr },
        { "currently_shown_application_view_id", reinterpret_cast<getter>(WebUILockScreenActivatedEventArgs_get_CurrentlyShownApplicationViewId), nullptr, nullptr, nullptr },
        { "info", reinterpret_cast<getter>(WebUILockScreenActivatedEventArgs_get_Info), nullptr, nullptr, nullptr },
        { "activated_operation", reinterpret_cast<getter>(WebUILockScreenActivatedEventArgs_get_ActivatedOperation), nullptr, nullptr, nullptr },
        { }};

    static PyType_Slot _type_slots_WebUILockScreenActivatedEventArgs[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_WebUILockScreenActivatedEventArgs) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_WebUILockScreenActivatedEventArgs) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_WebUILockScreenActivatedEventArgs) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_WebUILockScreenActivatedEventArgs) },
        { }};

    static PyType_Spec type_spec_WebUILockScreenActivatedEventArgs = {
        "winrt._winrt_windows_ui_webui.WebUILockScreenActivatedEventArgs",
        sizeof(py::wrapper::Windows::UI::WebUI::WebUILockScreenActivatedEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_WebUILockScreenActivatedEventArgs};

    // ----- WebUILockScreenCallActivatedEventArgs class --------------------

    static PyObject* _new_WebUILockScreenCallActivatedEventArgs(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::UI::WebUI::WebUILockScreenCallActivatedEventArgs>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::UI::WebUI::WebUILockScreenCallActivatedEventArgs>::type_name);
        return nullptr;
    }

    static void _dealloc_WebUILockScreenCallActivatedEventArgs(py::wrapper::Windows::UI::WebUI::WebUILockScreenCallActivatedEventArgs* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* WebUILockScreenCallActivatedEventArgs_get_Kind(py::wrapper::Windows::UI::WebUI::WebUILockScreenCallActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.WebUI.WebUILockScreenCallActivatedEventArgs", L"Kind");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Kind();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* WebUILockScreenCallActivatedEventArgs_get_PreviousExecutionState(py::wrapper::Windows::UI::WebUI::WebUILockScreenCallActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.WebUI.WebUILockScreenCallActivatedEventArgs", L"PreviousExecutionState");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.PreviousExecutionState();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* WebUILockScreenCallActivatedEventArgs_get_SplashScreen(py::wrapper::Windows::UI::WebUI::WebUILockScreenCallActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.WebUI.WebUILockScreenCallActivatedEventArgs", L"SplashScreen");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.SplashScreen();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* WebUILockScreenCallActivatedEventArgs_get_CurrentlyShownApplicationViewId(py::wrapper::Windows::UI::WebUI::WebUILockScreenCallActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.WebUI.WebUILockScreenCallActivatedEventArgs", L"CurrentlyShownApplicationViewId");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.CurrentlyShownApplicationViewId();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* WebUILockScreenCallActivatedEventArgs_get_Arguments(py::wrapper::Windows::UI::WebUI::WebUILockScreenCallActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.WebUI.WebUILockScreenCallActivatedEventArgs", L"Arguments");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Arguments();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* WebUILockScreenCallActivatedEventArgs_get_TileId(py::wrapper::Windows::UI::WebUI::WebUILockScreenCallActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.WebUI.WebUILockScreenCallActivatedEventArgs", L"TileId");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.TileId();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* WebUILockScreenCallActivatedEventArgs_get_CallUI(py::wrapper::Windows::UI::WebUI::WebUILockScreenCallActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.WebUI.WebUILockScreenCallActivatedEventArgs", L"CallUI");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.CallUI();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* WebUILockScreenCallActivatedEventArgs_get_ActivatedOperation(py::wrapper::Windows::UI::WebUI::WebUILockScreenCallActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.WebUI.WebUILockScreenCallActivatedEventArgs", L"ActivatedOperation");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.ActivatedOperation();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_WebUILockScreenCallActivatedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::WebUI::WebUILockScreenCallActivatedEventArgs>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_WebUILockScreenCallActivatedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::WebUI::WebUILockScreenCallActivatedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_WebUILockScreenCallActivatedEventArgs[] = {
        { "_assign_array_", _assign_array_WebUILockScreenCallActivatedEventArgs, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_WebUILockScreenCallActivatedEventArgs), METH_O | METH_STATIC, nullptr },
        { }};

    static PyGetSetDef _getset_WebUILockScreenCallActivatedEventArgs[] = {
        { "kind", reinterpret_cast<getter>(WebUILockScreenCallActivatedEventArgs_get_Kind), nullptr, nullptr, nullptr },
        { "previous_execution_state", reinterpret_cast<getter>(WebUILockScreenCallActivatedEventArgs_get_PreviousExecutionState), nullptr, nullptr, nullptr },
        { "splash_screen", reinterpret_cast<getter>(WebUILockScreenCallActivatedEventArgs_get_SplashScreen), nullptr, nullptr, nullptr },
        { "currently_shown_application_view_id", reinterpret_cast<getter>(WebUILockScreenCallActivatedEventArgs_get_CurrentlyShownApplicationViewId), nullptr, nullptr, nullptr },
        { "arguments", reinterpret_cast<getter>(WebUILockScreenCallActivatedEventArgs_get_Arguments), nullptr, nullptr, nullptr },
        { "tile_id", reinterpret_cast<getter>(WebUILockScreenCallActivatedEventArgs_get_TileId), nullptr, nullptr, nullptr },
        { "call_ui", reinterpret_cast<getter>(WebUILockScreenCallActivatedEventArgs_get_CallUI), nullptr, nullptr, nullptr },
        { "activated_operation", reinterpret_cast<getter>(WebUILockScreenCallActivatedEventArgs_get_ActivatedOperation), nullptr, nullptr, nullptr },
        { }};

    static PyType_Slot _type_slots_WebUILockScreenCallActivatedEventArgs[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_WebUILockScreenCallActivatedEventArgs) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_WebUILockScreenCallActivatedEventArgs) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_WebUILockScreenCallActivatedEventArgs) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_WebUILockScreenCallActivatedEventArgs) },
        { }};

    static PyType_Spec type_spec_WebUILockScreenCallActivatedEventArgs = {
        "winrt._winrt_windows_ui_webui.WebUILockScreenCallActivatedEventArgs",
        sizeof(py::wrapper::Windows::UI::WebUI::WebUILockScreenCallActivatedEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_WebUILockScreenCallActivatedEventArgs};

    // ----- WebUILockScreenComponentActivatedEventArgs class --------------------

    static PyObject* _new_WebUILockScreenComponentActivatedEventArgs(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::UI::WebUI::WebUILockScreenComponentActivatedEventArgs>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::UI::WebUI::WebUILockScreenComponentActivatedEventArgs>::type_name);
        return nullptr;
    }

    static void _dealloc_WebUILockScreenComponentActivatedEventArgs(py::wrapper::Windows::UI::WebUI::WebUILockScreenComponentActivatedEventArgs* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* WebUILockScreenComponentActivatedEventArgs_get_Kind(py::wrapper::Windows::UI::WebUI::WebUILockScreenComponentActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.WebUI.WebUILockScreenComponentActivatedEventArgs", L"Kind");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Kind();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* WebUILockScreenComponentActivatedEventArgs_get_PreviousExecutionState(py::wrapper::Windows::UI::WebUI::WebUILockScreenComponentActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.WebUI.WebUILockScreenComponentActivatedEventArgs", L"PreviousExecutionState");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.PreviousExecutionState();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* WebUILockScreenComponentActivatedEventArgs_get_SplashScreen(py::wrapper::Windows::UI::WebUI::WebUILockScreenComponentActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.WebUI.WebUILockScreenComponentActivatedEventArgs", L"SplashScreen");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.SplashScreen();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* WebUILockScreenComponentActivatedEventArgs_get_ActivatedOperation(py::wrapper::Windows::UI::WebUI::WebUILockScreenComponentActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.WebUI.WebUILockScreenComponentActivatedEventArgs", L"ActivatedOperation");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.ActivatedOperation();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_WebUILockScreenComponentActivatedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::WebUI::WebUILockScreenComponentActivatedEventArgs>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_WebUILockScreenComponentActivatedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::WebUI::WebUILockScreenComponentActivatedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_WebUILockScreenComponentActivatedEventArgs[] = {
        { "_assign_array_", _assign_array_WebUILockScreenComponentActivatedEventArgs, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_WebUILockScreenComponentActivatedEventArgs), METH_O | METH_STATIC, nullptr },
        { }};

    static PyGetSetDef _getset_WebUILockScreenComponentActivatedEventArgs[] = {
        { "kind", reinterpret_cast<getter>(WebUILockScreenComponentActivatedEventArgs_get_Kind), nullptr, nullptr, nullptr },
        { "previous_execution_state", reinterpret_cast<getter>(WebUILockScreenComponentActivatedEventArgs_get_PreviousExecutionState), nullptr, nullptr, nullptr },
        { "splash_screen", reinterpret_cast<getter>(WebUILockScreenComponentActivatedEventArgs_get_SplashScreen), nullptr, nullptr, nullptr },
        { "activated_operation", reinterpret_cast<getter>(WebUILockScreenComponentActivatedEventArgs_get_ActivatedOperation), nullptr, nullptr, nullptr },
        { }};

    static PyType_Slot _type_slots_WebUILockScreenComponentActivatedEventArgs[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_WebUILockScreenComponentActivatedEventArgs) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_WebUILockScreenComponentActivatedEventArgs) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_WebUILockScreenComponentActivatedEventArgs) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_WebUILockScreenComponentActivatedEventArgs) },
        { }};

    static PyType_Spec type_spec_WebUILockScreenComponentActivatedEventArgs = {
        "winrt._winrt_windows_ui_webui.WebUILockScreenComponentActivatedEventArgs",
        sizeof(py::wrapper::Windows::UI::WebUI::WebUILockScreenComponentActivatedEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_WebUILockScreenComponentActivatedEventArgs};

    // ----- WebUINavigatedDeferral class --------------------

    static PyObject* _new_WebUINavigatedDeferral(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::UI::WebUI::WebUINavigatedDeferral>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::UI::WebUI::WebUINavigatedDeferral>::type_name);
        return nullptr;
    }

    static void _dealloc_WebUINavigatedDeferral(py::wrapper::Windows::UI::WebUI::WebUINavigatedDeferral* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* WebUINavigatedDeferral_Complete(py::wrapper::Windows::UI::WebUI::WebUINavigatedDeferral* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.WebUI.WebUINavigatedDeferral", L"Complete", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                {
                    auto _gil = release_gil();
                    self->obj.Complete();
                }

                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* _assign_array_WebUINavigatedDeferral(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::WebUI::WebUINavigatedDeferral>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_WebUINavigatedDeferral(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::WebUI::WebUINavigatedDeferral>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_WebUINavigatedDeferral[] = {
        { "complete", reinterpret_cast<PyCFunction>(WebUINavigatedDeferral_Complete), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_WebUINavigatedDeferral, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_WebUINavigatedDeferral), METH_O | METH_STATIC, nullptr },
        { }};

    static PyGetSetDef _getset_WebUINavigatedDeferral[] = {
        { }};

    static PyType_Slot _type_slots_WebUINavigatedDeferral[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_WebUINavigatedDeferral) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_WebUINavigatedDeferral) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_WebUINavigatedDeferral) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_WebUINavigatedDeferral) },
        { }};

    static PyType_Spec type_spec_WebUINavigatedDeferral = {
        "winrt._winrt_windows_ui_webui.WebUINavigatedDeferral",
        sizeof(py::wrapper::Windows::UI::WebUI::WebUINavigatedDeferral),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_WebUINavigatedDeferral};

    // ----- WebUINavigatedEventArgs class --------------------

    static PyObject* _new_WebUINavigatedEventArgs(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::UI::WebUI::WebUINavigatedEventArgs>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::UI::WebUI::WebUINavigatedEventArgs>::type_name);
        return nullptr;
    }

    static void _dealloc_WebUINavigatedEventArgs(py::wrapper::Windows::UI::WebUI::WebUINavigatedEventArgs* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* WebUINavigatedEventArgs_get_NavigatedOperation(py::wrapper::Windows::UI::WebUI::WebUINavigatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.WebUI.WebUINavigatedEventArgs", L"NavigatedOperation");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.NavigatedOperation();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_WebUINavigatedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::WebUI::WebUINavigatedEventArgs>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_WebUINavigatedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::WebUI::WebUINavigatedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_WebUINavigatedEventArgs[] = {
        { "_assign_array_", _assign_array_WebUINavigatedEventArgs, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_WebUINavigatedEventArgs), METH_O | METH_STATIC, nullptr },
        { }};

    static PyGetSetDef _getset_WebUINavigatedEventArgs[] = {
        { "navigated_operation", reinterpret_cast<getter>(WebUINavigatedEventArgs_get_NavigatedOperation), nullptr, nullptr, nullptr },
        { }};

    static PyType_Slot _type_slots_WebUINavigatedEventArgs[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_WebUINavigatedEventArgs) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_WebUINavigatedEventArgs) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_WebUINavigatedEventArgs) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_WebUINavigatedEventArgs) },
        { }};

    static PyType_Spec type_spec_WebUINavigatedEventArgs = {
        "winrt._winrt_windows_ui_webui.WebUINavigatedEventArgs",
        sizeof(py::wrapper::Windows::UI::WebUI::WebUINavigatedEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_WebUINavigatedEventArgs};

    // ----- WebUINavigatedOperation class --------------------

    static PyObject* _new_WebUINavigatedOperation(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::UI::WebUI::WebUINavigatedOperation>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::UI::WebUI::WebUINavigatedOperation>::type_name);
        return nullptr;
    }

    static void _dealloc_WebUINavigatedOperation(py::wrapper::Windows::UI::WebUI::WebUINavigatedOperation* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* WebUINavigatedOperation_GetDeferral(py::wrapper::Windows::UI::WebUI::WebUINavigatedOperation* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.WebUI.WebUINavigatedOperation", L"GetDeferral", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return self->obj.GetDeferral();
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* _assign_array_WebUINavigatedOperation(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::WebUI::WebUINavigatedOperation>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_WebUINavigatedOperation(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::WebUI::WebUINavigatedOperation>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_WebUINavigatedOperation[] = {
        { "get_deferral", reinterpret_cast<PyCFunction>(WebUINavigatedOperation_GetDeferral), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_WebUINavigatedOperation, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_WebUINavigatedOperation), METH_O | METH_STATIC, nullptr },
        { }};

    static PyGetSetDef _getset_WebUINavigatedOperation[] = {
        { }};

    static PyType_Slot _type_slots_WebUINavigatedOperation[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_WebUINavigatedOperation) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_WebUINavigatedOperation) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_WebUINavigatedOperation) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_WebUINavigatedOperation) },
        { }};

    static PyType_Spec type_spec_WebUINavigatedOperation = {
        "winrt._winrt_windows_ui_webui.WebUINavigatedOperation",
        sizeof(py::wrapper::Windows::UI::WebUI::WebUINavigatedOperation),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_WebUINavigatedOperation};

    // ----- WebUIPhoneCallActivatedEventArgs class --------------------

    static PyObject* _new_WebUIPhoneCallActivatedEventArgs(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::UI::WebUI::WebUIPhoneCallActivatedEventArgs>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::UI::WebUI::WebUIPhoneCallActivatedEventArgs>::type_name);
        return nullptr;
    }

    static void _dealloc_WebUIPhoneCallActivatedEventArgs(py::wrapper::Windows::UI::WebUI::WebUIPhoneCallActivatedEventArgs* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* WebUIPhoneCallActivatedEventArgs_get_Kind(py::wrapper::Windows::UI::WebUI::WebUIPhoneCallActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.WebUI.WebUIPhoneCallActivatedEventArgs", L"Kind");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Kind();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* WebUIPhoneCallActivatedEventArgs_get_PreviousExecutionState(py::wrapper::Windows::UI::WebUI::WebUIPhoneCallActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.WebUI.WebUIPhoneCallActivatedEventArgs", L"PreviousExecutionState");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.PreviousExecutionState();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* WebUIPhoneCallActivatedEventArgs_get_SplashScreen(py::wrapper::Windows::UI::WebUI::WebUIPhoneCallActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.WebUI.WebUIPhoneCallActivatedEventArgs", L"SplashScreen");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.SplashScreen();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* WebUIPhoneCallActivatedEventArgs_get_User(py::wrapper::Windows::UI::WebUI::WebUIPhoneCallActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.WebUI.WebUIPhoneCallActivatedEventArgs", L"User");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.User();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* WebUIPhoneCallActivatedEventArgs_get_LineId(py::wrapper::Windows::UI::WebUI::WebUIPhoneCallActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.WebUI.WebUIPhoneCallActivatedEventArgs", L"LineId");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.LineId();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* WebUIPhoneCallActivatedEventArgs_get_ActivatedOperation(py::wrapper::Windows::UI::WebUI::WebUIPhoneCallActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.WebUI.WebUIPhoneCallActivatedEventArgs", L"ActivatedOperation");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.ActivatedOperation();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_WebUIPhoneCallActivatedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::WebUI::WebUIPhoneCallActivatedEventArgs>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_WebUIPhoneCallActivatedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::WebUI::WebUIPhoneCallActivatedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_WebUIPhoneCallActivatedEventArgs[] = {
        { "_assign_array_", _assign_array_WebUIPhoneCallActivatedEventArgs, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_WebUIPhoneCallActivatedEventArgs), METH_O | METH_STATIC, nullptr },
        { }};

    static PyGetSetDef _getset_WebUIPhoneCallActivatedEventArgs[] = {
        { "kind", reinterpret_cast<getter>(WebUIPhoneCallActivatedEventArgs_get_Kind), nullptr, nullptr, nullptr },
        { "previous_execution_state", reinterpret_cast<getter>(WebUIPhoneCallActivatedEventArgs_get_PreviousExecutionState), nullptr, nullptr, nullptr },
        { "splash_screen", reinterpret_cast<getter>(WebUIPhoneCallActivatedEventArgs_get_SplashScreen), nullptr, nullptr, nullptr },
        { "user", reinterpret_cast<getter>(WebUIPhoneCallActivatedEventArgs_get_User), nullptr, nullptr, nullptr },
        { "line_id", reinterpret_cast<getter>(WebUIPhoneCallActivatedEventArgs_get_LineId), nullptr, nullptr, nullptr },
        { "activated_operation", reinterpret_cast<getter>(WebUIPhoneCallActivatedEventArgs_get_ActivatedOperation), nullptr, nullptr, nullptr },
        { }};

    static PyType_Slot _type_slots_WebUIPhoneCallActivatedEventArgs[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_WebUIPhoneCallActivatedEventArgs) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_WebUIPhoneCallActivatedEventArgs) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_WebUIPhoneCallActivatedEventArgs) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_WebUIPhoneCallActivatedEventArgs) },
        { }};

    static PyType_Spec type_spec_WebUIPhoneCallActivatedEventArgs = {
        "winrt._winrt_windows_ui_webui.WebUIPhoneCallActivatedEventArgs",
        sizeof(py::wrapper::Windows::UI::WebUI::WebUIPhoneCallActivatedEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_WebUIPhoneCallActivatedEventArgs};

    // ----- WebUIPrint3DWorkflowActivatedEventArgs class --------------------

    static PyObject* _new_WebUIPrint3DWorkflowActivatedEventArgs(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::UI::WebUI::WebUIPrint3DWorkflowActivatedEventArgs>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::UI::WebUI::WebUIPrint3DWorkflowActivatedEventArgs>::type_name);
        return nullptr;
    }

    static void _dealloc_WebUIPrint3DWorkflowActivatedEventArgs(py::wrapper::Windows::UI::WebUI::WebUIPrint3DWorkflowActivatedEventArgs* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* WebUIPrint3DWorkflowActivatedEventArgs_get_Kind(py::wrapper::Windows::UI::WebUI::WebUIPrint3DWorkflowActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.WebUI.WebUIPrint3DWorkflowActivatedEventArgs", L"Kind");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Kind();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* WebUIPrint3DWorkflowActivatedEventArgs_get_PreviousExecutionState(py::wrapper::Windows::UI::WebUI::WebUIPrint3DWorkflowActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.WebUI.WebUIPrint3DWorkflowActivatedEventArgs", L"PreviousExecutionState");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.PreviousExecutionState();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* WebUIPrint3DWorkflowActivatedEventArgs_get_SplashScreen(py::wrapper::Windows::UI::WebUI::WebUIPrint3DWorkflowActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.WebUI.WebUIPrint3DWorkflowActivatedEventArgs", L"SplashScreen");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.SplashScreen();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* WebUIPrint3DWorkflowActivatedEventArgs_get_Workflow(py::wrapper::Windows::UI::WebUI::WebUIPrint3DWorkflowActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.WebUI.WebUIPrint3DWorkflowActivatedEventArgs", L"Workflow");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Workflow();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* WebUIPrint3DWorkflowActivatedEventArgs_get_ActivatedOperation(py::wrapper::Windows::UI::WebUI::WebUIPrint3DWorkflowActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.WebUI.WebUIPrint3DWorkflowActivatedEventArgs", L"ActivatedOperation");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.ActivatedOperation();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_WebUIPrint3DWorkflowActivatedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::WebUI::WebUIPrint3DWorkflowActivatedEventArgs>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_WebUIPrint3DWorkflowActivatedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::WebUI::WebUIPrint3DWorkflowActivatedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_WebUIPrint3DWorkflowActivatedEventArgs[] = {
        { "_assign_array_", _assign_array_WebUIPrint3DWorkflowActivatedEventArgs, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_WebUIPrint3DWorkflowActivatedEventArgs), METH_O | METH_STATIC, nullptr },
        { }};

    static PyGetSetDef _getset_WebUIPrint3DWorkflowActivatedEventArgs[] = {
        { "kind", reinterpret_cast<getter>(WebUIPrint3DWorkflowActivatedEventArgs_get_Kind), nullptr, nullptr, nullptr },
        { "previous_execution_state", reinterpret_cast<getter>(WebUIPrint3DWorkflowActivatedEventArgs_get_PreviousExecutionState), nullptr, nullptr, nullptr },
        { "splash_screen", reinterpret_cast<getter>(WebUIPrint3DWorkflowActivatedEventArgs_get_SplashScreen), nullptr, nullptr, nullptr },
        { "workflow", reinterpret_cast<getter>(WebUIPrint3DWorkflowActivatedEventArgs_get_Workflow), nullptr, nullptr, nullptr },
        { "activated_operation", reinterpret_cast<getter>(WebUIPrint3DWorkflowActivatedEventArgs_get_ActivatedOperation), nullptr, nullptr, nullptr },
        { }};

    static PyType_Slot _type_slots_WebUIPrint3DWorkflowActivatedEventArgs[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_WebUIPrint3DWorkflowActivatedEventArgs) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_WebUIPrint3DWorkflowActivatedEventArgs) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_WebUIPrint3DWorkflowActivatedEventArgs) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_WebUIPrint3DWorkflowActivatedEventArgs) },
        { }};

    static PyType_Spec type_spec_WebUIPrint3DWorkflowActivatedEventArgs = {
        "winrt._winrt_windows_ui_webui.WebUIPrint3DWorkflowActivatedEventArgs",
        sizeof(py::wrapper::Windows::UI::WebUI::WebUIPrint3DWorkflowActivatedEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_WebUIPrint3DWorkflowActivatedEventArgs};

    // ----- WebUIPrintTaskSettingsActivatedEventArgs class --------------------

    static PyObject* _new_WebUIPrintTaskSettingsActivatedEventArgs(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::UI::WebUI::WebUIPrintTaskSettingsActivatedEventArgs>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::UI::WebUI::WebUIPrintTaskSettingsActivatedEventArgs>::type_name);
        return nullptr;
    }

    static void _dealloc_WebUIPrintTaskSettingsActivatedEventArgs(py::wrapper::Windows::UI::WebUI::WebUIPrintTaskSettingsActivatedEventArgs* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* WebUIPrintTaskSettingsActivatedEventArgs_get_Kind(py::wrapper::Windows::UI::WebUI::WebUIPrintTaskSettingsActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.WebUI.WebUIPrintTaskSettingsActivatedEventArgs", L"Kind");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Kind();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* WebUIPrintTaskSettingsActivatedEventArgs_get_PreviousExecutionState(py::wrapper::Windows::UI::WebUI::WebUIPrintTaskSettingsActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.WebUI.WebUIPrintTaskSettingsActivatedEventArgs", L"PreviousExecutionState");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.PreviousExecutionState();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* WebUIPrintTaskSettingsActivatedEventArgs_get_SplashScreen(py::wrapper::Windows::UI::WebUI::WebUIPrintTaskSettingsActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.WebUI.WebUIPrintTaskSettingsActivatedEventArgs", L"SplashScreen");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.SplashScreen();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* WebUIPrintTaskSettingsActivatedEventArgs_get_Configuration(py::wrapper::Windows::UI::WebUI::WebUIPrintTaskSettingsActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.WebUI.WebUIPrintTaskSettingsActivatedEventArgs", L"Configuration");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Configuration();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* WebUIPrintTaskSettingsActivatedEventArgs_get_ActivatedOperation(py::wrapper::Windows::UI::WebUI::WebUIPrintTaskSettingsActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.WebUI.WebUIPrintTaskSettingsActivatedEventArgs", L"ActivatedOperation");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.ActivatedOperation();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_WebUIPrintTaskSettingsActivatedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::WebUI::WebUIPrintTaskSettingsActivatedEventArgs>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_WebUIPrintTaskSettingsActivatedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::WebUI::WebUIPrintTaskSettingsActivatedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_WebUIPrintTaskSettingsActivatedEventArgs[] = {
        { "_assign_array_", _assign_array_WebUIPrintTaskSettingsActivatedEventArgs, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_WebUIPrintTaskSettingsActivatedEventArgs), METH_O | METH_STATIC, nullptr },
        { }};

    static PyGetSetDef _getset_WebUIPrintTaskSettingsActivatedEventArgs[] = {
        { "kind", reinterpret_cast<getter>(WebUIPrintTaskSettingsActivatedEventArgs_get_Kind), nullptr, nullptr, nullptr },
        { "previous_execution_state", reinterpret_cast<getter>(WebUIPrintTaskSettingsActivatedEventArgs_get_PreviousExecutionState), nullptr, nullptr, nullptr },
        { "splash_screen", reinterpret_cast<getter>(WebUIPrintTaskSettingsActivatedEventArgs_get_SplashScreen), nullptr, nullptr, nullptr },
        { "configuration", reinterpret_cast<getter>(WebUIPrintTaskSettingsActivatedEventArgs_get_Configuration), nullptr, nullptr, nullptr },
        { "activated_operation", reinterpret_cast<getter>(WebUIPrintTaskSettingsActivatedEventArgs_get_ActivatedOperation), nullptr, nullptr, nullptr },
        { }};

    static PyType_Slot _type_slots_WebUIPrintTaskSettingsActivatedEventArgs[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_WebUIPrintTaskSettingsActivatedEventArgs) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_WebUIPrintTaskSettingsActivatedEventArgs) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_WebUIPrintTaskSettingsActivatedEventArgs) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_WebUIPrintTaskSettingsActivatedEventArgs) },
        { }};

    static PyType_Spec type_spec_WebUIPrintTaskSettingsActivatedEventArgs = {
        "winrt._winrt_windows_ui_webui.WebUIPrintTaskSettingsActivatedEventArgs",
        sizeof(py::wrapper::Windows::UI::WebUI::WebUIPrintTaskSettingsActivatedEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_WebUIPrintTaskSettingsActivatedEventArgs};

    // ----- WebUIPrintWorkflowForegroundTaskActivatedEventArgs class --------------------

    static PyObject* _new_WebUIPrintWorkflowForegroundTaskActivatedEventArgs(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::UI::WebUI::WebUIPrintWorkflowForegroundTaskActivatedEventArgs>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::UI::WebUI::WebUIPrintWorkflowForegroundTaskActivatedEventArgs>::type_name);
        return nullptr;
    }

    static void _dealloc_WebUIPrintWorkflowForegroundTaskActivatedEventArgs(py::wrapper::Windows::UI::WebUI::WebUIPrintWorkflowForegroundTaskActivatedEventArgs* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* WebUIPrintWorkflowForegroundTaskActivatedEventArgs_get_Kind(py::wrapper::Windows::UI::WebUI::WebUIPrintWorkflowForegroundTaskActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.WebUI.WebUIPrintWorkflowForegroundTaskActivatedEventArgs", L"Kind");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Kind();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* WebUIPrintWorkflowForegroundTaskActivatedEventArgs_get_PreviousExecutionState(py::wrapper::Windows::UI::WebUI::WebUIPrintWorkflowForegroundTaskActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.WebUI.WebUIPrintWorkflowForegroundTaskActivatedEventArgs", L"PreviousExecutionState");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.PreviousExecutionState();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* WebUIPrintWorkflowForegroundTaskActivatedEventArgs_get_SplashScreen(py::wrapper::Windows::UI::WebUI::WebUIPrintWorkflowForegroundTaskActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.WebUI.WebUIPrintWorkflowForegroundTaskActivatedEventArgs", L"SplashScreen");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.SplashScreen();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* WebUIPrintWorkflowForegroundTaskActivatedEventArgs_get_ActivatedOperation(py::wrapper::Windows::UI::WebUI::WebUIPrintWorkflowForegroundTaskActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.WebUI.WebUIPrintWorkflowForegroundTaskActivatedEventArgs", L"ActivatedOperation");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.ActivatedOperation();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_WebUIPrintWorkflowForegroundTaskActivatedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::WebUI::WebUIPrintWorkflowForegroundTaskActivatedEventArgs>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_WebUIPrintWorkflowForegroundTaskActivatedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::WebUI::WebUIPrintWorkflowForegroundTaskActivatedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_WebUIPrintWorkflowForegroundTaskActivatedEventArgs[] = {
        { "_assign_array_", _assign_array_WebUIPrintWorkflowForegroundTaskActivatedEventArgs, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_WebUIPrintWorkflowForegroundTaskActivatedEventArgs), METH_O | METH_STATIC, nullptr },
        { }};

    static PyGetSetDef _getset_WebUIPrintWorkflowForegroundTaskActivatedEventArgs[] = {
        { "kind", reinterpret_cast<getter>(WebUIPrintWorkflowForegroundTaskActivatedEventArgs_get_Kind), nullptr, nullptr, nullptr },
        { "previous_execution_state", reinterpret_cast<getter>(WebUIPrintWorkflowForegroundTaskActivatedEventArgs_get_PreviousExecutionState), nullptr, nullptr, nullptr },
        { "splash_screen", reinterpret_cast<getter>(WebUIPrintWorkflowForegroundTaskActivatedEventArgs_get_SplashScreen), nullptr, nullptr, nullptr },
        { "activated_operation", reinterpret_cast<getter>(WebUIPrintWorkflowForegroundTaskActivatedEventArgs_get_ActivatedOperation), nullptr, nullptr, nullptr },
        { }};

    static PyType_Slot _type_slots_WebUIPrintWorkflowForegroundTaskActivatedEventArgs[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_WebUIPrintWorkflowForegroundTaskActivatedEventArgs) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_WebUIPrintWorkflowForegroundTaskActivatedEventArgs) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_WebUIPrintWorkflowForegroundTaskActivatedEventArgs) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_WebUIPrintWorkflowForegroundTaskActivatedEventArgs) },
        { }};

    static PyType_Spec type_spec_WebUIPrintWorkflowForegroundTaskActivatedEventArgs = {
        "winrt._winrt_windows_ui_webui.WebUIPrintWorkflowForegroundTaskActivatedEventArgs",
        sizeof(py::wrapper::Windows::UI::WebUI::WebUIPrintWorkflowForegroundTaskActivatedEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_WebUIPrintWorkflowForegroundTaskActivatedEventArgs};

    // ----- WebUIProtocolActivatedEventArgs class --------------------

    static PyObject* _new_WebUIProtocolActivatedEventArgs(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::UI::WebUI::WebUIProtocolActivatedEventArgs>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::UI::WebUI::WebUIProtocolActivatedEventArgs>::type_name);
        return nullptr;
    }

    static void _dealloc_WebUIProtocolActivatedEventArgs(py::wrapper::Windows::UI::WebUI::WebUIProtocolActivatedEventArgs* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* WebUIProtocolActivatedEventArgs_get_Kind(py::wrapper::Windows::UI::WebUI::WebUIProtocolActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.WebUI.WebUIProtocolActivatedEventArgs", L"Kind");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Kind();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* WebUIProtocolActivatedEventArgs_get_PreviousExecutionState(py::wrapper::Windows::UI::WebUI::WebUIProtocolActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.WebUI.WebUIProtocolActivatedEventArgs", L"PreviousExecutionState");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.PreviousExecutionState();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* WebUIProtocolActivatedEventArgs_get_SplashScreen(py::wrapper::Windows::UI::WebUI::WebUIProtocolActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.WebUI.WebUIProtocolActivatedEventArgs", L"SplashScreen");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.SplashScreen();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* WebUIProtocolActivatedEventArgs_get_User(py::wrapper::Windows::UI::WebUI::WebUIProtocolActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.WebUI.WebUIProtocolActivatedEventArgs", L"User");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.User();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* WebUIProtocolActivatedEventArgs_get_CurrentlyShownApplicationViewId(py::wrapper::Windows::UI::WebUI::WebUIProtocolActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.WebUI.WebUIProtocolActivatedEventArgs", L"CurrentlyShownApplicationViewId");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.CurrentlyShownApplicationViewId();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* WebUIProtocolActivatedEventArgs_get_Uri(py::wrapper::Windows::UI::WebUI::WebUIProtocolActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.WebUI.WebUIProtocolActivatedEventArgs", L"Uri");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Uri();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* WebUIProtocolActivatedEventArgs_get_CallerPackageFamilyName(py::wrapper::Windows::UI::WebUI::WebUIProtocolActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.WebUI.WebUIProtocolActivatedEventArgs", L"CallerPackageFamilyName");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.CallerPackageFamilyName();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* WebUIProtocolActivatedEventArgs_get_Data(py::wrapper::Windows::UI::WebUI::WebUIProtocolActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.WebUI.WebUIProtocolActivatedEventArgs", L"Data");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Data();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* WebUIProtocolActivatedEventArgs_get_ActivatedOperation(py::wrapper::Windows::UI::WebUI::WebUIProtocolActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.WebUI.WebUIProtocolActivatedEventArgs", L"ActivatedOperation");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.ActivatedOperation();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_WebUIProtocolActivatedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::WebUI::WebUIProtocolActivatedEventArgs>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_WebUIProtocolActivatedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::WebUI::WebUIProtocolActivatedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_WebUIProtocolActivatedEventArgs[] = {
        { "_assign_array_", _assign_array_WebUIProtocolActivatedEventArgs, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_WebUIProtocolActivatedEventArgs), METH_O | METH_STATIC, nullptr },
        { }};

    static PyGetSetDef _getset_WebUIProtocolActivatedEventArgs[] = {
        { "kind", reinterpret_cast<getter>(WebUIProtocolActivatedEventArgs_get_Kind), nullptr, nullptr, nullptr },
        { "previous_execution_state", reinterpret_cast<getter>(WebUIProtocolActivatedEventArgs_get_PreviousExecutionState), nullptr, nullptr, nullptr },
        { "splash_screen", reinterpret_cast<getter>(WebUIProtocolActivatedEventArgs_get_SplashScreen), nullptr, nullptr, nullptr },
        { "user", reinterpret_cast<getter>(WebUIProtocolActivatedEventArgs_get_User), nullptr, nullptr, nullptr },
        { "currently_shown_application_view_id", reinterpret_cast<getter>(WebUIProtocolActivatedEventArgs_get_CurrentlyShownApplicationViewId), nullptr, nullptr, nullptr },
        { "uri", reinterpret_cast<getter>(WebUIProtocolActivatedEventArgs_get_Uri), nullptr, nullptr, nullptr },
        { "caller_package_family_name", reinterpret_cast<getter>(WebUIProtocolActivatedEventArgs_get_CallerPackageFamilyName), nullptr, nullptr, nullptr },
        { "data", reinterpret_cast<getter>(WebUIProtocolActivatedEventArgs_get_Data), nullptr, nullptr, nullptr },
        { "activated_operation", reinterpret_cast<getter>(WebUIProtocolActivatedEventArgs_get_ActivatedOperation), nullptr, nullptr, nullptr },
        { }};

    static PyType_Slot _type_slots_WebUIProtocolActivatedEventArgs[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_WebUIProtocolActivatedEventArgs) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_WebUIProtocolActivatedEventArgs) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_WebUIProtocolActivatedEventArgs) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_WebUIProtocolActivatedEventArgs) },
        { }};

    static PyType_Spec type_spec_WebUIProtocolActivatedEventArgs = {
        "winrt._winrt_windows_ui_webui.WebUIProtocolActivatedEventArgs",
        sizeof(py::wrapper::Windows::UI::WebUI::WebUIProtocolActivatedEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_WebUIProtocolActivatedEventArgs};

    // ----- WebUIProtocolForResultsActivatedEventArgs class --------------------

    static PyObject* _new_WebUIProtocolForResultsActivatedEventArgs(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::UI::WebUI::WebUIProtocolForResultsActivatedEventArgs>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::UI::WebUI::WebUIProtocolForResultsActivatedEventArgs>::type_name);
        return nullptr;
    }

    static void _dealloc_WebUIProtocolForResultsActivatedEventArgs(py::wrapper::Windows::UI::WebUI::WebUIProtocolForResultsActivatedEventArgs* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* WebUIProtocolForResultsActivatedEventArgs_get_Kind(py::wrapper::Windows::UI::WebUI::WebUIProtocolForResultsActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.WebUI.WebUIProtocolForResultsActivatedEventArgs", L"Kind");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Kind();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* WebUIProtocolForResultsActivatedEventArgs_get_PreviousExecutionState(py::wrapper::Windows::UI::WebUI::WebUIProtocolForResultsActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.WebUI.WebUIProtocolForResultsActivatedEventArgs", L"PreviousExecutionState");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.PreviousExecutionState();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* WebUIProtocolForResultsActivatedEventArgs_get_SplashScreen(py::wrapper::Windows::UI::WebUI::WebUIProtocolForResultsActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.WebUI.WebUIProtocolForResultsActivatedEventArgs", L"SplashScreen");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.SplashScreen();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* WebUIProtocolForResultsActivatedEventArgs_get_User(py::wrapper::Windows::UI::WebUI::WebUIProtocolForResultsActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.WebUI.WebUIProtocolForResultsActivatedEventArgs", L"User");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.User();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* WebUIProtocolForResultsActivatedEventArgs_get_CurrentlyShownApplicationViewId(py::wrapper::Windows::UI::WebUI::WebUIProtocolForResultsActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.WebUI.WebUIProtocolForResultsActivatedEventArgs", L"CurrentlyShownApplicationViewId");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.CurrentlyShownApplicationViewId();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* WebUIProtocolForResultsActivatedEventArgs_get_Uri(py::wrapper::Windows::UI::WebUI::WebUIProtocolForResultsActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.WebUI.WebUIProtocolForResultsActivatedEventArgs", L"Uri");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Uri();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* WebUIProtocolForResultsActivatedEventArgs_get_CallerPackageFamilyName(py::wrapper::Windows::UI::WebUI::WebUIProtocolForResultsActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.WebUI.WebUIProtocolForResultsActivatedEventArgs", L"CallerPackageFamilyName");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.CallerPackageFamilyName();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* WebUIProtocolForResultsActivatedEventArgs_get_Data(py::wrapper::Windows::UI::WebUI::WebUIProtocolForResultsActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.WebUI.WebUIProtocolForResultsActivatedEventArgs", L"Data");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Data();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* WebUIProtocolForResultsActivatedEventArgs_get_ProtocolForResultsOperation(py::wrapper::Windows::UI::WebUI::WebUIProtocolForResultsActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.WebUI.WebUIProtocolForResultsActivatedEventArgs", L"ProtocolForResultsOperation");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.ProtocolForResultsOperation();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* WebUIProtocolForResultsActivatedEventArgs_get_ActivatedOperation(py::wrapper::Windows::UI::WebUI::WebUIProtocolForResultsActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.WebUI.WebUIProtocolForResultsActivatedEventArgs", L"ActivatedOperation");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.ActivatedOperation();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_WebUIProtocolForResultsActivatedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::WebUI::WebUIProtocolForResultsActivatedEventArgs>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_WebUIProtocolForResultsActivatedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::WebUI::WebUIProtocolForResultsActivatedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_WebUIProtocolForResultsActivatedEventArgs[] = {
        { "_assign_array_", _assign_array_WebUIProtocolForResultsActivatedEventArgs, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_WebUIProtocolForResultsActivatedEventArgs), METH_O | METH_STATIC, nullptr },
        { }};

    static PyGetSetDef _getset_WebUIProtocolForResultsActivatedEventArgs[] = {
        { "kind", reinterpret_cast<getter>(WebUIProtocolForResultsActivatedEventArgs_get_Kind), nullptr, nullptr, nullptr },
        { "previous_execution_state", reinterpret_cast<getter>(WebUIProtocolForResultsActivatedEventArgs_get_PreviousExecutionState), nullptr, nullptr, nullptr },
        { "splash_screen", reinterpret_cast<getter>(WebUIProtocolForResultsActivatedEventArgs_get_SplashScreen), nullptr, nullptr, nullptr },
        { "user", reinterpret_cast<getter>(WebUIProtocolForResultsActivatedEventArgs_get_User), nullptr, nullptr, nullptr },
        { "currently_shown_application_view_id", reinterpret_cast<getter>(WebUIProtocolForResultsActivatedEventArgs_get_CurrentlyShownApplicationViewId), nullptr, nullptr, nullptr },
        { "uri", reinterpret_cast<getter>(WebUIProtocolForResultsActivatedEventArgs_get_Uri), nullptr, nullptr, nullptr },
        { "caller_package_family_name", reinterpret_cast<getter>(WebUIProtocolForResultsActivatedEventArgs_get_CallerPackageFamilyName), nullptr, nullptr, nullptr },
        { "data", reinterpret_cast<getter>(WebUIProtocolForResultsActivatedEventArgs_get_Data), nullptr, nullptr, nullptr },
        { "protocol_for_results_operation", reinterpret_cast<getter>(WebUIProtocolForResultsActivatedEventArgs_get_ProtocolForResultsOperation), nullptr, nullptr, nullptr },
        { "activated_operation", reinterpret_cast<getter>(WebUIProtocolForResultsActivatedEventArgs_get_ActivatedOperation), nullptr, nullptr, nullptr },
        { }};

    static PyType_Slot _type_slots_WebUIProtocolForResultsActivatedEventArgs[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_WebUIProtocolForResultsActivatedEventArgs) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_WebUIProtocolForResultsActivatedEventArgs) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_WebUIProtocolForResultsActivatedEventArgs) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_WebUIProtocolForResultsActivatedEventArgs) },
        { }};

    static PyType_Spec type_spec_WebUIProtocolForResultsActivatedEventArgs = {
        "winrt._winrt_windows_ui_webui.WebUIProtocolForResultsActivatedEventArgs",
        sizeof(py::wrapper::Windows::UI::WebUI::WebUIProtocolForResultsActivatedEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_WebUIProtocolForResultsActivatedEventArgs};

    // ----- WebUIRestrictedLaunchActivatedEventArgs class --------------------

    static PyObject* _new_WebUIRestrictedLaunchActivatedEventArgs(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::UI::WebUI::WebUIRestrictedLaunchActivatedEventArgs>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::UI::WebUI::WebUIRestrictedLaunchActivatedEventArgs>::type_name);
        return nullptr;
    }

    static void _dealloc_WebUIRestrictedLaunchActivatedEventArgs(py::wrapper::Windows::UI::WebUI::WebUIRestrictedLaunchActivatedEventArgs* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* WebUIRestrictedLaunchActivatedEventArgs_get_Kind(py::wrapper::Windows::UI::WebUI::WebUIRestrictedLaunchActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.WebUI.WebUIRestrictedLaunchActivatedEventArgs", L"Kind");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Kind();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* WebUIRestrictedLaunchActivatedEventArgs_get_PreviousExecutionState(py::wrapper::Windows::UI::WebUI::WebUIRestrictedLaunchActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.WebUI.WebUIRestrictedLaunchActivatedEventArgs", L"PreviousExecutionState");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.PreviousExecutionState();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* WebUIRestrictedLaunchActivatedEventArgs_get_SplashScreen(py::wrapper::Windows::UI::WebUI::WebUIRestrictedLaunchActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.WebUI.WebUIRestrictedLaunchActivatedEventArgs", L"SplashScreen");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.SplashScreen();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* WebUIRestrictedLaunchActivatedEventArgs_get_User(py::wrapper::Windows::UI::WebUI::WebUIRestrictedLaunchActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.WebUI.WebUIRestrictedLaunchActivatedEventArgs", L"User");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.User();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* WebUIRestrictedLaunchActivatedEventArgs_get_SharedContext(py::wrapper::Windows::UI::WebUI::WebUIRestrictedLaunchActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.WebUI.WebUIRestrictedLaunchActivatedEventArgs", L"SharedContext");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.SharedContext();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* WebUIRestrictedLaunchActivatedEventArgs_get_ActivatedOperation(py::wrapper::Windows::UI::WebUI::WebUIRestrictedLaunchActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.WebUI.WebUIRestrictedLaunchActivatedEventArgs", L"ActivatedOperation");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.ActivatedOperation();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_WebUIRestrictedLaunchActivatedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::WebUI::WebUIRestrictedLaunchActivatedEventArgs>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_WebUIRestrictedLaunchActivatedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::WebUI::WebUIRestrictedLaunchActivatedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_WebUIRestrictedLaunchActivatedEventArgs[] = {
        { "_assign_array_", _assign_array_WebUIRestrictedLaunchActivatedEventArgs, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_WebUIRestrictedLaunchActivatedEventArgs), METH_O | METH_STATIC, nullptr },
        { }};

    static PyGetSetDef _getset_WebUIRestrictedLaunchActivatedEventArgs[] = {
        { "kind", reinterpret_cast<getter>(WebUIRestrictedLaunchActivatedEventArgs_get_Kind), nullptr, nullptr, nullptr },
        { "previous_execution_state", reinterpret_cast<getter>(WebUIRestrictedLaunchActivatedEventArgs_get_PreviousExecutionState), nullptr, nullptr, nullptr },
        { "splash_screen", reinterpret_cast<getter>(WebUIRestrictedLaunchActivatedEventArgs_get_SplashScreen), nullptr, nullptr, nullptr },
        { "user", reinterpret_cast<getter>(WebUIRestrictedLaunchActivatedEventArgs_get_User), nullptr, nullptr, nullptr },
        { "shared_context", reinterpret_cast<getter>(WebUIRestrictedLaunchActivatedEventArgs_get_SharedContext), nullptr, nullptr, nullptr },
        { "activated_operation", reinterpret_cast<getter>(WebUIRestrictedLaunchActivatedEventArgs_get_ActivatedOperation), nullptr, nullptr, nullptr },
        { }};

    static PyType_Slot _type_slots_WebUIRestrictedLaunchActivatedEventArgs[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_WebUIRestrictedLaunchActivatedEventArgs) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_WebUIRestrictedLaunchActivatedEventArgs) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_WebUIRestrictedLaunchActivatedEventArgs) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_WebUIRestrictedLaunchActivatedEventArgs) },
        { }};

    static PyType_Spec type_spec_WebUIRestrictedLaunchActivatedEventArgs = {
        "winrt._winrt_windows_ui_webui.WebUIRestrictedLaunchActivatedEventArgs",
        sizeof(py::wrapper::Windows::UI::WebUI::WebUIRestrictedLaunchActivatedEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_WebUIRestrictedLaunchActivatedEventArgs};

    // ----- WebUISearchActivatedEventArgs class --------------------

    static PyObject* _new_WebUISearchActivatedEventArgs(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::UI::WebUI::WebUISearchActivatedEventArgs>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::UI::WebUI::WebUISearchActivatedEventArgs>::type_name);
        return nullptr;
    }

    static void _dealloc_WebUISearchActivatedEventArgs(py::wrapper::Windows::UI::WebUI::WebUISearchActivatedEventArgs* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* WebUISearchActivatedEventArgs_get_Kind(py::wrapper::Windows::UI::WebUI::WebUISearchActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.WebUI.WebUISearchActivatedEventArgs", L"Kind");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Kind();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* WebUISearchActivatedEventArgs_get_PreviousExecutionState(py::wrapper::Windows::UI::WebUI::WebUISearchActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.WebUI.WebUISearchActivatedEventArgs", L"PreviousExecutionState");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.PreviousExecutionState();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* WebUISearchActivatedEventArgs_get_SplashScreen(py::wrapper::Windows::UI::WebUI::WebUISearchActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.WebUI.WebUISearchActivatedEventArgs", L"SplashScreen");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.SplashScreen();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* WebUISearchActivatedEventArgs_get_CurrentlyShownApplicationViewId(py::wrapper::Windows::UI::WebUI::WebUISearchActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.WebUI.WebUISearchActivatedEventArgs", L"CurrentlyShownApplicationViewId");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.CurrentlyShownApplicationViewId();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* WebUISearchActivatedEventArgs_get_Language(py::wrapper::Windows::UI::WebUI::WebUISearchActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.WebUI.WebUISearchActivatedEventArgs", L"Language");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Language();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* WebUISearchActivatedEventArgs_get_QueryText(py::wrapper::Windows::UI::WebUI::WebUISearchActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.WebUI.WebUISearchActivatedEventArgs", L"QueryText");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.QueryText();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* WebUISearchActivatedEventArgs_get_LinguisticDetails(py::wrapper::Windows::UI::WebUI::WebUISearchActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.WebUI.WebUISearchActivatedEventArgs", L"LinguisticDetails");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.LinguisticDetails();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* WebUISearchActivatedEventArgs_get_ActivatedOperation(py::wrapper::Windows::UI::WebUI::WebUISearchActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.WebUI.WebUISearchActivatedEventArgs", L"ActivatedOperation");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.ActivatedOperation();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_WebUISearchActivatedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::WebUI::WebUISearchActivatedEventArgs>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_WebUISearchActivatedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::WebUI::WebUISearchActivatedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_WebUISearchActivatedEventArgs[] = {
        { "_assign_array_", _assign_array_WebUISearchActivatedEventArgs, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_WebUISearchActivatedEventArgs), METH_O | METH_STATIC, nullptr },
        { }};

    static PyGetSetDef _getset_WebUISearchActivatedEventArgs[] = {
        { "kind", reinterpret_cast<getter>(WebUISearchActivatedEventArgs_get_Kind), nullptr, nullptr, nullptr },
        { "previous_execution_state", reinterpret_cast<getter>(WebUISearchActivatedEventArgs_get_PreviousExecutionState), nullptr, nullptr, nullptr },
        { "splash_screen", reinterpret_cast<getter>(WebUISearchActivatedEventArgs_get_SplashScreen), nullptr, nullptr, nullptr },
        { "currently_shown_application_view_id", reinterpret_cast<getter>(WebUISearchActivatedEventArgs_get_CurrentlyShownApplicationViewId), nullptr, nullptr, nullptr },
        { "language", reinterpret_cast<getter>(WebUISearchActivatedEventArgs_get_Language), nullptr, nullptr, nullptr },
        { "query_text", reinterpret_cast<getter>(WebUISearchActivatedEventArgs_get_QueryText), nullptr, nullptr, nullptr },
        { "linguistic_details", reinterpret_cast<getter>(WebUISearchActivatedEventArgs_get_LinguisticDetails), nullptr, nullptr, nullptr },
        { "activated_operation", reinterpret_cast<getter>(WebUISearchActivatedEventArgs_get_ActivatedOperation), nullptr, nullptr, nullptr },
        { }};

    static PyType_Slot _type_slots_WebUISearchActivatedEventArgs[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_WebUISearchActivatedEventArgs) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_WebUISearchActivatedEventArgs) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_WebUISearchActivatedEventArgs) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_WebUISearchActivatedEventArgs) },
        { }};

    static PyType_Spec type_spec_WebUISearchActivatedEventArgs = {
        "winrt._winrt_windows_ui_webui.WebUISearchActivatedEventArgs",
        sizeof(py::wrapper::Windows::UI::WebUI::WebUISearchActivatedEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_WebUISearchActivatedEventArgs};

    // ----- WebUIShareTargetActivatedEventArgs class --------------------

    static PyObject* _new_WebUIShareTargetActivatedEventArgs(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::UI::WebUI::WebUIShareTargetActivatedEventArgs>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::UI::WebUI::WebUIShareTargetActivatedEventArgs>::type_name);
        return nullptr;
    }

    static void _dealloc_WebUIShareTargetActivatedEventArgs(py::wrapper::Windows::UI::WebUI::WebUIShareTargetActivatedEventArgs* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* WebUIShareTargetActivatedEventArgs_get_Kind(py::wrapper::Windows::UI::WebUI::WebUIShareTargetActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.WebUI.WebUIShareTargetActivatedEventArgs", L"Kind");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Kind();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* WebUIShareTargetActivatedEventArgs_get_PreviousExecutionState(py::wrapper::Windows::UI::WebUI::WebUIShareTargetActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.WebUI.WebUIShareTargetActivatedEventArgs", L"PreviousExecutionState");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.PreviousExecutionState();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* WebUIShareTargetActivatedEventArgs_get_SplashScreen(py::wrapper::Windows::UI::WebUI::WebUIShareTargetActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.WebUI.WebUIShareTargetActivatedEventArgs", L"SplashScreen");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.SplashScreen();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* WebUIShareTargetActivatedEventArgs_get_User(py::wrapper::Windows::UI::WebUI::WebUIShareTargetActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.WebUI.WebUIShareTargetActivatedEventArgs", L"User");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.User();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* WebUIShareTargetActivatedEventArgs_get_ShareOperation(py::wrapper::Windows::UI::WebUI::WebUIShareTargetActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.WebUI.WebUIShareTargetActivatedEventArgs", L"ShareOperation");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.ShareOperation();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* WebUIShareTargetActivatedEventArgs_get_ActivatedOperation(py::wrapper::Windows::UI::WebUI::WebUIShareTargetActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.WebUI.WebUIShareTargetActivatedEventArgs", L"ActivatedOperation");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.ActivatedOperation();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_WebUIShareTargetActivatedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::WebUI::WebUIShareTargetActivatedEventArgs>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_WebUIShareTargetActivatedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::WebUI::WebUIShareTargetActivatedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_WebUIShareTargetActivatedEventArgs[] = {
        { "_assign_array_", _assign_array_WebUIShareTargetActivatedEventArgs, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_WebUIShareTargetActivatedEventArgs), METH_O | METH_STATIC, nullptr },
        { }};

    static PyGetSetDef _getset_WebUIShareTargetActivatedEventArgs[] = {
        { "kind", reinterpret_cast<getter>(WebUIShareTargetActivatedEventArgs_get_Kind), nullptr, nullptr, nullptr },
        { "previous_execution_state", reinterpret_cast<getter>(WebUIShareTargetActivatedEventArgs_get_PreviousExecutionState), nullptr, nullptr, nullptr },
        { "splash_screen", reinterpret_cast<getter>(WebUIShareTargetActivatedEventArgs_get_SplashScreen), nullptr, nullptr, nullptr },
        { "user", reinterpret_cast<getter>(WebUIShareTargetActivatedEventArgs_get_User), nullptr, nullptr, nullptr },
        { "share_operation", reinterpret_cast<getter>(WebUIShareTargetActivatedEventArgs_get_ShareOperation), nullptr, nullptr, nullptr },
        { "activated_operation", reinterpret_cast<getter>(WebUIShareTargetActivatedEventArgs_get_ActivatedOperation), nullptr, nullptr, nullptr },
        { }};

    static PyType_Slot _type_slots_WebUIShareTargetActivatedEventArgs[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_WebUIShareTargetActivatedEventArgs) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_WebUIShareTargetActivatedEventArgs) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_WebUIShareTargetActivatedEventArgs) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_WebUIShareTargetActivatedEventArgs) },
        { }};

    static PyType_Spec type_spec_WebUIShareTargetActivatedEventArgs = {
        "winrt._winrt_windows_ui_webui.WebUIShareTargetActivatedEventArgs",
        sizeof(py::wrapper::Windows::UI::WebUI::WebUIShareTargetActivatedEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_WebUIShareTargetActivatedEventArgs};

    // ----- WebUIStartupTaskActivatedEventArgs class --------------------

    static PyObject* _new_WebUIStartupTaskActivatedEventArgs(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::UI::WebUI::WebUIStartupTaskActivatedEventArgs>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::UI::WebUI::WebUIStartupTaskActivatedEventArgs>::type_name);
        return nullptr;
    }

    static void _dealloc_WebUIStartupTaskActivatedEventArgs(py::wrapper::Windows::UI::WebUI::WebUIStartupTaskActivatedEventArgs* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* WebUIStartupTaskActivatedEventArgs_get_Kind(py::wrapper::Windows::UI::WebUI::WebUIStartupTaskActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.WebUI.WebUIStartupTaskActivatedEventArgs", L"Kind");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Kind();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* WebUIStartupTaskActivatedEventArgs_get_PreviousExecutionState(py::wrapper::Windows::UI::WebUI::WebUIStartupTaskActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.WebUI.WebUIStartupTaskActivatedEventArgs", L"PreviousExecutionState");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.PreviousExecutionState();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* WebUIStartupTaskActivatedEventArgs_get_SplashScreen(py::wrapper::Windows::UI::WebUI::WebUIStartupTaskActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.WebUI.WebUIStartupTaskActivatedEventArgs", L"SplashScreen");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.SplashScreen();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* WebUIStartupTaskActivatedEventArgs_get_User(py::wrapper::Windows::UI::WebUI::WebUIStartupTaskActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.WebUI.WebUIStartupTaskActivatedEventArgs", L"User");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.User();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* WebUIStartupTaskActivatedEventArgs_get_TaskId(py::wrapper::Windows::UI::WebUI::WebUIStartupTaskActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.WebUI.WebUIStartupTaskActivatedEventArgs", L"TaskId");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.TaskId();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* WebUIStartupTaskActivatedEventArgs_get_ActivatedOperation(py::wrapper::Windows::UI::WebUI::WebUIStartupTaskActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.WebUI.WebUIStartupTaskActivatedEventArgs", L"ActivatedOperation");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.ActivatedOperation();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_WebUIStartupTaskActivatedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::WebUI::WebUIStartupTaskActivatedEventArgs>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_WebUIStartupTaskActivatedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::WebUI::WebUIStartupTaskActivatedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_WebUIStartupTaskActivatedEventArgs[] = {
        { "_assign_array_", _assign_array_WebUIStartupTaskActivatedEventArgs, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_WebUIStartupTaskActivatedEventArgs), METH_O | METH_STATIC, nullptr },
        { }};

    static PyGetSetDef _getset_WebUIStartupTaskActivatedEventArgs[] = {
        { "kind", reinterpret_cast<getter>(WebUIStartupTaskActivatedEventArgs_get_Kind), nullptr, nullptr, nullptr },
        { "previous_execution_state", reinterpret_cast<getter>(WebUIStartupTaskActivatedEventArgs_get_PreviousExecutionState), nullptr, nullptr, nullptr },
        { "splash_screen", reinterpret_cast<getter>(WebUIStartupTaskActivatedEventArgs_get_SplashScreen), nullptr, nullptr, nullptr },
        { "user", reinterpret_cast<getter>(WebUIStartupTaskActivatedEventArgs_get_User), nullptr, nullptr, nullptr },
        { "task_id", reinterpret_cast<getter>(WebUIStartupTaskActivatedEventArgs_get_TaskId), nullptr, nullptr, nullptr },
        { "activated_operation", reinterpret_cast<getter>(WebUIStartupTaskActivatedEventArgs_get_ActivatedOperation), nullptr, nullptr, nullptr },
        { }};

    static PyType_Slot _type_slots_WebUIStartupTaskActivatedEventArgs[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_WebUIStartupTaskActivatedEventArgs) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_WebUIStartupTaskActivatedEventArgs) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_WebUIStartupTaskActivatedEventArgs) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_WebUIStartupTaskActivatedEventArgs) },
        { }};

    static PyType_Spec type_spec_WebUIStartupTaskActivatedEventArgs = {
        "winrt._winrt_windows_ui_webui.WebUIStartupTaskActivatedEventArgs",
        sizeof(py::wrapper::Windows::UI::WebUI::WebUIStartupTaskActivatedEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_WebUIStartupTaskActivatedEventArgs};

    // ----- WebUIToastNotificationActivatedEventArgs class --------------------

    static PyObject* _new_WebUIToastNotificationActivatedEventArgs(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::UI::WebUI::WebUIToastNotificationActivatedEventArgs>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::UI::WebUI::WebUIToastNotificationActivatedEventArgs>::type_name);
        return nullptr;
    }

    static void _dealloc_WebUIToastNotificationActivatedEventArgs(py::wrapper::Windows::UI::WebUI::WebUIToastNotificationActivatedEventArgs* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* WebUIToastNotificationActivatedEventArgs_get_Kind(py::wrapper::Windows::UI::WebUI::WebUIToastNotificationActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.WebUI.WebUIToastNotificationActivatedEventArgs", L"Kind");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Kind();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* WebUIToastNotificationActivatedEventArgs_get_PreviousExecutionState(py::wrapper::Windows::UI::WebUI::WebUIToastNotificationActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.WebUI.WebUIToastNotificationActivatedEventArgs", L"PreviousExecutionState");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.PreviousExecutionState();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* WebUIToastNotificationActivatedEventArgs_get_SplashScreen(py::wrapper::Windows::UI::WebUI::WebUIToastNotificationActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.WebUI.WebUIToastNotificationActivatedEventArgs", L"SplashScreen");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.SplashScreen();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* WebUIToastNotificationActivatedEventArgs_get_User(py::wrapper::Windows::UI::WebUI::WebUIToastNotificationActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.WebUI.WebUIToastNotificationActivatedEventArgs", L"User");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.User();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* WebUIToastNotificationActivatedEventArgs_get_Argument(py::wrapper::Windows::UI::WebUI::WebUIToastNotificationActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.WebUI.WebUIToastNotificationActivatedEventArgs", L"Argument");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Argument();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* WebUIToastNotificationActivatedEventArgs_get_UserInput(py::wrapper::Windows::UI::WebUI::WebUIToastNotificationActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.WebUI.WebUIToastNotificationActivatedEventArgs", L"UserInput");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.UserInput();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* WebUIToastNotificationActivatedEventArgs_get_ActivatedOperation(py::wrapper::Windows::UI::WebUI::WebUIToastNotificationActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.WebUI.WebUIToastNotificationActivatedEventArgs", L"ActivatedOperation");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.ActivatedOperation();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_WebUIToastNotificationActivatedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::WebUI::WebUIToastNotificationActivatedEventArgs>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_WebUIToastNotificationActivatedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::WebUI::WebUIToastNotificationActivatedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_WebUIToastNotificationActivatedEventArgs[] = {
        { "_assign_array_", _assign_array_WebUIToastNotificationActivatedEventArgs, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_WebUIToastNotificationActivatedEventArgs), METH_O | METH_STATIC, nullptr },
        { }};

    static PyGetSetDef _getset_WebUIToastNotificationActivatedEventArgs[] = {
        { "kind", reinterpret_cast<getter>(WebUIToastNotificationActivatedEventArgs_get_Kind), nullptr, nullptr, nullptr },
        { "previous_execution_state", reinterpret_cast<getter>(WebUIToastNotificationActivatedEventArgs_get_PreviousExecutionState), nullptr, nullptr, nullptr },
        { "splash_screen", reinterpret_cast<getter>(WebUIToastNotificationActivatedEventArgs_get_SplashScreen), nullptr, nullptr, nullptr },
        { "user", reinterpret_cast<getter>(WebUIToastNotificationActivatedEventArgs_get_User), nullptr, nullptr, nullptr },
        { "argument", reinterpret_cast<getter>(WebUIToastNotificationActivatedEventArgs_get_Argument), nullptr, nullptr, nullptr },
        { "user_input", reinterpret_cast<getter>(WebUIToastNotificationActivatedEventArgs_get_UserInput), nullptr, nullptr, nullptr },
        { "activated_operation", reinterpret_cast<getter>(WebUIToastNotificationActivatedEventArgs_get_ActivatedOperation), nullptr, nullptr, nullptr },
        { }};

    static PyType_Slot _type_slots_WebUIToastNotificationActivatedEventArgs[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_WebUIToastNotificationActivatedEventArgs) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_WebUIToastNotificationActivatedEventArgs) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_WebUIToastNotificationActivatedEventArgs) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_WebUIToastNotificationActivatedEventArgs) },
        { }};

    static PyType_Spec type_spec_WebUIToastNotificationActivatedEventArgs = {
        "winrt._winrt_windows_ui_webui.WebUIToastNotificationActivatedEventArgs",
        sizeof(py::wrapper::Windows::UI::WebUI::WebUIToastNotificationActivatedEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_WebUIToastNotificationActivatedEventArgs};

    // ----- WebUIUserDataAccountProviderActivatedEventArgs class --------------------

    static PyObject* _new_WebUIUserDataAccountProviderActivatedEventArgs(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::UI::WebUI::WebUIUserDataAccountProviderActivatedEventArgs>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::UI::WebUI::WebUIUserDataAccountProviderActivatedEventArgs>::type_name);
        return nullptr;
    }

    static void _dealloc_WebUIUserDataAccountProviderActivatedEventArgs(py::wrapper::Windows::UI::WebUI::WebUIUserDataAccountProviderActivatedEventArgs* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* WebUIUserDataAccountProviderActivatedEventArgs_get_Kind(py::wrapper::Windows::UI::WebUI::WebUIUserDataAccountProviderActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.WebUI.WebUIUserDataAccountProviderActivatedEventArgs", L"Kind");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Kind();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* WebUIUserDataAccountProviderActivatedEventArgs_get_PreviousExecutionState(py::wrapper::Windows::UI::WebUI::WebUIUserDataAccountProviderActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.WebUI.WebUIUserDataAccountProviderActivatedEventArgs", L"PreviousExecutionState");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.PreviousExecutionState();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* WebUIUserDataAccountProviderActivatedEventArgs_get_SplashScreen(py::wrapper::Windows::UI::WebUI::WebUIUserDataAccountProviderActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.WebUI.WebUIUserDataAccountProviderActivatedEventArgs", L"SplashScreen");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.SplashScreen();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* WebUIUserDataAccountProviderActivatedEventArgs_get_Operation(py::wrapper::Windows::UI::WebUI::WebUIUserDataAccountProviderActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.WebUI.WebUIUserDataAccountProviderActivatedEventArgs", L"Operation");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Operation();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* WebUIUserDataAccountProviderActivatedEventArgs_get_ActivatedOperation(py::wrapper::Windows::UI::WebUI::WebUIUserDataAccountProviderActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.WebUI.WebUIUserDataAccountProviderActivatedEventArgs", L"ActivatedOperation");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.ActivatedOperation();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_WebUIUserDataAccountProviderActivatedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::WebUI::WebUIUserDataAccountProviderActivatedEventArgs>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_WebUIUserDataAccountProviderActivatedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::WebUI::WebUIUserDataAccountProviderActivatedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_WebUIUserDataAccountProviderActivatedEventArgs[] = {
        { "_assign_array_", _assign_array_WebUIUserDataAccountProviderActivatedEventArgs, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_WebUIUserDataAccountProviderActivatedEventArgs), METH_O | METH_STATIC, nullptr },
        { }};

    static PyGetSetDef _getset_WebUIUserDataAccountProviderActivatedEventArgs[] = {
        { "kind", reinterpret_cast<getter>(WebUIUserDataAccountProviderActivatedEventArgs_get_Kind), nullptr, nullptr, nullptr },
        { "previous_execution_state", reinterpret_cast<getter>(WebUIUserDataAccountProviderActivatedEventArgs_get_PreviousExecutionState), nullptr, nullptr, nullptr },
        { "splash_screen", reinterpret_cast<getter>(WebUIUserDataAccountProviderActivatedEventArgs_get_SplashScreen), nullptr, nullptr, nullptr },
        { "operation", reinterpret_cast<getter>(WebUIUserDataAccountProviderActivatedEventArgs_get_Operation), nullptr, nullptr, nullptr },
        { "activated_operation", reinterpret_cast<getter>(WebUIUserDataAccountProviderActivatedEventArgs_get_ActivatedOperation), nullptr, nullptr, nullptr },
        { }};

    static PyType_Slot _type_slots_WebUIUserDataAccountProviderActivatedEventArgs[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_WebUIUserDataAccountProviderActivatedEventArgs) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_WebUIUserDataAccountProviderActivatedEventArgs) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_WebUIUserDataAccountProviderActivatedEventArgs) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_WebUIUserDataAccountProviderActivatedEventArgs) },
        { }};

    static PyType_Spec type_spec_WebUIUserDataAccountProviderActivatedEventArgs = {
        "winrt._winrt_windows_ui_webui.WebUIUserDataAccountProviderActivatedEventArgs",
        sizeof(py::wrapper::Windows::UI::WebUI::WebUIUserDataAccountProviderActivatedEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_WebUIUserDataAccountProviderActivatedEventArgs};

    // ----- WebUIView class --------------------

    static PyObject* _new_WebUIView(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::UI::WebUI::WebUIView>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::UI::WebUI::WebUIView>::type_name);
        return nullptr;
    }

    static void _dealloc_WebUIView(py::wrapper::Windows::UI::WebUI::WebUIView* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* WebUIView_AddInitializeScript(py::wrapper::Windows::UI::WebUI::WebUIView* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.WebUI.WebUIView", L"AddInitializeScript", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                {
                    auto _gil = release_gil();
                    self->obj.AddInitializeScript(param0);
                }

                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* WebUIView_BuildLocalStreamUri(py::wrapper::Windows::UI::WebUI::WebUIView* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.WebUI.WebUIView", L"BuildLocalStreamUri", 2);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(2);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::hstring>(args, 1);

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return self->obj.BuildLocalStreamUri(param0, param1);
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* WebUIView_CapturePreviewToStreamAsync(py::wrapper::Windows::UI::WebUI::WebUIView* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.WebUI.WebUIView", L"CapturePreviewToStreamAsync", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Storage::Streams::IRandomAccessStream>(args, 0);

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return self->obj.CapturePreviewToStreamAsync(param0);
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* WebUIView_CaptureSelectedContentToDataPackageAsync(py::wrapper::Windows::UI::WebUI::WebUIView* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.WebUI.WebUIView", L"CaptureSelectedContentToDataPackageAsync", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return self->obj.CaptureSelectedContentToDataPackageAsync();
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* WebUIView_CreateAsync(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.WebUI.WebUIView", L"CreateAsync", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return winrt::Windows::UI::WebUI::WebUIView::CreateAsync();
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* WebUIView_CreateWithUriAsync(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.WebUI.WebUIView", L"CreateAsync", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Foundation::Uri>(args, 0);

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return winrt::Windows::UI::WebUI::WebUIView::CreateAsync(param0);
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* WebUIView_GetDeferredPermissionRequestById(py::wrapper::Windows::UI::WebUI::WebUIView* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.WebUI.WebUIView", L"GetDeferredPermissionRequestById", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<uint32_t>(args, 0);
                winrt::Windows::Web::UI::WebViewControlDeferredPermissionRequest param1{nullptr};

                {
                    auto _gil = release_gil();
                    self->obj.GetDeferredPermissionRequestById(param0, param1);
                }

                py::pyobj_handle out1{ py::convert(param1) };
                if (!out1)
                {
                    return nullptr;
                }

                return out1.detach();
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* WebUIView_GoBack(py::wrapper::Windows::UI::WebUI::WebUIView* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.WebUI.WebUIView", L"GoBack", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                {
                    auto _gil = release_gil();
                    self->obj.GoBack();
                }

                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* WebUIView_GoForward(py::wrapper::Windows::UI::WebUI::WebUIView* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.WebUI.WebUIView", L"GoForward", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                {
                    auto _gil = release_gil();
                    self->obj.GoForward();
                }

                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* WebUIView_InvokeScriptAsync(py::wrapper::Windows::UI::WebUI::WebUIView* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.WebUI.WebUIView", L"InvokeScriptAsync", 2);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(2);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Foundation::Collections::IIterable<winrt::hstring>>(args, 1);

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return self->obj.InvokeScriptAsync(param0, param1);
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* WebUIView_Navigate(py::wrapper::Windows::UI::WebUI::WebUIView* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.WebUI.WebUIView", L"Navigate", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Foundation::Uri>(args, 0);

                {
                    auto _gil = release_gil();
                    self->obj.Navigate(param0);
                }

                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* WebUIView_NavigateToLocalStreamUri(py::wrapper::Windows::UI::WebUI::WebUIView* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.WebUI.WebUIView", L"NavigateToLocalStreamUri", 2);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(2);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Foundation::Uri>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Web::IUriToStreamResolver>(args, 1);

                {
                    auto _gil = release_gil();
                    self->obj.NavigateToLocalStreamUri(param0, param1);
                }

                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* WebUIView_NavigateToString(py::wrapper::Windows::UI::WebUI::WebUIView* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.WebUI.WebUIView", L"NavigateToString", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                {
                    auto _gil = release_gil();
                    self->obj.NavigateToString(param0);
                }

                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* WebUIView_NavigateWithHttpRequestMessage(py::wrapper::Windows::UI::WebUI::WebUIView* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.WebUI.WebUIView", L"NavigateWithHttpRequestMessage", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Web::Http::HttpRequestMessage>(args, 0);

                {
                    auto _gil = release_gil();
                    self->obj.NavigateWithHttpRequestMessage(param0);
                }

                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* WebUIView_Refresh(py::wrapper::Windows::UI::WebUI::WebUIView* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.WebUI.WebUIView", L"Refresh", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                {
                    auto _gil = release_gil();
                    self->obj.Refresh();
                }

                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* WebUIView_Stop(py::wrapper::Windows::UI::WebUI::WebUIView* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.WebUI.WebUIView", L"Stop", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                {
                    auto _gil = release_gil();
                    self->obj.Stop();
                }

                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* WebUIView_get_IgnoreApplicationContentUriRulesNavigationRestrictions(py::wrapper::Windows::UI::WebUI::WebUIView* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.WebUI.WebUIView", L"IgnoreApplicationContentUriRulesNavigationRestrictions");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.IgnoreApplicationContentUriRulesNavigationRestrictions();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int WebUIView_put_IgnoreApplicationContentUriRulesNavigationRestrictions(py::wrapper::Windows::UI::WebUI::WebUIView* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.WebUI.WebUIView", L"IgnoreApplicationContentUriRulesNavigationRestrictions");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<bool>(arg);

            {
                auto _gil = release_gil();
                self->obj.IgnoreApplicationContentUriRulesNavigationRestrictions(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* WebUIView_get_ApplicationViewId(py::wrapper::Windows::UI::WebUI::WebUIView* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.WebUI.WebUIView", L"ApplicationViewId");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.ApplicationViewId();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* WebUIView_get_Source(py::wrapper::Windows::UI::WebUI::WebUIView* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.WebUI.WebUIView", L"Source");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Source();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int WebUIView_put_Source(py::wrapper::Windows::UI::WebUI::WebUIView* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.WebUI.WebUIView", L"Source");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::Uri>(arg);

            {
                auto _gil = release_gil();
                self->obj.Source(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* WebUIView_get_DefaultBackgroundColor(py::wrapper::Windows::UI::WebUI::WebUIView* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.WebUI.WebUIView", L"DefaultBackgroundColor");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.DefaultBackgroundColor();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int WebUIView_put_DefaultBackgroundColor(py::wrapper::Windows::UI::WebUI::WebUIView* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.WebUI.WebUIView", L"DefaultBackgroundColor");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::UI::Color>(arg);

            {
                auto _gil = release_gil();
                self->obj.DefaultBackgroundColor(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* WebUIView_get_CanGoBack(py::wrapper::Windows::UI::WebUI::WebUIView* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.WebUI.WebUIView", L"CanGoBack");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.CanGoBack();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* WebUIView_get_CanGoForward(py::wrapper::Windows::UI::WebUI::WebUIView* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.WebUI.WebUIView", L"CanGoForward");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.CanGoForward();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* WebUIView_get_ContainsFullScreenElement(py::wrapper::Windows::UI::WebUI::WebUIView* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.WebUI.WebUIView", L"ContainsFullScreenElement");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.ContainsFullScreenElement();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* WebUIView_get_DeferredPermissionRequests(py::wrapper::Windows::UI::WebUI::WebUIView* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.WebUI.WebUIView", L"DeferredPermissionRequests");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.DeferredPermissionRequests();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* WebUIView_get_DocumentTitle(py::wrapper::Windows::UI::WebUI::WebUIView* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.WebUI.WebUIView", L"DocumentTitle");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.DocumentTitle();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* WebUIView_get_Settings(py::wrapper::Windows::UI::WebUI::WebUIView* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.WebUI.WebUIView", L"Settings");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Settings();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* WebUIView_add_Activated(py::wrapper::Windows::UI::WebUI::WebUIView* self, PyObject* arg) noexcept
    {
        try
        {
            static std::optional<bool> is_event_present{};

            if (!is_event_present.has_value())
            {
                is_event_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.UI.WebUI.WebUIView", L"Activated");
            }

            if (!is_event_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::UI::WebUI::WebUIView, winrt::Windows::ApplicationModel::Activation::IActivatedEventArgs>>(arg);

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Activated(param0);
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* WebUIView_remove_Activated(py::wrapper::Windows::UI::WebUI::WebUIView* self, PyObject* arg) noexcept
    {
        try
        {
            static std::optional<bool> is_event_present{};

            if (!is_event_present.has_value())
            {
                is_event_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.UI.WebUI.WebUIView", L"Activated");
            }

            if (!is_event_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::event_token>(arg);

            {
                auto _gil = release_gil();
                self->obj.Activated(param0);
            }

            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* WebUIView_add_Closed(py::wrapper::Windows::UI::WebUI::WebUIView* self, PyObject* arg) noexcept
    {
        try
        {
            static std::optional<bool> is_event_present{};

            if (!is_event_present.has_value())
            {
                is_event_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.UI.WebUI.WebUIView", L"Closed");
            }

            if (!is_event_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::UI::WebUI::WebUIView, winrt::Windows::Foundation::IInspectable>>(arg);

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Closed(param0);
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* WebUIView_remove_Closed(py::wrapper::Windows::UI::WebUI::WebUIView* self, PyObject* arg) noexcept
    {
        try
        {
            static std::optional<bool> is_event_present{};

            if (!is_event_present.has_value())
            {
                is_event_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.UI.WebUI.WebUIView", L"Closed");
            }

            if (!is_event_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::event_token>(arg);

            {
                auto _gil = release_gil();
                self->obj.Closed(param0);
            }

            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* WebUIView_add_ContainsFullScreenElementChanged(py::wrapper::Windows::UI::WebUI::WebUIView* self, PyObject* arg) noexcept
    {
        try
        {
            static std::optional<bool> is_event_present{};

            if (!is_event_present.has_value())
            {
                is_event_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.UI.WebUI.WebUIView", L"ContainsFullScreenElementChanged");
            }

            if (!is_event_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Web::UI::IWebViewControl, winrt::Windows::Foundation::IInspectable>>(arg);

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.ContainsFullScreenElementChanged(param0);
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* WebUIView_remove_ContainsFullScreenElementChanged(py::wrapper::Windows::UI::WebUI::WebUIView* self, PyObject* arg) noexcept
    {
        try
        {
            static std::optional<bool> is_event_present{};

            if (!is_event_present.has_value())
            {
                is_event_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.UI.WebUI.WebUIView", L"ContainsFullScreenElementChanged");
            }

            if (!is_event_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::event_token>(arg);

            {
                auto _gil = release_gil();
                self->obj.ContainsFullScreenElementChanged(param0);
            }

            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* WebUIView_add_ContentLoading(py::wrapper::Windows::UI::WebUI::WebUIView* self, PyObject* arg) noexcept
    {
        try
        {
            static std::optional<bool> is_event_present{};

            if (!is_event_present.has_value())
            {
                is_event_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.UI.WebUI.WebUIView", L"ContentLoading");
            }

            if (!is_event_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Web::UI::IWebViewControl, winrt::Windows::Web::UI::WebViewControlContentLoadingEventArgs>>(arg);

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.ContentLoading(param0);
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* WebUIView_remove_ContentLoading(py::wrapper::Windows::UI::WebUI::WebUIView* self, PyObject* arg) noexcept
    {
        try
        {
            static std::optional<bool> is_event_present{};

            if (!is_event_present.has_value())
            {
                is_event_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.UI.WebUI.WebUIView", L"ContentLoading");
            }

            if (!is_event_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::event_token>(arg);

            {
                auto _gil = release_gil();
                self->obj.ContentLoading(param0);
            }

            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* WebUIView_add_DOMContentLoaded(py::wrapper::Windows::UI::WebUI::WebUIView* self, PyObject* arg) noexcept
    {
        try
        {
            static std::optional<bool> is_event_present{};

            if (!is_event_present.has_value())
            {
                is_event_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.UI.WebUI.WebUIView", L"DOMContentLoaded");
            }

            if (!is_event_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Web::UI::IWebViewControl, winrt::Windows::Web::UI::WebViewControlDOMContentLoadedEventArgs>>(arg);

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.DOMContentLoaded(param0);
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* WebUIView_remove_DOMContentLoaded(py::wrapper::Windows::UI::WebUI::WebUIView* self, PyObject* arg) noexcept
    {
        try
        {
            static std::optional<bool> is_event_present{};

            if (!is_event_present.has_value())
            {
                is_event_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.UI.WebUI.WebUIView", L"DOMContentLoaded");
            }

            if (!is_event_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::event_token>(arg);

            {
                auto _gil = release_gil();
                self->obj.DOMContentLoaded(param0);
            }

            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* WebUIView_add_FrameContentLoading(py::wrapper::Windows::UI::WebUI::WebUIView* self, PyObject* arg) noexcept
    {
        try
        {
            static std::optional<bool> is_event_present{};

            if (!is_event_present.has_value())
            {
                is_event_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.UI.WebUI.WebUIView", L"FrameContentLoading");
            }

            if (!is_event_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Web::UI::IWebViewControl, winrt::Windows::Web::UI::WebViewControlContentLoadingEventArgs>>(arg);

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.FrameContentLoading(param0);
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* WebUIView_remove_FrameContentLoading(py::wrapper::Windows::UI::WebUI::WebUIView* self, PyObject* arg) noexcept
    {
        try
        {
            static std::optional<bool> is_event_present{};

            if (!is_event_present.has_value())
            {
                is_event_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.UI.WebUI.WebUIView", L"FrameContentLoading");
            }

            if (!is_event_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::event_token>(arg);

            {
                auto _gil = release_gil();
                self->obj.FrameContentLoading(param0);
            }

            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* WebUIView_add_FrameDOMContentLoaded(py::wrapper::Windows::UI::WebUI::WebUIView* self, PyObject* arg) noexcept
    {
        try
        {
            static std::optional<bool> is_event_present{};

            if (!is_event_present.has_value())
            {
                is_event_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.UI.WebUI.WebUIView", L"FrameDOMContentLoaded");
            }

            if (!is_event_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Web::UI::IWebViewControl, winrt::Windows::Web::UI::WebViewControlDOMContentLoadedEventArgs>>(arg);

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.FrameDOMContentLoaded(param0);
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* WebUIView_remove_FrameDOMContentLoaded(py::wrapper::Windows::UI::WebUI::WebUIView* self, PyObject* arg) noexcept
    {
        try
        {
            static std::optional<bool> is_event_present{};

            if (!is_event_present.has_value())
            {
                is_event_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.UI.WebUI.WebUIView", L"FrameDOMContentLoaded");
            }

            if (!is_event_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::event_token>(arg);

            {
                auto _gil = release_gil();
                self->obj.FrameDOMContentLoaded(param0);
            }

            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* WebUIView_add_FrameNavigationCompleted(py::wrapper::Windows::UI::WebUI::WebUIView* self, PyObject* arg) noexcept
    {
        try
        {
            static std::optional<bool> is_event_present{};

            if (!is_event_present.has_value())
            {
                is_event_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.UI.WebUI.WebUIView", L"FrameNavigationCompleted");
            }

            if (!is_event_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Web::UI::IWebViewControl, winrt::Windows::Web::UI::WebViewControlNavigationCompletedEventArgs>>(arg);

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.FrameNavigationCompleted(param0);
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* WebUIView_remove_FrameNavigationCompleted(py::wrapper::Windows::UI::WebUI::WebUIView* self, PyObject* arg) noexcept
    {
        try
        {
            static std::optional<bool> is_event_present{};

            if (!is_event_present.has_value())
            {
                is_event_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.UI.WebUI.WebUIView", L"FrameNavigationCompleted");
            }

            if (!is_event_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::event_token>(arg);

            {
                auto _gil = release_gil();
                self->obj.FrameNavigationCompleted(param0);
            }

            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* WebUIView_add_FrameNavigationStarting(py::wrapper::Windows::UI::WebUI::WebUIView* self, PyObject* arg) noexcept
    {
        try
        {
            static std::optional<bool> is_event_present{};

            if (!is_event_present.has_value())
            {
                is_event_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.UI.WebUI.WebUIView", L"FrameNavigationStarting");
            }

            if (!is_event_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Web::UI::IWebViewControl, winrt::Windows::Web::UI::WebViewControlNavigationStartingEventArgs>>(arg);

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.FrameNavigationStarting(param0);
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* WebUIView_remove_FrameNavigationStarting(py::wrapper::Windows::UI::WebUI::WebUIView* self, PyObject* arg) noexcept
    {
        try
        {
            static std::optional<bool> is_event_present{};

            if (!is_event_present.has_value())
            {
                is_event_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.UI.WebUI.WebUIView", L"FrameNavigationStarting");
            }

            if (!is_event_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::event_token>(arg);

            {
                auto _gil = release_gil();
                self->obj.FrameNavigationStarting(param0);
            }

            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* WebUIView_add_LongRunningScriptDetected(py::wrapper::Windows::UI::WebUI::WebUIView* self, PyObject* arg) noexcept
    {
        try
        {
            static std::optional<bool> is_event_present{};

            if (!is_event_present.has_value())
            {
                is_event_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.UI.WebUI.WebUIView", L"LongRunningScriptDetected");
            }

            if (!is_event_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Web::UI::IWebViewControl, winrt::Windows::Web::UI::WebViewControlLongRunningScriptDetectedEventArgs>>(arg);

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.LongRunningScriptDetected(param0);
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* WebUIView_remove_LongRunningScriptDetected(py::wrapper::Windows::UI::WebUI::WebUIView* self, PyObject* arg) noexcept
    {
        try
        {
            static std::optional<bool> is_event_present{};

            if (!is_event_present.has_value())
            {
                is_event_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.UI.WebUI.WebUIView", L"LongRunningScriptDetected");
            }

            if (!is_event_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::event_token>(arg);

            {
                auto _gil = release_gil();
                self->obj.LongRunningScriptDetected(param0);
            }

            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* WebUIView_add_NavigationCompleted(py::wrapper::Windows::UI::WebUI::WebUIView* self, PyObject* arg) noexcept
    {
        try
        {
            static std::optional<bool> is_event_present{};

            if (!is_event_present.has_value())
            {
                is_event_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.UI.WebUI.WebUIView", L"NavigationCompleted");
            }

            if (!is_event_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Web::UI::IWebViewControl, winrt::Windows::Web::UI::WebViewControlNavigationCompletedEventArgs>>(arg);

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.NavigationCompleted(param0);
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* WebUIView_remove_NavigationCompleted(py::wrapper::Windows::UI::WebUI::WebUIView* self, PyObject* arg) noexcept
    {
        try
        {
            static std::optional<bool> is_event_present{};

            if (!is_event_present.has_value())
            {
                is_event_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.UI.WebUI.WebUIView", L"NavigationCompleted");
            }

            if (!is_event_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::event_token>(arg);

            {
                auto _gil = release_gil();
                self->obj.NavigationCompleted(param0);
            }

            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* WebUIView_add_NavigationStarting(py::wrapper::Windows::UI::WebUI::WebUIView* self, PyObject* arg) noexcept
    {
        try
        {
            static std::optional<bool> is_event_present{};

            if (!is_event_present.has_value())
            {
                is_event_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.UI.WebUI.WebUIView", L"NavigationStarting");
            }

            if (!is_event_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Web::UI::IWebViewControl, winrt::Windows::Web::UI::WebViewControlNavigationStartingEventArgs>>(arg);

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.NavigationStarting(param0);
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* WebUIView_remove_NavigationStarting(py::wrapper::Windows::UI::WebUI::WebUIView* self, PyObject* arg) noexcept
    {
        try
        {
            static std::optional<bool> is_event_present{};

            if (!is_event_present.has_value())
            {
                is_event_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.UI.WebUI.WebUIView", L"NavigationStarting");
            }

            if (!is_event_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::event_token>(arg);

            {
                auto _gil = release_gil();
                self->obj.NavigationStarting(param0);
            }

            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* WebUIView_add_NewWindowRequested(py::wrapper::Windows::UI::WebUI::WebUIView* self, PyObject* arg) noexcept
    {
        try
        {
            static std::optional<bool> is_event_present{};

            if (!is_event_present.has_value())
            {
                is_event_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.UI.WebUI.WebUIView", L"NewWindowRequested");
            }

            if (!is_event_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Web::UI::IWebViewControl, winrt::Windows::Web::UI::WebViewControlNewWindowRequestedEventArgs>>(arg);

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.NewWindowRequested(param0);
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* WebUIView_remove_NewWindowRequested(py::wrapper::Windows::UI::WebUI::WebUIView* self, PyObject* arg) noexcept
    {
        try
        {
            static std::optional<bool> is_event_present{};

            if (!is_event_present.has_value())
            {
                is_event_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.UI.WebUI.WebUIView", L"NewWindowRequested");
            }

            if (!is_event_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::event_token>(arg);

            {
                auto _gil = release_gil();
                self->obj.NewWindowRequested(param0);
            }

            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* WebUIView_add_PermissionRequested(py::wrapper::Windows::UI::WebUI::WebUIView* self, PyObject* arg) noexcept
    {
        try
        {
            static std::optional<bool> is_event_present{};

            if (!is_event_present.has_value())
            {
                is_event_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.UI.WebUI.WebUIView", L"PermissionRequested");
            }

            if (!is_event_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Web::UI::IWebViewControl, winrt::Windows::Web::UI::WebViewControlPermissionRequestedEventArgs>>(arg);

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.PermissionRequested(param0);
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* WebUIView_remove_PermissionRequested(py::wrapper::Windows::UI::WebUI::WebUIView* self, PyObject* arg) noexcept
    {
        try
        {
            static std::optional<bool> is_event_present{};

            if (!is_event_present.has_value())
            {
                is_event_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.UI.WebUI.WebUIView", L"PermissionRequested");
            }

            if (!is_event_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::event_token>(arg);

            {
                auto _gil = release_gil();
                self->obj.PermissionRequested(param0);
            }

            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* WebUIView_add_ScriptNotify(py::wrapper::Windows::UI::WebUI::WebUIView* self, PyObject* arg) noexcept
    {
        try
        {
            static std::optional<bool> is_event_present{};

            if (!is_event_present.has_value())
            {
                is_event_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.UI.WebUI.WebUIView", L"ScriptNotify");
            }

            if (!is_event_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Web::UI::IWebViewControl, winrt::Windows::Web::UI::WebViewControlScriptNotifyEventArgs>>(arg);

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.ScriptNotify(param0);
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* WebUIView_remove_ScriptNotify(py::wrapper::Windows::UI::WebUI::WebUIView* self, PyObject* arg) noexcept
    {
        try
        {
            static std::optional<bool> is_event_present{};

            if (!is_event_present.has_value())
            {
                is_event_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.UI.WebUI.WebUIView", L"ScriptNotify");
            }

            if (!is_event_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::event_token>(arg);

            {
                auto _gil = release_gil();
                self->obj.ScriptNotify(param0);
            }

            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* WebUIView_add_UnsafeContentWarningDisplaying(py::wrapper::Windows::UI::WebUI::WebUIView* self, PyObject* arg) noexcept
    {
        try
        {
            static std::optional<bool> is_event_present{};

            if (!is_event_present.has_value())
            {
                is_event_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.UI.WebUI.WebUIView", L"UnsafeContentWarningDisplaying");
            }

            if (!is_event_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Web::UI::IWebViewControl, winrt::Windows::Foundation::IInspectable>>(arg);

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.UnsafeContentWarningDisplaying(param0);
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* WebUIView_remove_UnsafeContentWarningDisplaying(py::wrapper::Windows::UI::WebUI::WebUIView* self, PyObject* arg) noexcept
    {
        try
        {
            static std::optional<bool> is_event_present{};

            if (!is_event_present.has_value())
            {
                is_event_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.UI.WebUI.WebUIView", L"UnsafeContentWarningDisplaying");
            }

            if (!is_event_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::event_token>(arg);

            {
                auto _gil = release_gil();
                self->obj.UnsafeContentWarningDisplaying(param0);
            }

            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* WebUIView_add_UnsupportedUriSchemeIdentified(py::wrapper::Windows::UI::WebUI::WebUIView* self, PyObject* arg) noexcept
    {
        try
        {
            static std::optional<bool> is_event_present{};

            if (!is_event_present.has_value())
            {
                is_event_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.UI.WebUI.WebUIView", L"UnsupportedUriSchemeIdentified");
            }

            if (!is_event_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Web::UI::IWebViewControl, winrt::Windows::Web::UI::WebViewControlUnsupportedUriSchemeIdentifiedEventArgs>>(arg);

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.UnsupportedUriSchemeIdentified(param0);
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* WebUIView_remove_UnsupportedUriSchemeIdentified(py::wrapper::Windows::UI::WebUI::WebUIView* self, PyObject* arg) noexcept
    {
        try
        {
            static std::optional<bool> is_event_present{};

            if (!is_event_present.has_value())
            {
                is_event_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.UI.WebUI.WebUIView", L"UnsupportedUriSchemeIdentified");
            }

            if (!is_event_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::event_token>(arg);

            {
                auto _gil = release_gil();
                self->obj.UnsupportedUriSchemeIdentified(param0);
            }

            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* WebUIView_add_UnviewableContentIdentified(py::wrapper::Windows::UI::WebUI::WebUIView* self, PyObject* arg) noexcept
    {
        try
        {
            static std::optional<bool> is_event_present{};

            if (!is_event_present.has_value())
            {
                is_event_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.UI.WebUI.WebUIView", L"UnviewableContentIdentified");
            }

            if (!is_event_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Web::UI::IWebViewControl, winrt::Windows::Web::UI::WebViewControlUnviewableContentIdentifiedEventArgs>>(arg);

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.UnviewableContentIdentified(param0);
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* WebUIView_remove_UnviewableContentIdentified(py::wrapper::Windows::UI::WebUI::WebUIView* self, PyObject* arg) noexcept
    {
        try
        {
            static std::optional<bool> is_event_present{};

            if (!is_event_present.has_value())
            {
                is_event_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.UI.WebUI.WebUIView", L"UnviewableContentIdentified");
            }

            if (!is_event_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::event_token>(arg);

            {
                auto _gil = release_gil();
                self->obj.UnviewableContentIdentified(param0);
            }

            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* WebUIView_add_WebResourceRequested(py::wrapper::Windows::UI::WebUI::WebUIView* self, PyObject* arg) noexcept
    {
        try
        {
            static std::optional<bool> is_event_present{};

            if (!is_event_present.has_value())
            {
                is_event_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.UI.WebUI.WebUIView", L"WebResourceRequested");
            }

            if (!is_event_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Web::UI::IWebViewControl, winrt::Windows::Web::UI::WebViewControlWebResourceRequestedEventArgs>>(arg);

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.WebResourceRequested(param0);
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* WebUIView_remove_WebResourceRequested(py::wrapper::Windows::UI::WebUI::WebUIView* self, PyObject* arg) noexcept
    {
        try
        {
            static std::optional<bool> is_event_present{};

            if (!is_event_present.has_value())
            {
                is_event_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.UI.WebUI.WebUIView", L"WebResourceRequested");
            }

            if (!is_event_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::event_token>(arg);

            {
                auto _gil = release_gil();
                self->obj.WebResourceRequested(param0);
            }

            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_WebUIView(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::WebUI::WebUIView>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_WebUIView(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::WebUI::WebUIView>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_WebUIView[] = {
        { "add_initialize_script", reinterpret_cast<PyCFunction>(WebUIView_AddInitializeScript), METH_VARARGS, nullptr },
        { "build_local_stream_uri", reinterpret_cast<PyCFunction>(WebUIView_BuildLocalStreamUri), METH_VARARGS, nullptr },
        { "capture_preview_to_stream_async", reinterpret_cast<PyCFunction>(WebUIView_CapturePreviewToStreamAsync), METH_VARARGS, nullptr },
        { "capture_selected_content_to_data_package_async", reinterpret_cast<PyCFunction>(WebUIView_CaptureSelectedContentToDataPackageAsync), METH_VARARGS, nullptr },
        { "get_deferred_permission_request_by_id", reinterpret_cast<PyCFunction>(WebUIView_GetDeferredPermissionRequestById), METH_VARARGS, nullptr },
        { "go_back", reinterpret_cast<PyCFunction>(WebUIView_GoBack), METH_VARARGS, nullptr },
        { "go_forward", reinterpret_cast<PyCFunction>(WebUIView_GoForward), METH_VARARGS, nullptr },
        { "invoke_script_async", reinterpret_cast<PyCFunction>(WebUIView_InvokeScriptAsync), METH_VARARGS, nullptr },
        { "navigate", reinterpret_cast<PyCFunction>(WebUIView_Navigate), METH_VARARGS, nullptr },
        { "navigate_to_local_stream_uri", reinterpret_cast<PyCFunction>(WebUIView_NavigateToLocalStreamUri), METH_VARARGS, nullptr },
        { "navigate_to_string", reinterpret_cast<PyCFunction>(WebUIView_NavigateToString), METH_VARARGS, nullptr },
        { "navigate_with_http_request_message", reinterpret_cast<PyCFunction>(WebUIView_NavigateWithHttpRequestMessage), METH_VARARGS, nullptr },
        { "refresh", reinterpret_cast<PyCFunction>(WebUIView_Refresh), METH_VARARGS, nullptr },
        { "stop", reinterpret_cast<PyCFunction>(WebUIView_Stop), METH_VARARGS, nullptr },
        { "add_activated", reinterpret_cast<PyCFunction>(WebUIView_add_Activated), METH_O, nullptr },
        { "remove_activated", reinterpret_cast<PyCFunction>(WebUIView_remove_Activated), METH_O, nullptr },
        { "add_closed", reinterpret_cast<PyCFunction>(WebUIView_add_Closed), METH_O, nullptr },
        { "remove_closed", reinterpret_cast<PyCFunction>(WebUIView_remove_Closed), METH_O, nullptr },
        { "add_contains_full_screen_element_changed", reinterpret_cast<PyCFunction>(WebUIView_add_ContainsFullScreenElementChanged), METH_O, nullptr },
        { "remove_contains_full_screen_element_changed", reinterpret_cast<PyCFunction>(WebUIView_remove_ContainsFullScreenElementChanged), METH_O, nullptr },
        { "add_content_loading", reinterpret_cast<PyCFunction>(WebUIView_add_ContentLoading), METH_O, nullptr },
        { "remove_content_loading", reinterpret_cast<PyCFunction>(WebUIView_remove_ContentLoading), METH_O, nullptr },
        { "add_dom_content_loaded", reinterpret_cast<PyCFunction>(WebUIView_add_DOMContentLoaded), METH_O, nullptr },
        { "remove_dom_content_loaded", reinterpret_cast<PyCFunction>(WebUIView_remove_DOMContentLoaded), METH_O, nullptr },
        { "add_frame_content_loading", reinterpret_cast<PyCFunction>(WebUIView_add_FrameContentLoading), METH_O, nullptr },
        { "remove_frame_content_loading", reinterpret_cast<PyCFunction>(WebUIView_remove_FrameContentLoading), METH_O, nullptr },
        { "add_frame_dom_content_loaded", reinterpret_cast<PyCFunction>(WebUIView_add_FrameDOMContentLoaded), METH_O, nullptr },
        { "remove_frame_dom_content_loaded", reinterpret_cast<PyCFunction>(WebUIView_remove_FrameDOMContentLoaded), METH_O, nullptr },
        { "add_frame_navigation_completed", reinterpret_cast<PyCFunction>(WebUIView_add_FrameNavigationCompleted), METH_O, nullptr },
        { "remove_frame_navigation_completed", reinterpret_cast<PyCFunction>(WebUIView_remove_FrameNavigationCompleted), METH_O, nullptr },
        { "add_frame_navigation_starting", reinterpret_cast<PyCFunction>(WebUIView_add_FrameNavigationStarting), METH_O, nullptr },
        { "remove_frame_navigation_starting", reinterpret_cast<PyCFunction>(WebUIView_remove_FrameNavigationStarting), METH_O, nullptr },
        { "add_long_running_script_detected", reinterpret_cast<PyCFunction>(WebUIView_add_LongRunningScriptDetected), METH_O, nullptr },
        { "remove_long_running_script_detected", reinterpret_cast<PyCFunction>(WebUIView_remove_LongRunningScriptDetected), METH_O, nullptr },
        { "add_navigation_completed", reinterpret_cast<PyCFunction>(WebUIView_add_NavigationCompleted), METH_O, nullptr },
        { "remove_navigation_completed", reinterpret_cast<PyCFunction>(WebUIView_remove_NavigationCompleted), METH_O, nullptr },
        { "add_navigation_starting", reinterpret_cast<PyCFunction>(WebUIView_add_NavigationStarting), METH_O, nullptr },
        { "remove_navigation_starting", reinterpret_cast<PyCFunction>(WebUIView_remove_NavigationStarting), METH_O, nullptr },
        { "add_new_window_requested", reinterpret_cast<PyCFunction>(WebUIView_add_NewWindowRequested), METH_O, nullptr },
        { "remove_new_window_requested", reinterpret_cast<PyCFunction>(WebUIView_remove_NewWindowRequested), METH_O, nullptr },
        { "add_permission_requested", reinterpret_cast<PyCFunction>(WebUIView_add_PermissionRequested), METH_O, nullptr },
        { "remove_permission_requested", reinterpret_cast<PyCFunction>(WebUIView_remove_PermissionRequested), METH_O, nullptr },
        { "add_script_notify", reinterpret_cast<PyCFunction>(WebUIView_add_ScriptNotify), METH_O, nullptr },
        { "remove_script_notify", reinterpret_cast<PyCFunction>(WebUIView_remove_ScriptNotify), METH_O, nullptr },
        { "add_unsafe_content_warning_displaying", reinterpret_cast<PyCFunction>(WebUIView_add_UnsafeContentWarningDisplaying), METH_O, nullptr },
        { "remove_unsafe_content_warning_displaying", reinterpret_cast<PyCFunction>(WebUIView_remove_UnsafeContentWarningDisplaying), METH_O, nullptr },
        { "add_unsupported_uri_scheme_identified", reinterpret_cast<PyCFunction>(WebUIView_add_UnsupportedUriSchemeIdentified), METH_O, nullptr },
        { "remove_unsupported_uri_scheme_identified", reinterpret_cast<PyCFunction>(WebUIView_remove_UnsupportedUriSchemeIdentified), METH_O, nullptr },
        { "add_unviewable_content_identified", reinterpret_cast<PyCFunction>(WebUIView_add_UnviewableContentIdentified), METH_O, nullptr },
        { "remove_unviewable_content_identified", reinterpret_cast<PyCFunction>(WebUIView_remove_UnviewableContentIdentified), METH_O, nullptr },
        { "add_web_resource_requested", reinterpret_cast<PyCFunction>(WebUIView_add_WebResourceRequested), METH_O, nullptr },
        { "remove_web_resource_requested", reinterpret_cast<PyCFunction>(WebUIView_remove_WebResourceRequested), METH_O, nullptr },
        { "_assign_array_", _assign_array_WebUIView, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_WebUIView), METH_O | METH_STATIC, nullptr },
        { }};

    static PyGetSetDef _getset_WebUIView[] = {
        { "ignore_application_content_uri_rules_navigation_restrictions", reinterpret_cast<getter>(WebUIView_get_IgnoreApplicationContentUriRulesNavigationRestrictions), reinterpret_cast<setter>(WebUIView_put_IgnoreApplicationContentUriRulesNavigationRestrictions), nullptr, nullptr },
        { "application_view_id", reinterpret_cast<getter>(WebUIView_get_ApplicationViewId), nullptr, nullptr, nullptr },
        { "source", reinterpret_cast<getter>(WebUIView_get_Source), reinterpret_cast<setter>(WebUIView_put_Source), nullptr, nullptr },
        { "default_background_color", reinterpret_cast<getter>(WebUIView_get_DefaultBackgroundColor), reinterpret_cast<setter>(WebUIView_put_DefaultBackgroundColor), nullptr, nullptr },
        { "can_go_back", reinterpret_cast<getter>(WebUIView_get_CanGoBack), nullptr, nullptr, nullptr },
        { "can_go_forward", reinterpret_cast<getter>(WebUIView_get_CanGoForward), nullptr, nullptr, nullptr },
        { "contains_full_screen_element", reinterpret_cast<getter>(WebUIView_get_ContainsFullScreenElement), nullptr, nullptr, nullptr },
        { "deferred_permission_requests", reinterpret_cast<getter>(WebUIView_get_DeferredPermissionRequests), nullptr, nullptr, nullptr },
        { "document_title", reinterpret_cast<getter>(WebUIView_get_DocumentTitle), nullptr, nullptr, nullptr },
        { "settings", reinterpret_cast<getter>(WebUIView_get_Settings), nullptr, nullptr, nullptr },
        { }};

    static PyType_Slot _type_slots_WebUIView[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_WebUIView) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_WebUIView) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_WebUIView) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_WebUIView) },
        { }};

    static PyType_Spec type_spec_WebUIView = {
        "winrt._winrt_windows_ui_webui.WebUIView",
        sizeof(py::wrapper::Windows::UI::WebUI::WebUIView),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_WebUIView};

    static PyGetSetDef getset_WebUIView_Static[] = {
        { }};

    static PyMethodDef methods_WebUIView_Static[] = {
        { "create_async", reinterpret_cast<PyCFunction>(WebUIView_CreateAsync), METH_VARARGS, nullptr },
        { "create_with_uri_async", reinterpret_cast<PyCFunction>(WebUIView_CreateWithUriAsync), METH_VARARGS, nullptr },
        { }};

    static PyType_Slot type_slots_WebUIView_Static[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_WebUIView_Static) },
        { Py_tp_methods, reinterpret_cast<void*>(methods_WebUIView_Static) },
        { }
    };

    static PyType_Spec type_spec_WebUIView_Static = {
        "winrt._winrt_windows_ui_webui.WebUIView_Static",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT,
        type_slots_WebUIView_Static};

    // ----- WebUIVoiceCommandActivatedEventArgs class --------------------

    static PyObject* _new_WebUIVoiceCommandActivatedEventArgs(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::UI::WebUI::WebUIVoiceCommandActivatedEventArgs>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::UI::WebUI::WebUIVoiceCommandActivatedEventArgs>::type_name);
        return nullptr;
    }

    static void _dealloc_WebUIVoiceCommandActivatedEventArgs(py::wrapper::Windows::UI::WebUI::WebUIVoiceCommandActivatedEventArgs* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* WebUIVoiceCommandActivatedEventArgs_get_Kind(py::wrapper::Windows::UI::WebUI::WebUIVoiceCommandActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.WebUI.WebUIVoiceCommandActivatedEventArgs", L"Kind");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Kind();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* WebUIVoiceCommandActivatedEventArgs_get_PreviousExecutionState(py::wrapper::Windows::UI::WebUI::WebUIVoiceCommandActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.WebUI.WebUIVoiceCommandActivatedEventArgs", L"PreviousExecutionState");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.PreviousExecutionState();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* WebUIVoiceCommandActivatedEventArgs_get_SplashScreen(py::wrapper::Windows::UI::WebUI::WebUIVoiceCommandActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.WebUI.WebUIVoiceCommandActivatedEventArgs", L"SplashScreen");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.SplashScreen();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* WebUIVoiceCommandActivatedEventArgs_get_User(py::wrapper::Windows::UI::WebUI::WebUIVoiceCommandActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.WebUI.WebUIVoiceCommandActivatedEventArgs", L"User");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.User();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* WebUIVoiceCommandActivatedEventArgs_get_Result(py::wrapper::Windows::UI::WebUI::WebUIVoiceCommandActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.WebUI.WebUIVoiceCommandActivatedEventArgs", L"Result");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Result();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* WebUIVoiceCommandActivatedEventArgs_get_ActivatedOperation(py::wrapper::Windows::UI::WebUI::WebUIVoiceCommandActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.WebUI.WebUIVoiceCommandActivatedEventArgs", L"ActivatedOperation");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.ActivatedOperation();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_WebUIVoiceCommandActivatedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::WebUI::WebUIVoiceCommandActivatedEventArgs>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_WebUIVoiceCommandActivatedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::WebUI::WebUIVoiceCommandActivatedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_WebUIVoiceCommandActivatedEventArgs[] = {
        { "_assign_array_", _assign_array_WebUIVoiceCommandActivatedEventArgs, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_WebUIVoiceCommandActivatedEventArgs), METH_O | METH_STATIC, nullptr },
        { }};

    static PyGetSetDef _getset_WebUIVoiceCommandActivatedEventArgs[] = {
        { "kind", reinterpret_cast<getter>(WebUIVoiceCommandActivatedEventArgs_get_Kind), nullptr, nullptr, nullptr },
        { "previous_execution_state", reinterpret_cast<getter>(WebUIVoiceCommandActivatedEventArgs_get_PreviousExecutionState), nullptr, nullptr, nullptr },
        { "splash_screen", reinterpret_cast<getter>(WebUIVoiceCommandActivatedEventArgs_get_SplashScreen), nullptr, nullptr, nullptr },
        { "user", reinterpret_cast<getter>(WebUIVoiceCommandActivatedEventArgs_get_User), nullptr, nullptr, nullptr },
        { "result", reinterpret_cast<getter>(WebUIVoiceCommandActivatedEventArgs_get_Result), nullptr, nullptr, nullptr },
        { "activated_operation", reinterpret_cast<getter>(WebUIVoiceCommandActivatedEventArgs_get_ActivatedOperation), nullptr, nullptr, nullptr },
        { }};

    static PyType_Slot _type_slots_WebUIVoiceCommandActivatedEventArgs[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_WebUIVoiceCommandActivatedEventArgs) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_WebUIVoiceCommandActivatedEventArgs) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_WebUIVoiceCommandActivatedEventArgs) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_WebUIVoiceCommandActivatedEventArgs) },
        { }};

    static PyType_Spec type_spec_WebUIVoiceCommandActivatedEventArgs = {
        "winrt._winrt_windows_ui_webui.WebUIVoiceCommandActivatedEventArgs",
        sizeof(py::wrapper::Windows::UI::WebUI::WebUIVoiceCommandActivatedEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_WebUIVoiceCommandActivatedEventArgs};

    // ----- WebUIWalletActionActivatedEventArgs class --------------------

    static PyObject* _new_WebUIWalletActionActivatedEventArgs(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::UI::WebUI::WebUIWalletActionActivatedEventArgs>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::UI::WebUI::WebUIWalletActionActivatedEventArgs>::type_name);
        return nullptr;
    }

    static void _dealloc_WebUIWalletActionActivatedEventArgs(py::wrapper::Windows::UI::WebUI::WebUIWalletActionActivatedEventArgs* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* WebUIWalletActionActivatedEventArgs_get_Kind(py::wrapper::Windows::UI::WebUI::WebUIWalletActionActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.WebUI.WebUIWalletActionActivatedEventArgs", L"Kind");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Kind();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* WebUIWalletActionActivatedEventArgs_get_PreviousExecutionState(py::wrapper::Windows::UI::WebUI::WebUIWalletActionActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.WebUI.WebUIWalletActionActivatedEventArgs", L"PreviousExecutionState");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.PreviousExecutionState();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* WebUIWalletActionActivatedEventArgs_get_SplashScreen(py::wrapper::Windows::UI::WebUI::WebUIWalletActionActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.WebUI.WebUIWalletActionActivatedEventArgs", L"SplashScreen");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.SplashScreen();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* WebUIWalletActionActivatedEventArgs_get_ActionId(py::wrapper::Windows::UI::WebUI::WebUIWalletActionActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.WebUI.WebUIWalletActionActivatedEventArgs", L"ActionId");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.ActionId();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* WebUIWalletActionActivatedEventArgs_get_ActionKind(py::wrapper::Windows::UI::WebUI::WebUIWalletActionActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.WebUI.WebUIWalletActionActivatedEventArgs", L"ActionKind");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.ActionKind();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* WebUIWalletActionActivatedEventArgs_get_ItemId(py::wrapper::Windows::UI::WebUI::WebUIWalletActionActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.WebUI.WebUIWalletActionActivatedEventArgs", L"ItemId");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.ItemId();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* WebUIWalletActionActivatedEventArgs_get_ActivatedOperation(py::wrapper::Windows::UI::WebUI::WebUIWalletActionActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.WebUI.WebUIWalletActionActivatedEventArgs", L"ActivatedOperation");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.ActivatedOperation();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_WebUIWalletActionActivatedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::WebUI::WebUIWalletActionActivatedEventArgs>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_WebUIWalletActionActivatedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::WebUI::WebUIWalletActionActivatedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_WebUIWalletActionActivatedEventArgs[] = {
        { "_assign_array_", _assign_array_WebUIWalletActionActivatedEventArgs, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_WebUIWalletActionActivatedEventArgs), METH_O | METH_STATIC, nullptr },
        { }};

    static PyGetSetDef _getset_WebUIWalletActionActivatedEventArgs[] = {
        { "kind", reinterpret_cast<getter>(WebUIWalletActionActivatedEventArgs_get_Kind), nullptr, nullptr, nullptr },
        { "previous_execution_state", reinterpret_cast<getter>(WebUIWalletActionActivatedEventArgs_get_PreviousExecutionState), nullptr, nullptr, nullptr },
        { "splash_screen", reinterpret_cast<getter>(WebUIWalletActionActivatedEventArgs_get_SplashScreen), nullptr, nullptr, nullptr },
        { "action_id", reinterpret_cast<getter>(WebUIWalletActionActivatedEventArgs_get_ActionId), nullptr, nullptr, nullptr },
        { "action_kind", reinterpret_cast<getter>(WebUIWalletActionActivatedEventArgs_get_ActionKind), nullptr, nullptr, nullptr },
        { "item_id", reinterpret_cast<getter>(WebUIWalletActionActivatedEventArgs_get_ItemId), nullptr, nullptr, nullptr },
        { "activated_operation", reinterpret_cast<getter>(WebUIWalletActionActivatedEventArgs_get_ActivatedOperation), nullptr, nullptr, nullptr },
        { }};

    static PyType_Slot _type_slots_WebUIWalletActionActivatedEventArgs[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_WebUIWalletActionActivatedEventArgs) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_WebUIWalletActionActivatedEventArgs) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_WebUIWalletActionActivatedEventArgs) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_WebUIWalletActionActivatedEventArgs) },
        { }};

    static PyType_Spec type_spec_WebUIWalletActionActivatedEventArgs = {
        "winrt._winrt_windows_ui_webui.WebUIWalletActionActivatedEventArgs",
        sizeof(py::wrapper::Windows::UI::WebUI::WebUIWalletActionActivatedEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_WebUIWalletActionActivatedEventArgs};

    // ----- WebUIWebAccountProviderActivatedEventArgs class --------------------

    static PyObject* _new_WebUIWebAccountProviderActivatedEventArgs(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::UI::WebUI::WebUIWebAccountProviderActivatedEventArgs>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::UI::WebUI::WebUIWebAccountProviderActivatedEventArgs>::type_name);
        return nullptr;
    }

    static void _dealloc_WebUIWebAccountProviderActivatedEventArgs(py::wrapper::Windows::UI::WebUI::WebUIWebAccountProviderActivatedEventArgs* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* WebUIWebAccountProviderActivatedEventArgs_get_Kind(py::wrapper::Windows::UI::WebUI::WebUIWebAccountProviderActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.WebUI.WebUIWebAccountProviderActivatedEventArgs", L"Kind");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Kind();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* WebUIWebAccountProviderActivatedEventArgs_get_PreviousExecutionState(py::wrapper::Windows::UI::WebUI::WebUIWebAccountProviderActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.WebUI.WebUIWebAccountProviderActivatedEventArgs", L"PreviousExecutionState");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.PreviousExecutionState();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* WebUIWebAccountProviderActivatedEventArgs_get_SplashScreen(py::wrapper::Windows::UI::WebUI::WebUIWebAccountProviderActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.WebUI.WebUIWebAccountProviderActivatedEventArgs", L"SplashScreen");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.SplashScreen();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* WebUIWebAccountProviderActivatedEventArgs_get_User(py::wrapper::Windows::UI::WebUI::WebUIWebAccountProviderActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.WebUI.WebUIWebAccountProviderActivatedEventArgs", L"User");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.User();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* WebUIWebAccountProviderActivatedEventArgs_get_Operation(py::wrapper::Windows::UI::WebUI::WebUIWebAccountProviderActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.WebUI.WebUIWebAccountProviderActivatedEventArgs", L"Operation");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Operation();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* WebUIWebAccountProviderActivatedEventArgs_get_ActivatedOperation(py::wrapper::Windows::UI::WebUI::WebUIWebAccountProviderActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.WebUI.WebUIWebAccountProviderActivatedEventArgs", L"ActivatedOperation");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.ActivatedOperation();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_WebUIWebAccountProviderActivatedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::WebUI::WebUIWebAccountProviderActivatedEventArgs>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_WebUIWebAccountProviderActivatedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::WebUI::WebUIWebAccountProviderActivatedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_WebUIWebAccountProviderActivatedEventArgs[] = {
        { "_assign_array_", _assign_array_WebUIWebAccountProviderActivatedEventArgs, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_WebUIWebAccountProviderActivatedEventArgs), METH_O | METH_STATIC, nullptr },
        { }};

    static PyGetSetDef _getset_WebUIWebAccountProviderActivatedEventArgs[] = {
        { "kind", reinterpret_cast<getter>(WebUIWebAccountProviderActivatedEventArgs_get_Kind), nullptr, nullptr, nullptr },
        { "previous_execution_state", reinterpret_cast<getter>(WebUIWebAccountProviderActivatedEventArgs_get_PreviousExecutionState), nullptr, nullptr, nullptr },
        { "splash_screen", reinterpret_cast<getter>(WebUIWebAccountProviderActivatedEventArgs_get_SplashScreen), nullptr, nullptr, nullptr },
        { "user", reinterpret_cast<getter>(WebUIWebAccountProviderActivatedEventArgs_get_User), nullptr, nullptr, nullptr },
        { "operation", reinterpret_cast<getter>(WebUIWebAccountProviderActivatedEventArgs_get_Operation), nullptr, nullptr, nullptr },
        { "activated_operation", reinterpret_cast<getter>(WebUIWebAccountProviderActivatedEventArgs_get_ActivatedOperation), nullptr, nullptr, nullptr },
        { }};

    static PyType_Slot _type_slots_WebUIWebAccountProviderActivatedEventArgs[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_WebUIWebAccountProviderActivatedEventArgs) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_WebUIWebAccountProviderActivatedEventArgs) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_WebUIWebAccountProviderActivatedEventArgs) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_WebUIWebAccountProviderActivatedEventArgs) },
        { }};

    static PyType_Spec type_spec_WebUIWebAccountProviderActivatedEventArgs = {
        "winrt._winrt_windows_ui_webui.WebUIWebAccountProviderActivatedEventArgs",
        sizeof(py::wrapper::Windows::UI::WebUI::WebUIWebAccountProviderActivatedEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_WebUIWebAccountProviderActivatedEventArgs};

    // ----- WebUIWebAuthenticationBrokerContinuationEventArgs class --------------------

    static PyObject* _new_WebUIWebAuthenticationBrokerContinuationEventArgs(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::UI::WebUI::WebUIWebAuthenticationBrokerContinuationEventArgs>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::UI::WebUI::WebUIWebAuthenticationBrokerContinuationEventArgs>::type_name);
        return nullptr;
    }

    static void _dealloc_WebUIWebAuthenticationBrokerContinuationEventArgs(py::wrapper::Windows::UI::WebUI::WebUIWebAuthenticationBrokerContinuationEventArgs* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* WebUIWebAuthenticationBrokerContinuationEventArgs_get_Kind(py::wrapper::Windows::UI::WebUI::WebUIWebAuthenticationBrokerContinuationEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.WebUI.WebUIWebAuthenticationBrokerContinuationEventArgs", L"Kind");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Kind();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* WebUIWebAuthenticationBrokerContinuationEventArgs_get_PreviousExecutionState(py::wrapper::Windows::UI::WebUI::WebUIWebAuthenticationBrokerContinuationEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.WebUI.WebUIWebAuthenticationBrokerContinuationEventArgs", L"PreviousExecutionState");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.PreviousExecutionState();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* WebUIWebAuthenticationBrokerContinuationEventArgs_get_SplashScreen(py::wrapper::Windows::UI::WebUI::WebUIWebAuthenticationBrokerContinuationEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.WebUI.WebUIWebAuthenticationBrokerContinuationEventArgs", L"SplashScreen");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.SplashScreen();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* WebUIWebAuthenticationBrokerContinuationEventArgs_get_ContinuationData(py::wrapper::Windows::UI::WebUI::WebUIWebAuthenticationBrokerContinuationEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.WebUI.WebUIWebAuthenticationBrokerContinuationEventArgs", L"ContinuationData");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.ContinuationData();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* WebUIWebAuthenticationBrokerContinuationEventArgs_get_WebAuthenticationResult(py::wrapper::Windows::UI::WebUI::WebUIWebAuthenticationBrokerContinuationEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.WebUI.WebUIWebAuthenticationBrokerContinuationEventArgs", L"WebAuthenticationResult");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.WebAuthenticationResult();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* WebUIWebAuthenticationBrokerContinuationEventArgs_get_ActivatedOperation(py::wrapper::Windows::UI::WebUI::WebUIWebAuthenticationBrokerContinuationEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.WebUI.WebUIWebAuthenticationBrokerContinuationEventArgs", L"ActivatedOperation");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.ActivatedOperation();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_WebUIWebAuthenticationBrokerContinuationEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::WebUI::WebUIWebAuthenticationBrokerContinuationEventArgs>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_WebUIWebAuthenticationBrokerContinuationEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::WebUI::WebUIWebAuthenticationBrokerContinuationEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_WebUIWebAuthenticationBrokerContinuationEventArgs[] = {
        { "_assign_array_", _assign_array_WebUIWebAuthenticationBrokerContinuationEventArgs, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_WebUIWebAuthenticationBrokerContinuationEventArgs), METH_O | METH_STATIC, nullptr },
        { }};

    static PyGetSetDef _getset_WebUIWebAuthenticationBrokerContinuationEventArgs[] = {
        { "kind", reinterpret_cast<getter>(WebUIWebAuthenticationBrokerContinuationEventArgs_get_Kind), nullptr, nullptr, nullptr },
        { "previous_execution_state", reinterpret_cast<getter>(WebUIWebAuthenticationBrokerContinuationEventArgs_get_PreviousExecutionState), nullptr, nullptr, nullptr },
        { "splash_screen", reinterpret_cast<getter>(WebUIWebAuthenticationBrokerContinuationEventArgs_get_SplashScreen), nullptr, nullptr, nullptr },
        { "continuation_data", reinterpret_cast<getter>(WebUIWebAuthenticationBrokerContinuationEventArgs_get_ContinuationData), nullptr, nullptr, nullptr },
        { "web_authentication_result", reinterpret_cast<getter>(WebUIWebAuthenticationBrokerContinuationEventArgs_get_WebAuthenticationResult), nullptr, nullptr, nullptr },
        { "activated_operation", reinterpret_cast<getter>(WebUIWebAuthenticationBrokerContinuationEventArgs_get_ActivatedOperation), nullptr, nullptr, nullptr },
        { }};

    static PyType_Slot _type_slots_WebUIWebAuthenticationBrokerContinuationEventArgs[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_WebUIWebAuthenticationBrokerContinuationEventArgs) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_WebUIWebAuthenticationBrokerContinuationEventArgs) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_WebUIWebAuthenticationBrokerContinuationEventArgs) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_WebUIWebAuthenticationBrokerContinuationEventArgs) },
        { }};

    static PyType_Spec type_spec_WebUIWebAuthenticationBrokerContinuationEventArgs = {
        "winrt._winrt_windows_ui_webui.WebUIWebAuthenticationBrokerContinuationEventArgs",
        sizeof(py::wrapper::Windows::UI::WebUI::WebUIWebAuthenticationBrokerContinuationEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_WebUIWebAuthenticationBrokerContinuationEventArgs};

    // ----- IActivatedEventArgsDeferral interface --------------------

    static PyObject* _new_IActivatedEventArgsDeferral(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::UI::WebUI::IActivatedEventArgsDeferral>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::UI::WebUI::IActivatedEventArgsDeferral>::type_name);
        return nullptr;
    }

    static void _dealloc_IActivatedEventArgsDeferral(py::wrapper::Windows::UI::WebUI::IActivatedEventArgsDeferral* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* IActivatedEventArgsDeferral_get_ActivatedOperation(py::wrapper::Windows::UI::WebUI::IActivatedEventArgsDeferral* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.WebUI.IActivatedEventArgsDeferral", L"ActivatedOperation");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.ActivatedOperation();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_IActivatedEventArgsDeferral(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::WebUI::IActivatedEventArgsDeferral>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_IActivatedEventArgsDeferral(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::WebUI::IActivatedEventArgsDeferral>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_IActivatedEventArgsDeferral[] = {
        { "_assign_array_", _assign_array_IActivatedEventArgsDeferral, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_IActivatedEventArgsDeferral), METH_O | METH_STATIC, nullptr },
        { }};

    static PyGetSetDef _getset_IActivatedEventArgsDeferral[] = {
        { "activated_operation", reinterpret_cast<getter>(IActivatedEventArgsDeferral_get_ActivatedOperation), nullptr, nullptr, nullptr },
        { }};

    static PyType_Slot _type_slots_IActivatedEventArgsDeferral[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_IActivatedEventArgsDeferral) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_IActivatedEventArgsDeferral) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_IActivatedEventArgsDeferral) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_IActivatedEventArgsDeferral) },
        { }};

    static PyType_Spec type_spec_IActivatedEventArgsDeferral = {
        "winrt._winrt_windows_ui_webui.IActivatedEventArgsDeferral",
        sizeof(py::wrapper::Windows::UI::WebUI::IActivatedEventArgsDeferral),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_IActivatedEventArgsDeferral};

    struct ImplementsIActivatedEventArgsDeferral : py::ImplementsInterfaceT<ImplementsIActivatedEventArgsDeferral, winrt::Windows::UI::WebUI::IActivatedEventArgsDeferral>
    {
        ImplementsIActivatedEventArgsDeferral() = delete;
        ImplementsIActivatedEventArgsDeferral(PyObject* py_obj, winrt::impl::inspectable_abi* runtime_class) : py::ImplementsInterfaceT<ImplementsIActivatedEventArgsDeferral, winrt::Windows::UI::WebUI::IActivatedEventArgsDeferral>(py_obj, runtime_class)
        {
        }

        auto ActivatedOperation()
        {
            try
            {
                py::pyobj_handle self{this->get_py_obj()};

                py::pyobj_handle value{PyObject_GetAttrString(self.get(), "activated_operation")};
                if (!value)
                {
                    throw python_exception();
                }

                return py::convert_to<winrt::Windows::UI::WebUI::ActivatedOperation>(value.get());
            }
            catch (python_exception)
            {
                py::write_unraisable_and_throw();
            }
        }
    };

    static PyObject* _guid_ImplementsIActivatedEventArgsDeferral(PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::guid_of<winrt::Windows::UI::WebUI::IActivatedEventArgsDeferral>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _make_ImplementsIActivatedEventArgsDeferral(PyObject* /*unused*/, PyObject* args) noexcept
    {
        try
        {
            PyObject* py_obj;
            winrt::impl::inspectable_abi* runtime_class;

            if (!PyArg_ParseTuple(args, "On", &py_obj, &runtime_class))
            {
                return nullptr;
            }

            auto iface{std::make_unique<ImplementsIActivatedEventArgsDeferral>(py_obj, runtime_class)};

            return PyLong_FromVoidPtr(iface.release());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef methods_ImplementsIActivatedEventArgsDeferral[] = {
        { "_guid_", reinterpret_cast<PyCFunction>(_guid_ImplementsIActivatedEventArgsDeferral), METH_NOARGS | METH_STATIC, nullptr },
        { "_make_", reinterpret_cast<PyCFunction>(_make_ImplementsIActivatedEventArgsDeferral), METH_VARARGS | METH_STATIC, nullptr },
        { }};

    static PyType_Slot type_slots_ImplementsIActivatedEventArgsDeferral[] = {
        { Py_tp_methods, reinterpret_cast<void*>(methods_ImplementsIActivatedEventArgsDeferral) },
        { }};

    static PyType_Spec type_spec_ImplementsIActivatedEventArgsDeferral = {
        "winrt._winrt_windows_ui_webui.ImplementsIActivatedEventArgsDeferral",
        0,
        0,
        Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,
        type_slots_ImplementsIActivatedEventArgsDeferral};

    // ----- IWebUIBackgroundTaskInstance interface --------------------

    static PyObject* _new_IWebUIBackgroundTaskInstance(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::UI::WebUI::IWebUIBackgroundTaskInstance>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::UI::WebUI::IWebUIBackgroundTaskInstance>::type_name);
        return nullptr;
    }

    static void _dealloc_IWebUIBackgroundTaskInstance(py::wrapper::Windows::UI::WebUI::IWebUIBackgroundTaskInstance* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* IWebUIBackgroundTaskInstance_get_Succeeded(py::wrapper::Windows::UI::WebUI::IWebUIBackgroundTaskInstance* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.WebUI.IWebUIBackgroundTaskInstance", L"Succeeded");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Succeeded();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int IWebUIBackgroundTaskInstance_put_Succeeded(py::wrapper::Windows::UI::WebUI::IWebUIBackgroundTaskInstance* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.WebUI.IWebUIBackgroundTaskInstance", L"Succeeded");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<bool>(arg);

            {
                auto _gil = release_gil();
                self->obj.Succeeded(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* _assign_array_IWebUIBackgroundTaskInstance(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::WebUI::IWebUIBackgroundTaskInstance>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_IWebUIBackgroundTaskInstance(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::WebUI::IWebUIBackgroundTaskInstance>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_IWebUIBackgroundTaskInstance[] = {
        { "_assign_array_", _assign_array_IWebUIBackgroundTaskInstance, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_IWebUIBackgroundTaskInstance), METH_O | METH_STATIC, nullptr },
        { }};

    static PyGetSetDef _getset_IWebUIBackgroundTaskInstance[] = {
        { "succeeded", reinterpret_cast<getter>(IWebUIBackgroundTaskInstance_get_Succeeded), reinterpret_cast<setter>(IWebUIBackgroundTaskInstance_put_Succeeded), nullptr, nullptr },
        { }};

    static PyType_Slot _type_slots_IWebUIBackgroundTaskInstance[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_IWebUIBackgroundTaskInstance) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_IWebUIBackgroundTaskInstance) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_IWebUIBackgroundTaskInstance) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_IWebUIBackgroundTaskInstance) },
        { }};

    static PyType_Spec type_spec_IWebUIBackgroundTaskInstance = {
        "winrt._winrt_windows_ui_webui.IWebUIBackgroundTaskInstance",
        sizeof(py::wrapper::Windows::UI::WebUI::IWebUIBackgroundTaskInstance),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_IWebUIBackgroundTaskInstance};

    struct ImplementsIWebUIBackgroundTaskInstance : py::ImplementsInterfaceT<ImplementsIWebUIBackgroundTaskInstance, winrt::Windows::UI::WebUI::IWebUIBackgroundTaskInstance>
    {
        ImplementsIWebUIBackgroundTaskInstance() = delete;
        ImplementsIWebUIBackgroundTaskInstance(PyObject* py_obj, winrt::impl::inspectable_abi* runtime_class) : py::ImplementsInterfaceT<ImplementsIWebUIBackgroundTaskInstance, winrt::Windows::UI::WebUI::IWebUIBackgroundTaskInstance>(py_obj, runtime_class)
        {
        }

        auto Succeeded()
        {
            try
            {
                py::pyobj_handle self{this->get_py_obj()};

                py::pyobj_handle value{PyObject_GetAttrString(self.get(), "succeeded")};
                if (!value)
                {
                    throw python_exception();
                }

                return py::convert_to<bool>(value.get());
            }
            catch (python_exception)
            {
                py::write_unraisable_and_throw();
            }
        }

        void Succeeded(bool param0)
        {
            try
            {
                py::pyobj_handle self{this->get_py_obj()};

                py::pyobj_handle value{py::convert(param0)};
                if (!value)
                {
                    throw python_exception();
                }

                if (PyObject_SetAttrString(self.get(), "succeeded", value.get()) == -1)
                {
                    throw python_exception();
                }
            }
            catch (python_exception)
            {
                py::write_unraisable_and_throw();
            }
        }
    };

    static PyObject* _guid_ImplementsIWebUIBackgroundTaskInstance(PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::guid_of<winrt::Windows::UI::WebUI::IWebUIBackgroundTaskInstance>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _make_ImplementsIWebUIBackgroundTaskInstance(PyObject* /*unused*/, PyObject* args) noexcept
    {
        try
        {
            PyObject* py_obj;
            winrt::impl::inspectable_abi* runtime_class;

            if (!PyArg_ParseTuple(args, "On", &py_obj, &runtime_class))
            {
                return nullptr;
            }

            auto iface{std::make_unique<ImplementsIWebUIBackgroundTaskInstance>(py_obj, runtime_class)};

            return PyLong_FromVoidPtr(iface.release());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef methods_ImplementsIWebUIBackgroundTaskInstance[] = {
        { "_guid_", reinterpret_cast<PyCFunction>(_guid_ImplementsIWebUIBackgroundTaskInstance), METH_NOARGS | METH_STATIC, nullptr },
        { "_make_", reinterpret_cast<PyCFunction>(_make_ImplementsIWebUIBackgroundTaskInstance), METH_VARARGS | METH_STATIC, nullptr },
        { }};

    static PyType_Slot type_slots_ImplementsIWebUIBackgroundTaskInstance[] = {
        { Py_tp_methods, reinterpret_cast<void*>(methods_ImplementsIWebUIBackgroundTaskInstance) },
        { }};

    static PyType_Spec type_spec_ImplementsIWebUIBackgroundTaskInstance = {
        "winrt._winrt_windows_ui_webui.ImplementsIWebUIBackgroundTaskInstance",
        0,
        0,
        Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,
        type_slots_ImplementsIWebUIBackgroundTaskInstance};

    // ----- IWebUINavigatedEventArgs interface --------------------

    static PyObject* _new_IWebUINavigatedEventArgs(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::UI::WebUI::IWebUINavigatedEventArgs>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::UI::WebUI::IWebUINavigatedEventArgs>::type_name);
        return nullptr;
    }

    static void _dealloc_IWebUINavigatedEventArgs(py::wrapper::Windows::UI::WebUI::IWebUINavigatedEventArgs* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* IWebUINavigatedEventArgs_get_NavigatedOperation(py::wrapper::Windows::UI::WebUI::IWebUINavigatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.WebUI.IWebUINavigatedEventArgs", L"NavigatedOperation");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.NavigatedOperation();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_IWebUINavigatedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::WebUI::IWebUINavigatedEventArgs>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_IWebUINavigatedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::WebUI::IWebUINavigatedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_IWebUINavigatedEventArgs[] = {
        { "_assign_array_", _assign_array_IWebUINavigatedEventArgs, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_IWebUINavigatedEventArgs), METH_O | METH_STATIC, nullptr },
        { }};

    static PyGetSetDef _getset_IWebUINavigatedEventArgs[] = {
        { "navigated_operation", reinterpret_cast<getter>(IWebUINavigatedEventArgs_get_NavigatedOperation), nullptr, nullptr, nullptr },
        { }};

    static PyType_Slot _type_slots_IWebUINavigatedEventArgs[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_IWebUINavigatedEventArgs) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_IWebUINavigatedEventArgs) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_IWebUINavigatedEventArgs) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_IWebUINavigatedEventArgs) },
        { }};

    static PyType_Spec type_spec_IWebUINavigatedEventArgs = {
        "winrt._winrt_windows_ui_webui.IWebUINavigatedEventArgs",
        sizeof(py::wrapper::Windows::UI::WebUI::IWebUINavigatedEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_IWebUINavigatedEventArgs};

    struct ImplementsIWebUINavigatedEventArgs : py::ImplementsInterfaceT<ImplementsIWebUINavigatedEventArgs, winrt::Windows::UI::WebUI::IWebUINavigatedEventArgs>
    {
        ImplementsIWebUINavigatedEventArgs() = delete;
        ImplementsIWebUINavigatedEventArgs(PyObject* py_obj, winrt::impl::inspectable_abi* runtime_class) : py::ImplementsInterfaceT<ImplementsIWebUINavigatedEventArgs, winrt::Windows::UI::WebUI::IWebUINavigatedEventArgs>(py_obj, runtime_class)
        {
        }

        auto NavigatedOperation()
        {
            try
            {
                py::pyobj_handle self{this->get_py_obj()};

                py::pyobj_handle value{PyObject_GetAttrString(self.get(), "navigated_operation")};
                if (!value)
                {
                    throw python_exception();
                }

                return py::convert_to<winrt::Windows::UI::WebUI::WebUINavigatedOperation>(value.get());
            }
            catch (python_exception)
            {
                py::write_unraisable_and_throw();
            }
        }
    };

    static PyObject* _guid_ImplementsIWebUINavigatedEventArgs(PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::guid_of<winrt::Windows::UI::WebUI::IWebUINavigatedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _make_ImplementsIWebUINavigatedEventArgs(PyObject* /*unused*/, PyObject* args) noexcept
    {
        try
        {
            PyObject* py_obj;
            winrt::impl::inspectable_abi* runtime_class;

            if (!PyArg_ParseTuple(args, "On", &py_obj, &runtime_class))
            {
                return nullptr;
            }

            auto iface{std::make_unique<ImplementsIWebUINavigatedEventArgs>(py_obj, runtime_class)};

            return PyLong_FromVoidPtr(iface.release());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef methods_ImplementsIWebUINavigatedEventArgs[] = {
        { "_guid_", reinterpret_cast<PyCFunction>(_guid_ImplementsIWebUINavigatedEventArgs), METH_NOARGS | METH_STATIC, nullptr },
        { "_make_", reinterpret_cast<PyCFunction>(_make_ImplementsIWebUINavigatedEventArgs), METH_VARARGS | METH_STATIC, nullptr },
        { }};

    static PyType_Slot type_slots_ImplementsIWebUINavigatedEventArgs[] = {
        { Py_tp_methods, reinterpret_cast<void*>(methods_ImplementsIWebUINavigatedEventArgs) },
        { }};

    static PyType_Spec type_spec_ImplementsIWebUINavigatedEventArgs = {
        "winrt._winrt_windows_ui_webui.ImplementsIWebUINavigatedEventArgs",
        0,
        0,
        Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,
        type_slots_ImplementsIWebUINavigatedEventArgs};

    // ----- Windows.UI.WebUI Initialization --------------------

    PyDoc_STRVAR(module_doc, "Windows.UI.WebUI");

    static PyModuleDef module_def = {
        PyModuleDef_HEAD_INIT,
        "_winrt_windows_ui_webui",
        module_doc,
        0,
        nullptr,
        nullptr,
        nullptr,
        nullptr,
        nullptr};
} // py::cpp::Windows::UI::WebUI

PyMODINIT_FUNC PyInit__winrt_windows_ui_webui(void) noexcept
{
    using namespace py::cpp::Windows::UI::WebUI;

    if (py::import_winrt_runtime() == -1)
    {
        return nullptr;
    }

    py::pyobj_handle module{PyModule_Create(&module_def)};

    if (!module)
    {
        return nullptr;
    }

    auto object_type = py::get_object_type();
    if (!object_type)
    {
        return nullptr;
    }

    py::pyobj_handle object_bases{PyTuple_Pack(1, object_type)};

    if (!object_bases)
    {
        return nullptr;
    }

    py::pytype_handle ActivatedDeferral_type{py::register_python_type(module.get(), &type_spec_ActivatedDeferral, object_bases.get(), nullptr)};
    if (!ActivatedDeferral_type)
    {
        return nullptr;
    }

    py::pytype_handle ActivatedOperation_type{py::register_python_type(module.get(), &type_spec_ActivatedOperation, object_bases.get(), nullptr)};
    if (!ActivatedOperation_type)
    {
        return nullptr;
    }

    py::pytype_handle BackgroundActivatedEventArgs_type{py::register_python_type(module.get(), &type_spec_BackgroundActivatedEventArgs, object_bases.get(), nullptr)};
    if (!BackgroundActivatedEventArgs_type)
    {
        return nullptr;
    }

    py::pytype_handle EnteredBackgroundEventArgs_type{py::register_python_type(module.get(), &type_spec_EnteredBackgroundEventArgs, object_bases.get(), nullptr)};
    if (!EnteredBackgroundEventArgs_type)
    {
        return nullptr;
    }

    py::pytype_handle HtmlPrintDocumentSource_type{py::register_python_type(module.get(), &type_spec_HtmlPrintDocumentSource, object_bases.get(), nullptr)};
    if (!HtmlPrintDocumentSource_type)
    {
        return nullptr;
    }

    py::pytype_handle LeavingBackgroundEventArgs_type{py::register_python_type(module.get(), &type_spec_LeavingBackgroundEventArgs, object_bases.get(), nullptr)};
    if (!LeavingBackgroundEventArgs_type)
    {
        return nullptr;
    }

    py::pytype_handle NewWebUIViewCreatedEventArgs_type{py::register_python_type(module.get(), &type_spec_NewWebUIViewCreatedEventArgs, object_bases.get(), nullptr)};
    if (!NewWebUIViewCreatedEventArgs_type)
    {
        return nullptr;
    }

    py::pytype_handle SuspendingDeferral_type{py::register_python_type(module.get(), &type_spec_SuspendingDeferral, object_bases.get(), nullptr)};
    if (!SuspendingDeferral_type)
    {
        return nullptr;
    }

    py::pytype_handle SuspendingEventArgs_type{py::register_python_type(module.get(), &type_spec_SuspendingEventArgs, object_bases.get(), nullptr)};
    if (!SuspendingEventArgs_type)
    {
        return nullptr;
    }

    py::pytype_handle SuspendingOperation_type{py::register_python_type(module.get(), &type_spec_SuspendingOperation, object_bases.get(), nullptr)};
    if (!SuspendingOperation_type)
    {
        return nullptr;
    }

    py::pyobj_handle type_WebUIApplication_Static{PyType_FromSpec(&type_spec_WebUIApplication_Static)};
    if (!type_WebUIApplication_Static)
    {
        return nullptr;
    }

    py::pytype_handle WebUIApplication_type{py::register_python_type(module.get(), &type_spec_WebUIApplication, object_bases.get(), reinterpret_cast<PyTypeObject*>(type_WebUIApplication_Static.get()))};
    if (!WebUIApplication_type)
    {
        return nullptr;
    }

    py::pytype_handle WebUIAppointmentsProviderAddAppointmentActivatedEventArgs_type{py::register_python_type(module.get(), &type_spec_WebUIAppointmentsProviderAddAppointmentActivatedEventArgs, object_bases.get(), nullptr)};
    if (!WebUIAppointmentsProviderAddAppointmentActivatedEventArgs_type)
    {
        return nullptr;
    }

    py::pytype_handle WebUIAppointmentsProviderRemoveAppointmentActivatedEventArgs_type{py::register_python_type(module.get(), &type_spec_WebUIAppointmentsProviderRemoveAppointmentActivatedEventArgs, object_bases.get(), nullptr)};
    if (!WebUIAppointmentsProviderRemoveAppointmentActivatedEventArgs_type)
    {
        return nullptr;
    }

    py::pytype_handle WebUIAppointmentsProviderReplaceAppointmentActivatedEventArgs_type{py::register_python_type(module.get(), &type_spec_WebUIAppointmentsProviderReplaceAppointmentActivatedEventArgs, object_bases.get(), nullptr)};
    if (!WebUIAppointmentsProviderReplaceAppointmentActivatedEventArgs_type)
    {
        return nullptr;
    }

    py::pytype_handle WebUIAppointmentsProviderShowAppointmentDetailsActivatedEventArgs_type{py::register_python_type(module.get(), &type_spec_WebUIAppointmentsProviderShowAppointmentDetailsActivatedEventArgs, object_bases.get(), nullptr)};
    if (!WebUIAppointmentsProviderShowAppointmentDetailsActivatedEventArgs_type)
    {
        return nullptr;
    }

    py::pytype_handle WebUIAppointmentsProviderShowTimeFrameActivatedEventArgs_type{py::register_python_type(module.get(), &type_spec_WebUIAppointmentsProviderShowTimeFrameActivatedEventArgs, object_bases.get(), nullptr)};
    if (!WebUIAppointmentsProviderShowTimeFrameActivatedEventArgs_type)
    {
        return nullptr;
    }

    py::pyobj_handle type_WebUIBackgroundTaskInstance_Static{PyType_FromSpec(&type_spec_WebUIBackgroundTaskInstance_Static)};
    if (!type_WebUIBackgroundTaskInstance_Static)
    {
        return nullptr;
    }

    py::pytype_handle WebUIBackgroundTaskInstance_type{py::register_python_type(module.get(), &type_spec_WebUIBackgroundTaskInstance, object_bases.get(), reinterpret_cast<PyTypeObject*>(type_WebUIBackgroundTaskInstance_Static.get()))};
    if (!WebUIBackgroundTaskInstance_type)
    {
        return nullptr;
    }

    py::pytype_handle WebUIBackgroundTaskInstanceRuntimeClass_type{py::register_python_type(module.get(), &type_spec_WebUIBackgroundTaskInstanceRuntimeClass, object_bases.get(), nullptr)};
    if (!WebUIBackgroundTaskInstanceRuntimeClass_type)
    {
        return nullptr;
    }

    py::pytype_handle WebUIBarcodeScannerPreviewActivatedEventArgs_type{py::register_python_type(module.get(), &type_spec_WebUIBarcodeScannerPreviewActivatedEventArgs, object_bases.get(), nullptr)};
    if (!WebUIBarcodeScannerPreviewActivatedEventArgs_type)
    {
        return nullptr;
    }

    py::pytype_handle WebUICachedFileUpdaterActivatedEventArgs_type{py::register_python_type(module.get(), &type_spec_WebUICachedFileUpdaterActivatedEventArgs, object_bases.get(), nullptr)};
    if (!WebUICachedFileUpdaterActivatedEventArgs_type)
    {
        return nullptr;
    }

    py::pytype_handle WebUICameraSettingsActivatedEventArgs_type{py::register_python_type(module.get(), &type_spec_WebUICameraSettingsActivatedEventArgs, object_bases.get(), nullptr)};
    if (!WebUICameraSettingsActivatedEventArgs_type)
    {
        return nullptr;
    }

    py::pytype_handle WebUICommandLineActivatedEventArgs_type{py::register_python_type(module.get(), &type_spec_WebUICommandLineActivatedEventArgs, object_bases.get(), nullptr)};
    if (!WebUICommandLineActivatedEventArgs_type)
    {
        return nullptr;
    }

    py::pytype_handle WebUIContactCallActivatedEventArgs_type{py::register_python_type(module.get(), &type_spec_WebUIContactCallActivatedEventArgs, object_bases.get(), nullptr)};
    if (!WebUIContactCallActivatedEventArgs_type)
    {
        return nullptr;
    }

    py::pytype_handle WebUIContactMapActivatedEventArgs_type{py::register_python_type(module.get(), &type_spec_WebUIContactMapActivatedEventArgs, object_bases.get(), nullptr)};
    if (!WebUIContactMapActivatedEventArgs_type)
    {
        return nullptr;
    }

    py::pytype_handle WebUIContactMessageActivatedEventArgs_type{py::register_python_type(module.get(), &type_spec_WebUIContactMessageActivatedEventArgs, object_bases.get(), nullptr)};
    if (!WebUIContactMessageActivatedEventArgs_type)
    {
        return nullptr;
    }

    py::pytype_handle WebUIContactPanelActivatedEventArgs_type{py::register_python_type(module.get(), &type_spec_WebUIContactPanelActivatedEventArgs, object_bases.get(), nullptr)};
    if (!WebUIContactPanelActivatedEventArgs_type)
    {
        return nullptr;
    }

    py::pytype_handle WebUIContactPickerActivatedEventArgs_type{py::register_python_type(module.get(), &type_spec_WebUIContactPickerActivatedEventArgs, object_bases.get(), nullptr)};
    if (!WebUIContactPickerActivatedEventArgs_type)
    {
        return nullptr;
    }

    py::pytype_handle WebUIContactPostActivatedEventArgs_type{py::register_python_type(module.get(), &type_spec_WebUIContactPostActivatedEventArgs, object_bases.get(), nullptr)};
    if (!WebUIContactPostActivatedEventArgs_type)
    {
        return nullptr;
    }

    py::pytype_handle WebUIContactVideoCallActivatedEventArgs_type{py::register_python_type(module.get(), &type_spec_WebUIContactVideoCallActivatedEventArgs, object_bases.get(), nullptr)};
    if (!WebUIContactVideoCallActivatedEventArgs_type)
    {
        return nullptr;
    }

    py::pytype_handle WebUIDeviceActivatedEventArgs_type{py::register_python_type(module.get(), &type_spec_WebUIDeviceActivatedEventArgs, object_bases.get(), nullptr)};
    if (!WebUIDeviceActivatedEventArgs_type)
    {
        return nullptr;
    }

    py::pytype_handle WebUIDevicePairingActivatedEventArgs_type{py::register_python_type(module.get(), &type_spec_WebUIDevicePairingActivatedEventArgs, object_bases.get(), nullptr)};
    if (!WebUIDevicePairingActivatedEventArgs_type)
    {
        return nullptr;
    }

    py::pytype_handle WebUIDialReceiverActivatedEventArgs_type{py::register_python_type(module.get(), &type_spec_WebUIDialReceiverActivatedEventArgs, object_bases.get(), nullptr)};
    if (!WebUIDialReceiverActivatedEventArgs_type)
    {
        return nullptr;
    }

    py::pytype_handle WebUIFileActivatedEventArgs_type{py::register_python_type(module.get(), &type_spec_WebUIFileActivatedEventArgs, object_bases.get(), nullptr)};
    if (!WebUIFileActivatedEventArgs_type)
    {
        return nullptr;
    }

    py::pytype_handle WebUIFileOpenPickerActivatedEventArgs_type{py::register_python_type(module.get(), &type_spec_WebUIFileOpenPickerActivatedEventArgs, object_bases.get(), nullptr)};
    if (!WebUIFileOpenPickerActivatedEventArgs_type)
    {
        return nullptr;
    }

    py::pytype_handle WebUIFileOpenPickerContinuationEventArgs_type{py::register_python_type(module.get(), &type_spec_WebUIFileOpenPickerContinuationEventArgs, object_bases.get(), nullptr)};
    if (!WebUIFileOpenPickerContinuationEventArgs_type)
    {
        return nullptr;
    }

    py::pytype_handle WebUIFileSavePickerActivatedEventArgs_type{py::register_python_type(module.get(), &type_spec_WebUIFileSavePickerActivatedEventArgs, object_bases.get(), nullptr)};
    if (!WebUIFileSavePickerActivatedEventArgs_type)
    {
        return nullptr;
    }

    py::pytype_handle WebUIFileSavePickerContinuationEventArgs_type{py::register_python_type(module.get(), &type_spec_WebUIFileSavePickerContinuationEventArgs, object_bases.get(), nullptr)};
    if (!WebUIFileSavePickerContinuationEventArgs_type)
    {
        return nullptr;
    }

    py::pytype_handle WebUIFolderPickerContinuationEventArgs_type{py::register_python_type(module.get(), &type_spec_WebUIFolderPickerContinuationEventArgs, object_bases.get(), nullptr)};
    if (!WebUIFolderPickerContinuationEventArgs_type)
    {
        return nullptr;
    }

    py::pytype_handle WebUILaunchActivatedEventArgs_type{py::register_python_type(module.get(), &type_spec_WebUILaunchActivatedEventArgs, object_bases.get(), nullptr)};
    if (!WebUILaunchActivatedEventArgs_type)
    {
        return nullptr;
    }

    py::pytype_handle WebUILockScreenActivatedEventArgs_type{py::register_python_type(module.get(), &type_spec_WebUILockScreenActivatedEventArgs, object_bases.get(), nullptr)};
    if (!WebUILockScreenActivatedEventArgs_type)
    {
        return nullptr;
    }

    py::pytype_handle WebUILockScreenCallActivatedEventArgs_type{py::register_python_type(module.get(), &type_spec_WebUILockScreenCallActivatedEventArgs, object_bases.get(), nullptr)};
    if (!WebUILockScreenCallActivatedEventArgs_type)
    {
        return nullptr;
    }

    py::pytype_handle WebUILockScreenComponentActivatedEventArgs_type{py::register_python_type(module.get(), &type_spec_WebUILockScreenComponentActivatedEventArgs, object_bases.get(), nullptr)};
    if (!WebUILockScreenComponentActivatedEventArgs_type)
    {
        return nullptr;
    }

    py::pytype_handle WebUINavigatedDeferral_type{py::register_python_type(module.get(), &type_spec_WebUINavigatedDeferral, object_bases.get(), nullptr)};
    if (!WebUINavigatedDeferral_type)
    {
        return nullptr;
    }

    py::pytype_handle WebUINavigatedEventArgs_type{py::register_python_type(module.get(), &type_spec_WebUINavigatedEventArgs, object_bases.get(), nullptr)};
    if (!WebUINavigatedEventArgs_type)
    {
        return nullptr;
    }

    py::pytype_handle WebUINavigatedOperation_type{py::register_python_type(module.get(), &type_spec_WebUINavigatedOperation, object_bases.get(), nullptr)};
    if (!WebUINavigatedOperation_type)
    {
        return nullptr;
    }

    py::pytype_handle WebUIPhoneCallActivatedEventArgs_type{py::register_python_type(module.get(), &type_spec_WebUIPhoneCallActivatedEventArgs, object_bases.get(), nullptr)};
    if (!WebUIPhoneCallActivatedEventArgs_type)
    {
        return nullptr;
    }

    py::pytype_handle WebUIPrint3DWorkflowActivatedEventArgs_type{py::register_python_type(module.get(), &type_spec_WebUIPrint3DWorkflowActivatedEventArgs, object_bases.get(), nullptr)};
    if (!WebUIPrint3DWorkflowActivatedEventArgs_type)
    {
        return nullptr;
    }

    py::pytype_handle WebUIPrintTaskSettingsActivatedEventArgs_type{py::register_python_type(module.get(), &type_spec_WebUIPrintTaskSettingsActivatedEventArgs, object_bases.get(), nullptr)};
    if (!WebUIPrintTaskSettingsActivatedEventArgs_type)
    {
        return nullptr;
    }

    py::pytype_handle WebUIPrintWorkflowForegroundTaskActivatedEventArgs_type{py::register_python_type(module.get(), &type_spec_WebUIPrintWorkflowForegroundTaskActivatedEventArgs, object_bases.get(), nullptr)};
    if (!WebUIPrintWorkflowForegroundTaskActivatedEventArgs_type)
    {
        return nullptr;
    }

    py::pytype_handle WebUIProtocolActivatedEventArgs_type{py::register_python_type(module.get(), &type_spec_WebUIProtocolActivatedEventArgs, object_bases.get(), nullptr)};
    if (!WebUIProtocolActivatedEventArgs_type)
    {
        return nullptr;
    }

    py::pytype_handle WebUIProtocolForResultsActivatedEventArgs_type{py::register_python_type(module.get(), &type_spec_WebUIProtocolForResultsActivatedEventArgs, object_bases.get(), nullptr)};
    if (!WebUIProtocolForResultsActivatedEventArgs_type)
    {
        return nullptr;
    }

    py::pytype_handle WebUIRestrictedLaunchActivatedEventArgs_type{py::register_python_type(module.get(), &type_spec_WebUIRestrictedLaunchActivatedEventArgs, object_bases.get(), nullptr)};
    if (!WebUIRestrictedLaunchActivatedEventArgs_type)
    {
        return nullptr;
    }

    py::pytype_handle WebUISearchActivatedEventArgs_type{py::register_python_type(module.get(), &type_spec_WebUISearchActivatedEventArgs, object_bases.get(), nullptr)};
    if (!WebUISearchActivatedEventArgs_type)
    {
        return nullptr;
    }

    py::pytype_handle WebUIShareTargetActivatedEventArgs_type{py::register_python_type(module.get(), &type_spec_WebUIShareTargetActivatedEventArgs, object_bases.get(), nullptr)};
    if (!WebUIShareTargetActivatedEventArgs_type)
    {
        return nullptr;
    }

    py::pytype_handle WebUIStartupTaskActivatedEventArgs_type{py::register_python_type(module.get(), &type_spec_WebUIStartupTaskActivatedEventArgs, object_bases.get(), nullptr)};
    if (!WebUIStartupTaskActivatedEventArgs_type)
    {
        return nullptr;
    }

    py::pytype_handle WebUIToastNotificationActivatedEventArgs_type{py::register_python_type(module.get(), &type_spec_WebUIToastNotificationActivatedEventArgs, object_bases.get(), nullptr)};
    if (!WebUIToastNotificationActivatedEventArgs_type)
    {
        return nullptr;
    }

    py::pytype_handle WebUIUserDataAccountProviderActivatedEventArgs_type{py::register_python_type(module.get(), &type_spec_WebUIUserDataAccountProviderActivatedEventArgs, object_bases.get(), nullptr)};
    if (!WebUIUserDataAccountProviderActivatedEventArgs_type)
    {
        return nullptr;
    }

    py::pyobj_handle type_WebUIView_Static{PyType_FromSpec(&type_spec_WebUIView_Static)};
    if (!type_WebUIView_Static)
    {
        return nullptr;
    }

    py::pytype_handle WebUIView_type{py::register_python_type(module.get(), &type_spec_WebUIView, object_bases.get(), reinterpret_cast<PyTypeObject*>(type_WebUIView_Static.get()))};
    if (!WebUIView_type)
    {
        return nullptr;
    }

    py::pytype_handle WebUIVoiceCommandActivatedEventArgs_type{py::register_python_type(module.get(), &type_spec_WebUIVoiceCommandActivatedEventArgs, object_bases.get(), nullptr)};
    if (!WebUIVoiceCommandActivatedEventArgs_type)
    {
        return nullptr;
    }

    py::pytype_handle WebUIWalletActionActivatedEventArgs_type{py::register_python_type(module.get(), &type_spec_WebUIWalletActionActivatedEventArgs, object_bases.get(), nullptr)};
    if (!WebUIWalletActionActivatedEventArgs_type)
    {
        return nullptr;
    }

    py::pytype_handle WebUIWebAccountProviderActivatedEventArgs_type{py::register_python_type(module.get(), &type_spec_WebUIWebAccountProviderActivatedEventArgs, object_bases.get(), nullptr)};
    if (!WebUIWebAccountProviderActivatedEventArgs_type)
    {
        return nullptr;
    }

    py::pytype_handle WebUIWebAuthenticationBrokerContinuationEventArgs_type{py::register_python_type(module.get(), &type_spec_WebUIWebAuthenticationBrokerContinuationEventArgs, object_bases.get(), nullptr)};
    if (!WebUIWebAuthenticationBrokerContinuationEventArgs_type)
    {
        return nullptr;
    }

    py::pytype_handle IActivatedEventArgsDeferral_type{py::register_python_type(module.get(), &type_spec_IActivatedEventArgsDeferral, object_bases.get(), nullptr)};
    if (!IActivatedEventArgsDeferral_type)
    {
        return nullptr;
    }

    py::pytype_handle ImplementsIActivatedEventArgsDeferral_type{reinterpret_cast<PyTypeObject*>(PyType_FromModuleAndSpec(module.get(), &type_spec_ImplementsIActivatedEventArgsDeferral, nullptr))};
    if (!ImplementsIActivatedEventArgsDeferral_type)
    {
        return nullptr;
    }

    if (PyModule_AddType(module.get(), ImplementsIActivatedEventArgsDeferral_type.get()) == -1)
    {
        return nullptr;
    }

    py::pytype_handle IWebUIBackgroundTaskInstance_type{py::register_python_type(module.get(), &type_spec_IWebUIBackgroundTaskInstance, object_bases.get(), nullptr)};
    if (!IWebUIBackgroundTaskInstance_type)
    {
        return nullptr;
    }

    py::pytype_handle ImplementsIWebUIBackgroundTaskInstance_type{reinterpret_cast<PyTypeObject*>(PyType_FromModuleAndSpec(module.get(), &type_spec_ImplementsIWebUIBackgroundTaskInstance, nullptr))};
    if (!ImplementsIWebUIBackgroundTaskInstance_type)
    {
        return nullptr;
    }

    if (PyModule_AddType(module.get(), ImplementsIWebUIBackgroundTaskInstance_type.get()) == -1)
    {
        return nullptr;
    }

    py::pytype_handle IWebUINavigatedEventArgs_type{py::register_python_type(module.get(), &type_spec_IWebUINavigatedEventArgs, object_bases.get(), nullptr)};
    if (!IWebUINavigatedEventArgs_type)
    {
        return nullptr;
    }

    py::pytype_handle ImplementsIWebUINavigatedEventArgs_type{reinterpret_cast<PyTypeObject*>(PyType_FromModuleAndSpec(module.get(), &type_spec_ImplementsIWebUINavigatedEventArgs, nullptr))};
    if (!ImplementsIWebUINavigatedEventArgs_type)
    {
        return nullptr;
    }

    if (PyModule_AddType(module.get(), ImplementsIWebUINavigatedEventArgs_type.get()) == -1)
    {
        return nullptr;
    }


    return module.detach();
}
