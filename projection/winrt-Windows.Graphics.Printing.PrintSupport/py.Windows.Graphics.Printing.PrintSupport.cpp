// WARNING: Please don't edit this file. It was generated by Python/WinRT v2.2.0

#include "py.Windows.Graphics.Printing.PrintSupport.h"

namespace py::cpp::Windows::Graphics::Printing::PrintSupport
{
    // ----- PrintSupportExtensionSession class --------------------

    static PyObject* _new_PrintSupportExtensionSession(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Graphics::Printing::PrintSupport::PrintSupportExtensionSession>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Graphics::Printing::PrintSupport::PrintSupportExtensionSession>::type_name);
        return nullptr;
    }

    static void _dealloc_PrintSupportExtensionSession(py::wrapper::Windows::Graphics::Printing::PrintSupport::PrintSupportExtensionSession* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* PrintSupportExtensionSession_Start(py::wrapper::Windows::Graphics::Printing::PrintSupport::PrintSupportExtensionSession* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Graphics.Printing.PrintSupport.PrintSupportExtensionSession", L"Start", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                self->obj.Start();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PrintSupportExtensionSession_get_Printer(py::wrapper::Windows::Graphics::Printing::PrintSupport::PrintSupportExtensionSession* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Graphics.Printing.PrintSupport.PrintSupportExtensionSession", L"Printer");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Printer());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PrintSupportExtensionSession_add_PrintDeviceCapabilitiesChanged(py::wrapper::Windows::Graphics::Printing::PrintSupport::PrintSupportExtensionSession* self, PyObject* arg) noexcept
    {
        try
        {
            static std::optional<bool> is_event_present{};

            if (!is_event_present.has_value())
            {
                is_event_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Graphics.Printing.PrintSupport.PrintSupportExtensionSession", L"PrintDeviceCapabilitiesChanged");
            }

            if (!is_event_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Graphics::Printing::PrintSupport::PrintSupportExtensionSession, winrt::Windows::Graphics::Printing::PrintSupport::PrintSupportPrintDeviceCapabilitiesChangedEventArgs>>(arg);

            return py::convert(self->obj.PrintDeviceCapabilitiesChanged(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PrintSupportExtensionSession_remove_PrintDeviceCapabilitiesChanged(py::wrapper::Windows::Graphics::Printing::PrintSupport::PrintSupportExtensionSession* self, PyObject* arg) noexcept
    {
        try
        {
            static std::optional<bool> is_event_present{};

            if (!is_event_present.has_value())
            {
                is_event_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Graphics.Printing.PrintSupport.PrintSupportExtensionSession", L"PrintDeviceCapabilitiesChanged");
            }

            if (!is_event_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.PrintDeviceCapabilitiesChanged(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PrintSupportExtensionSession_add_PrintTicketValidationRequested(py::wrapper::Windows::Graphics::Printing::PrintSupport::PrintSupportExtensionSession* self, PyObject* arg) noexcept
    {
        try
        {
            static std::optional<bool> is_event_present{};

            if (!is_event_present.has_value())
            {
                is_event_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Graphics.Printing.PrintSupport.PrintSupportExtensionSession", L"PrintTicketValidationRequested");
            }

            if (!is_event_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Graphics::Printing::PrintSupport::PrintSupportExtensionSession, winrt::Windows::Graphics::Printing::PrintSupport::PrintSupportPrintTicketValidationRequestedEventArgs>>(arg);

            return py::convert(self->obj.PrintTicketValidationRequested(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PrintSupportExtensionSession_remove_PrintTicketValidationRequested(py::wrapper::Windows::Graphics::Printing::PrintSupport::PrintSupportExtensionSession* self, PyObject* arg) noexcept
    {
        try
        {
            static std::optional<bool> is_event_present{};

            if (!is_event_present.has_value())
            {
                is_event_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Graphics.Printing.PrintSupport.PrintSupportExtensionSession", L"PrintTicketValidationRequested");
            }

            if (!is_event_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.PrintTicketValidationRequested(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PrintSupportExtensionSession_add_PrinterSelected(py::wrapper::Windows::Graphics::Printing::PrintSupport::PrintSupportExtensionSession* self, PyObject* arg) noexcept
    {
        try
        {
            static std::optional<bool> is_event_present{};

            if (!is_event_present.has_value())
            {
                is_event_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Graphics.Printing.PrintSupport.PrintSupportExtensionSession", L"PrinterSelected");
            }

            if (!is_event_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Graphics::Printing::PrintSupport::PrintSupportExtensionSession, winrt::Windows::Graphics::Printing::PrintSupport::PrintSupportPrinterSelectedEventArgs>>(arg);

            return py::convert(self->obj.PrinterSelected(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PrintSupportExtensionSession_remove_PrinterSelected(py::wrapper::Windows::Graphics::Printing::PrintSupport::PrintSupportExtensionSession* self, PyObject* arg) noexcept
    {
        try
        {
            static std::optional<bool> is_event_present{};

            if (!is_event_present.has_value())
            {
                is_event_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Graphics.Printing.PrintSupport.PrintSupportExtensionSession", L"PrinterSelected");
            }

            if (!is_event_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.PrinterSelected(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_PrintSupportExtensionSession(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Graphics::Printing::PrintSupport::PrintSupportExtensionSession>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_PrintSupportExtensionSession(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Graphics::Printing::PrintSupport::PrintSupportExtensionSession>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_PrintSupportExtensionSession[] = {
        { "start", reinterpret_cast<PyCFunction>(PrintSupportExtensionSession_Start), METH_VARARGS, nullptr },
        { "add_print_device_capabilities_changed", reinterpret_cast<PyCFunction>(PrintSupportExtensionSession_add_PrintDeviceCapabilitiesChanged), METH_O, nullptr },
        { "remove_print_device_capabilities_changed", reinterpret_cast<PyCFunction>(PrintSupportExtensionSession_remove_PrintDeviceCapabilitiesChanged), METH_O, nullptr },
        { "add_print_ticket_validation_requested", reinterpret_cast<PyCFunction>(PrintSupportExtensionSession_add_PrintTicketValidationRequested), METH_O, nullptr },
        { "remove_print_ticket_validation_requested", reinterpret_cast<PyCFunction>(PrintSupportExtensionSession_remove_PrintTicketValidationRequested), METH_O, nullptr },
        { "add_printer_selected", reinterpret_cast<PyCFunction>(PrintSupportExtensionSession_add_PrinterSelected), METH_O, nullptr },
        { "remove_printer_selected", reinterpret_cast<PyCFunction>(PrintSupportExtensionSession_remove_PrinterSelected), METH_O, nullptr },
        { "_assign_array_", _assign_array_PrintSupportExtensionSession, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_PrintSupportExtensionSession), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_PrintSupportExtensionSession[] = {
        { "printer", reinterpret_cast<getter>(PrintSupportExtensionSession_get_Printer), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_PrintSupportExtensionSession[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_PrintSupportExtensionSession) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_PrintSupportExtensionSession) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_PrintSupportExtensionSession) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_PrintSupportExtensionSession) },
        { }
    };

    static PyType_Spec type_spec_PrintSupportExtensionSession = {
        "winrt._winrt_windows_graphics_printing_printsupport.PrintSupportExtensionSession",
        sizeof(py::wrapper::Windows::Graphics::Printing::PrintSupport::PrintSupportExtensionSession),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_PrintSupportExtensionSession};

    // ----- PrintSupportExtensionTriggerDetails class --------------------

    static PyObject* _new_PrintSupportExtensionTriggerDetails(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Graphics::Printing::PrintSupport::PrintSupportExtensionTriggerDetails>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Graphics::Printing::PrintSupport::PrintSupportExtensionTriggerDetails>::type_name);
        return nullptr;
    }

    static void _dealloc_PrintSupportExtensionTriggerDetails(py::wrapper::Windows::Graphics::Printing::PrintSupport::PrintSupportExtensionTriggerDetails* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* PrintSupportExtensionTriggerDetails_get_Session(py::wrapper::Windows::Graphics::Printing::PrintSupport::PrintSupportExtensionTriggerDetails* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Graphics.Printing.PrintSupport.PrintSupportExtensionTriggerDetails", L"Session");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Session());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_PrintSupportExtensionTriggerDetails(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Graphics::Printing::PrintSupport::PrintSupportExtensionTriggerDetails>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_PrintSupportExtensionTriggerDetails(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Graphics::Printing::PrintSupport::PrintSupportExtensionTriggerDetails>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_PrintSupportExtensionTriggerDetails[] = {
        { "_assign_array_", _assign_array_PrintSupportExtensionTriggerDetails, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_PrintSupportExtensionTriggerDetails), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_PrintSupportExtensionTriggerDetails[] = {
        { "session", reinterpret_cast<getter>(PrintSupportExtensionTriggerDetails_get_Session), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_PrintSupportExtensionTriggerDetails[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_PrintSupportExtensionTriggerDetails) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_PrintSupportExtensionTriggerDetails) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_PrintSupportExtensionTriggerDetails) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_PrintSupportExtensionTriggerDetails) },
        { }
    };

    static PyType_Spec type_spec_PrintSupportExtensionTriggerDetails = {
        "winrt._winrt_windows_graphics_printing_printsupport.PrintSupportExtensionTriggerDetails",
        sizeof(py::wrapper::Windows::Graphics::Printing::PrintSupport::PrintSupportExtensionTriggerDetails),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_PrintSupportExtensionTriggerDetails};

    // ----- PrintSupportPrintDeviceCapabilitiesChangedEventArgs class --------------------

    static PyObject* _new_PrintSupportPrintDeviceCapabilitiesChangedEventArgs(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Graphics::Printing::PrintSupport::PrintSupportPrintDeviceCapabilitiesChangedEventArgs>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Graphics::Printing::PrintSupport::PrintSupportPrintDeviceCapabilitiesChangedEventArgs>::type_name);
        return nullptr;
    }

    static void _dealloc_PrintSupportPrintDeviceCapabilitiesChangedEventArgs(py::wrapper::Windows::Graphics::Printing::PrintSupport::PrintSupportPrintDeviceCapabilitiesChangedEventArgs* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* PrintSupportPrintDeviceCapabilitiesChangedEventArgs_GetCurrentPrintDeviceCapabilities(py::wrapper::Windows::Graphics::Printing::PrintSupport::PrintSupportPrintDeviceCapabilitiesChangedEventArgs* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Graphics.Printing.PrintSupport.PrintSupportPrintDeviceCapabilitiesChangedEventArgs", L"GetCurrentPrintDeviceCapabilities", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert(self->obj.GetCurrentPrintDeviceCapabilities());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PrintSupportPrintDeviceCapabilitiesChangedEventArgs_GetCurrentPrintDeviceResources(py::wrapper::Windows::Graphics::Printing::PrintSupport::PrintSupportPrintDeviceCapabilitiesChangedEventArgs* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Graphics.Printing.PrintSupport.PrintSupportPrintDeviceCapabilitiesChangedEventArgs", L"GetCurrentPrintDeviceResources", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert(self->obj.GetCurrentPrintDeviceResources());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PrintSupportPrintDeviceCapabilitiesChangedEventArgs_GetDeferral(py::wrapper::Windows::Graphics::Printing::PrintSupport::PrintSupportPrintDeviceCapabilitiesChangedEventArgs* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Graphics.Printing.PrintSupport.PrintSupportPrintDeviceCapabilitiesChangedEventArgs", L"GetDeferral", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert(self->obj.GetDeferral());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PrintSupportPrintDeviceCapabilitiesChangedEventArgs_SetPrintDeviceCapabilitiesUpdatePolicy(py::wrapper::Windows::Graphics::Printing::PrintSupport::PrintSupportPrintDeviceCapabilitiesChangedEventArgs* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Graphics.Printing.PrintSupport.PrintSupportPrintDeviceCapabilitiesChangedEventArgs", L"SetPrintDeviceCapabilitiesUpdatePolicy", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Graphics::Printing::PrintSupport::PrintSupportPrintDeviceCapabilitiesUpdatePolicy>(args, 0);

                self->obj.SetPrintDeviceCapabilitiesUpdatePolicy(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PrintSupportPrintDeviceCapabilitiesChangedEventArgs_SetSupportedPdlPassthroughContentTypes(py::wrapper::Windows::Graphics::Printing::PrintSupport::PrintSupportPrintDeviceCapabilitiesChangedEventArgs* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Graphics.Printing.PrintSupport.PrintSupportPrintDeviceCapabilitiesChangedEventArgs", L"SetSupportedPdlPassthroughContentTypes", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Foundation::Collections::IIterable<winrt::hstring>>(args, 0);

                self->obj.SetSupportedPdlPassthroughContentTypes(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PrintSupportPrintDeviceCapabilitiesChangedEventArgs_UpdatePrintDeviceCapabilities(py::wrapper::Windows::Graphics::Printing::PrintSupport::PrintSupportPrintDeviceCapabilitiesChangedEventArgs* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Graphics.Printing.PrintSupport.PrintSupportPrintDeviceCapabilitiesChangedEventArgs", L"UpdatePrintDeviceCapabilities", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Data::Xml::Dom::XmlDocument>(args, 0);

                self->obj.UpdatePrintDeviceCapabilities(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PrintSupportPrintDeviceCapabilitiesChangedEventArgs_UpdatePrintDeviceResources(py::wrapper::Windows::Graphics::Printing::PrintSupport::PrintSupportPrintDeviceCapabilitiesChangedEventArgs* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Graphics.Printing.PrintSupport.PrintSupportPrintDeviceCapabilitiesChangedEventArgs", L"UpdatePrintDeviceResources", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Data::Xml::Dom::XmlDocument>(args, 0);

                self->obj.UpdatePrintDeviceResources(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PrintSupportPrintDeviceCapabilitiesChangedEventArgs_get_ResourceLanguage(py::wrapper::Windows::Graphics::Printing::PrintSupport::PrintSupportPrintDeviceCapabilitiesChangedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Graphics.Printing.PrintSupport.PrintSupportPrintDeviceCapabilitiesChangedEventArgs", L"ResourceLanguage");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.ResourceLanguage());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_PrintSupportPrintDeviceCapabilitiesChangedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Graphics::Printing::PrintSupport::PrintSupportPrintDeviceCapabilitiesChangedEventArgs>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_PrintSupportPrintDeviceCapabilitiesChangedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Graphics::Printing::PrintSupport::PrintSupportPrintDeviceCapabilitiesChangedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_PrintSupportPrintDeviceCapabilitiesChangedEventArgs[] = {
        { "get_current_print_device_capabilities", reinterpret_cast<PyCFunction>(PrintSupportPrintDeviceCapabilitiesChangedEventArgs_GetCurrentPrintDeviceCapabilities), METH_VARARGS, nullptr },
        { "get_current_print_device_resources", reinterpret_cast<PyCFunction>(PrintSupportPrintDeviceCapabilitiesChangedEventArgs_GetCurrentPrintDeviceResources), METH_VARARGS, nullptr },
        { "get_deferral", reinterpret_cast<PyCFunction>(PrintSupportPrintDeviceCapabilitiesChangedEventArgs_GetDeferral), METH_VARARGS, nullptr },
        { "set_print_device_capabilities_update_policy", reinterpret_cast<PyCFunction>(PrintSupportPrintDeviceCapabilitiesChangedEventArgs_SetPrintDeviceCapabilitiesUpdatePolicy), METH_VARARGS, nullptr },
        { "set_supported_pdl_passthrough_content_types", reinterpret_cast<PyCFunction>(PrintSupportPrintDeviceCapabilitiesChangedEventArgs_SetSupportedPdlPassthroughContentTypes), METH_VARARGS, nullptr },
        { "update_print_device_capabilities", reinterpret_cast<PyCFunction>(PrintSupportPrintDeviceCapabilitiesChangedEventArgs_UpdatePrintDeviceCapabilities), METH_VARARGS, nullptr },
        { "update_print_device_resources", reinterpret_cast<PyCFunction>(PrintSupportPrintDeviceCapabilitiesChangedEventArgs_UpdatePrintDeviceResources), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_PrintSupportPrintDeviceCapabilitiesChangedEventArgs, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_PrintSupportPrintDeviceCapabilitiesChangedEventArgs), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_PrintSupportPrintDeviceCapabilitiesChangedEventArgs[] = {
        { "resource_language", reinterpret_cast<getter>(PrintSupportPrintDeviceCapabilitiesChangedEventArgs_get_ResourceLanguage), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_PrintSupportPrintDeviceCapabilitiesChangedEventArgs[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_PrintSupportPrintDeviceCapabilitiesChangedEventArgs) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_PrintSupportPrintDeviceCapabilitiesChangedEventArgs) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_PrintSupportPrintDeviceCapabilitiesChangedEventArgs) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_PrintSupportPrintDeviceCapabilitiesChangedEventArgs) },
        { }
    };

    static PyType_Spec type_spec_PrintSupportPrintDeviceCapabilitiesChangedEventArgs = {
        "winrt._winrt_windows_graphics_printing_printsupport.PrintSupportPrintDeviceCapabilitiesChangedEventArgs",
        sizeof(py::wrapper::Windows::Graphics::Printing::PrintSupport::PrintSupportPrintDeviceCapabilitiesChangedEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_PrintSupportPrintDeviceCapabilitiesChangedEventArgs};

    // ----- PrintSupportPrintDeviceCapabilitiesUpdatePolicy class --------------------

    static PyObject* _new_PrintSupportPrintDeviceCapabilitiesUpdatePolicy(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Graphics::Printing::PrintSupport::PrintSupportPrintDeviceCapabilitiesUpdatePolicy>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Graphics::Printing::PrintSupport::PrintSupportPrintDeviceCapabilitiesUpdatePolicy>::type_name);
        return nullptr;
    }

    static void _dealloc_PrintSupportPrintDeviceCapabilitiesUpdatePolicy(py::wrapper::Windows::Graphics::Printing::PrintSupport::PrintSupportPrintDeviceCapabilitiesUpdatePolicy* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* PrintSupportPrintDeviceCapabilitiesUpdatePolicy_CreatePeriodicRefresh(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Graphics.Printing.PrintSupport.PrintSupportPrintDeviceCapabilitiesUpdatePolicy", L"CreatePeriodicRefresh", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Foundation::TimeSpan>(args, 0);

                return py::convert(winrt::Windows::Graphics::Printing::PrintSupport::PrintSupportPrintDeviceCapabilitiesUpdatePolicy::CreatePeriodicRefresh(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PrintSupportPrintDeviceCapabilitiesUpdatePolicy_CreatePrintJobRefresh(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Graphics.Printing.PrintSupport.PrintSupportPrintDeviceCapabilitiesUpdatePolicy", L"CreatePrintJobRefresh", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<uint32_t>(args, 0);

                return py::convert(winrt::Windows::Graphics::Printing::PrintSupport::PrintSupportPrintDeviceCapabilitiesUpdatePolicy::CreatePrintJobRefresh(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* _assign_array_PrintSupportPrintDeviceCapabilitiesUpdatePolicy(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Graphics::Printing::PrintSupport::PrintSupportPrintDeviceCapabilitiesUpdatePolicy>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_PrintSupportPrintDeviceCapabilitiesUpdatePolicy(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Graphics::Printing::PrintSupport::PrintSupportPrintDeviceCapabilitiesUpdatePolicy>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_PrintSupportPrintDeviceCapabilitiesUpdatePolicy[] = {
        { "_assign_array_", _assign_array_PrintSupportPrintDeviceCapabilitiesUpdatePolicy, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_PrintSupportPrintDeviceCapabilitiesUpdatePolicy), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_PrintSupportPrintDeviceCapabilitiesUpdatePolicy[] = {
        { }
    };

    static PyType_Slot _type_slots_PrintSupportPrintDeviceCapabilitiesUpdatePolicy[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_PrintSupportPrintDeviceCapabilitiesUpdatePolicy) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_PrintSupportPrintDeviceCapabilitiesUpdatePolicy) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_PrintSupportPrintDeviceCapabilitiesUpdatePolicy) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_PrintSupportPrintDeviceCapabilitiesUpdatePolicy) },
        { }
    };

    static PyType_Spec type_spec_PrintSupportPrintDeviceCapabilitiesUpdatePolicy = {
        "winrt._winrt_windows_graphics_printing_printsupport.PrintSupportPrintDeviceCapabilitiesUpdatePolicy",
        sizeof(py::wrapper::Windows::Graphics::Printing::PrintSupport::PrintSupportPrintDeviceCapabilitiesUpdatePolicy),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_PrintSupportPrintDeviceCapabilitiesUpdatePolicy};

    static PyGetSetDef getset_PrintSupportPrintDeviceCapabilitiesUpdatePolicy_Static[] = {
        { }
    };

    static PyMethodDef methods_PrintSupportPrintDeviceCapabilitiesUpdatePolicy_Static[] = {
        { "create_periodic_refresh", reinterpret_cast<PyCFunction>(PrintSupportPrintDeviceCapabilitiesUpdatePolicy_CreatePeriodicRefresh), METH_VARARGS, nullptr },
        { "create_print_job_refresh", reinterpret_cast<PyCFunction>(PrintSupportPrintDeviceCapabilitiesUpdatePolicy_CreatePrintJobRefresh), METH_VARARGS, nullptr },
        { }
    };

    static PyType_Slot type_slots_PrintSupportPrintDeviceCapabilitiesUpdatePolicy_Static[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_PrintSupportPrintDeviceCapabilitiesUpdatePolicy_Static) },
        { Py_tp_methods, reinterpret_cast<void*>(methods_PrintSupportPrintDeviceCapabilitiesUpdatePolicy_Static) },
        { }
    };

    static PyType_Spec type_spec_PrintSupportPrintDeviceCapabilitiesUpdatePolicy_Static =
    {
        "winrt._winrt_windows_graphics_printing_printsupport.PrintSupportPrintDeviceCapabilitiesUpdatePolicy_Static",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT,
        type_slots_PrintSupportPrintDeviceCapabilitiesUpdatePolicy_Static
    };

    // ----- PrintSupportPrintTicketElement class --------------------

    static PyObject* _new_PrintSupportPrintTicketElement(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 0)
        {
            try
            {
                winrt::Windows::Graphics::Printing::PrintSupport::PrintSupportPrintTicketElement instance{};
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_PrintSupportPrintTicketElement(py::wrapper::Windows::Graphics::Printing::PrintSupport::PrintSupportPrintTicketElement* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* PrintSupportPrintTicketElement_get_NamespaceUri(py::wrapper::Windows::Graphics::Printing::PrintSupport::PrintSupportPrintTicketElement* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Graphics.Printing.PrintSupport.PrintSupportPrintTicketElement", L"NamespaceUri");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.NamespaceUri());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int PrintSupportPrintTicketElement_put_NamespaceUri(py::wrapper::Windows::Graphics::Printing::PrintSupport::PrintSupportPrintTicketElement* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Graphics.Printing.PrintSupport.PrintSupportPrintTicketElement", L"NamespaceUri");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.NamespaceUri(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* PrintSupportPrintTicketElement_get_LocalName(py::wrapper::Windows::Graphics::Printing::PrintSupport::PrintSupportPrintTicketElement* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Graphics.Printing.PrintSupport.PrintSupportPrintTicketElement", L"LocalName");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.LocalName());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int PrintSupportPrintTicketElement_put_LocalName(py::wrapper::Windows::Graphics::Printing::PrintSupport::PrintSupportPrintTicketElement* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Graphics.Printing.PrintSupport.PrintSupportPrintTicketElement", L"LocalName");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.LocalName(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* _assign_array_PrintSupportPrintTicketElement(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Graphics::Printing::PrintSupport::PrintSupportPrintTicketElement>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_PrintSupportPrintTicketElement(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Graphics::Printing::PrintSupport::PrintSupportPrintTicketElement>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_PrintSupportPrintTicketElement[] = {
        { "_assign_array_", _assign_array_PrintSupportPrintTicketElement, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_PrintSupportPrintTicketElement), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_PrintSupportPrintTicketElement[] = {
        { "namespace_uri", reinterpret_cast<getter>(PrintSupportPrintTicketElement_get_NamespaceUri), reinterpret_cast<setter>(PrintSupportPrintTicketElement_put_NamespaceUri), nullptr, nullptr },
        { "local_name", reinterpret_cast<getter>(PrintSupportPrintTicketElement_get_LocalName), reinterpret_cast<setter>(PrintSupportPrintTicketElement_put_LocalName), nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_PrintSupportPrintTicketElement[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_PrintSupportPrintTicketElement) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_PrintSupportPrintTicketElement) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_PrintSupportPrintTicketElement) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_PrintSupportPrintTicketElement) },
        { }
    };

    static PyType_Spec type_spec_PrintSupportPrintTicketElement = {
        "winrt._winrt_windows_graphics_printing_printsupport.PrintSupportPrintTicketElement",
        sizeof(py::wrapper::Windows::Graphics::Printing::PrintSupport::PrintSupportPrintTicketElement),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_PrintSupportPrintTicketElement};

    // ----- PrintSupportPrintTicketValidationRequestedEventArgs class --------------------

    static PyObject* _new_PrintSupportPrintTicketValidationRequestedEventArgs(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Graphics::Printing::PrintSupport::PrintSupportPrintTicketValidationRequestedEventArgs>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Graphics::Printing::PrintSupport::PrintSupportPrintTicketValidationRequestedEventArgs>::type_name);
        return nullptr;
    }

    static void _dealloc_PrintSupportPrintTicketValidationRequestedEventArgs(py::wrapper::Windows::Graphics::Printing::PrintSupport::PrintSupportPrintTicketValidationRequestedEventArgs* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* PrintSupportPrintTicketValidationRequestedEventArgs_GetDeferral(py::wrapper::Windows::Graphics::Printing::PrintSupport::PrintSupportPrintTicketValidationRequestedEventArgs* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Graphics.Printing.PrintSupport.PrintSupportPrintTicketValidationRequestedEventArgs", L"GetDeferral", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert(self->obj.GetDeferral());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PrintSupportPrintTicketValidationRequestedEventArgs_SetPrintTicketValidationStatus(py::wrapper::Windows::Graphics::Printing::PrintSupport::PrintSupportPrintTicketValidationRequestedEventArgs* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Graphics.Printing.PrintSupport.PrintSupportPrintTicketValidationRequestedEventArgs", L"SetPrintTicketValidationStatus", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Graphics::Printing::PrintSupport::WorkflowPrintTicketValidationStatus>(args, 0);

                self->obj.SetPrintTicketValidationStatus(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PrintSupportPrintTicketValidationRequestedEventArgs_get_PrintTicket(py::wrapper::Windows::Graphics::Printing::PrintSupport::PrintSupportPrintTicketValidationRequestedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Graphics.Printing.PrintSupport.PrintSupportPrintTicketValidationRequestedEventArgs", L"PrintTicket");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.PrintTicket());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_PrintSupportPrintTicketValidationRequestedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Graphics::Printing::PrintSupport::PrintSupportPrintTicketValidationRequestedEventArgs>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_PrintSupportPrintTicketValidationRequestedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Graphics::Printing::PrintSupport::PrintSupportPrintTicketValidationRequestedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_PrintSupportPrintTicketValidationRequestedEventArgs[] = {
        { "get_deferral", reinterpret_cast<PyCFunction>(PrintSupportPrintTicketValidationRequestedEventArgs_GetDeferral), METH_VARARGS, nullptr },
        { "set_print_ticket_validation_status", reinterpret_cast<PyCFunction>(PrintSupportPrintTicketValidationRequestedEventArgs_SetPrintTicketValidationStatus), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_PrintSupportPrintTicketValidationRequestedEventArgs, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_PrintSupportPrintTicketValidationRequestedEventArgs), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_PrintSupportPrintTicketValidationRequestedEventArgs[] = {
        { "print_ticket", reinterpret_cast<getter>(PrintSupportPrintTicketValidationRequestedEventArgs_get_PrintTicket), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_PrintSupportPrintTicketValidationRequestedEventArgs[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_PrintSupportPrintTicketValidationRequestedEventArgs) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_PrintSupportPrintTicketValidationRequestedEventArgs) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_PrintSupportPrintTicketValidationRequestedEventArgs) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_PrintSupportPrintTicketValidationRequestedEventArgs) },
        { }
    };

    static PyType_Spec type_spec_PrintSupportPrintTicketValidationRequestedEventArgs = {
        "winrt._winrt_windows_graphics_printing_printsupport.PrintSupportPrintTicketValidationRequestedEventArgs",
        sizeof(py::wrapper::Windows::Graphics::Printing::PrintSupport::PrintSupportPrintTicketValidationRequestedEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_PrintSupportPrintTicketValidationRequestedEventArgs};

    // ----- PrintSupportPrinterSelectedEventArgs class --------------------

    static PyObject* _new_PrintSupportPrinterSelectedEventArgs(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Graphics::Printing::PrintSupport::PrintSupportPrinterSelectedEventArgs>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Graphics::Printing::PrintSupport::PrintSupportPrinterSelectedEventArgs>::type_name);
        return nullptr;
    }

    static void _dealloc_PrintSupportPrinterSelectedEventArgs(py::wrapper::Windows::Graphics::Printing::PrintSupport::PrintSupportPrinterSelectedEventArgs* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* PrintSupportPrinterSelectedEventArgs_GetDeferral(py::wrapper::Windows::Graphics::Printing::PrintSupport::PrintSupportPrinterSelectedEventArgs* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Graphics.Printing.PrintSupport.PrintSupportPrinterSelectedEventArgs", L"GetDeferral", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert(self->obj.GetDeferral());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PrintSupportPrinterSelectedEventArgs_SetAdaptiveCard(py::wrapper::Windows::Graphics::Printing::PrintSupport::PrintSupportPrinterSelectedEventArgs* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Graphics.Printing.PrintSupport.PrintSupportPrinterSelectedEventArgs", L"SetAdaptiveCard", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::UI::Shell::IAdaptiveCard>(args, 0);

                self->obj.SetAdaptiveCard(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PrintSupportPrinterSelectedEventArgs_SetAdditionalFeatures(py::wrapper::Windows::Graphics::Printing::PrintSupport::PrintSupportPrinterSelectedEventArgs* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Graphics.Printing.PrintSupport.PrintSupportPrinterSelectedEventArgs", L"SetAdditionalFeatures", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Foundation::Collections::IIterable<winrt::Windows::Graphics::Printing::PrintSupport::PrintSupportPrintTicketElement>>(args, 0);

                self->obj.SetAdditionalFeatures(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PrintSupportPrinterSelectedEventArgs_SetAdditionalParameters(py::wrapper::Windows::Graphics::Printing::PrintSupport::PrintSupportPrinterSelectedEventArgs* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Graphics.Printing.PrintSupport.PrintSupportPrinterSelectedEventArgs", L"SetAdditionalParameters", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Foundation::Collections::IIterable<winrt::Windows::Graphics::Printing::PrintSupport::PrintSupportPrintTicketElement>>(args, 0);

                self->obj.SetAdditionalParameters(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PrintSupportPrinterSelectedEventArgs_get_PrintTicket(py::wrapper::Windows::Graphics::Printing::PrintSupport::PrintSupportPrinterSelectedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Graphics.Printing.PrintSupport.PrintSupportPrinterSelectedEventArgs", L"PrintTicket");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.PrintTicket());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int PrintSupportPrinterSelectedEventArgs_put_PrintTicket(py::wrapper::Windows::Graphics::Printing::PrintSupport::PrintSupportPrinterSelectedEventArgs* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Graphics.Printing.PrintSupport.PrintSupportPrinterSelectedEventArgs", L"PrintTicket");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::Graphics::Printing::PrintTicket::WorkflowPrintTicket>(arg);

            self->obj.PrintTicket(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* PrintSupportPrinterSelectedEventArgs_get_AllowedAdditionalFeaturesAndParametersCount(py::wrapper::Windows::Graphics::Printing::PrintSupport::PrintSupportPrinterSelectedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Graphics.Printing.PrintSupport.PrintSupportPrinterSelectedEventArgs", L"AllowedAdditionalFeaturesAndParametersCount");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.AllowedAdditionalFeaturesAndParametersCount());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PrintSupportPrinterSelectedEventArgs_get_SourceAppInfo(py::wrapper::Windows::Graphics::Printing::PrintSupport::PrintSupportPrinterSelectedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Graphics.Printing.PrintSupport.PrintSupportPrinterSelectedEventArgs", L"SourceAppInfo");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.SourceAppInfo());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_PrintSupportPrinterSelectedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Graphics::Printing::PrintSupport::PrintSupportPrinterSelectedEventArgs>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_PrintSupportPrinterSelectedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Graphics::Printing::PrintSupport::PrintSupportPrinterSelectedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_PrintSupportPrinterSelectedEventArgs[] = {
        { "get_deferral", reinterpret_cast<PyCFunction>(PrintSupportPrinterSelectedEventArgs_GetDeferral), METH_VARARGS, nullptr },
        { "set_adaptive_card", reinterpret_cast<PyCFunction>(PrintSupportPrinterSelectedEventArgs_SetAdaptiveCard), METH_VARARGS, nullptr },
        { "set_additional_features", reinterpret_cast<PyCFunction>(PrintSupportPrinterSelectedEventArgs_SetAdditionalFeatures), METH_VARARGS, nullptr },
        { "set_additional_parameters", reinterpret_cast<PyCFunction>(PrintSupportPrinterSelectedEventArgs_SetAdditionalParameters), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_PrintSupportPrinterSelectedEventArgs, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_PrintSupportPrinterSelectedEventArgs), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_PrintSupportPrinterSelectedEventArgs[] = {
        { "print_ticket", reinterpret_cast<getter>(PrintSupportPrinterSelectedEventArgs_get_PrintTicket), reinterpret_cast<setter>(PrintSupportPrinterSelectedEventArgs_put_PrintTicket), nullptr, nullptr },
        { "allowed_additional_features_and_parameters_count", reinterpret_cast<getter>(PrintSupportPrinterSelectedEventArgs_get_AllowedAdditionalFeaturesAndParametersCount), nullptr, nullptr, nullptr },
        { "source_app_info", reinterpret_cast<getter>(PrintSupportPrinterSelectedEventArgs_get_SourceAppInfo), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_PrintSupportPrinterSelectedEventArgs[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_PrintSupportPrinterSelectedEventArgs) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_PrintSupportPrinterSelectedEventArgs) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_PrintSupportPrinterSelectedEventArgs) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_PrintSupportPrinterSelectedEventArgs) },
        { }
    };

    static PyType_Spec type_spec_PrintSupportPrinterSelectedEventArgs = {
        "winrt._winrt_windows_graphics_printing_printsupport.PrintSupportPrinterSelectedEventArgs",
        sizeof(py::wrapper::Windows::Graphics::Printing::PrintSupport::PrintSupportPrinterSelectedEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_PrintSupportPrinterSelectedEventArgs};

    // ----- PrintSupportSessionInfo class --------------------

    static PyObject* _new_PrintSupportSessionInfo(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Graphics::Printing::PrintSupport::PrintSupportSessionInfo>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Graphics::Printing::PrintSupport::PrintSupportSessionInfo>::type_name);
        return nullptr;
    }

    static void _dealloc_PrintSupportSessionInfo(py::wrapper::Windows::Graphics::Printing::PrintSupport::PrintSupportSessionInfo* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* PrintSupportSessionInfo_get_Printer(py::wrapper::Windows::Graphics::Printing::PrintSupport::PrintSupportSessionInfo* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Graphics.Printing.PrintSupport.PrintSupportSessionInfo", L"Printer");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Printer());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PrintSupportSessionInfo_get_SourceAppInfo(py::wrapper::Windows::Graphics::Printing::PrintSupport::PrintSupportSessionInfo* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Graphics.Printing.PrintSupport.PrintSupportSessionInfo", L"SourceAppInfo");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.SourceAppInfo());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_PrintSupportSessionInfo(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Graphics::Printing::PrintSupport::PrintSupportSessionInfo>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_PrintSupportSessionInfo(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Graphics::Printing::PrintSupport::PrintSupportSessionInfo>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_PrintSupportSessionInfo[] = {
        { "_assign_array_", _assign_array_PrintSupportSessionInfo, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_PrintSupportSessionInfo), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_PrintSupportSessionInfo[] = {
        { "printer", reinterpret_cast<getter>(PrintSupportSessionInfo_get_Printer), nullptr, nullptr, nullptr },
        { "source_app_info", reinterpret_cast<getter>(PrintSupportSessionInfo_get_SourceAppInfo), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_PrintSupportSessionInfo[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_PrintSupportSessionInfo) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_PrintSupportSessionInfo) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_PrintSupportSessionInfo) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_PrintSupportSessionInfo) },
        { }
    };

    static PyType_Spec type_spec_PrintSupportSessionInfo = {
        "winrt._winrt_windows_graphics_printing_printsupport.PrintSupportSessionInfo",
        sizeof(py::wrapper::Windows::Graphics::Printing::PrintSupport::PrintSupportSessionInfo),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_PrintSupportSessionInfo};

    // ----- PrintSupportSettingsActivatedEventArgs class --------------------

    static PyObject* _new_PrintSupportSettingsActivatedEventArgs(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Graphics::Printing::PrintSupport::PrintSupportSettingsActivatedEventArgs>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Graphics::Printing::PrintSupport::PrintSupportSettingsActivatedEventArgs>::type_name);
        return nullptr;
    }

    static void _dealloc_PrintSupportSettingsActivatedEventArgs(py::wrapper::Windows::Graphics::Printing::PrintSupport::PrintSupportSettingsActivatedEventArgs* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* PrintSupportSettingsActivatedEventArgs_GetDeferral(py::wrapper::Windows::Graphics::Printing::PrintSupport::PrintSupportSettingsActivatedEventArgs* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Graphics.Printing.PrintSupport.PrintSupportSettingsActivatedEventArgs", L"GetDeferral", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert(self->obj.GetDeferral());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PrintSupportSettingsActivatedEventArgs_get_Kind(py::wrapper::Windows::Graphics::Printing::PrintSupport::PrintSupportSettingsActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Graphics.Printing.PrintSupport.PrintSupportSettingsActivatedEventArgs", L"Kind");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Kind());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PrintSupportSettingsActivatedEventArgs_get_PreviousExecutionState(py::wrapper::Windows::Graphics::Printing::PrintSupport::PrintSupportSettingsActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Graphics.Printing.PrintSupport.PrintSupportSettingsActivatedEventArgs", L"PreviousExecutionState");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.PreviousExecutionState());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PrintSupportSettingsActivatedEventArgs_get_SplashScreen(py::wrapper::Windows::Graphics::Printing::PrintSupport::PrintSupportSettingsActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Graphics.Printing.PrintSupport.PrintSupportSettingsActivatedEventArgs", L"SplashScreen");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.SplashScreen());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PrintSupportSettingsActivatedEventArgs_get_User(py::wrapper::Windows::Graphics::Printing::PrintSupport::PrintSupportSettingsActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Graphics.Printing.PrintSupport.PrintSupportSettingsActivatedEventArgs", L"User");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.User());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PrintSupportSettingsActivatedEventArgs_get_Session(py::wrapper::Windows::Graphics::Printing::PrintSupport::PrintSupportSettingsActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Graphics.Printing.PrintSupport.PrintSupportSettingsActivatedEventArgs", L"Session");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Session());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_PrintSupportSettingsActivatedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Graphics::Printing::PrintSupport::PrintSupportSettingsActivatedEventArgs>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_PrintSupportSettingsActivatedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Graphics::Printing::PrintSupport::PrintSupportSettingsActivatedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_PrintSupportSettingsActivatedEventArgs[] = {
        { "get_deferral", reinterpret_cast<PyCFunction>(PrintSupportSettingsActivatedEventArgs_GetDeferral), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_PrintSupportSettingsActivatedEventArgs, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_PrintSupportSettingsActivatedEventArgs), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_PrintSupportSettingsActivatedEventArgs[] = {
        { "kind", reinterpret_cast<getter>(PrintSupportSettingsActivatedEventArgs_get_Kind), nullptr, nullptr, nullptr },
        { "previous_execution_state", reinterpret_cast<getter>(PrintSupportSettingsActivatedEventArgs_get_PreviousExecutionState), nullptr, nullptr, nullptr },
        { "splash_screen", reinterpret_cast<getter>(PrintSupportSettingsActivatedEventArgs_get_SplashScreen), nullptr, nullptr, nullptr },
        { "user", reinterpret_cast<getter>(PrintSupportSettingsActivatedEventArgs_get_User), nullptr, nullptr, nullptr },
        { "session", reinterpret_cast<getter>(PrintSupportSettingsActivatedEventArgs_get_Session), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_PrintSupportSettingsActivatedEventArgs[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_PrintSupportSettingsActivatedEventArgs) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_PrintSupportSettingsActivatedEventArgs) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_PrintSupportSettingsActivatedEventArgs) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_PrintSupportSettingsActivatedEventArgs) },
        { }
    };

    static PyType_Spec type_spec_PrintSupportSettingsActivatedEventArgs = {
        "winrt._winrt_windows_graphics_printing_printsupport.PrintSupportSettingsActivatedEventArgs",
        sizeof(py::wrapper::Windows::Graphics::Printing::PrintSupport::PrintSupportSettingsActivatedEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_PrintSupportSettingsActivatedEventArgs};

    // ----- PrintSupportSettingsUISession class --------------------

    static PyObject* _new_PrintSupportSettingsUISession(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Graphics::Printing::PrintSupport::PrintSupportSettingsUISession>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Graphics::Printing::PrintSupport::PrintSupportSettingsUISession>::type_name);
        return nullptr;
    }

    static void _dealloc_PrintSupportSettingsUISession(py::wrapper::Windows::Graphics::Printing::PrintSupport::PrintSupportSettingsUISession* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* PrintSupportSettingsUISession_UpdatePrintTicket(py::wrapper::Windows::Graphics::Printing::PrintSupport::PrintSupportSettingsUISession* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Graphics.Printing.PrintSupport.PrintSupportSettingsUISession", L"UpdatePrintTicket", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Graphics::Printing::PrintTicket::WorkflowPrintTicket>(args, 0);

                self->obj.UpdatePrintTicket(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PrintSupportSettingsUISession_get_DocumentTitle(py::wrapper::Windows::Graphics::Printing::PrintSupport::PrintSupportSettingsUISession* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Graphics.Printing.PrintSupport.PrintSupportSettingsUISession", L"DocumentTitle");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.DocumentTitle());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PrintSupportSettingsUISession_get_LaunchKind(py::wrapper::Windows::Graphics::Printing::PrintSupport::PrintSupportSettingsUISession* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Graphics.Printing.PrintSupport.PrintSupportSettingsUISession", L"LaunchKind");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.LaunchKind());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PrintSupportSettingsUISession_get_SessionInfo(py::wrapper::Windows::Graphics::Printing::PrintSupport::PrintSupportSettingsUISession* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Graphics.Printing.PrintSupport.PrintSupportSettingsUISession", L"SessionInfo");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.SessionInfo());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PrintSupportSettingsUISession_get_SessionPrintTicket(py::wrapper::Windows::Graphics::Printing::PrintSupport::PrintSupportSettingsUISession* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Graphics.Printing.PrintSupport.PrintSupportSettingsUISession", L"SessionPrintTicket");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.SessionPrintTicket());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_PrintSupportSettingsUISession(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Graphics::Printing::PrintSupport::PrintSupportSettingsUISession>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_PrintSupportSettingsUISession(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Graphics::Printing::PrintSupport::PrintSupportSettingsUISession>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_PrintSupportSettingsUISession[] = {
        { "update_print_ticket", reinterpret_cast<PyCFunction>(PrintSupportSettingsUISession_UpdatePrintTicket), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_PrintSupportSettingsUISession, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_PrintSupportSettingsUISession), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_PrintSupportSettingsUISession[] = {
        { "document_title", reinterpret_cast<getter>(PrintSupportSettingsUISession_get_DocumentTitle), nullptr, nullptr, nullptr },
        { "launch_kind", reinterpret_cast<getter>(PrintSupportSettingsUISession_get_LaunchKind), nullptr, nullptr, nullptr },
        { "session_info", reinterpret_cast<getter>(PrintSupportSettingsUISession_get_SessionInfo), nullptr, nullptr, nullptr },
        { "session_print_ticket", reinterpret_cast<getter>(PrintSupportSettingsUISession_get_SessionPrintTicket), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_PrintSupportSettingsUISession[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_PrintSupportSettingsUISession) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_PrintSupportSettingsUISession) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_PrintSupportSettingsUISession) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_PrintSupportSettingsUISession) },
        { }
    };

    static PyType_Spec type_spec_PrintSupportSettingsUISession = {
        "winrt._winrt_windows_graphics_printing_printsupport.PrintSupportSettingsUISession",
        sizeof(py::wrapper::Windows::Graphics::Printing::PrintSupport::PrintSupportSettingsUISession),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_PrintSupportSettingsUISession};

    // ----- Windows.Graphics.Printing.PrintSupport Initialization --------------------

    PyDoc_STRVAR(module_doc, "Windows.Graphics.Printing.PrintSupport");

    static PyModuleDef module_def = {
        PyModuleDef_HEAD_INIT,
        "_winrt_windows_graphics_printing_printsupport",
        module_doc,
        0,
        nullptr,
        nullptr,
        nullptr,
        nullptr,
        nullptr};
} // py::cpp::Windows::Graphics::Printing::PrintSupport

PyMODINIT_FUNC PyInit__winrt_windows_graphics_printing_printsupport(void) noexcept
{
    using namespace py::cpp::Windows::Graphics::Printing::PrintSupport;

    if (py::import_winrt_runtime() == -1)
    {
        return nullptr;
    }

    py::pyobj_handle module{PyModule_Create(&module_def)};

    if (!module)
    {
        return nullptr;
    }

    auto object_type = py::get_object_type();
    if (!object_type)
    {
        return nullptr;
    }

    py::pyobj_handle object_bases{PyTuple_Pack(1, object_type)};

    if (!object_bases)
    {
        return nullptr;
    }

    py::pytype_handle PrintSupportExtensionSession_type{py::register_python_type(module.get(), &type_spec_PrintSupportExtensionSession, object_bases.get(), nullptr)};
    if (!PrintSupportExtensionSession_type)
    {
        return nullptr;
    }

    py::pytype_handle PrintSupportExtensionTriggerDetails_type{py::register_python_type(module.get(), &type_spec_PrintSupportExtensionTriggerDetails, object_bases.get(), nullptr)};
    if (!PrintSupportExtensionTriggerDetails_type)
    {
        return nullptr;
    }

    py::pytype_handle PrintSupportPrintDeviceCapabilitiesChangedEventArgs_type{py::register_python_type(module.get(), &type_spec_PrintSupportPrintDeviceCapabilitiesChangedEventArgs, object_bases.get(), nullptr)};
    if (!PrintSupportPrintDeviceCapabilitiesChangedEventArgs_type)
    {
        return nullptr;
    }

    py::pyobj_handle type_PrintSupportPrintDeviceCapabilitiesUpdatePolicy_Static{PyType_FromSpec(&type_spec_PrintSupportPrintDeviceCapabilitiesUpdatePolicy_Static)};
    if (!type_PrintSupportPrintDeviceCapabilitiesUpdatePolicy_Static)
    {
        return nullptr;
    }

    py::pytype_handle PrintSupportPrintDeviceCapabilitiesUpdatePolicy_type{py::register_python_type(module.get(), &type_spec_PrintSupportPrintDeviceCapabilitiesUpdatePolicy, object_bases.get(), reinterpret_cast<PyTypeObject*>(type_PrintSupportPrintDeviceCapabilitiesUpdatePolicy_Static.get()))};
    if (!PrintSupportPrintDeviceCapabilitiesUpdatePolicy_type)
    {
        return nullptr;
    }

    py::pytype_handle PrintSupportPrintTicketElement_type{py::register_python_type(module.get(), &type_spec_PrintSupportPrintTicketElement, object_bases.get(), nullptr)};
    if (!PrintSupportPrintTicketElement_type)
    {
        return nullptr;
    }

    py::pytype_handle PrintSupportPrintTicketValidationRequestedEventArgs_type{py::register_python_type(module.get(), &type_spec_PrintSupportPrintTicketValidationRequestedEventArgs, object_bases.get(), nullptr)};
    if (!PrintSupportPrintTicketValidationRequestedEventArgs_type)
    {
        return nullptr;
    }

    py::pytype_handle PrintSupportPrinterSelectedEventArgs_type{py::register_python_type(module.get(), &type_spec_PrintSupportPrinterSelectedEventArgs, object_bases.get(), nullptr)};
    if (!PrintSupportPrinterSelectedEventArgs_type)
    {
        return nullptr;
    }

    py::pytype_handle PrintSupportSessionInfo_type{py::register_python_type(module.get(), &type_spec_PrintSupportSessionInfo, object_bases.get(), nullptr)};
    if (!PrintSupportSessionInfo_type)
    {
        return nullptr;
    }

    py::pytype_handle PrintSupportSettingsActivatedEventArgs_type{py::register_python_type(module.get(), &type_spec_PrintSupportSettingsActivatedEventArgs, object_bases.get(), nullptr)};
    if (!PrintSupportSettingsActivatedEventArgs_type)
    {
        return nullptr;
    }

    py::pytype_handle PrintSupportSettingsUISession_type{py::register_python_type(module.get(), &type_spec_PrintSupportSettingsUISession, object_bases.get(), nullptr)};
    if (!PrintSupportSettingsUISession_type)
    {
        return nullptr;
    }


    return module.detach();
}
