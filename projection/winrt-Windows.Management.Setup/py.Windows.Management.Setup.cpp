// WARNING: Please don't edit this file. It was generated by Python/WinRT v2.3.0

#include "py.Windows.Management.Setup.h"

namespace py::cpp::Windows::Management::Setup
{
    // ----- AgentProvisioningProgressReport class --------------------

    static PyObject* _new_AgentProvisioningProgressReport(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 0)
        {
            try
            {
                winrt::Windows::Management::Setup::AgentProvisioningProgressReport instance{};
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_AgentProvisioningProgressReport(py::wrapper::Windows::Management::Setup::AgentProvisioningProgressReport* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* AgentProvisioningProgressReport_get_State(py::wrapper::Windows::Management::Setup::AgentProvisioningProgressReport* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Management.Setup.AgentProvisioningProgressReport", L"State");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.State());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int AgentProvisioningProgressReport_put_State(py::wrapper::Windows::Management::Setup::AgentProvisioningProgressReport* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Management.Setup.AgentProvisioningProgressReport", L"State");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::Management::Setup::DeploymentAgentProgressState>(arg);

            self->obj.State(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* AgentProvisioningProgressReport_get_ProgressPercentage(py::wrapper::Windows::Management::Setup::AgentProvisioningProgressReport* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Management.Setup.AgentProvisioningProgressReport", L"ProgressPercentage");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.ProgressPercentage());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int AgentProvisioningProgressReport_put_ProgressPercentage(py::wrapper::Windows::Management::Setup::AgentProvisioningProgressReport* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Management.Setup.AgentProvisioningProgressReport", L"ProgressPercentage");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<double>(arg);

            self->obj.ProgressPercentage(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* AgentProvisioningProgressReport_get_EstimatedTimeRemaining(py::wrapper::Windows::Management::Setup::AgentProvisioningProgressReport* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Management.Setup.AgentProvisioningProgressReport", L"EstimatedTimeRemaining");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.EstimatedTimeRemaining());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int AgentProvisioningProgressReport_put_EstimatedTimeRemaining(py::wrapper::Windows::Management::Setup::AgentProvisioningProgressReport* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Management.Setup.AgentProvisioningProgressReport", L"EstimatedTimeRemaining");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::TimeSpan>(arg);

            self->obj.EstimatedTimeRemaining(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* AgentProvisioningProgressReport_get_DisplayProgressSecondary(py::wrapper::Windows::Management::Setup::AgentProvisioningProgressReport* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Management.Setup.AgentProvisioningProgressReport", L"DisplayProgressSecondary");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.DisplayProgressSecondary());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int AgentProvisioningProgressReport_put_DisplayProgressSecondary(py::wrapper::Windows::Management::Setup::AgentProvisioningProgressReport* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Management.Setup.AgentProvisioningProgressReport", L"DisplayProgressSecondary");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.DisplayProgressSecondary(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* AgentProvisioningProgressReport_get_DisplayProgress(py::wrapper::Windows::Management::Setup::AgentProvisioningProgressReport* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Management.Setup.AgentProvisioningProgressReport", L"DisplayProgress");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.DisplayProgress());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int AgentProvisioningProgressReport_put_DisplayProgress(py::wrapper::Windows::Management::Setup::AgentProvisioningProgressReport* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Management.Setup.AgentProvisioningProgressReport", L"DisplayProgress");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.DisplayProgress(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* AgentProvisioningProgressReport_get_CurrentBatchIndex(py::wrapper::Windows::Management::Setup::AgentProvisioningProgressReport* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Management.Setup.AgentProvisioningProgressReport", L"CurrentBatchIndex");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.CurrentBatchIndex());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int AgentProvisioningProgressReport_put_CurrentBatchIndex(py::wrapper::Windows::Management::Setup::AgentProvisioningProgressReport* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Management.Setup.AgentProvisioningProgressReport", L"CurrentBatchIndex");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<uint32_t>(arg);

            self->obj.CurrentBatchIndex(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* AgentProvisioningProgressReport_get_Batches(py::wrapper::Windows::Management::Setup::AgentProvisioningProgressReport* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Management.Setup.AgentProvisioningProgressReport", L"Batches");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Batches());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_AgentProvisioningProgressReport(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Management::Setup::AgentProvisioningProgressReport>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_AgentProvisioningProgressReport(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Management::Setup::AgentProvisioningProgressReport>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_AgentProvisioningProgressReport[] = {
        { "_assign_array_", _assign_array_AgentProvisioningProgressReport, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_AgentProvisioningProgressReport), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_AgentProvisioningProgressReport[] = {
        { "state", reinterpret_cast<getter>(AgentProvisioningProgressReport_get_State), reinterpret_cast<setter>(AgentProvisioningProgressReport_put_State), nullptr, nullptr },
        { "progress_percentage", reinterpret_cast<getter>(AgentProvisioningProgressReport_get_ProgressPercentage), reinterpret_cast<setter>(AgentProvisioningProgressReport_put_ProgressPercentage), nullptr, nullptr },
        { "estimated_time_remaining", reinterpret_cast<getter>(AgentProvisioningProgressReport_get_EstimatedTimeRemaining), reinterpret_cast<setter>(AgentProvisioningProgressReport_put_EstimatedTimeRemaining), nullptr, nullptr },
        { "display_progress_secondary", reinterpret_cast<getter>(AgentProvisioningProgressReport_get_DisplayProgressSecondary), reinterpret_cast<setter>(AgentProvisioningProgressReport_put_DisplayProgressSecondary), nullptr, nullptr },
        { "display_progress", reinterpret_cast<getter>(AgentProvisioningProgressReport_get_DisplayProgress), reinterpret_cast<setter>(AgentProvisioningProgressReport_put_DisplayProgress), nullptr, nullptr },
        { "current_batch_index", reinterpret_cast<getter>(AgentProvisioningProgressReport_get_CurrentBatchIndex), reinterpret_cast<setter>(AgentProvisioningProgressReport_put_CurrentBatchIndex), nullptr, nullptr },
        { "batches", reinterpret_cast<getter>(AgentProvisioningProgressReport_get_Batches), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_AgentProvisioningProgressReport[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_AgentProvisioningProgressReport) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_AgentProvisioningProgressReport) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_AgentProvisioningProgressReport) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_AgentProvisioningProgressReport) },
        { }
    };

    static PyType_Spec type_spec_AgentProvisioningProgressReport = {
        "winrt._winrt_windows_management_setup.AgentProvisioningProgressReport",
        sizeof(py::wrapper::Windows::Management::Setup::AgentProvisioningProgressReport),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_AgentProvisioningProgressReport};

    // ----- DeploymentSessionConnectionChangedEventArgs class --------------------

    static PyObject* _new_DeploymentSessionConnectionChangedEventArgs(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Management::Setup::DeploymentSessionConnectionChangedEventArgs>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Management::Setup::DeploymentSessionConnectionChangedEventArgs>::type_name);
        return nullptr;
    }

    static void _dealloc_DeploymentSessionConnectionChangedEventArgs(py::wrapper::Windows::Management::Setup::DeploymentSessionConnectionChangedEventArgs* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* DeploymentSessionConnectionChangedEventArgs_get_Change(py::wrapper::Windows::Management::Setup::DeploymentSessionConnectionChangedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Management.Setup.DeploymentSessionConnectionChangedEventArgs", L"Change");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Change());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* DeploymentSessionConnectionChangedEventArgs_get_SessionId(py::wrapper::Windows::Management::Setup::DeploymentSessionConnectionChangedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Management.Setup.DeploymentSessionConnectionChangedEventArgs", L"SessionId");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.SessionId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_DeploymentSessionConnectionChangedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Management::Setup::DeploymentSessionConnectionChangedEventArgs>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_DeploymentSessionConnectionChangedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Management::Setup::DeploymentSessionConnectionChangedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_DeploymentSessionConnectionChangedEventArgs[] = {
        { "_assign_array_", _assign_array_DeploymentSessionConnectionChangedEventArgs, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_DeploymentSessionConnectionChangedEventArgs), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_DeploymentSessionConnectionChangedEventArgs[] = {
        { "change", reinterpret_cast<getter>(DeploymentSessionConnectionChangedEventArgs_get_Change), nullptr, nullptr, nullptr },
        { "session_id", reinterpret_cast<getter>(DeploymentSessionConnectionChangedEventArgs_get_SessionId), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_DeploymentSessionConnectionChangedEventArgs[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_DeploymentSessionConnectionChangedEventArgs) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_DeploymentSessionConnectionChangedEventArgs) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_DeploymentSessionConnectionChangedEventArgs) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_DeploymentSessionConnectionChangedEventArgs) },
        { }
    };

    static PyType_Spec type_spec_DeploymentSessionConnectionChangedEventArgs = {
        "winrt._winrt_windows_management_setup.DeploymentSessionConnectionChangedEventArgs",
        sizeof(py::wrapper::Windows::Management::Setup::DeploymentSessionConnectionChangedEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_DeploymentSessionConnectionChangedEventArgs};

    // ----- DeploymentSessionHeartbeatRequestedEventArgs class --------------------

    static PyObject* _new_DeploymentSessionHeartbeatRequestedEventArgs(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Management::Setup::DeploymentSessionHeartbeatRequestedEventArgs>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Management::Setup::DeploymentSessionHeartbeatRequestedEventArgs>::type_name);
        return nullptr;
    }

    static void _dealloc_DeploymentSessionHeartbeatRequestedEventArgs(py::wrapper::Windows::Management::Setup::DeploymentSessionHeartbeatRequestedEventArgs* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* DeploymentSessionHeartbeatRequestedEventArgs_get_Handled(py::wrapper::Windows::Management::Setup::DeploymentSessionHeartbeatRequestedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Management.Setup.DeploymentSessionHeartbeatRequestedEventArgs", L"Handled");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Handled());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int DeploymentSessionHeartbeatRequestedEventArgs_put_Handled(py::wrapper::Windows::Management::Setup::DeploymentSessionHeartbeatRequestedEventArgs* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Management.Setup.DeploymentSessionHeartbeatRequestedEventArgs", L"Handled");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<bool>(arg);

            self->obj.Handled(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* _assign_array_DeploymentSessionHeartbeatRequestedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Management::Setup::DeploymentSessionHeartbeatRequestedEventArgs>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_DeploymentSessionHeartbeatRequestedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Management::Setup::DeploymentSessionHeartbeatRequestedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_DeploymentSessionHeartbeatRequestedEventArgs[] = {
        { "_assign_array_", _assign_array_DeploymentSessionHeartbeatRequestedEventArgs, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_DeploymentSessionHeartbeatRequestedEventArgs), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_DeploymentSessionHeartbeatRequestedEventArgs[] = {
        { "handled", reinterpret_cast<getter>(DeploymentSessionHeartbeatRequestedEventArgs_get_Handled), reinterpret_cast<setter>(DeploymentSessionHeartbeatRequestedEventArgs_put_Handled), nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_DeploymentSessionHeartbeatRequestedEventArgs[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_DeploymentSessionHeartbeatRequestedEventArgs) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_DeploymentSessionHeartbeatRequestedEventArgs) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_DeploymentSessionHeartbeatRequestedEventArgs) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_DeploymentSessionHeartbeatRequestedEventArgs) },
        { }
    };

    static PyType_Spec type_spec_DeploymentSessionHeartbeatRequestedEventArgs = {
        "winrt._winrt_windows_management_setup.DeploymentSessionHeartbeatRequestedEventArgs",
        sizeof(py::wrapper::Windows::Management::Setup::DeploymentSessionHeartbeatRequestedEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_DeploymentSessionHeartbeatRequestedEventArgs};

    // ----- DeploymentSessionStateChangedEventArgs class --------------------

    static PyObject* _new_DeploymentSessionStateChangedEventArgs(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Management::Setup::DeploymentSessionStateChangedEventArgs>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Management::Setup::DeploymentSessionStateChangedEventArgs>::type_name);
        return nullptr;
    }

    static void _dealloc_DeploymentSessionStateChangedEventArgs(py::wrapper::Windows::Management::Setup::DeploymentSessionStateChangedEventArgs* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* DeploymentSessionStateChangedEventArgs_get_Change(py::wrapper::Windows::Management::Setup::DeploymentSessionStateChangedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Management.Setup.DeploymentSessionStateChangedEventArgs", L"Change");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Change());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* DeploymentSessionStateChangedEventArgs_get_SessionId(py::wrapper::Windows::Management::Setup::DeploymentSessionStateChangedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Management.Setup.DeploymentSessionStateChangedEventArgs", L"SessionId");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.SessionId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_DeploymentSessionStateChangedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Management::Setup::DeploymentSessionStateChangedEventArgs>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_DeploymentSessionStateChangedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Management::Setup::DeploymentSessionStateChangedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_DeploymentSessionStateChangedEventArgs[] = {
        { "_assign_array_", _assign_array_DeploymentSessionStateChangedEventArgs, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_DeploymentSessionStateChangedEventArgs), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_DeploymentSessionStateChangedEventArgs[] = {
        { "change", reinterpret_cast<getter>(DeploymentSessionStateChangedEventArgs_get_Change), nullptr, nullptr, nullptr },
        { "session_id", reinterpret_cast<getter>(DeploymentSessionStateChangedEventArgs_get_SessionId), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_DeploymentSessionStateChangedEventArgs[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_DeploymentSessionStateChangedEventArgs) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_DeploymentSessionStateChangedEventArgs) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_DeploymentSessionStateChangedEventArgs) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_DeploymentSessionStateChangedEventArgs) },
        { }
    };

    static PyType_Spec type_spec_DeploymentSessionStateChangedEventArgs = {
        "winrt._winrt_windows_management_setup.DeploymentSessionStateChangedEventArgs",
        sizeof(py::wrapper::Windows::Management::Setup::DeploymentSessionStateChangedEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_DeploymentSessionStateChangedEventArgs};

    // ----- DeploymentWorkload class --------------------

    static PyObject* _new_DeploymentWorkload(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                winrt::Windows::Management::Setup::DeploymentWorkload instance{param0};
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_DeploymentWorkload(py::wrapper::Windows::Management::Setup::DeploymentWorkload* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* DeploymentWorkload_get_StateDetails(py::wrapper::Windows::Management::Setup::DeploymentWorkload* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Management.Setup.DeploymentWorkload", L"StateDetails");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.StateDetails());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int DeploymentWorkload_put_StateDetails(py::wrapper::Windows::Management::Setup::DeploymentWorkload* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Management.Setup.DeploymentWorkload", L"StateDetails");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.StateDetails(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* DeploymentWorkload_get_State(py::wrapper::Windows::Management::Setup::DeploymentWorkload* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Management.Setup.DeploymentWorkload", L"State");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.State());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int DeploymentWorkload_put_State(py::wrapper::Windows::Management::Setup::DeploymentWorkload* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Management.Setup.DeploymentWorkload", L"State");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::Management::Setup::DeploymentWorkloadState>(arg);

            self->obj.State(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* DeploymentWorkload_get_StartTime(py::wrapper::Windows::Management::Setup::DeploymentWorkload* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Management.Setup.DeploymentWorkload", L"StartTime");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.StartTime());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int DeploymentWorkload_put_StartTime(py::wrapper::Windows::Management::Setup::DeploymentWorkload* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Management.Setup.DeploymentWorkload", L"StartTime");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::IReference<winrt::Windows::Foundation::DateTime>>(arg);

            self->obj.StartTime(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* DeploymentWorkload_get_PossibleResolution(py::wrapper::Windows::Management::Setup::DeploymentWorkload* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Management.Setup.DeploymentWorkload", L"PossibleResolution");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.PossibleResolution());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int DeploymentWorkload_put_PossibleResolution(py::wrapper::Windows::Management::Setup::DeploymentWorkload* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Management.Setup.DeploymentWorkload", L"PossibleResolution");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.PossibleResolution(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* DeploymentWorkload_get_PossibleCause(py::wrapper::Windows::Management::Setup::DeploymentWorkload* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Management.Setup.DeploymentWorkload", L"PossibleCause");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.PossibleCause());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int DeploymentWorkload_put_PossibleCause(py::wrapper::Windows::Management::Setup::DeploymentWorkload* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Management.Setup.DeploymentWorkload", L"PossibleCause");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.PossibleCause(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* DeploymentWorkload_get_ErrorMessage(py::wrapper::Windows::Management::Setup::DeploymentWorkload* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Management.Setup.DeploymentWorkload", L"ErrorMessage");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.ErrorMessage());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int DeploymentWorkload_put_ErrorMessage(py::wrapper::Windows::Management::Setup::DeploymentWorkload* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Management.Setup.DeploymentWorkload", L"ErrorMessage");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.ErrorMessage(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* DeploymentWorkload_get_ErrorCode(py::wrapper::Windows::Management::Setup::DeploymentWorkload* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Management.Setup.DeploymentWorkload", L"ErrorCode");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.ErrorCode());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int DeploymentWorkload_put_ErrorCode(py::wrapper::Windows::Management::Setup::DeploymentWorkload* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Management.Setup.DeploymentWorkload", L"ErrorCode");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<uint32_t>(arg);

            self->obj.ErrorCode(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* DeploymentWorkload_get_EndTime(py::wrapper::Windows::Management::Setup::DeploymentWorkload* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Management.Setup.DeploymentWorkload", L"EndTime");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.EndTime());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int DeploymentWorkload_put_EndTime(py::wrapper::Windows::Management::Setup::DeploymentWorkload* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Management.Setup.DeploymentWorkload", L"EndTime");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::IReference<winrt::Windows::Foundation::DateTime>>(arg);

            self->obj.EndTime(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* DeploymentWorkload_get_DisplayFriendlyName(py::wrapper::Windows::Management::Setup::DeploymentWorkload* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Management.Setup.DeploymentWorkload", L"DisplayFriendlyName");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.DisplayFriendlyName());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int DeploymentWorkload_put_DisplayFriendlyName(py::wrapper::Windows::Management::Setup::DeploymentWorkload* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Management.Setup.DeploymentWorkload", L"DisplayFriendlyName");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.DisplayFriendlyName(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* DeploymentWorkload_get_Id(py::wrapper::Windows::Management::Setup::DeploymentWorkload* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Management.Setup.DeploymentWorkload", L"Id");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Id());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_DeploymentWorkload(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Management::Setup::DeploymentWorkload>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_DeploymentWorkload(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Management::Setup::DeploymentWorkload>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_DeploymentWorkload[] = {
        { "_assign_array_", _assign_array_DeploymentWorkload, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_DeploymentWorkload), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_DeploymentWorkload[] = {
        { "state_details", reinterpret_cast<getter>(DeploymentWorkload_get_StateDetails), reinterpret_cast<setter>(DeploymentWorkload_put_StateDetails), nullptr, nullptr },
        { "state", reinterpret_cast<getter>(DeploymentWorkload_get_State), reinterpret_cast<setter>(DeploymentWorkload_put_State), nullptr, nullptr },
        { "start_time", reinterpret_cast<getter>(DeploymentWorkload_get_StartTime), reinterpret_cast<setter>(DeploymentWorkload_put_StartTime), nullptr, nullptr },
        { "possible_resolution", reinterpret_cast<getter>(DeploymentWorkload_get_PossibleResolution), reinterpret_cast<setter>(DeploymentWorkload_put_PossibleResolution), nullptr, nullptr },
        { "possible_cause", reinterpret_cast<getter>(DeploymentWorkload_get_PossibleCause), reinterpret_cast<setter>(DeploymentWorkload_put_PossibleCause), nullptr, nullptr },
        { "error_message", reinterpret_cast<getter>(DeploymentWorkload_get_ErrorMessage), reinterpret_cast<setter>(DeploymentWorkload_put_ErrorMessage), nullptr, nullptr },
        { "error_code", reinterpret_cast<getter>(DeploymentWorkload_get_ErrorCode), reinterpret_cast<setter>(DeploymentWorkload_put_ErrorCode), nullptr, nullptr },
        { "end_time", reinterpret_cast<getter>(DeploymentWorkload_get_EndTime), reinterpret_cast<setter>(DeploymentWorkload_put_EndTime), nullptr, nullptr },
        { "display_friendly_name", reinterpret_cast<getter>(DeploymentWorkload_get_DisplayFriendlyName), reinterpret_cast<setter>(DeploymentWorkload_put_DisplayFriendlyName), nullptr, nullptr },
        { "id", reinterpret_cast<getter>(DeploymentWorkload_get_Id), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_DeploymentWorkload[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_DeploymentWorkload) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_DeploymentWorkload) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_DeploymentWorkload) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_DeploymentWorkload) },
        { }
    };

    static PyType_Spec type_spec_DeploymentWorkload = {
        "winrt._winrt_windows_management_setup.DeploymentWorkload",
        sizeof(py::wrapper::Windows::Management::Setup::DeploymentWorkload),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_DeploymentWorkload};

    // ----- DeploymentWorkloadBatch class --------------------

    static PyObject* _new_DeploymentWorkloadBatch(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<uint32_t>(args, 0);

                winrt::Windows::Management::Setup::DeploymentWorkloadBatch instance{param0};
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_DeploymentWorkloadBatch(py::wrapper::Windows::Management::Setup::DeploymentWorkloadBatch* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* DeploymentWorkloadBatch_get_DisplayCategoryTitle(py::wrapper::Windows::Management::Setup::DeploymentWorkloadBatch* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Management.Setup.DeploymentWorkloadBatch", L"DisplayCategoryTitle");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.DisplayCategoryTitle());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int DeploymentWorkloadBatch_put_DisplayCategoryTitle(py::wrapper::Windows::Management::Setup::DeploymentWorkloadBatch* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Management.Setup.DeploymentWorkloadBatch", L"DisplayCategoryTitle");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.DisplayCategoryTitle(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* DeploymentWorkloadBatch_get_BatchWorkloads(py::wrapper::Windows::Management::Setup::DeploymentWorkloadBatch* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Management.Setup.DeploymentWorkloadBatch", L"BatchWorkloads");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.BatchWorkloads());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* DeploymentWorkloadBatch_get_Id(py::wrapper::Windows::Management::Setup::DeploymentWorkloadBatch* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Management.Setup.DeploymentWorkloadBatch", L"Id");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Id());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_DeploymentWorkloadBatch(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Management::Setup::DeploymentWorkloadBatch>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_DeploymentWorkloadBatch(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Management::Setup::DeploymentWorkloadBatch>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_DeploymentWorkloadBatch[] = {
        { "_assign_array_", _assign_array_DeploymentWorkloadBatch, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_DeploymentWorkloadBatch), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_DeploymentWorkloadBatch[] = {
        { "display_category_title", reinterpret_cast<getter>(DeploymentWorkloadBatch_get_DisplayCategoryTitle), reinterpret_cast<setter>(DeploymentWorkloadBatch_put_DisplayCategoryTitle), nullptr, nullptr },
        { "batch_workloads", reinterpret_cast<getter>(DeploymentWorkloadBatch_get_BatchWorkloads), nullptr, nullptr, nullptr },
        { "id", reinterpret_cast<getter>(DeploymentWorkloadBatch_get_Id), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_DeploymentWorkloadBatch[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_DeploymentWorkloadBatch) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_DeploymentWorkloadBatch) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_DeploymentWorkloadBatch) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_DeploymentWorkloadBatch) },
        { }
    };

    static PyType_Spec type_spec_DeploymentWorkloadBatch = {
        "winrt._winrt_windows_management_setup.DeploymentWorkloadBatch",
        sizeof(py::wrapper::Windows::Management::Setup::DeploymentWorkloadBatch),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_DeploymentWorkloadBatch};

    // ----- DevicePreparationExecutionContext class --------------------

    static PyObject* _new_DevicePreparationExecutionContext(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Management::Setup::DevicePreparationExecutionContext>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Management::Setup::DevicePreparationExecutionContext>::type_name);
        return nullptr;
    }

    static void _dealloc_DevicePreparationExecutionContext(py::wrapper::Windows::Management::Setup::DevicePreparationExecutionContext* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* DevicePreparationExecutionContext_get_Context(py::wrapper::Windows::Management::Setup::DevicePreparationExecutionContext* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Management.Setup.DevicePreparationExecutionContext", L"Context");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Context());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_DevicePreparationExecutionContext(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Management::Setup::DevicePreparationExecutionContext>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_DevicePreparationExecutionContext(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Management::Setup::DevicePreparationExecutionContext>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_DevicePreparationExecutionContext[] = {
        { "_assign_array_", _assign_array_DevicePreparationExecutionContext, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_DevicePreparationExecutionContext), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_DevicePreparationExecutionContext[] = {
        { "context", reinterpret_cast<getter>(DevicePreparationExecutionContext_get_Context), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_DevicePreparationExecutionContext[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_DevicePreparationExecutionContext) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_DevicePreparationExecutionContext) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_DevicePreparationExecutionContext) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_DevicePreparationExecutionContext) },
        { }
    };

    static PyType_Spec type_spec_DevicePreparationExecutionContext = {
        "winrt._winrt_windows_management_setup.DevicePreparationExecutionContext",
        sizeof(py::wrapper::Windows::Management::Setup::DevicePreparationExecutionContext),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_DevicePreparationExecutionContext};

    // ----- MachineProvisioningProgressReporter class --------------------

    static PyObject* _new_MachineProvisioningProgressReporter(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Management::Setup::MachineProvisioningProgressReporter>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Management::Setup::MachineProvisioningProgressReporter>::type_name);
        return nullptr;
    }

    static void _dealloc_MachineProvisioningProgressReporter(py::wrapper::Windows::Management::Setup::MachineProvisioningProgressReporter* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* MachineProvisioningProgressReporter_GetDevicePreparationExecutionContextAsync(py::wrapper::Windows::Management::Setup::MachineProvisioningProgressReporter* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Management.Setup.MachineProvisioningProgressReporter", L"GetDevicePreparationExecutionContextAsync", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert(self->obj.GetDevicePreparationExecutionContextAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MachineProvisioningProgressReporter_GetForLaunchUri(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Management.Setup.MachineProvisioningProgressReporter", L"GetForLaunchUri", 2);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(2);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Foundation::Uri>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Management::Setup::DeploymentSessionHeartbeatRequested>(args, 1);

                return py::convert(winrt::Windows::Management::Setup::MachineProvisioningProgressReporter::GetForLaunchUri(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MachineProvisioningProgressReporter_ReportProgress(py::wrapper::Windows::Management::Setup::MachineProvisioningProgressReporter* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Management.Setup.MachineProvisioningProgressReporter", L"ReportProgress", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Management::Setup::AgentProvisioningProgressReport>(args, 0);

                self->obj.ReportProgress(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MachineProvisioningProgressReporter_get_SessionConnection(py::wrapper::Windows::Management::Setup::MachineProvisioningProgressReporter* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Management.Setup.MachineProvisioningProgressReporter", L"SessionConnection");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.SessionConnection());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MachineProvisioningProgressReporter_get_SessionId(py::wrapper::Windows::Management::Setup::MachineProvisioningProgressReporter* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Management.Setup.MachineProvisioningProgressReporter", L"SessionId");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.SessionId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MachineProvisioningProgressReporter_get_SessionState(py::wrapper::Windows::Management::Setup::MachineProvisioningProgressReporter* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Management.Setup.MachineProvisioningProgressReporter", L"SessionState");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.SessionState());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MachineProvisioningProgressReporter_add_SessionConnectionChanged(py::wrapper::Windows::Management::Setup::MachineProvisioningProgressReporter* self, PyObject* arg) noexcept
    {
        try
        {
            static std::optional<bool> is_event_present{};

            if (!is_event_present.has_value())
            {
                is_event_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Management.Setup.MachineProvisioningProgressReporter", L"SessionConnectionChanged");
            }

            if (!is_event_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Management::Setup::MachineProvisioningProgressReporter, winrt::Windows::Management::Setup::DeploymentSessionConnectionChangedEventArgs>>(arg);

            return py::convert(self->obj.SessionConnectionChanged(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MachineProvisioningProgressReporter_remove_SessionConnectionChanged(py::wrapper::Windows::Management::Setup::MachineProvisioningProgressReporter* self, PyObject* arg) noexcept
    {
        try
        {
            static std::optional<bool> is_event_present{};

            if (!is_event_present.has_value())
            {
                is_event_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Management.Setup.MachineProvisioningProgressReporter", L"SessionConnectionChanged");
            }

            if (!is_event_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.SessionConnectionChanged(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MachineProvisioningProgressReporter_add_SessionStateChanged(py::wrapper::Windows::Management::Setup::MachineProvisioningProgressReporter* self, PyObject* arg) noexcept
    {
        try
        {
            static std::optional<bool> is_event_present{};

            if (!is_event_present.has_value())
            {
                is_event_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Management.Setup.MachineProvisioningProgressReporter", L"SessionStateChanged");
            }

            if (!is_event_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Management::Setup::MachineProvisioningProgressReporter, winrt::Windows::Management::Setup::DeploymentSessionStateChangedEventArgs>>(arg);

            return py::convert(self->obj.SessionStateChanged(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MachineProvisioningProgressReporter_remove_SessionStateChanged(py::wrapper::Windows::Management::Setup::MachineProvisioningProgressReporter* self, PyObject* arg) noexcept
    {
        try
        {
            static std::optional<bool> is_event_present{};

            if (!is_event_present.has_value())
            {
                is_event_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Management.Setup.MachineProvisioningProgressReporter", L"SessionStateChanged");
            }

            if (!is_event_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.SessionStateChanged(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_MachineProvisioningProgressReporter(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Management::Setup::MachineProvisioningProgressReporter>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_MachineProvisioningProgressReporter(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Management::Setup::MachineProvisioningProgressReporter>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_MachineProvisioningProgressReporter[] = {
        { "get_device_preparation_execution_context_async", reinterpret_cast<PyCFunction>(MachineProvisioningProgressReporter_GetDevicePreparationExecutionContextAsync), METH_VARARGS, nullptr },
        { "report_progress", reinterpret_cast<PyCFunction>(MachineProvisioningProgressReporter_ReportProgress), METH_VARARGS, nullptr },
        { "add_session_connection_changed", reinterpret_cast<PyCFunction>(MachineProvisioningProgressReporter_add_SessionConnectionChanged), METH_O, nullptr },
        { "remove_session_connection_changed", reinterpret_cast<PyCFunction>(MachineProvisioningProgressReporter_remove_SessionConnectionChanged), METH_O, nullptr },
        { "add_session_state_changed", reinterpret_cast<PyCFunction>(MachineProvisioningProgressReporter_add_SessionStateChanged), METH_O, nullptr },
        { "remove_session_state_changed", reinterpret_cast<PyCFunction>(MachineProvisioningProgressReporter_remove_SessionStateChanged), METH_O, nullptr },
        { "_assign_array_", _assign_array_MachineProvisioningProgressReporter, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_MachineProvisioningProgressReporter), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_MachineProvisioningProgressReporter[] = {
        { "session_connection", reinterpret_cast<getter>(MachineProvisioningProgressReporter_get_SessionConnection), nullptr, nullptr, nullptr },
        { "session_id", reinterpret_cast<getter>(MachineProvisioningProgressReporter_get_SessionId), nullptr, nullptr, nullptr },
        { "session_state", reinterpret_cast<getter>(MachineProvisioningProgressReporter_get_SessionState), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_MachineProvisioningProgressReporter[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_MachineProvisioningProgressReporter) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_MachineProvisioningProgressReporter) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_MachineProvisioningProgressReporter) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_MachineProvisioningProgressReporter) },
        { }
    };

    static PyType_Spec type_spec_MachineProvisioningProgressReporter = {
        "winrt._winrt_windows_management_setup.MachineProvisioningProgressReporter",
        sizeof(py::wrapper::Windows::Management::Setup::MachineProvisioningProgressReporter),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_MachineProvisioningProgressReporter};

    static PyGetSetDef getset_MachineProvisioningProgressReporter_Static[] = {
        { }
    };

    static PyMethodDef methods_MachineProvisioningProgressReporter_Static[] = {
        { "get_for_launch_uri", reinterpret_cast<PyCFunction>(MachineProvisioningProgressReporter_GetForLaunchUri), METH_VARARGS, nullptr },
        { }
    };

    static PyType_Slot type_slots_MachineProvisioningProgressReporter_Static[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_MachineProvisioningProgressReporter_Static) },
        { Py_tp_methods, reinterpret_cast<void*>(methods_MachineProvisioningProgressReporter_Static) },
        { }
    };

    static PyType_Spec type_spec_MachineProvisioningProgressReporter_Static =
    {
        "winrt._winrt_windows_management_setup.MachineProvisioningProgressReporter_Static",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT,
        type_slots_MachineProvisioningProgressReporter_Static
    };

    // ----- Windows.Management.Setup Initialization --------------------

    PyDoc_STRVAR(module_doc, "Windows.Management.Setup");

    static PyModuleDef module_def = {
        PyModuleDef_HEAD_INIT,
        "_winrt_windows_management_setup",
        module_doc,
        0,
        nullptr,
        nullptr,
        nullptr,
        nullptr,
        nullptr};
} // py::cpp::Windows::Management::Setup

PyMODINIT_FUNC PyInit__winrt_windows_management_setup(void) noexcept
{
    using namespace py::cpp::Windows::Management::Setup;

    if (py::import_winrt_runtime() == -1)
    {
        return nullptr;
    }

    py::pyobj_handle module{PyModule_Create(&module_def)};

    if (!module)
    {
        return nullptr;
    }

    auto object_type = py::get_object_type();
    if (!object_type)
    {
        return nullptr;
    }

    py::pyobj_handle object_bases{PyTuple_Pack(1, object_type)};

    if (!object_bases)
    {
        return nullptr;
    }

    py::pytype_handle AgentProvisioningProgressReport_type{py::register_python_type(module.get(), &type_spec_AgentProvisioningProgressReport, object_bases.get(), nullptr)};
    if (!AgentProvisioningProgressReport_type)
    {
        return nullptr;
    }

    py::pytype_handle DeploymentSessionConnectionChangedEventArgs_type{py::register_python_type(module.get(), &type_spec_DeploymentSessionConnectionChangedEventArgs, object_bases.get(), nullptr)};
    if (!DeploymentSessionConnectionChangedEventArgs_type)
    {
        return nullptr;
    }

    py::pytype_handle DeploymentSessionHeartbeatRequestedEventArgs_type{py::register_python_type(module.get(), &type_spec_DeploymentSessionHeartbeatRequestedEventArgs, object_bases.get(), nullptr)};
    if (!DeploymentSessionHeartbeatRequestedEventArgs_type)
    {
        return nullptr;
    }

    py::pytype_handle DeploymentSessionStateChangedEventArgs_type{py::register_python_type(module.get(), &type_spec_DeploymentSessionStateChangedEventArgs, object_bases.get(), nullptr)};
    if (!DeploymentSessionStateChangedEventArgs_type)
    {
        return nullptr;
    }

    py::pytype_handle DeploymentWorkload_type{py::register_python_type(module.get(), &type_spec_DeploymentWorkload, object_bases.get(), nullptr)};
    if (!DeploymentWorkload_type)
    {
        return nullptr;
    }

    py::pytype_handle DeploymentWorkloadBatch_type{py::register_python_type(module.get(), &type_spec_DeploymentWorkloadBatch, object_bases.get(), nullptr)};
    if (!DeploymentWorkloadBatch_type)
    {
        return nullptr;
    }

    py::pytype_handle DevicePreparationExecutionContext_type{py::register_python_type(module.get(), &type_spec_DevicePreparationExecutionContext, object_bases.get(), nullptr)};
    if (!DevicePreparationExecutionContext_type)
    {
        return nullptr;
    }

    py::pyobj_handle type_MachineProvisioningProgressReporter_Static{PyType_FromSpec(&type_spec_MachineProvisioningProgressReporter_Static)};
    if (!type_MachineProvisioningProgressReporter_Static)
    {
        return nullptr;
    }

    py::pytype_handle MachineProvisioningProgressReporter_type{py::register_python_type(module.get(), &type_spec_MachineProvisioningProgressReporter, object_bases.get(), reinterpret_cast<PyTypeObject*>(type_MachineProvisioningProgressReporter_Static.get()))};
    if (!MachineProvisioningProgressReporter_type)
    {
        return nullptr;
    }


    return module.detach();
}
