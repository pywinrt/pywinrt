# WARNING: Please don't edit this file. It was generated by Python/WinRT v0.0.0

import datetime
import sys
import types
import typing
import uuid as _uuid
from builtins import property as _property

import winrt._winrt
import winrt.system
import winrt.windows.applicationmodel.background as windows_applicationmodel_background
import winrt.windows.foundation as windows_foundation
import winrt.windows.foundation.collections as windows_foundation_collections
import winrt.windows.security.credentials as windows_security_credentials
import winrt.windows.storage.streams as windows_storage_streams
import winrt.windows.ui as windows_ui
import winrt.windows.ui.popups as windows_ui_popups

from winrt.windows.devices.enumeration import DeviceAccessStatus, DeviceClass, DeviceInformationKind, DevicePairingAddPairingSetMemberStatus, DevicePairingKinds, DevicePairingProtectionLevel, DevicePairingResultStatus, DevicePickerDisplayStatusOptions, DeviceUnpairingResultStatus, DeviceWatcherEventKind, DeviceWatcherStatus, Panel

Self = typing.TypeVar('Self')

@typing.final
class DeviceAccessChangedEventArgs(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> DeviceAccessChangedEventArgs: ...
    @_property
    def status(self) -> DeviceAccessStatus: ...
    @_property
    def id(self) -> str: ...
    @_property
    def user_prompt_required(self) -> bool: ...

@typing.final
class DeviceAccessInformation_Static(type):
    def create_from_device_class(cls, device_class: DeviceClass, /) -> DeviceAccessInformation: ...
    def create_from_device_class_id(cls, device_class_id: _uuid.UUID, /) -> DeviceAccessInformation: ...
    def create_from_id(cls, device_id: str, /) -> DeviceAccessInformation: ...

@typing.final
class DeviceAccessInformation(winrt.system.Object, metaclass=DeviceAccessInformation_Static):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> DeviceAccessInformation: ...
    def add_access_changed(self, handler: windows_foundation.TypedEventHandler[DeviceAccessInformation, DeviceAccessChangedEventArgs], /) -> windows_foundation.EventRegistrationToken: ...
    def remove_access_changed(self, cookie: windows_foundation.EventRegistrationToken, /) -> None: ...
    @_property
    def current_status(self) -> DeviceAccessStatus: ...
    @_property
    def user_prompt_required(self) -> bool: ...

@typing.final
class DeviceConnectionChangeTriggerDetails(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> DeviceConnectionChangeTriggerDetails: ...
    @_property
    def device_id(self) -> str: ...

@typing.final
class DeviceDisconnectButtonClickedEventArgs(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> DeviceDisconnectButtonClickedEventArgs: ...
    @_property
    def device(self) -> DeviceInformation: ...

@typing.final
class DeviceInformation_Static(type):
    def create_from_id_async(cls, device_id: str, /) -> windows_foundation.IAsyncOperation[DeviceInformation]: ...
    def create_from_id_async_additional_properties(cls, device_id: str, additional_properties: typing.Iterable[str], /) -> windows_foundation.IAsyncOperation[DeviceInformation]: ...
    def create_from_id_async_with_additional_properties_kind_and_settings(cls, device_id: str, additional_properties: typing.Iterable[str], kind: DeviceInformationKind, settings: ImplementsIDeviceEnumerationSettings, /) -> windows_foundation.IAsyncOperation[DeviceInformation]: ...
    def create_from_id_async_with_kind_and_additional_properties(cls, device_id: str, additional_properties: typing.Iterable[str], kind: DeviceInformationKind, /) -> windows_foundation.IAsyncOperation[DeviceInformation]: ...
    def create_watcher(cls) -> DeviceWatcher: ...
    def create_watcher_aqs_filter(cls, aqs_filter: str, /) -> DeviceWatcher: ...
    def create_watcher_aqs_filter_and_additional_properties(cls, aqs_filter: str, additional_properties: typing.Iterable[str], /) -> DeviceWatcher: ...
    def create_watcher_device_class(cls, device_class: DeviceClass, /) -> DeviceWatcher: ...
    def create_watcher_with_aqs_filter_additional_properties_kind_and_settings(cls, aqs_filter: str, additional_properties: typing.Iterable[str], kind: DeviceInformationKind, settings: ImplementsIDeviceEnumerationSettings, /) -> DeviceWatcher: ...
    def create_watcher_with_kind_aqs_filter_and_additional_properties(cls, aqs_filter: str, additional_properties: typing.Iterable[str], kind: DeviceInformationKind, /) -> DeviceWatcher: ...
    def find_all_async(cls) -> windows_foundation.IAsyncOperation[DeviceInformationCollection]: ...
    def find_all_async_aqs_filter(cls, aqs_filter: str, /) -> windows_foundation.IAsyncOperation[DeviceInformationCollection]: ...
    def find_all_async_aqs_filter_and_additional_properties(cls, aqs_filter: str, additional_properties: typing.Iterable[str], /) -> windows_foundation.IAsyncOperation[DeviceInformationCollection]: ...
    def find_all_async_device_class(cls, device_class: DeviceClass, /) -> windows_foundation.IAsyncOperation[DeviceInformationCollection]: ...
    def find_all_async_with_aqs_filter_additional_properties_kind_and_settings(cls, aqs_filter: str, additional_properties: typing.Iterable[str], kind: DeviceInformationKind, settings: ImplementsIDeviceEnumerationSettings, /) -> windows_foundation.IAsyncOperation[DeviceInformationCollection]: ...
    def find_all_async_with_kind_aqs_filter_and_additional_properties(cls, aqs_filter: str, additional_properties: typing.Iterable[str], kind: DeviceInformationKind, /) -> windows_foundation.IAsyncOperation[DeviceInformationCollection]: ...
    def get_aqs_filter_from_device_class(cls, device_class: DeviceClass, /) -> str: ...

@typing.final
class DeviceInformation(winrt.system.Object, metaclass=DeviceInformation_Static):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> DeviceInformation: ...
    def get_glyph_thumbnail_async(self) -> windows_foundation.IAsyncOperation[DeviceThumbnail]: ...
    def get_thumbnail_async(self) -> windows_foundation.IAsyncOperation[DeviceThumbnail]: ...
    def update(self, update_info: DeviceInformationUpdate, /) -> None: ...
    @_property
    def enclosure_location(self) -> EnclosureLocation: ...
    @_property
    def id(self) -> str: ...
    @_property
    def is_default(self) -> bool: ...
    @_property
    def is_enabled(self) -> bool: ...
    @_property
    def name(self) -> str: ...
    @_property
    def properties(self) -> typing.Mapping[str, winrt.system.Object]: ...
    @_property
    def kind(self) -> DeviceInformationKind: ...
    @_property
    def pairing(self) -> DeviceInformationPairing: ...

@typing.final
class DeviceInformationCollection(winrt.system.Object, winrt._winrt.Sequence[DeviceInformation]):
    def __len__(self) -> int: ...
    def __iter__(self) -> windows_foundation_collections.IIterator[DeviceInformation]: ...
    @typing.overload
    def __getitem__(self, index: typing.SupportsIndex) -> DeviceInformation: ...
    @typing.overload
    def __getitem__(self, index: slice) -> winrt.system.Array[DeviceInformation]: ...
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> DeviceInformationCollection: ...
    def first(self) -> windows_foundation_collections.IIterator[DeviceInformation]: ...
    def get_at(self, index: winrt.system.UInt32, /) -> DeviceInformation: ...
    def get_many(self, start_index: winrt.system.UInt32, items: typing.Union[winrt.system.Array[DeviceInformation], winrt.system.WriteableBuffer], /) -> winrt.system.UInt32: ...
    def index_of(self, value: DeviceInformation, /) -> typing.Tuple[bool, winrt.system.UInt32]: ...
    @_property
    def size(self) -> winrt.system.UInt32: ...

@typing.final
class DeviceInformationCustomPairing(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> DeviceInformationCustomPairing: ...
    def add_pairing_set_member(self, device: DeviceInformation, /) -> None: ...
    def pair_async(self, pairing_kinds_supported: DevicePairingKinds, /) -> windows_foundation.IAsyncOperation[DevicePairingResult]: ...
    def pair_with_protection_level_and_settings_async(self, pairing_kinds_supported: DevicePairingKinds, min_protection_level: DevicePairingProtectionLevel, device_pairing_settings: ImplementsIDevicePairingSettings, /) -> windows_foundation.IAsyncOperation[DevicePairingResult]: ...
    def pair_with_protection_level_async(self, pairing_kinds_supported: DevicePairingKinds, min_protection_level: DevicePairingProtectionLevel, /) -> windows_foundation.IAsyncOperation[DevicePairingResult]: ...
    def add_pairing_requested(self, handler: windows_foundation.TypedEventHandler[DeviceInformationCustomPairing, DevicePairingRequestedEventArgs], /) -> windows_foundation.EventRegistrationToken: ...
    def remove_pairing_requested(self, token: windows_foundation.EventRegistrationToken, /) -> None: ...
    def add_pairing_set_members_requested(self, handler: windows_foundation.TypedEventHandler[DeviceInformationCustomPairing, DevicePairingSetMembersRequestedEventArgs], /) -> windows_foundation.EventRegistrationToken: ...
    def remove_pairing_set_members_requested(self, token: windows_foundation.EventRegistrationToken, /) -> None: ...

@typing.final
class DeviceInformationPairing_Static(type):
    def try_register_for_all_inbound_pairing_requests(cls, pairing_kinds_supported: DevicePairingKinds, /) -> bool: ...
    def try_register_for_all_inbound_pairing_requests_with_protection_level(cls, pairing_kinds_supported: DevicePairingKinds, min_protection_level: DevicePairingProtectionLevel, /) -> bool: ...

@typing.final
class DeviceInformationPairing(winrt.system.Object, metaclass=DeviceInformationPairing_Static):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> DeviceInformationPairing: ...
    def pair_async(self) -> windows_foundation.IAsyncOperation[DevicePairingResult]: ...
    def pair_with_protection_level_and_settings_async(self, min_protection_level: DevicePairingProtectionLevel, device_pairing_settings: ImplementsIDevicePairingSettings, /) -> windows_foundation.IAsyncOperation[DevicePairingResult]: ...
    def pair_with_protection_level_async(self, min_protection_level: DevicePairingProtectionLevel, /) -> windows_foundation.IAsyncOperation[DevicePairingResult]: ...
    def unpair_async(self) -> windows_foundation.IAsyncOperation[DeviceUnpairingResult]: ...
    @_property
    def can_pair(self) -> bool: ...
    @_property
    def is_paired(self) -> bool: ...
    @_property
    def custom(self) -> DeviceInformationCustomPairing: ...
    @_property
    def protection_level(self) -> DevicePairingProtectionLevel: ...

@typing.final
class DeviceInformationUpdate(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> DeviceInformationUpdate: ...
    @_property
    def id(self) -> str: ...
    @_property
    def properties(self) -> typing.Mapping[str, winrt.system.Object]: ...
    @_property
    def kind(self) -> DeviceInformationKind: ...

@typing.final
class DevicePairingRequestedEventArgs(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> DevicePairingRequestedEventArgs: ...
    def accept(self) -> None: ...
    def accept_with_address(self, address: str, /) -> None: ...
    def accept_with_password_credential(self, password_credential: windows_security_credentials.PasswordCredential, /) -> None: ...
    def accept_with_pin(self, pin: str, /) -> None: ...
    def get_deferral(self) -> windows_foundation.Deferral: ...
    @_property
    def device_information(self) -> DeviceInformation: ...
    @_property
    def pairing_kind(self) -> DevicePairingKinds: ...
    @_property
    def pin(self) -> str: ...

@typing.final
class DevicePairingResult(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> DevicePairingResult: ...
    @_property
    def protection_level_used(self) -> DevicePairingProtectionLevel: ...
    @_property
    def status(self) -> DevicePairingResultStatus: ...

@typing.final
class DevicePairingSetMembersRequestedEventArgs(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> DevicePairingSetMembersRequestedEventArgs: ...
    @_property
    def pairing_set_members(self) -> typing.Sequence[DeviceInformation]: ...
    @_property
    def parent_device_information(self) -> DeviceInformation: ...
    @_property
    def status(self) -> DevicePairingAddPairingSetMemberStatus: ...

@typing.final
class DevicePicker(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> DevicePicker: ...
    def __new__(cls: typing.Type[Self]) -> Self: ...
    def hide(self) -> None: ...
    def pick_single_device_async(self, selection: windows_foundation.Rect, /) -> windows_foundation.IAsyncOperation[DeviceInformation]: ...
    def pick_single_device_async_with_placement(self, selection: windows_foundation.Rect, placement: windows_ui_popups.Placement, /) -> windows_foundation.IAsyncOperation[DeviceInformation]: ...
    def set_display_status(self, device: DeviceInformation, status: str, options: DevicePickerDisplayStatusOptions, /) -> None: ...
    def show(self, selection: windows_foundation.Rect, /) -> None: ...
    def show_with_placement(self, selection: windows_foundation.Rect, placement: windows_ui_popups.Placement, /) -> None: ...
    def add_device_picker_dismissed(self, handler: windows_foundation.TypedEventHandler[DevicePicker, winrt.system.Object], /) -> windows_foundation.EventRegistrationToken: ...
    def remove_device_picker_dismissed(self, token: windows_foundation.EventRegistrationToken, /) -> None: ...
    def add_device_selected(self, handler: windows_foundation.TypedEventHandler[DevicePicker, DeviceSelectedEventArgs], /) -> windows_foundation.EventRegistrationToken: ...
    def remove_device_selected(self, token: windows_foundation.EventRegistrationToken, /) -> None: ...
    def add_disconnect_button_clicked(self, handler: windows_foundation.TypedEventHandler[DevicePicker, DeviceDisconnectButtonClickedEventArgs], /) -> windows_foundation.EventRegistrationToken: ...
    def remove_disconnect_button_clicked(self, token: windows_foundation.EventRegistrationToken, /) -> None: ...
    @_property
    def appearance(self) -> DevicePickerAppearance: ...
    @_property
    def filter(self) -> DevicePickerFilter: ...
    @_property
    def requested_properties(self) -> typing.MutableSequence[str]: ...

@typing.final
class DevicePickerAppearance(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> DevicePickerAppearance: ...
    @_property
    def title(self) -> str: ...
    @title.setter
    def title(self, value: str) -> None: ...
    @_property
    def selected_foreground_color(self) -> windows_ui.Color: ...
    @selected_foreground_color.setter
    def selected_foreground_color(self, value: windows_ui.Color) -> None: ...
    @_property
    def selected_background_color(self) -> windows_ui.Color: ...
    @selected_background_color.setter
    def selected_background_color(self, value: windows_ui.Color) -> None: ...
    @_property
    def selected_accent_color(self) -> windows_ui.Color: ...
    @selected_accent_color.setter
    def selected_accent_color(self, value: windows_ui.Color) -> None: ...
    @_property
    def foreground_color(self) -> windows_ui.Color: ...
    @foreground_color.setter
    def foreground_color(self, value: windows_ui.Color) -> None: ...
    @_property
    def background_color(self) -> windows_ui.Color: ...
    @background_color.setter
    def background_color(self, value: windows_ui.Color) -> None: ...
    @_property
    def accent_color(self) -> windows_ui.Color: ...
    @accent_color.setter
    def accent_color(self, value: windows_ui.Color) -> None: ...

@typing.final
class DevicePickerFilter(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> DevicePickerFilter: ...
    @_property
    def supported_device_classes(self) -> typing.MutableSequence[DeviceClass]: ...
    @_property
    def supported_device_selectors(self) -> typing.MutableSequence[str]: ...

@typing.final
class DeviceSelectedEventArgs(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> DeviceSelectedEventArgs: ...
    @_property
    def selected_device(self) -> DeviceInformation: ...

@typing.final
class DeviceThumbnail(winrt.system.Object, windows_storage_streams.ImplementsIRandomAccessStreamWithContentType, windows_storage_streams.ImplementsIContentTypeProvider, windows_storage_streams.ImplementsIRandomAccessStream, windows_storage_streams.ImplementsIOutputStream, windows_storage_streams.ImplementsIInputStream, windows_foundation.ImplementsIClosable):
    def __enter__(self: Self) -> Self: ...
    def __exit__(self, *args) -> None: ...
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> DeviceThumbnail: ...
    def clone_stream(self) -> windows_storage_streams.IRandomAccessStream: ...
    def close(self) -> None: ...
    def flush_async(self) -> windows_foundation.IAsyncOperation[bool]: ...
    def get_input_stream_at(self, position: winrt.system.UInt64, /) -> windows_storage_streams.IInputStream: ...
    def get_output_stream_at(self, position: winrt.system.UInt64, /) -> windows_storage_streams.IOutputStream: ...
    def read_async(self, buffer: windows_storage_streams.ImplementsIBuffer, count: winrt.system.UInt32, options: windows_storage_streams.InputStreamOptions, /) -> windows_foundation.IAsyncOperationWithProgress[windows_storage_streams.IBuffer, winrt.system.UInt32]: ...
    def seek(self, position: winrt.system.UInt64, /) -> None: ...
    def write_async(self, buffer: windows_storage_streams.ImplementsIBuffer, /) -> windows_foundation.IAsyncOperationWithProgress[winrt.system.UInt32, winrt.system.UInt32]: ...
    @_property
    def content_type(self) -> str: ...
    @_property
    def size(self) -> winrt.system.UInt64: ...
    @size.setter
    def size(self, value: winrt.system.UInt64) -> None: ...
    @_property
    def can_read(self) -> bool: ...
    @_property
    def can_write(self) -> bool: ...
    @_property
    def position(self) -> winrt.system.UInt64: ...

@typing.final
class DeviceUnpairingResult(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> DeviceUnpairingResult: ...
    @_property
    def status(self) -> DeviceUnpairingResultStatus: ...

@typing.final
class DeviceWatcher(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> DeviceWatcher: ...
    def get_background_trigger(self, requested_event_kinds: typing.Iterable[DeviceWatcherEventKind], /) -> windows_applicationmodel_background.DeviceWatcherTrigger: ...
    def start(self) -> None: ...
    def stop(self) -> None: ...
    def add_added(self, handler: windows_foundation.TypedEventHandler[DeviceWatcher, DeviceInformation], /) -> windows_foundation.EventRegistrationToken: ...
    def remove_added(self, token: windows_foundation.EventRegistrationToken, /) -> None: ...
    def add_enumeration_completed(self, handler: windows_foundation.TypedEventHandler[DeviceWatcher, winrt.system.Object], /) -> windows_foundation.EventRegistrationToken: ...
    def remove_enumeration_completed(self, token: windows_foundation.EventRegistrationToken, /) -> None: ...
    def add_removed(self, handler: windows_foundation.TypedEventHandler[DeviceWatcher, DeviceInformationUpdate], /) -> windows_foundation.EventRegistrationToken: ...
    def remove_removed(self, token: windows_foundation.EventRegistrationToken, /) -> None: ...
    def add_stopped(self, handler: windows_foundation.TypedEventHandler[DeviceWatcher, winrt.system.Object], /) -> windows_foundation.EventRegistrationToken: ...
    def remove_stopped(self, token: windows_foundation.EventRegistrationToken, /) -> None: ...
    def add_updated(self, handler: windows_foundation.TypedEventHandler[DeviceWatcher, DeviceInformationUpdate], /) -> windows_foundation.EventRegistrationToken: ...
    def remove_updated(self, token: windows_foundation.EventRegistrationToken, /) -> None: ...
    @_property
    def status(self) -> DeviceWatcherStatus: ...

@typing.final
class DeviceWatcherEvent(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> DeviceWatcherEvent: ...
    @_property
    def device_information(self) -> DeviceInformation: ...
    @_property
    def device_information_update(self) -> DeviceInformationUpdate: ...
    @_property
    def kind(self) -> DeviceWatcherEventKind: ...

@typing.final
class DeviceWatcherTriggerDetails(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> DeviceWatcherTriggerDetails: ...
    @_property
    def device_watcher_events(self) -> typing.Sequence[DeviceWatcherEvent]: ...

@typing.final
class EnclosureLocation(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> EnclosureLocation: ...
    @_property
    def in_dock(self) -> bool: ...
    @_property
    def in_lid(self) -> bool: ...
    @_property
    def panel(self) -> Panel: ...
    @_property
    def rotation_angle_in_degrees_clockwise(self) -> winrt.system.UInt32: ...

class ImplementsIDeviceEnumerationSettings():
    pass

@typing.final
class IDeviceEnumerationSettings(winrt.system.Object, ImplementsIDeviceEnumerationSettings):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> IDeviceEnumerationSettings: ...

class ImplementsIDevicePairingSettings():
    pass

@typing.final
class IDevicePairingSettings(winrt.system.Object, ImplementsIDevicePairingSettings):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> IDevicePairingSettings: ...

