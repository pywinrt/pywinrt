// WARNING: Please don't edit this file. It was generated by Python/WinRT v2.0.1

#include "py.Windows.Devices.Enumeration.h"


namespace py::cpp::Windows::Devices::Enumeration
{
    // ----- DeviceAccessChangedEventArgs class --------------------

    static PyObject* _new_DeviceAccessChangedEventArgs(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Devices::Enumeration::DeviceAccessChangedEventArgs>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Devices::Enumeration::DeviceAccessChangedEventArgs>::type_name);
        return nullptr;
    }

    static void _dealloc_DeviceAccessChangedEventArgs(py::wrapper::Windows::Devices::Enumeration::DeviceAccessChangedEventArgs* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* DeviceAccessChangedEventArgs_get_Status(py::wrapper::Windows::Devices::Enumeration::DeviceAccessChangedEventArgs* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Enumeration.DeviceAccessChangedEventArgs", L"Status"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Status());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* DeviceAccessChangedEventArgs_get_Id(py::wrapper::Windows::Devices::Enumeration::DeviceAccessChangedEventArgs* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Enumeration.DeviceAccessChangedEventArgs", L"Id"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Id());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_DeviceAccessChangedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Devices::Enumeration::DeviceAccessChangedEventArgs>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_DeviceAccessChangedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Devices::Enumeration::DeviceAccessChangedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_DeviceAccessChangedEventArgs[] = {
        { "_assign_array_", _assign_array_DeviceAccessChangedEventArgs, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_DeviceAccessChangedEventArgs), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_DeviceAccessChangedEventArgs[] = {
        { "status", reinterpret_cast<getter>(DeviceAccessChangedEventArgs_get_Status), nullptr, nullptr, nullptr },
        { "id", reinterpret_cast<getter>(DeviceAccessChangedEventArgs_get_Id), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_DeviceAccessChangedEventArgs[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_DeviceAccessChangedEventArgs) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_DeviceAccessChangedEventArgs) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_DeviceAccessChangedEventArgs) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_DeviceAccessChangedEventArgs) },
        { },
    };

    static PyType_Spec type_spec_DeviceAccessChangedEventArgs =
    {
        "winrt._winrt_windows_devices_enumeration.DeviceAccessChangedEventArgs",
        sizeof(py::wrapper::Windows::Devices::Enumeration::DeviceAccessChangedEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_DeviceAccessChangedEventArgs
    };

    // ----- DeviceAccessInformation class --------------------

    static PyObject* _new_DeviceAccessInformation(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Devices::Enumeration::DeviceAccessInformation>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Devices::Enumeration::DeviceAccessInformation>::type_name);
        return nullptr;
    }

    static void _dealloc_DeviceAccessInformation(py::wrapper::Windows::Devices::Enumeration::DeviceAccessInformation* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* DeviceAccessInformation_CreateFromDeviceClass(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.Enumeration.DeviceAccessInformation", L"CreateFromDeviceClass", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::Devices::Enumeration::DeviceClass>(args, 0);

                return py::convert(winrt::Windows::Devices::Enumeration::DeviceAccessInformation::CreateFromDeviceClass(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* DeviceAccessInformation_CreateFromDeviceClassId(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.Enumeration.DeviceAccessInformation", L"CreateFromDeviceClassId", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::guid>(args, 0);

                return py::convert(winrt::Windows::Devices::Enumeration::DeviceAccessInformation::CreateFromDeviceClassId(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* DeviceAccessInformation_CreateFromId(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.Enumeration.DeviceAccessInformation", L"CreateFromId", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                return py::convert(winrt::Windows::Devices::Enumeration::DeviceAccessInformation::CreateFromId(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* DeviceAccessInformation_get_CurrentStatus(py::wrapper::Windows::Devices::Enumeration::DeviceAccessInformation* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Enumeration.DeviceAccessInformation", L"CurrentStatus"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.CurrentStatus());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* DeviceAccessInformation_add_AccessChanged(py::wrapper::Windows::Devices::Enumeration::DeviceAccessInformation* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Devices.Enumeration.DeviceAccessInformation", L"AccessChanged"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Devices::Enumeration::DeviceAccessInformation, winrt::Windows::Devices::Enumeration::DeviceAccessChangedEventArgs>>(arg);

            return py::convert(self->obj.AccessChanged(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* DeviceAccessInformation_remove_AccessChanged(py::wrapper::Windows::Devices::Enumeration::DeviceAccessInformation* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Devices.Enumeration.DeviceAccessInformation", L"AccessChanged"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.AccessChanged(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_DeviceAccessInformation(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Devices::Enumeration::DeviceAccessInformation>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_DeviceAccessInformation(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Devices::Enumeration::DeviceAccessInformation>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_DeviceAccessInformation[] = {
        { "add_access_changed", reinterpret_cast<PyCFunction>(DeviceAccessInformation_add_AccessChanged), METH_O, nullptr },
        { "remove_access_changed", reinterpret_cast<PyCFunction>(DeviceAccessInformation_remove_AccessChanged), METH_O, nullptr },
        { "_assign_array_", _assign_array_DeviceAccessInformation, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_DeviceAccessInformation), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_DeviceAccessInformation[] = {
        { "current_status", reinterpret_cast<getter>(DeviceAccessInformation_get_CurrentStatus), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_DeviceAccessInformation[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_DeviceAccessInformation) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_DeviceAccessInformation) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_DeviceAccessInformation) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_DeviceAccessInformation) },
        { },
    };

    static PyType_Spec type_spec_DeviceAccessInformation =
    {
        "winrt._winrt_windows_devices_enumeration.DeviceAccessInformation",
        sizeof(py::wrapper::Windows::Devices::Enumeration::DeviceAccessInformation),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_DeviceAccessInformation
    };

    static PyGetSetDef getset_DeviceAccessInformation_Static[] = {
        { }
    };

    static PyMethodDef methods_DeviceAccessInformation_Static[] = {
        { "create_from_device_class", reinterpret_cast<PyCFunction>(DeviceAccessInformation_CreateFromDeviceClass), METH_VARARGS, nullptr },
        { "create_from_device_class_id", reinterpret_cast<PyCFunction>(DeviceAccessInformation_CreateFromDeviceClassId), METH_VARARGS, nullptr },
        { "create_from_id", reinterpret_cast<PyCFunction>(DeviceAccessInformation_CreateFromId), METH_VARARGS, nullptr },
        { }
    };

    static PyType_Slot type_slots_DeviceAccessInformation_Static[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_DeviceAccessInformation_Static) },
        { Py_tp_methods, reinterpret_cast<void*>(methods_DeviceAccessInformation_Static) },
        { }
    };

    static PyType_Spec type_spec_DeviceAccessInformation_Static =
    {
        "winrt._winrt_windows_devices_enumeration.DeviceAccessInformation_Static",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT,
        type_slots_DeviceAccessInformation_Static
    };

    // ----- DeviceConnectionChangeTriggerDetails class --------------------

    static PyObject* _new_DeviceConnectionChangeTriggerDetails(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Devices::Enumeration::DeviceConnectionChangeTriggerDetails>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Devices::Enumeration::DeviceConnectionChangeTriggerDetails>::type_name);
        return nullptr;
    }

    static void _dealloc_DeviceConnectionChangeTriggerDetails(py::wrapper::Windows::Devices::Enumeration::DeviceConnectionChangeTriggerDetails* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* DeviceConnectionChangeTriggerDetails_get_DeviceId(py::wrapper::Windows::Devices::Enumeration::DeviceConnectionChangeTriggerDetails* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Enumeration.DeviceConnectionChangeTriggerDetails", L"DeviceId"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.DeviceId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_DeviceConnectionChangeTriggerDetails(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Devices::Enumeration::DeviceConnectionChangeTriggerDetails>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_DeviceConnectionChangeTriggerDetails(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Devices::Enumeration::DeviceConnectionChangeTriggerDetails>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_DeviceConnectionChangeTriggerDetails[] = {
        { "_assign_array_", _assign_array_DeviceConnectionChangeTriggerDetails, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_DeviceConnectionChangeTriggerDetails), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_DeviceConnectionChangeTriggerDetails[] = {
        { "device_id", reinterpret_cast<getter>(DeviceConnectionChangeTriggerDetails_get_DeviceId), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_DeviceConnectionChangeTriggerDetails[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_DeviceConnectionChangeTriggerDetails) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_DeviceConnectionChangeTriggerDetails) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_DeviceConnectionChangeTriggerDetails) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_DeviceConnectionChangeTriggerDetails) },
        { },
    };

    static PyType_Spec type_spec_DeviceConnectionChangeTriggerDetails =
    {
        "winrt._winrt_windows_devices_enumeration.DeviceConnectionChangeTriggerDetails",
        sizeof(py::wrapper::Windows::Devices::Enumeration::DeviceConnectionChangeTriggerDetails),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_DeviceConnectionChangeTriggerDetails
    };

    // ----- DeviceDisconnectButtonClickedEventArgs class --------------------

    static PyObject* _new_DeviceDisconnectButtonClickedEventArgs(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Devices::Enumeration::DeviceDisconnectButtonClickedEventArgs>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Devices::Enumeration::DeviceDisconnectButtonClickedEventArgs>::type_name);
        return nullptr;
    }

    static void _dealloc_DeviceDisconnectButtonClickedEventArgs(py::wrapper::Windows::Devices::Enumeration::DeviceDisconnectButtonClickedEventArgs* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* DeviceDisconnectButtonClickedEventArgs_get_Device(py::wrapper::Windows::Devices::Enumeration::DeviceDisconnectButtonClickedEventArgs* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Enumeration.DeviceDisconnectButtonClickedEventArgs", L"Device"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Device());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_DeviceDisconnectButtonClickedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Devices::Enumeration::DeviceDisconnectButtonClickedEventArgs>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_DeviceDisconnectButtonClickedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Devices::Enumeration::DeviceDisconnectButtonClickedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_DeviceDisconnectButtonClickedEventArgs[] = {
        { "_assign_array_", _assign_array_DeviceDisconnectButtonClickedEventArgs, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_DeviceDisconnectButtonClickedEventArgs), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_DeviceDisconnectButtonClickedEventArgs[] = {
        { "device", reinterpret_cast<getter>(DeviceDisconnectButtonClickedEventArgs_get_Device), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_DeviceDisconnectButtonClickedEventArgs[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_DeviceDisconnectButtonClickedEventArgs) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_DeviceDisconnectButtonClickedEventArgs) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_DeviceDisconnectButtonClickedEventArgs) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_DeviceDisconnectButtonClickedEventArgs) },
        { },
    };

    static PyType_Spec type_spec_DeviceDisconnectButtonClickedEventArgs =
    {
        "winrt._winrt_windows_devices_enumeration.DeviceDisconnectButtonClickedEventArgs",
        sizeof(py::wrapper::Windows::Devices::Enumeration::DeviceDisconnectButtonClickedEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_DeviceDisconnectButtonClickedEventArgs
    };

    // ----- DeviceInformation class --------------------

    static PyObject* _new_DeviceInformation(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Devices::Enumeration::DeviceInformation>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Devices::Enumeration::DeviceInformation>::type_name);
        return nullptr;
    }

    static void _dealloc_DeviceInformation(py::wrapper::Windows::Devices::Enumeration::DeviceInformation* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* DeviceInformation_CreateFromIdAsync(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.Enumeration.DeviceInformation", L"CreateFromIdAsync", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                return py::convert(winrt::Windows::Devices::Enumeration::DeviceInformation::CreateFromIdAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 2)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.Enumeration.DeviceInformation", L"CreateFromIdAsync", 2))
            {
                py::set_arg_count_version_error(2);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Foundation::Collections::IIterable<winrt::hstring>>(args, 1);

                return py::convert(winrt::Windows::Devices::Enumeration::DeviceInformation::CreateFromIdAsync(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 3)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.Enumeration.DeviceInformation", L"CreateFromIdAsync", 3))
            {
                py::set_arg_count_version_error(3);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Foundation::Collections::IIterable<winrt::hstring>>(args, 1);
                auto param2 = py::convert_to<winrt::Windows::Devices::Enumeration::DeviceInformationKind>(args, 2);

                return py::convert(winrt::Windows::Devices::Enumeration::DeviceInformation::CreateFromIdAsync(param0, param1, param2));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* DeviceInformation_CreateWatcher(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.Enumeration.DeviceInformation", L"CreateWatcher", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(winrt::Windows::Devices::Enumeration::DeviceInformation::CreateWatcher());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.Enumeration.DeviceInformation", L"CreateWatcher", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::Devices::Enumeration::DeviceClass>(args, 0);

                return py::convert(winrt::Windows::Devices::Enumeration::DeviceInformation::CreateWatcher(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 2)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.Enumeration.DeviceInformation", L"CreateWatcher", 2))
            {
                py::set_arg_count_version_error(2);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Foundation::Collections::IIterable<winrt::hstring>>(args, 1);

                return py::convert(winrt::Windows::Devices::Enumeration::DeviceInformation::CreateWatcher(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 3)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.Enumeration.DeviceInformation", L"CreateWatcher", 3))
            {
                py::set_arg_count_version_error(3);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Foundation::Collections::IIterable<winrt::hstring>>(args, 1);
                auto param2 = py::convert_to<winrt::Windows::Devices::Enumeration::DeviceInformationKind>(args, 2);

                return py::convert(winrt::Windows::Devices::Enumeration::DeviceInformation::CreateWatcher(param0, param1, param2));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* DeviceInformation_FindAllAsync(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.Enumeration.DeviceInformation", L"FindAllAsync", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(winrt::Windows::Devices::Enumeration::DeviceInformation::FindAllAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.Enumeration.DeviceInformation", L"FindAllAsync", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::Devices::Enumeration::DeviceClass>(args, 0);

                return py::convert(winrt::Windows::Devices::Enumeration::DeviceInformation::FindAllAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 2)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.Enumeration.DeviceInformation", L"FindAllAsync", 2))
            {
                py::set_arg_count_version_error(2);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Foundation::Collections::IIterable<winrt::hstring>>(args, 1);

                return py::convert(winrt::Windows::Devices::Enumeration::DeviceInformation::FindAllAsync(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 3)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.Enumeration.DeviceInformation", L"FindAllAsync", 3))
            {
                py::set_arg_count_version_error(3);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Foundation::Collections::IIterable<winrt::hstring>>(args, 1);
                auto param2 = py::convert_to<winrt::Windows::Devices::Enumeration::DeviceInformationKind>(args, 2);

                return py::convert(winrt::Windows::Devices::Enumeration::DeviceInformation::FindAllAsync(param0, param1, param2));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* DeviceInformation_GetAqsFilterFromDeviceClass(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.Enumeration.DeviceInformation", L"GetAqsFilterFromDeviceClass", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::Devices::Enumeration::DeviceClass>(args, 0);

                return py::convert(winrt::Windows::Devices::Enumeration::DeviceInformation::GetAqsFilterFromDeviceClass(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* DeviceInformation_GetGlyphThumbnailAsync(py::wrapper::Windows::Devices::Enumeration::DeviceInformation* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.Enumeration.DeviceInformation", L"GetGlyphThumbnailAsync", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(self->obj.GetGlyphThumbnailAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* DeviceInformation_GetThumbnailAsync(py::wrapper::Windows::Devices::Enumeration::DeviceInformation* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.Enumeration.DeviceInformation", L"GetThumbnailAsync", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(self->obj.GetThumbnailAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* DeviceInformation_Update(py::wrapper::Windows::Devices::Enumeration::DeviceInformation* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.Enumeration.DeviceInformation", L"Update", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::Devices::Enumeration::DeviceInformationUpdate>(args, 0);

                self->obj.Update(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* DeviceInformation_get_EnclosureLocation(py::wrapper::Windows::Devices::Enumeration::DeviceInformation* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Enumeration.DeviceInformation", L"EnclosureLocation"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.EnclosureLocation());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* DeviceInformation_get_Id(py::wrapper::Windows::Devices::Enumeration::DeviceInformation* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Enumeration.DeviceInformation", L"Id"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Id());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* DeviceInformation_get_IsDefault(py::wrapper::Windows::Devices::Enumeration::DeviceInformation* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Enumeration.DeviceInformation", L"IsDefault"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.IsDefault());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* DeviceInformation_get_IsEnabled(py::wrapper::Windows::Devices::Enumeration::DeviceInformation* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Enumeration.DeviceInformation", L"IsEnabled"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.IsEnabled());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* DeviceInformation_get_Name(py::wrapper::Windows::Devices::Enumeration::DeviceInformation* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Enumeration.DeviceInformation", L"Name"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Name());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* DeviceInformation_get_Properties(py::wrapper::Windows::Devices::Enumeration::DeviceInformation* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Enumeration.DeviceInformation", L"Properties"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Properties());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* DeviceInformation_get_Kind(py::wrapper::Windows::Devices::Enumeration::DeviceInformation* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Enumeration.DeviceInformation", L"Kind"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Kind());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* DeviceInformation_get_Pairing(py::wrapper::Windows::Devices::Enumeration::DeviceInformation* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Enumeration.DeviceInformation", L"Pairing"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Pairing());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_DeviceInformation(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Devices::Enumeration::DeviceInformation>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_DeviceInformation(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Devices::Enumeration::DeviceInformation>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_DeviceInformation[] = {
        { "get_glyph_thumbnail_async", reinterpret_cast<PyCFunction>(DeviceInformation_GetGlyphThumbnailAsync), METH_VARARGS, nullptr },
        { "get_thumbnail_async", reinterpret_cast<PyCFunction>(DeviceInformation_GetThumbnailAsync), METH_VARARGS, nullptr },
        { "update", reinterpret_cast<PyCFunction>(DeviceInformation_Update), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_DeviceInformation, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_DeviceInformation), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_DeviceInformation[] = {
        { "enclosure_location", reinterpret_cast<getter>(DeviceInformation_get_EnclosureLocation), nullptr, nullptr, nullptr },
        { "id", reinterpret_cast<getter>(DeviceInformation_get_Id), nullptr, nullptr, nullptr },
        { "is_default", reinterpret_cast<getter>(DeviceInformation_get_IsDefault), nullptr, nullptr, nullptr },
        { "is_enabled", reinterpret_cast<getter>(DeviceInformation_get_IsEnabled), nullptr, nullptr, nullptr },
        { "name", reinterpret_cast<getter>(DeviceInformation_get_Name), nullptr, nullptr, nullptr },
        { "properties", reinterpret_cast<getter>(DeviceInformation_get_Properties), nullptr, nullptr, nullptr },
        { "kind", reinterpret_cast<getter>(DeviceInformation_get_Kind), nullptr, nullptr, nullptr },
        { "pairing", reinterpret_cast<getter>(DeviceInformation_get_Pairing), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_DeviceInformation[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_DeviceInformation) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_DeviceInformation) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_DeviceInformation) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_DeviceInformation) },
        { },
    };

    static PyType_Spec type_spec_DeviceInformation =
    {
        "winrt._winrt_windows_devices_enumeration.DeviceInformation",
        sizeof(py::wrapper::Windows::Devices::Enumeration::DeviceInformation),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_DeviceInformation
    };

    static PyGetSetDef getset_DeviceInformation_Static[] = {
        { }
    };

    static PyMethodDef methods_DeviceInformation_Static[] = {
        { "create_from_id_async", reinterpret_cast<PyCFunction>(DeviceInformation_CreateFromIdAsync), METH_VARARGS, nullptr },
        { "create_watcher", reinterpret_cast<PyCFunction>(DeviceInformation_CreateWatcher), METH_VARARGS, nullptr },
        { "find_all_async", reinterpret_cast<PyCFunction>(DeviceInformation_FindAllAsync), METH_VARARGS, nullptr },
        { "get_aqs_filter_from_device_class", reinterpret_cast<PyCFunction>(DeviceInformation_GetAqsFilterFromDeviceClass), METH_VARARGS, nullptr },
        { }
    };

    static PyType_Slot type_slots_DeviceInformation_Static[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_DeviceInformation_Static) },
        { Py_tp_methods, reinterpret_cast<void*>(methods_DeviceInformation_Static) },
        { }
    };

    static PyType_Spec type_spec_DeviceInformation_Static =
    {
        "winrt._winrt_windows_devices_enumeration.DeviceInformation_Static",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT,
        type_slots_DeviceInformation_Static
    };

    // ----- DeviceInformationCollection class --------------------

    static PyObject* _new_DeviceInformationCollection(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Devices::Enumeration::DeviceInformationCollection>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Devices::Enumeration::DeviceInformationCollection>::type_name);
        return nullptr;
    }

    static void _dealloc_DeviceInformationCollection(py::wrapper::Windows::Devices::Enumeration::DeviceInformationCollection* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* DeviceInformationCollection_First(py::wrapper::Windows::Devices::Enumeration::DeviceInformationCollection* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.Enumeration.DeviceInformationCollection", L"First", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(self->obj.First());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* DeviceInformationCollection_GetAt(py::wrapper::Windows::Devices::Enumeration::DeviceInformationCollection* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.Enumeration.DeviceInformationCollection", L"GetAt", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<uint32_t>(args, 0);

                return py::convert(self->obj.GetAt(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* DeviceInformationCollection_GetMany(py::wrapper::Windows::Devices::Enumeration::DeviceInformationCollection* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.Enumeration.DeviceInformationCollection", L"GetMany", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<uint32_t>(args, 0);
                auto param1 = py::convert_to<py::pybuf_view<winrt::Windows::Devices::Enumeration::DeviceInformation, true>>(args, 1);

                return py::convert(self->obj.GetMany(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* DeviceInformationCollection_IndexOf(py::wrapper::Windows::Devices::Enumeration::DeviceInformationCollection* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.Enumeration.DeviceInformationCollection", L"IndexOf", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::Devices::Enumeration::DeviceInformation>(args, 0);
                uint32_t param1 {  };

                auto return_value = self->obj.IndexOf(param0, param1);

                py::pyobj_handle out_return_value{ py::convert(return_value) };
                if (!out_return_value)
                {
                    return nullptr;
                }
                py::pyobj_handle out1{ py::convert(param1) };
                if (!out1)
                {
                    return nullptr;
                }
                return PyTuple_Pack(2, out_return_value.get(), out1.get());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* DeviceInformationCollection_get_Size(py::wrapper::Windows::Devices::Enumeration::DeviceInformationCollection* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Enumeration.DeviceInformationCollection", L"Size"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Size());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_DeviceInformationCollection(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Devices::Enumeration::DeviceInformationCollection>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_DeviceInformationCollection(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Devices::Enumeration::DeviceInformationCollection>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _iterator_DeviceInformationCollection(py::wrapper::Windows::Devices::Enumeration::DeviceInformationCollection* self) noexcept
    {
        try
        {
            return py::convert(self->obj.First());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static Py_ssize_t _seq_length_DeviceInformationCollection(py::wrapper::Windows::Devices::Enumeration::DeviceInformationCollection* self) noexcept
    {
        try
        {
            return static_cast<Py_ssize_t>(self->obj.Size());
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* _seq_item_DeviceInformationCollection(py::wrapper::Windows::Devices::Enumeration::DeviceInformationCollection* self, Py_ssize_t i) noexcept
    {
        try
        {
            return py::convert(self->obj.GetAt(static_cast<uint32_t>(i)));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _seq_subscript_DeviceInformationCollection(py::wrapper::Windows::Devices::Enumeration::DeviceInformationCollection* self, PyObject* slice) noexcept
    {
        try
        {
            if (PyIndex_Check(slice))
            {
                pyobj_handle index{PyNumber_Index(slice)};

                if (!index)
                {
                    return nullptr;
                }

                auto i = PyNumber_AsSsize_t(index.get(), PyExc_IndexError);

                if (i == -1 && PyErr_Occurred())
                {
                    return nullptr;
                }

                return _seq_item_DeviceInformationCollection(self, i);
            }

            if (!PySlice_Check(slice))
            {
                PyErr_Format(
                    PyExc_TypeError,
                    "indicies must be integers, not '%s'",
                    Py_TYPE(slice)->tp_name);
            }

            Py_ssize_t start, stop, step, length;

            if (PySlice_GetIndicesEx(
                    slice, self->obj.Size(), &start, &stop, &step, &length)
                < 0)
            {
                return nullptr;
            }

            if (step != 1)
            {
                PyErr_SetString(
                    PyExc_NotImplementedError,
                    "slices with step other than 1 are not implemented");
                return nullptr;
            }

            winrt::com_array<winrt::Windows::Devices::Enumeration::DeviceInformation> items(static_cast<uint32_t>(length), empty_instance<winrt::Windows::Devices::Enumeration::DeviceInformation>::get());

            auto count = self->obj.GetMany(static_cast<uint32_t>(start), items);

            if (count != static_cast<uint32_t>(length))
            {
                PyErr_Format(
                    PyExc_RuntimeError,
                    "returned count %d did not match requested length %zd",
                    count,
                    length);
                return nullptr;
            }

            return convert(items);}
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_DeviceInformationCollection[] = {
        { "first", reinterpret_cast<PyCFunction>(DeviceInformationCollection_First), METH_VARARGS, nullptr },
        { "get_at", reinterpret_cast<PyCFunction>(DeviceInformationCollection_GetAt), METH_VARARGS, nullptr },
        { "get_many", reinterpret_cast<PyCFunction>(DeviceInformationCollection_GetMany), METH_VARARGS, nullptr },
        { "index_of", reinterpret_cast<PyCFunction>(DeviceInformationCollection_IndexOf), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_DeviceInformationCollection, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_DeviceInformationCollection), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_DeviceInformationCollection[] = {
        { "size", reinterpret_cast<getter>(DeviceInformationCollection_get_Size), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_DeviceInformationCollection[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_DeviceInformationCollection) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_DeviceInformationCollection) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_DeviceInformationCollection) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_DeviceInformationCollection) },
        { Py_tp_iter, reinterpret_cast<void*>(_iterator_DeviceInformationCollection) },
        { Py_sq_length, reinterpret_cast<void*>(_seq_length_DeviceInformationCollection) },
        { Py_sq_item, reinterpret_cast<void*>(_seq_item_DeviceInformationCollection) },
        { Py_mp_subscript, reinterpret_cast<void*>(_seq_subscript_DeviceInformationCollection) },
        { },
    };

    static PyType_Spec type_spec_DeviceInformationCollection =
    {
        "winrt._winrt_windows_devices_enumeration.DeviceInformationCollection",
        sizeof(py::wrapper::Windows::Devices::Enumeration::DeviceInformationCollection),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_DeviceInformationCollection
    };

    // ----- DeviceInformationCustomPairing class --------------------

    static PyObject* _new_DeviceInformationCustomPairing(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Devices::Enumeration::DeviceInformationCustomPairing>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Devices::Enumeration::DeviceInformationCustomPairing>::type_name);
        return nullptr;
    }

    static void _dealloc_DeviceInformationCustomPairing(py::wrapper::Windows::Devices::Enumeration::DeviceInformationCustomPairing* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* DeviceInformationCustomPairing_PairAsync(py::wrapper::Windows::Devices::Enumeration::DeviceInformationCustomPairing* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.Enumeration.DeviceInformationCustomPairing", L"PairAsync", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::Devices::Enumeration::DevicePairingKinds>(args, 0);

                return py::convert(self->obj.PairAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 2)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.Enumeration.DeviceInformationCustomPairing", L"PairAsync", 2))
            {
                py::set_arg_count_version_error(2);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::Devices::Enumeration::DevicePairingKinds>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Devices::Enumeration::DevicePairingProtectionLevel>(args, 1);

                return py::convert(self->obj.PairAsync(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 3)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.Enumeration.DeviceInformationCustomPairing", L"PairAsync", 3))
            {
                py::set_arg_count_version_error(3);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::Devices::Enumeration::DevicePairingKinds>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Devices::Enumeration::DevicePairingProtectionLevel>(args, 1);
                auto param2 = py::convert_to<winrt::Windows::Devices::Enumeration::IDevicePairingSettings>(args, 2);

                return py::convert(self->obj.PairAsync(param0, param1, param2));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* DeviceInformationCustomPairing_add_PairingRequested(py::wrapper::Windows::Devices::Enumeration::DeviceInformationCustomPairing* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Devices.Enumeration.DeviceInformationCustomPairing", L"PairingRequested"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Devices::Enumeration::DeviceInformationCustomPairing, winrt::Windows::Devices::Enumeration::DevicePairingRequestedEventArgs>>(arg);

            return py::convert(self->obj.PairingRequested(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* DeviceInformationCustomPairing_remove_PairingRequested(py::wrapper::Windows::Devices::Enumeration::DeviceInformationCustomPairing* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Devices.Enumeration.DeviceInformationCustomPairing", L"PairingRequested"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.PairingRequested(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_DeviceInformationCustomPairing(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Devices::Enumeration::DeviceInformationCustomPairing>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_DeviceInformationCustomPairing(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Devices::Enumeration::DeviceInformationCustomPairing>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_DeviceInformationCustomPairing[] = {
        { "pair_async", reinterpret_cast<PyCFunction>(DeviceInformationCustomPairing_PairAsync), METH_VARARGS, nullptr },
        { "add_pairing_requested", reinterpret_cast<PyCFunction>(DeviceInformationCustomPairing_add_PairingRequested), METH_O, nullptr },
        { "remove_pairing_requested", reinterpret_cast<PyCFunction>(DeviceInformationCustomPairing_remove_PairingRequested), METH_O, nullptr },
        { "_assign_array_", _assign_array_DeviceInformationCustomPairing, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_DeviceInformationCustomPairing), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_DeviceInformationCustomPairing[] = {
        { }
    };

    static PyType_Slot _type_slots_DeviceInformationCustomPairing[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_DeviceInformationCustomPairing) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_DeviceInformationCustomPairing) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_DeviceInformationCustomPairing) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_DeviceInformationCustomPairing) },
        { },
    };

    static PyType_Spec type_spec_DeviceInformationCustomPairing =
    {
        "winrt._winrt_windows_devices_enumeration.DeviceInformationCustomPairing",
        sizeof(py::wrapper::Windows::Devices::Enumeration::DeviceInformationCustomPairing),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_DeviceInformationCustomPairing
    };

    // ----- DeviceInformationPairing class --------------------

    static PyObject* _new_DeviceInformationPairing(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Devices::Enumeration::DeviceInformationPairing>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Devices::Enumeration::DeviceInformationPairing>::type_name);
        return nullptr;
    }

    static void _dealloc_DeviceInformationPairing(py::wrapper::Windows::Devices::Enumeration::DeviceInformationPairing* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* DeviceInformationPairing_PairAsync(py::wrapper::Windows::Devices::Enumeration::DeviceInformationPairing* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.Enumeration.DeviceInformationPairing", L"PairAsync", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(self->obj.PairAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.Enumeration.DeviceInformationPairing", L"PairAsync", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::Devices::Enumeration::DevicePairingProtectionLevel>(args, 0);

                return py::convert(self->obj.PairAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 2)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.Enumeration.DeviceInformationPairing", L"PairAsync", 2))
            {
                py::set_arg_count_version_error(2);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::Devices::Enumeration::DevicePairingProtectionLevel>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Devices::Enumeration::IDevicePairingSettings>(args, 1);

                return py::convert(self->obj.PairAsync(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* DeviceInformationPairing_TryRegisterForAllInboundPairingRequests(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.Enumeration.DeviceInformationPairing", L"TryRegisterForAllInboundPairingRequests", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::Devices::Enumeration::DevicePairingKinds>(args, 0);

                return py::convert(winrt::Windows::Devices::Enumeration::DeviceInformationPairing::TryRegisterForAllInboundPairingRequests(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* DeviceInformationPairing_TryRegisterForAllInboundPairingRequestsWithProtectionLevel(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.Enumeration.DeviceInformationPairing", L"TryRegisterForAllInboundPairingRequestsWithProtectionLevel", 2))
            {
                py::set_arg_count_version_error(2);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::Devices::Enumeration::DevicePairingKinds>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Devices::Enumeration::DevicePairingProtectionLevel>(args, 1);

                return py::convert(winrt::Windows::Devices::Enumeration::DeviceInformationPairing::TryRegisterForAllInboundPairingRequestsWithProtectionLevel(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* DeviceInformationPairing_UnpairAsync(py::wrapper::Windows::Devices::Enumeration::DeviceInformationPairing* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.Enumeration.DeviceInformationPairing", L"UnpairAsync", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(self->obj.UnpairAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* DeviceInformationPairing_get_CanPair(py::wrapper::Windows::Devices::Enumeration::DeviceInformationPairing* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Enumeration.DeviceInformationPairing", L"CanPair"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.CanPair());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* DeviceInformationPairing_get_IsPaired(py::wrapper::Windows::Devices::Enumeration::DeviceInformationPairing* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Enumeration.DeviceInformationPairing", L"IsPaired"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.IsPaired());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* DeviceInformationPairing_get_Custom(py::wrapper::Windows::Devices::Enumeration::DeviceInformationPairing* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Enumeration.DeviceInformationPairing", L"Custom"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Custom());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* DeviceInformationPairing_get_ProtectionLevel(py::wrapper::Windows::Devices::Enumeration::DeviceInformationPairing* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Enumeration.DeviceInformationPairing", L"ProtectionLevel"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.ProtectionLevel());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_DeviceInformationPairing(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Devices::Enumeration::DeviceInformationPairing>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_DeviceInformationPairing(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Devices::Enumeration::DeviceInformationPairing>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_DeviceInformationPairing[] = {
        { "pair_async", reinterpret_cast<PyCFunction>(DeviceInformationPairing_PairAsync), METH_VARARGS, nullptr },
        { "unpair_async", reinterpret_cast<PyCFunction>(DeviceInformationPairing_UnpairAsync), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_DeviceInformationPairing, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_DeviceInformationPairing), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_DeviceInformationPairing[] = {
        { "can_pair", reinterpret_cast<getter>(DeviceInformationPairing_get_CanPair), nullptr, nullptr, nullptr },
        { "is_paired", reinterpret_cast<getter>(DeviceInformationPairing_get_IsPaired), nullptr, nullptr, nullptr },
        { "custom", reinterpret_cast<getter>(DeviceInformationPairing_get_Custom), nullptr, nullptr, nullptr },
        { "protection_level", reinterpret_cast<getter>(DeviceInformationPairing_get_ProtectionLevel), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_DeviceInformationPairing[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_DeviceInformationPairing) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_DeviceInformationPairing) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_DeviceInformationPairing) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_DeviceInformationPairing) },
        { },
    };

    static PyType_Spec type_spec_DeviceInformationPairing =
    {
        "winrt._winrt_windows_devices_enumeration.DeviceInformationPairing",
        sizeof(py::wrapper::Windows::Devices::Enumeration::DeviceInformationPairing),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_DeviceInformationPairing
    };

    static PyGetSetDef getset_DeviceInformationPairing_Static[] = {
        { }
    };

    static PyMethodDef methods_DeviceInformationPairing_Static[] = {
        { "try_register_for_all_inbound_pairing_requests", reinterpret_cast<PyCFunction>(DeviceInformationPairing_TryRegisterForAllInboundPairingRequests), METH_VARARGS, nullptr },
        { "try_register_for_all_inbound_pairing_requests_with_protection_level", reinterpret_cast<PyCFunction>(DeviceInformationPairing_TryRegisterForAllInboundPairingRequestsWithProtectionLevel), METH_VARARGS, nullptr },
        { }
    };

    static PyType_Slot type_slots_DeviceInformationPairing_Static[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_DeviceInformationPairing_Static) },
        { Py_tp_methods, reinterpret_cast<void*>(methods_DeviceInformationPairing_Static) },
        { }
    };

    static PyType_Spec type_spec_DeviceInformationPairing_Static =
    {
        "winrt._winrt_windows_devices_enumeration.DeviceInformationPairing_Static",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT,
        type_slots_DeviceInformationPairing_Static
    };

    // ----- DeviceInformationUpdate class --------------------

    static PyObject* _new_DeviceInformationUpdate(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Devices::Enumeration::DeviceInformationUpdate>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Devices::Enumeration::DeviceInformationUpdate>::type_name);
        return nullptr;
    }

    static void _dealloc_DeviceInformationUpdate(py::wrapper::Windows::Devices::Enumeration::DeviceInformationUpdate* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* DeviceInformationUpdate_get_Id(py::wrapper::Windows::Devices::Enumeration::DeviceInformationUpdate* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Enumeration.DeviceInformationUpdate", L"Id"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Id());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* DeviceInformationUpdate_get_Properties(py::wrapper::Windows::Devices::Enumeration::DeviceInformationUpdate* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Enumeration.DeviceInformationUpdate", L"Properties"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Properties());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* DeviceInformationUpdate_get_Kind(py::wrapper::Windows::Devices::Enumeration::DeviceInformationUpdate* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Enumeration.DeviceInformationUpdate", L"Kind"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Kind());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_DeviceInformationUpdate(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Devices::Enumeration::DeviceInformationUpdate>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_DeviceInformationUpdate(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Devices::Enumeration::DeviceInformationUpdate>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_DeviceInformationUpdate[] = {
        { "_assign_array_", _assign_array_DeviceInformationUpdate, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_DeviceInformationUpdate), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_DeviceInformationUpdate[] = {
        { "id", reinterpret_cast<getter>(DeviceInformationUpdate_get_Id), nullptr, nullptr, nullptr },
        { "properties", reinterpret_cast<getter>(DeviceInformationUpdate_get_Properties), nullptr, nullptr, nullptr },
        { "kind", reinterpret_cast<getter>(DeviceInformationUpdate_get_Kind), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_DeviceInformationUpdate[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_DeviceInformationUpdate) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_DeviceInformationUpdate) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_DeviceInformationUpdate) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_DeviceInformationUpdate) },
        { },
    };

    static PyType_Spec type_spec_DeviceInformationUpdate =
    {
        "winrt._winrt_windows_devices_enumeration.DeviceInformationUpdate",
        sizeof(py::wrapper::Windows::Devices::Enumeration::DeviceInformationUpdate),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_DeviceInformationUpdate
    };

    // ----- DevicePairingRequestedEventArgs class --------------------

    static PyObject* _new_DevicePairingRequestedEventArgs(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Devices::Enumeration::DevicePairingRequestedEventArgs>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Devices::Enumeration::DevicePairingRequestedEventArgs>::type_name);
        return nullptr;
    }

    static void _dealloc_DevicePairingRequestedEventArgs(py::wrapper::Windows::Devices::Enumeration::DevicePairingRequestedEventArgs* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* DevicePairingRequestedEventArgs_Accept(py::wrapper::Windows::Devices::Enumeration::DevicePairingRequestedEventArgs* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.Enumeration.DevicePairingRequestedEventArgs", L"Accept", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                self->obj.Accept();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.Enumeration.DevicePairingRequestedEventArgs", L"Accept", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                self->obj.Accept(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* DevicePairingRequestedEventArgs_AcceptWithPasswordCredential(py::wrapper::Windows::Devices::Enumeration::DevicePairingRequestedEventArgs* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.Enumeration.DevicePairingRequestedEventArgs", L"AcceptWithPasswordCredential", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::Security::Credentials::PasswordCredential>(args, 0);

                self->obj.AcceptWithPasswordCredential(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* DevicePairingRequestedEventArgs_GetDeferral(py::wrapper::Windows::Devices::Enumeration::DevicePairingRequestedEventArgs* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.Enumeration.DevicePairingRequestedEventArgs", L"GetDeferral", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(self->obj.GetDeferral());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* DevicePairingRequestedEventArgs_get_DeviceInformation(py::wrapper::Windows::Devices::Enumeration::DevicePairingRequestedEventArgs* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Enumeration.DevicePairingRequestedEventArgs", L"DeviceInformation"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.DeviceInformation());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* DevicePairingRequestedEventArgs_get_PairingKind(py::wrapper::Windows::Devices::Enumeration::DevicePairingRequestedEventArgs* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Enumeration.DevicePairingRequestedEventArgs", L"PairingKind"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.PairingKind());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* DevicePairingRequestedEventArgs_get_Pin(py::wrapper::Windows::Devices::Enumeration::DevicePairingRequestedEventArgs* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Enumeration.DevicePairingRequestedEventArgs", L"Pin"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Pin());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_DevicePairingRequestedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Devices::Enumeration::DevicePairingRequestedEventArgs>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_DevicePairingRequestedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Devices::Enumeration::DevicePairingRequestedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_DevicePairingRequestedEventArgs[] = {
        { "accept", reinterpret_cast<PyCFunction>(DevicePairingRequestedEventArgs_Accept), METH_VARARGS, nullptr },
        { "accept_with_password_credential", reinterpret_cast<PyCFunction>(DevicePairingRequestedEventArgs_AcceptWithPasswordCredential), METH_VARARGS, nullptr },
        { "get_deferral", reinterpret_cast<PyCFunction>(DevicePairingRequestedEventArgs_GetDeferral), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_DevicePairingRequestedEventArgs, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_DevicePairingRequestedEventArgs), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_DevicePairingRequestedEventArgs[] = {
        { "device_information", reinterpret_cast<getter>(DevicePairingRequestedEventArgs_get_DeviceInformation), nullptr, nullptr, nullptr },
        { "pairing_kind", reinterpret_cast<getter>(DevicePairingRequestedEventArgs_get_PairingKind), nullptr, nullptr, nullptr },
        { "pin", reinterpret_cast<getter>(DevicePairingRequestedEventArgs_get_Pin), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_DevicePairingRequestedEventArgs[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_DevicePairingRequestedEventArgs) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_DevicePairingRequestedEventArgs) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_DevicePairingRequestedEventArgs) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_DevicePairingRequestedEventArgs) },
        { },
    };

    static PyType_Spec type_spec_DevicePairingRequestedEventArgs =
    {
        "winrt._winrt_windows_devices_enumeration.DevicePairingRequestedEventArgs",
        sizeof(py::wrapper::Windows::Devices::Enumeration::DevicePairingRequestedEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_DevicePairingRequestedEventArgs
    };

    // ----- DevicePairingResult class --------------------

    static PyObject* _new_DevicePairingResult(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Devices::Enumeration::DevicePairingResult>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Devices::Enumeration::DevicePairingResult>::type_name);
        return nullptr;
    }

    static void _dealloc_DevicePairingResult(py::wrapper::Windows::Devices::Enumeration::DevicePairingResult* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* DevicePairingResult_get_ProtectionLevelUsed(py::wrapper::Windows::Devices::Enumeration::DevicePairingResult* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Enumeration.DevicePairingResult", L"ProtectionLevelUsed"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.ProtectionLevelUsed());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* DevicePairingResult_get_Status(py::wrapper::Windows::Devices::Enumeration::DevicePairingResult* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Enumeration.DevicePairingResult", L"Status"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Status());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_DevicePairingResult(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Devices::Enumeration::DevicePairingResult>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_DevicePairingResult(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Devices::Enumeration::DevicePairingResult>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_DevicePairingResult[] = {
        { "_assign_array_", _assign_array_DevicePairingResult, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_DevicePairingResult), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_DevicePairingResult[] = {
        { "protection_level_used", reinterpret_cast<getter>(DevicePairingResult_get_ProtectionLevelUsed), nullptr, nullptr, nullptr },
        { "status", reinterpret_cast<getter>(DevicePairingResult_get_Status), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_DevicePairingResult[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_DevicePairingResult) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_DevicePairingResult) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_DevicePairingResult) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_DevicePairingResult) },
        { },
    };

    static PyType_Spec type_spec_DevicePairingResult =
    {
        "winrt._winrt_windows_devices_enumeration.DevicePairingResult",
        sizeof(py::wrapper::Windows::Devices::Enumeration::DevicePairingResult),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_DevicePairingResult
    };

    // ----- DevicePicker class --------------------

    static PyObject* _new_DevicePicker(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 0)
        {
            try
            {
                winrt::Windows::Devices::Enumeration::DevicePicker instance{  };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_DevicePicker(py::wrapper::Windows::Devices::Enumeration::DevicePicker* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* DevicePicker_Hide(py::wrapper::Windows::Devices::Enumeration::DevicePicker* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.Enumeration.DevicePicker", L"Hide", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                self->obj.Hide();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* DevicePicker_PickSingleDeviceAsync(py::wrapper::Windows::Devices::Enumeration::DevicePicker* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.Enumeration.DevicePicker", L"PickSingleDeviceAsync", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::Foundation::Rect>(args, 0);

                return py::convert(self->obj.PickSingleDeviceAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 2)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.Enumeration.DevicePicker", L"PickSingleDeviceAsync", 2))
            {
                py::set_arg_count_version_error(2);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::Foundation::Rect>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::UI::Popups::Placement>(args, 1);

                return py::convert(self->obj.PickSingleDeviceAsync(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* DevicePicker_SetDisplayStatus(py::wrapper::Windows::Devices::Enumeration::DevicePicker* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 3)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.Enumeration.DevicePicker", L"SetDisplayStatus", 3))
            {
                py::set_arg_count_version_error(3);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::Devices::Enumeration::DeviceInformation>(args, 0);
                auto param1 = py::convert_to<winrt::hstring>(args, 1);
                auto param2 = py::convert_to<winrt::Windows::Devices::Enumeration::DevicePickerDisplayStatusOptions>(args, 2);

                self->obj.SetDisplayStatus(param0, param1, param2);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* DevicePicker_Show(py::wrapper::Windows::Devices::Enumeration::DevicePicker* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.Enumeration.DevicePicker", L"Show", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::Foundation::Rect>(args, 0);

                self->obj.Show(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 2)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.Enumeration.DevicePicker", L"Show", 2))
            {
                py::set_arg_count_version_error(2);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::Foundation::Rect>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::UI::Popups::Placement>(args, 1);

                self->obj.Show(param0, param1);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* DevicePicker_get_Appearance(py::wrapper::Windows::Devices::Enumeration::DevicePicker* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Enumeration.DevicePicker", L"Appearance"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Appearance());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* DevicePicker_get_Filter(py::wrapper::Windows::Devices::Enumeration::DevicePicker* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Enumeration.DevicePicker", L"Filter"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Filter());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* DevicePicker_get_RequestedProperties(py::wrapper::Windows::Devices::Enumeration::DevicePicker* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Enumeration.DevicePicker", L"RequestedProperties"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.RequestedProperties());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* DevicePicker_add_DevicePickerDismissed(py::wrapper::Windows::Devices::Enumeration::DevicePicker* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Devices.Enumeration.DevicePicker", L"DevicePickerDismissed"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Devices::Enumeration::DevicePicker, winrt::Windows::Foundation::IInspectable>>(arg);

            return py::convert(self->obj.DevicePickerDismissed(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* DevicePicker_remove_DevicePickerDismissed(py::wrapper::Windows::Devices::Enumeration::DevicePicker* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Devices.Enumeration.DevicePicker", L"DevicePickerDismissed"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.DevicePickerDismissed(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* DevicePicker_add_DeviceSelected(py::wrapper::Windows::Devices::Enumeration::DevicePicker* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Devices.Enumeration.DevicePicker", L"DeviceSelected"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Devices::Enumeration::DevicePicker, winrt::Windows::Devices::Enumeration::DeviceSelectedEventArgs>>(arg);

            return py::convert(self->obj.DeviceSelected(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* DevicePicker_remove_DeviceSelected(py::wrapper::Windows::Devices::Enumeration::DevicePicker* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Devices.Enumeration.DevicePicker", L"DeviceSelected"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.DeviceSelected(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* DevicePicker_add_DisconnectButtonClicked(py::wrapper::Windows::Devices::Enumeration::DevicePicker* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Devices.Enumeration.DevicePicker", L"DisconnectButtonClicked"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Devices::Enumeration::DevicePicker, winrt::Windows::Devices::Enumeration::DeviceDisconnectButtonClickedEventArgs>>(arg);

            return py::convert(self->obj.DisconnectButtonClicked(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* DevicePicker_remove_DisconnectButtonClicked(py::wrapper::Windows::Devices::Enumeration::DevicePicker* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Devices.Enumeration.DevicePicker", L"DisconnectButtonClicked"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.DisconnectButtonClicked(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_DevicePicker(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Devices::Enumeration::DevicePicker>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_DevicePicker(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Devices::Enumeration::DevicePicker>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_DevicePicker[] = {
        { "hide", reinterpret_cast<PyCFunction>(DevicePicker_Hide), METH_VARARGS, nullptr },
        { "pick_single_device_async", reinterpret_cast<PyCFunction>(DevicePicker_PickSingleDeviceAsync), METH_VARARGS, nullptr },
        { "set_display_status", reinterpret_cast<PyCFunction>(DevicePicker_SetDisplayStatus), METH_VARARGS, nullptr },
        { "show", reinterpret_cast<PyCFunction>(DevicePicker_Show), METH_VARARGS, nullptr },
        { "add_device_picker_dismissed", reinterpret_cast<PyCFunction>(DevicePicker_add_DevicePickerDismissed), METH_O, nullptr },
        { "remove_device_picker_dismissed", reinterpret_cast<PyCFunction>(DevicePicker_remove_DevicePickerDismissed), METH_O, nullptr },
        { "add_device_selected", reinterpret_cast<PyCFunction>(DevicePicker_add_DeviceSelected), METH_O, nullptr },
        { "remove_device_selected", reinterpret_cast<PyCFunction>(DevicePicker_remove_DeviceSelected), METH_O, nullptr },
        { "add_disconnect_button_clicked", reinterpret_cast<PyCFunction>(DevicePicker_add_DisconnectButtonClicked), METH_O, nullptr },
        { "remove_disconnect_button_clicked", reinterpret_cast<PyCFunction>(DevicePicker_remove_DisconnectButtonClicked), METH_O, nullptr },
        { "_assign_array_", _assign_array_DevicePicker, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_DevicePicker), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_DevicePicker[] = {
        { "appearance", reinterpret_cast<getter>(DevicePicker_get_Appearance), nullptr, nullptr, nullptr },
        { "filter", reinterpret_cast<getter>(DevicePicker_get_Filter), nullptr, nullptr, nullptr },
        { "requested_properties", reinterpret_cast<getter>(DevicePicker_get_RequestedProperties), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_DevicePicker[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_DevicePicker) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_DevicePicker) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_DevicePicker) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_DevicePicker) },
        { },
    };

    static PyType_Spec type_spec_DevicePicker =
    {
        "winrt._winrt_windows_devices_enumeration.DevicePicker",
        sizeof(py::wrapper::Windows::Devices::Enumeration::DevicePicker),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_DevicePicker
    };

    // ----- DevicePickerAppearance class --------------------

    static PyObject* _new_DevicePickerAppearance(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Devices::Enumeration::DevicePickerAppearance>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Devices::Enumeration::DevicePickerAppearance>::type_name);
        return nullptr;
    }

    static void _dealloc_DevicePickerAppearance(py::wrapper::Windows::Devices::Enumeration::DevicePickerAppearance* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* DevicePickerAppearance_get_Title(py::wrapper::Windows::Devices::Enumeration::DevicePickerAppearance* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Enumeration.DevicePickerAppearance", L"Title"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Title());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int DevicePickerAppearance_put_Title(py::wrapper::Windows::Devices::Enumeration::DevicePickerAppearance* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Enumeration.DevicePickerAppearance", L"Title"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.Title(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* DevicePickerAppearance_get_SelectedForegroundColor(py::wrapper::Windows::Devices::Enumeration::DevicePickerAppearance* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Enumeration.DevicePickerAppearance", L"SelectedForegroundColor"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.SelectedForegroundColor());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int DevicePickerAppearance_put_SelectedForegroundColor(py::wrapper::Windows::Devices::Enumeration::DevicePickerAppearance* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Enumeration.DevicePickerAppearance", L"SelectedForegroundColor"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::UI::Color>(arg);

            self->obj.SelectedForegroundColor(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* DevicePickerAppearance_get_SelectedBackgroundColor(py::wrapper::Windows::Devices::Enumeration::DevicePickerAppearance* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Enumeration.DevicePickerAppearance", L"SelectedBackgroundColor"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.SelectedBackgroundColor());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int DevicePickerAppearance_put_SelectedBackgroundColor(py::wrapper::Windows::Devices::Enumeration::DevicePickerAppearance* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Enumeration.DevicePickerAppearance", L"SelectedBackgroundColor"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::UI::Color>(arg);

            self->obj.SelectedBackgroundColor(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* DevicePickerAppearance_get_SelectedAccentColor(py::wrapper::Windows::Devices::Enumeration::DevicePickerAppearance* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Enumeration.DevicePickerAppearance", L"SelectedAccentColor"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.SelectedAccentColor());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int DevicePickerAppearance_put_SelectedAccentColor(py::wrapper::Windows::Devices::Enumeration::DevicePickerAppearance* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Enumeration.DevicePickerAppearance", L"SelectedAccentColor"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::UI::Color>(arg);

            self->obj.SelectedAccentColor(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* DevicePickerAppearance_get_ForegroundColor(py::wrapper::Windows::Devices::Enumeration::DevicePickerAppearance* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Enumeration.DevicePickerAppearance", L"ForegroundColor"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.ForegroundColor());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int DevicePickerAppearance_put_ForegroundColor(py::wrapper::Windows::Devices::Enumeration::DevicePickerAppearance* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Enumeration.DevicePickerAppearance", L"ForegroundColor"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::UI::Color>(arg);

            self->obj.ForegroundColor(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* DevicePickerAppearance_get_BackgroundColor(py::wrapper::Windows::Devices::Enumeration::DevicePickerAppearance* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Enumeration.DevicePickerAppearance", L"BackgroundColor"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.BackgroundColor());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int DevicePickerAppearance_put_BackgroundColor(py::wrapper::Windows::Devices::Enumeration::DevicePickerAppearance* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Enumeration.DevicePickerAppearance", L"BackgroundColor"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::UI::Color>(arg);

            self->obj.BackgroundColor(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* DevicePickerAppearance_get_AccentColor(py::wrapper::Windows::Devices::Enumeration::DevicePickerAppearance* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Enumeration.DevicePickerAppearance", L"AccentColor"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.AccentColor());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int DevicePickerAppearance_put_AccentColor(py::wrapper::Windows::Devices::Enumeration::DevicePickerAppearance* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Enumeration.DevicePickerAppearance", L"AccentColor"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::UI::Color>(arg);

            self->obj.AccentColor(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* _assign_array_DevicePickerAppearance(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Devices::Enumeration::DevicePickerAppearance>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_DevicePickerAppearance(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Devices::Enumeration::DevicePickerAppearance>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_DevicePickerAppearance[] = {
        { "_assign_array_", _assign_array_DevicePickerAppearance, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_DevicePickerAppearance), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_DevicePickerAppearance[] = {
        { "title", reinterpret_cast<getter>(DevicePickerAppearance_get_Title), reinterpret_cast<setter>(DevicePickerAppearance_put_Title), nullptr, nullptr },
        { "selected_foreground_color", reinterpret_cast<getter>(DevicePickerAppearance_get_SelectedForegroundColor), reinterpret_cast<setter>(DevicePickerAppearance_put_SelectedForegroundColor), nullptr, nullptr },
        { "selected_background_color", reinterpret_cast<getter>(DevicePickerAppearance_get_SelectedBackgroundColor), reinterpret_cast<setter>(DevicePickerAppearance_put_SelectedBackgroundColor), nullptr, nullptr },
        { "selected_accent_color", reinterpret_cast<getter>(DevicePickerAppearance_get_SelectedAccentColor), reinterpret_cast<setter>(DevicePickerAppearance_put_SelectedAccentColor), nullptr, nullptr },
        { "foreground_color", reinterpret_cast<getter>(DevicePickerAppearance_get_ForegroundColor), reinterpret_cast<setter>(DevicePickerAppearance_put_ForegroundColor), nullptr, nullptr },
        { "background_color", reinterpret_cast<getter>(DevicePickerAppearance_get_BackgroundColor), reinterpret_cast<setter>(DevicePickerAppearance_put_BackgroundColor), nullptr, nullptr },
        { "accent_color", reinterpret_cast<getter>(DevicePickerAppearance_get_AccentColor), reinterpret_cast<setter>(DevicePickerAppearance_put_AccentColor), nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_DevicePickerAppearance[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_DevicePickerAppearance) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_DevicePickerAppearance) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_DevicePickerAppearance) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_DevicePickerAppearance) },
        { },
    };

    static PyType_Spec type_spec_DevicePickerAppearance =
    {
        "winrt._winrt_windows_devices_enumeration.DevicePickerAppearance",
        sizeof(py::wrapper::Windows::Devices::Enumeration::DevicePickerAppearance),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_DevicePickerAppearance
    };

    // ----- DevicePickerFilter class --------------------

    static PyObject* _new_DevicePickerFilter(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Devices::Enumeration::DevicePickerFilter>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Devices::Enumeration::DevicePickerFilter>::type_name);
        return nullptr;
    }

    static void _dealloc_DevicePickerFilter(py::wrapper::Windows::Devices::Enumeration::DevicePickerFilter* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* DevicePickerFilter_get_SupportedDeviceClasses(py::wrapper::Windows::Devices::Enumeration::DevicePickerFilter* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Enumeration.DevicePickerFilter", L"SupportedDeviceClasses"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.SupportedDeviceClasses());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* DevicePickerFilter_get_SupportedDeviceSelectors(py::wrapper::Windows::Devices::Enumeration::DevicePickerFilter* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Enumeration.DevicePickerFilter", L"SupportedDeviceSelectors"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.SupportedDeviceSelectors());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_DevicePickerFilter(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Devices::Enumeration::DevicePickerFilter>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_DevicePickerFilter(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Devices::Enumeration::DevicePickerFilter>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_DevicePickerFilter[] = {
        { "_assign_array_", _assign_array_DevicePickerFilter, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_DevicePickerFilter), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_DevicePickerFilter[] = {
        { "supported_device_classes", reinterpret_cast<getter>(DevicePickerFilter_get_SupportedDeviceClasses), nullptr, nullptr, nullptr },
        { "supported_device_selectors", reinterpret_cast<getter>(DevicePickerFilter_get_SupportedDeviceSelectors), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_DevicePickerFilter[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_DevicePickerFilter) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_DevicePickerFilter) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_DevicePickerFilter) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_DevicePickerFilter) },
        { },
    };

    static PyType_Spec type_spec_DevicePickerFilter =
    {
        "winrt._winrt_windows_devices_enumeration.DevicePickerFilter",
        sizeof(py::wrapper::Windows::Devices::Enumeration::DevicePickerFilter),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_DevicePickerFilter
    };

    // ----- DeviceSelectedEventArgs class --------------------

    static PyObject* _new_DeviceSelectedEventArgs(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Devices::Enumeration::DeviceSelectedEventArgs>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Devices::Enumeration::DeviceSelectedEventArgs>::type_name);
        return nullptr;
    }

    static void _dealloc_DeviceSelectedEventArgs(py::wrapper::Windows::Devices::Enumeration::DeviceSelectedEventArgs* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* DeviceSelectedEventArgs_get_SelectedDevice(py::wrapper::Windows::Devices::Enumeration::DeviceSelectedEventArgs* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Enumeration.DeviceSelectedEventArgs", L"SelectedDevice"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.SelectedDevice());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_DeviceSelectedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Devices::Enumeration::DeviceSelectedEventArgs>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_DeviceSelectedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Devices::Enumeration::DeviceSelectedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_DeviceSelectedEventArgs[] = {
        { "_assign_array_", _assign_array_DeviceSelectedEventArgs, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_DeviceSelectedEventArgs), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_DeviceSelectedEventArgs[] = {
        { "selected_device", reinterpret_cast<getter>(DeviceSelectedEventArgs_get_SelectedDevice), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_DeviceSelectedEventArgs[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_DeviceSelectedEventArgs) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_DeviceSelectedEventArgs) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_DeviceSelectedEventArgs) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_DeviceSelectedEventArgs) },
        { },
    };

    static PyType_Spec type_spec_DeviceSelectedEventArgs =
    {
        "winrt._winrt_windows_devices_enumeration.DeviceSelectedEventArgs",
        sizeof(py::wrapper::Windows::Devices::Enumeration::DeviceSelectedEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_DeviceSelectedEventArgs
    };

    // ----- DeviceThumbnail class --------------------

    static PyObject* _new_DeviceThumbnail(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Devices::Enumeration::DeviceThumbnail>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Devices::Enumeration::DeviceThumbnail>::type_name);
        return nullptr;
    }

    static void _dealloc_DeviceThumbnail(py::wrapper::Windows::Devices::Enumeration::DeviceThumbnail* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* DeviceThumbnail_CloneStream(py::wrapper::Windows::Devices::Enumeration::DeviceThumbnail* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.Enumeration.DeviceThumbnail", L"CloneStream", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(self->obj.CloneStream());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* DeviceThumbnail_Close(py::wrapper::Windows::Devices::Enumeration::DeviceThumbnail* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.Enumeration.DeviceThumbnail", L"Close", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                self->obj.Close();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* DeviceThumbnail_FlushAsync(py::wrapper::Windows::Devices::Enumeration::DeviceThumbnail* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.Enumeration.DeviceThumbnail", L"FlushAsync", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(self->obj.FlushAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* DeviceThumbnail_GetInputStreamAt(py::wrapper::Windows::Devices::Enumeration::DeviceThumbnail* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.Enumeration.DeviceThumbnail", L"GetInputStreamAt", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<uint64_t>(args, 0);

                return py::convert(self->obj.GetInputStreamAt(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* DeviceThumbnail_GetOutputStreamAt(py::wrapper::Windows::Devices::Enumeration::DeviceThumbnail* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.Enumeration.DeviceThumbnail", L"GetOutputStreamAt", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<uint64_t>(args, 0);

                return py::convert(self->obj.GetOutputStreamAt(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* DeviceThumbnail_ReadAsync(py::wrapper::Windows::Devices::Enumeration::DeviceThumbnail* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 3)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.Enumeration.DeviceThumbnail", L"ReadAsync", 3))
            {
                py::set_arg_count_version_error(3);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::Storage::Streams::IBuffer>(args, 0);
                auto param1 = py::convert_to<uint32_t>(args, 1);
                auto param2 = py::convert_to<winrt::Windows::Storage::Streams::InputStreamOptions>(args, 2);

                return py::convert(self->obj.ReadAsync(param0, param1, param2));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* DeviceThumbnail_Seek(py::wrapper::Windows::Devices::Enumeration::DeviceThumbnail* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.Enumeration.DeviceThumbnail", L"Seek", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<uint64_t>(args, 0);

                self->obj.Seek(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* DeviceThumbnail_WriteAsync(py::wrapper::Windows::Devices::Enumeration::DeviceThumbnail* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.Enumeration.DeviceThumbnail", L"WriteAsync", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::Storage::Streams::IBuffer>(args, 0);

                return py::convert(self->obj.WriteAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* DeviceThumbnail_get_ContentType(py::wrapper::Windows::Devices::Enumeration::DeviceThumbnail* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Enumeration.DeviceThumbnail", L"ContentType"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.ContentType());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* DeviceThumbnail_get_Size(py::wrapper::Windows::Devices::Enumeration::DeviceThumbnail* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Enumeration.DeviceThumbnail", L"Size"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Size());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int DeviceThumbnail_put_Size(py::wrapper::Windows::Devices::Enumeration::DeviceThumbnail* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Enumeration.DeviceThumbnail", L"Size"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<uint64_t>(arg);

            self->obj.Size(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* DeviceThumbnail_get_CanRead(py::wrapper::Windows::Devices::Enumeration::DeviceThumbnail* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Enumeration.DeviceThumbnail", L"CanRead"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.CanRead());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* DeviceThumbnail_get_CanWrite(py::wrapper::Windows::Devices::Enumeration::DeviceThumbnail* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Enumeration.DeviceThumbnail", L"CanWrite"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.CanWrite());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* DeviceThumbnail_get_Position(py::wrapper::Windows::Devices::Enumeration::DeviceThumbnail* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Enumeration.DeviceThumbnail", L"Position"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Position());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_DeviceThumbnail(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Devices::Enumeration::DeviceThumbnail>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_DeviceThumbnail(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Devices::Enumeration::DeviceThumbnail>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _enter_DeviceThumbnail(py::wrapper::Windows::Devices::Enumeration::DeviceThumbnail* self, PyObject* /*unused*/) noexcept
    {
        return Py_NewRef(self);
    }

    static PyObject* _exit_DeviceThumbnail(py::wrapper::Windows::Devices::Enumeration::DeviceThumbnail* self, PyObject* /*unused*/) noexcept
    {
        try
        {
            self->obj.Close();
            Py_RETURN_FALSE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_DeviceThumbnail[] = {
        { "clone_stream", reinterpret_cast<PyCFunction>(DeviceThumbnail_CloneStream), METH_VARARGS, nullptr },
        { "close", reinterpret_cast<PyCFunction>(DeviceThumbnail_Close), METH_VARARGS, nullptr },
        { "flush_async", reinterpret_cast<PyCFunction>(DeviceThumbnail_FlushAsync), METH_VARARGS, nullptr },
        { "get_input_stream_at", reinterpret_cast<PyCFunction>(DeviceThumbnail_GetInputStreamAt), METH_VARARGS, nullptr },
        { "get_output_stream_at", reinterpret_cast<PyCFunction>(DeviceThumbnail_GetOutputStreamAt), METH_VARARGS, nullptr },
        { "read_async", reinterpret_cast<PyCFunction>(DeviceThumbnail_ReadAsync), METH_VARARGS, nullptr },
        { "seek", reinterpret_cast<PyCFunction>(DeviceThumbnail_Seek), METH_VARARGS, nullptr },
        { "write_async", reinterpret_cast<PyCFunction>(DeviceThumbnail_WriteAsync), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_DeviceThumbnail, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_DeviceThumbnail), METH_O | METH_STATIC, nullptr },
        { "__enter__", reinterpret_cast<PyCFunction>(_enter_DeviceThumbnail), METH_NOARGS, nullptr },
        { "__exit__",  reinterpret_cast<PyCFunction>(_exit_DeviceThumbnail), METH_VARARGS, nullptr },
        { }
    };

    static PyGetSetDef _getset_DeviceThumbnail[] = {
        { "content_type", reinterpret_cast<getter>(DeviceThumbnail_get_ContentType), nullptr, nullptr, nullptr },
        { "size", reinterpret_cast<getter>(DeviceThumbnail_get_Size), reinterpret_cast<setter>(DeviceThumbnail_put_Size), nullptr, nullptr },
        { "can_read", reinterpret_cast<getter>(DeviceThumbnail_get_CanRead), nullptr, nullptr, nullptr },
        { "can_write", reinterpret_cast<getter>(DeviceThumbnail_get_CanWrite), nullptr, nullptr, nullptr },
        { "position", reinterpret_cast<getter>(DeviceThumbnail_get_Position), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_DeviceThumbnail[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_DeviceThumbnail) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_DeviceThumbnail) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_DeviceThumbnail) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_DeviceThumbnail) },
        { },
    };

    static PyType_Spec type_spec_DeviceThumbnail =
    {
        "winrt._winrt_windows_devices_enumeration.DeviceThumbnail",
        sizeof(py::wrapper::Windows::Devices::Enumeration::DeviceThumbnail),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_DeviceThumbnail
    };

    // ----- DeviceUnpairingResult class --------------------

    static PyObject* _new_DeviceUnpairingResult(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Devices::Enumeration::DeviceUnpairingResult>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Devices::Enumeration::DeviceUnpairingResult>::type_name);
        return nullptr;
    }

    static void _dealloc_DeviceUnpairingResult(py::wrapper::Windows::Devices::Enumeration::DeviceUnpairingResult* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* DeviceUnpairingResult_get_Status(py::wrapper::Windows::Devices::Enumeration::DeviceUnpairingResult* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Enumeration.DeviceUnpairingResult", L"Status"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Status());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_DeviceUnpairingResult(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Devices::Enumeration::DeviceUnpairingResult>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_DeviceUnpairingResult(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Devices::Enumeration::DeviceUnpairingResult>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_DeviceUnpairingResult[] = {
        { "_assign_array_", _assign_array_DeviceUnpairingResult, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_DeviceUnpairingResult), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_DeviceUnpairingResult[] = {
        { "status", reinterpret_cast<getter>(DeviceUnpairingResult_get_Status), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_DeviceUnpairingResult[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_DeviceUnpairingResult) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_DeviceUnpairingResult) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_DeviceUnpairingResult) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_DeviceUnpairingResult) },
        { },
    };

    static PyType_Spec type_spec_DeviceUnpairingResult =
    {
        "winrt._winrt_windows_devices_enumeration.DeviceUnpairingResult",
        sizeof(py::wrapper::Windows::Devices::Enumeration::DeviceUnpairingResult),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_DeviceUnpairingResult
    };

    // ----- DeviceWatcher class --------------------

    static PyObject* _new_DeviceWatcher(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Devices::Enumeration::DeviceWatcher>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Devices::Enumeration::DeviceWatcher>::type_name);
        return nullptr;
    }

    static void _dealloc_DeviceWatcher(py::wrapper::Windows::Devices::Enumeration::DeviceWatcher* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* DeviceWatcher_GetBackgroundTrigger(py::wrapper::Windows::Devices::Enumeration::DeviceWatcher* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.Enumeration.DeviceWatcher", L"GetBackgroundTrigger", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::Foundation::Collections::IIterable<winrt::Windows::Devices::Enumeration::DeviceWatcherEventKind>>(args, 0);

                return py::convert(self->obj.GetBackgroundTrigger(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* DeviceWatcher_Start(py::wrapper::Windows::Devices::Enumeration::DeviceWatcher* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.Enumeration.DeviceWatcher", L"Start", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                self->obj.Start();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* DeviceWatcher_Stop(py::wrapper::Windows::Devices::Enumeration::DeviceWatcher* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.Enumeration.DeviceWatcher", L"Stop", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                self->obj.Stop();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* DeviceWatcher_get_Status(py::wrapper::Windows::Devices::Enumeration::DeviceWatcher* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Enumeration.DeviceWatcher", L"Status"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Status());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* DeviceWatcher_add_Added(py::wrapper::Windows::Devices::Enumeration::DeviceWatcher* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Devices.Enumeration.DeviceWatcher", L"Added"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Devices::Enumeration::DeviceWatcher, winrt::Windows::Devices::Enumeration::DeviceInformation>>(arg);

            return py::convert(self->obj.Added(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* DeviceWatcher_remove_Added(py::wrapper::Windows::Devices::Enumeration::DeviceWatcher* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Devices.Enumeration.DeviceWatcher", L"Added"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.Added(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* DeviceWatcher_add_EnumerationCompleted(py::wrapper::Windows::Devices::Enumeration::DeviceWatcher* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Devices.Enumeration.DeviceWatcher", L"EnumerationCompleted"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Devices::Enumeration::DeviceWatcher, winrt::Windows::Foundation::IInspectable>>(arg);

            return py::convert(self->obj.EnumerationCompleted(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* DeviceWatcher_remove_EnumerationCompleted(py::wrapper::Windows::Devices::Enumeration::DeviceWatcher* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Devices.Enumeration.DeviceWatcher", L"EnumerationCompleted"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.EnumerationCompleted(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* DeviceWatcher_add_Removed(py::wrapper::Windows::Devices::Enumeration::DeviceWatcher* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Devices.Enumeration.DeviceWatcher", L"Removed"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Devices::Enumeration::DeviceWatcher, winrt::Windows::Devices::Enumeration::DeviceInformationUpdate>>(arg);

            return py::convert(self->obj.Removed(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* DeviceWatcher_remove_Removed(py::wrapper::Windows::Devices::Enumeration::DeviceWatcher* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Devices.Enumeration.DeviceWatcher", L"Removed"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.Removed(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* DeviceWatcher_add_Stopped(py::wrapper::Windows::Devices::Enumeration::DeviceWatcher* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Devices.Enumeration.DeviceWatcher", L"Stopped"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Devices::Enumeration::DeviceWatcher, winrt::Windows::Foundation::IInspectable>>(arg);

            return py::convert(self->obj.Stopped(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* DeviceWatcher_remove_Stopped(py::wrapper::Windows::Devices::Enumeration::DeviceWatcher* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Devices.Enumeration.DeviceWatcher", L"Stopped"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.Stopped(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* DeviceWatcher_add_Updated(py::wrapper::Windows::Devices::Enumeration::DeviceWatcher* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Devices.Enumeration.DeviceWatcher", L"Updated"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Devices::Enumeration::DeviceWatcher, winrt::Windows::Devices::Enumeration::DeviceInformationUpdate>>(arg);

            return py::convert(self->obj.Updated(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* DeviceWatcher_remove_Updated(py::wrapper::Windows::Devices::Enumeration::DeviceWatcher* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Devices.Enumeration.DeviceWatcher", L"Updated"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.Updated(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_DeviceWatcher(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Devices::Enumeration::DeviceWatcher>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_DeviceWatcher(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Devices::Enumeration::DeviceWatcher>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_DeviceWatcher[] = {
        { "get_background_trigger", reinterpret_cast<PyCFunction>(DeviceWatcher_GetBackgroundTrigger), METH_VARARGS, nullptr },
        { "start", reinterpret_cast<PyCFunction>(DeviceWatcher_Start), METH_VARARGS, nullptr },
        { "stop", reinterpret_cast<PyCFunction>(DeviceWatcher_Stop), METH_VARARGS, nullptr },
        { "add_added", reinterpret_cast<PyCFunction>(DeviceWatcher_add_Added), METH_O, nullptr },
        { "remove_added", reinterpret_cast<PyCFunction>(DeviceWatcher_remove_Added), METH_O, nullptr },
        { "add_enumeration_completed", reinterpret_cast<PyCFunction>(DeviceWatcher_add_EnumerationCompleted), METH_O, nullptr },
        { "remove_enumeration_completed", reinterpret_cast<PyCFunction>(DeviceWatcher_remove_EnumerationCompleted), METH_O, nullptr },
        { "add_removed", reinterpret_cast<PyCFunction>(DeviceWatcher_add_Removed), METH_O, nullptr },
        { "remove_removed", reinterpret_cast<PyCFunction>(DeviceWatcher_remove_Removed), METH_O, nullptr },
        { "add_stopped", reinterpret_cast<PyCFunction>(DeviceWatcher_add_Stopped), METH_O, nullptr },
        { "remove_stopped", reinterpret_cast<PyCFunction>(DeviceWatcher_remove_Stopped), METH_O, nullptr },
        { "add_updated", reinterpret_cast<PyCFunction>(DeviceWatcher_add_Updated), METH_O, nullptr },
        { "remove_updated", reinterpret_cast<PyCFunction>(DeviceWatcher_remove_Updated), METH_O, nullptr },
        { "_assign_array_", _assign_array_DeviceWatcher, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_DeviceWatcher), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_DeviceWatcher[] = {
        { "status", reinterpret_cast<getter>(DeviceWatcher_get_Status), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_DeviceWatcher[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_DeviceWatcher) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_DeviceWatcher) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_DeviceWatcher) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_DeviceWatcher) },
        { },
    };

    static PyType_Spec type_spec_DeviceWatcher =
    {
        "winrt._winrt_windows_devices_enumeration.DeviceWatcher",
        sizeof(py::wrapper::Windows::Devices::Enumeration::DeviceWatcher),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_DeviceWatcher
    };

    // ----- DeviceWatcherEvent class --------------------

    static PyObject* _new_DeviceWatcherEvent(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Devices::Enumeration::DeviceWatcherEvent>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Devices::Enumeration::DeviceWatcherEvent>::type_name);
        return nullptr;
    }

    static void _dealloc_DeviceWatcherEvent(py::wrapper::Windows::Devices::Enumeration::DeviceWatcherEvent* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* DeviceWatcherEvent_get_DeviceInformation(py::wrapper::Windows::Devices::Enumeration::DeviceWatcherEvent* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Enumeration.DeviceWatcherEvent", L"DeviceInformation"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.DeviceInformation());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* DeviceWatcherEvent_get_DeviceInformationUpdate(py::wrapper::Windows::Devices::Enumeration::DeviceWatcherEvent* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Enumeration.DeviceWatcherEvent", L"DeviceInformationUpdate"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.DeviceInformationUpdate());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* DeviceWatcherEvent_get_Kind(py::wrapper::Windows::Devices::Enumeration::DeviceWatcherEvent* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Enumeration.DeviceWatcherEvent", L"Kind"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Kind());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_DeviceWatcherEvent(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Devices::Enumeration::DeviceWatcherEvent>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_DeviceWatcherEvent(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Devices::Enumeration::DeviceWatcherEvent>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_DeviceWatcherEvent[] = {
        { "_assign_array_", _assign_array_DeviceWatcherEvent, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_DeviceWatcherEvent), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_DeviceWatcherEvent[] = {
        { "device_information", reinterpret_cast<getter>(DeviceWatcherEvent_get_DeviceInformation), nullptr, nullptr, nullptr },
        { "device_information_update", reinterpret_cast<getter>(DeviceWatcherEvent_get_DeviceInformationUpdate), nullptr, nullptr, nullptr },
        { "kind", reinterpret_cast<getter>(DeviceWatcherEvent_get_Kind), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_DeviceWatcherEvent[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_DeviceWatcherEvent) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_DeviceWatcherEvent) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_DeviceWatcherEvent) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_DeviceWatcherEvent) },
        { },
    };

    static PyType_Spec type_spec_DeviceWatcherEvent =
    {
        "winrt._winrt_windows_devices_enumeration.DeviceWatcherEvent",
        sizeof(py::wrapper::Windows::Devices::Enumeration::DeviceWatcherEvent),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_DeviceWatcherEvent
    };

    // ----- DeviceWatcherTriggerDetails class --------------------

    static PyObject* _new_DeviceWatcherTriggerDetails(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Devices::Enumeration::DeviceWatcherTriggerDetails>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Devices::Enumeration::DeviceWatcherTriggerDetails>::type_name);
        return nullptr;
    }

    static void _dealloc_DeviceWatcherTriggerDetails(py::wrapper::Windows::Devices::Enumeration::DeviceWatcherTriggerDetails* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* DeviceWatcherTriggerDetails_get_DeviceWatcherEvents(py::wrapper::Windows::Devices::Enumeration::DeviceWatcherTriggerDetails* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Enumeration.DeviceWatcherTriggerDetails", L"DeviceWatcherEvents"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.DeviceWatcherEvents());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_DeviceWatcherTriggerDetails(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Devices::Enumeration::DeviceWatcherTriggerDetails>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_DeviceWatcherTriggerDetails(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Devices::Enumeration::DeviceWatcherTriggerDetails>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_DeviceWatcherTriggerDetails[] = {
        { "_assign_array_", _assign_array_DeviceWatcherTriggerDetails, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_DeviceWatcherTriggerDetails), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_DeviceWatcherTriggerDetails[] = {
        { "device_watcher_events", reinterpret_cast<getter>(DeviceWatcherTriggerDetails_get_DeviceWatcherEvents), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_DeviceWatcherTriggerDetails[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_DeviceWatcherTriggerDetails) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_DeviceWatcherTriggerDetails) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_DeviceWatcherTriggerDetails) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_DeviceWatcherTriggerDetails) },
        { },
    };

    static PyType_Spec type_spec_DeviceWatcherTriggerDetails =
    {
        "winrt._winrt_windows_devices_enumeration.DeviceWatcherTriggerDetails",
        sizeof(py::wrapper::Windows::Devices::Enumeration::DeviceWatcherTriggerDetails),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_DeviceWatcherTriggerDetails
    };

    // ----- EnclosureLocation class --------------------

    static PyObject* _new_EnclosureLocation(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Devices::Enumeration::EnclosureLocation>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Devices::Enumeration::EnclosureLocation>::type_name);
        return nullptr;
    }

    static void _dealloc_EnclosureLocation(py::wrapper::Windows::Devices::Enumeration::EnclosureLocation* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* EnclosureLocation_get_InDock(py::wrapper::Windows::Devices::Enumeration::EnclosureLocation* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Enumeration.EnclosureLocation", L"InDock"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.InDock());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* EnclosureLocation_get_InLid(py::wrapper::Windows::Devices::Enumeration::EnclosureLocation* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Enumeration.EnclosureLocation", L"InLid"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.InLid());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* EnclosureLocation_get_Panel(py::wrapper::Windows::Devices::Enumeration::EnclosureLocation* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Enumeration.EnclosureLocation", L"Panel"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Panel());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* EnclosureLocation_get_RotationAngleInDegreesClockwise(py::wrapper::Windows::Devices::Enumeration::EnclosureLocation* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Enumeration.EnclosureLocation", L"RotationAngleInDegreesClockwise"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.RotationAngleInDegreesClockwise());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_EnclosureLocation(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Devices::Enumeration::EnclosureLocation>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_EnclosureLocation(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Devices::Enumeration::EnclosureLocation>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_EnclosureLocation[] = {
        { "_assign_array_", _assign_array_EnclosureLocation, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_EnclosureLocation), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_EnclosureLocation[] = {
        { "in_dock", reinterpret_cast<getter>(EnclosureLocation_get_InDock), nullptr, nullptr, nullptr },
        { "in_lid", reinterpret_cast<getter>(EnclosureLocation_get_InLid), nullptr, nullptr, nullptr },
        { "panel", reinterpret_cast<getter>(EnclosureLocation_get_Panel), nullptr, nullptr, nullptr },
        { "rotation_angle_in_degrees_clockwise", reinterpret_cast<getter>(EnclosureLocation_get_RotationAngleInDegreesClockwise), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_EnclosureLocation[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_EnclosureLocation) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_EnclosureLocation) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_EnclosureLocation) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_EnclosureLocation) },
        { },
    };

    static PyType_Spec type_spec_EnclosureLocation =
    {
        "winrt._winrt_windows_devices_enumeration.EnclosureLocation",
        sizeof(py::wrapper::Windows::Devices::Enumeration::EnclosureLocation),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_EnclosureLocation
    };

    // ----- IDevicePairingSettings interface --------------------

    static PyObject* _new_IDevicePairingSettings(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Devices::Enumeration::IDevicePairingSettings>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Devices::Enumeration::IDevicePairingSettings>::type_name);
        return nullptr;
    }

    static void _dealloc_IDevicePairingSettings(py::wrapper::Windows::Devices::Enumeration::IDevicePairingSettings* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* _assign_array_IDevicePairingSettings(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Devices::Enumeration::IDevicePairingSettings>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_IDevicePairingSettings(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Devices::Enumeration::IDevicePairingSettings>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_IDevicePairingSettings[] = {
        { "_assign_array_", _assign_array_IDevicePairingSettings, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_IDevicePairingSettings), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_IDevicePairingSettings[] = {
        { }
    };

    static PyType_Slot _type_slots_IDevicePairingSettings[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_IDevicePairingSettings) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_IDevicePairingSettings) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_IDevicePairingSettings) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_IDevicePairingSettings) },
        { },
    };

    static PyType_Spec type_spec_IDevicePairingSettings =
    {
        "winrt._winrt_windows_devices_enumeration.IDevicePairingSettings",
        sizeof(py::wrapper::Windows::Devices::Enumeration::IDevicePairingSettings),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_IDevicePairingSettings
    };

    // ----- Windows.Devices.Enumeration Initialization --------------------
    PyDoc_STRVAR(module_doc, "Windows::Devices::Enumeration");


    static PyModuleDef module_def
        = {PyModuleDef_HEAD_INIT,
           "_winrt_windows_devices_enumeration",
           module_doc,
           0,
           nullptr,
           nullptr,
           nullptr,
           nullptr,
           nullptr};

} // py::cpp::Windows::Devices::Enumeration

PyMODINIT_FUNC PyInit__winrt_windows_devices_enumeration(void) noexcept
{
    using namespace py::cpp::Windows::Devices::Enumeration;

    if (py::import_winrt_runtime() == -1)
    {
        return nullptr;
    }

    py::pyobj_handle module{PyModule_Create(&module_def)};

    if (!module)
    {
        return nullptr;
    }

    auto object_type = py::get_object_type();
    if (!object_type)
    {
        return nullptr;
    }

    py::pyobj_handle object_bases{PyTuple_Pack(1, object_type)};

    if (!object_bases)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_DeviceAccessChangedEventArgs, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    py::pyobj_handle type_DeviceAccessInformation_Static{PyType_FromSpec(&type_spec_DeviceAccessInformation_Static)};
    if (!type_DeviceAccessInformation_Static)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_DeviceAccessInformation, object_bases.get(), reinterpret_cast<PyTypeObject*>(type_DeviceAccessInformation_Static.get())) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_DeviceConnectionChangeTriggerDetails, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_DeviceDisconnectButtonClickedEventArgs, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    py::pyobj_handle type_DeviceInformation_Static{PyType_FromSpec(&type_spec_DeviceInformation_Static)};
    if (!type_DeviceInformation_Static)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_DeviceInformation, object_bases.get(), reinterpret_cast<PyTypeObject*>(type_DeviceInformation_Static.get())) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_DeviceInformationCollection, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_DeviceInformationCustomPairing, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    py::pyobj_handle type_DeviceInformationPairing_Static{PyType_FromSpec(&type_spec_DeviceInformationPairing_Static)};
    if (!type_DeviceInformationPairing_Static)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_DeviceInformationPairing, object_bases.get(), reinterpret_cast<PyTypeObject*>(type_DeviceInformationPairing_Static.get())) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_DeviceInformationUpdate, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_DevicePairingRequestedEventArgs, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_DevicePairingResult, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_DevicePicker, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_DevicePickerAppearance, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_DevicePickerFilter, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_DeviceSelectedEventArgs, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_DeviceThumbnail, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_DeviceUnpairingResult, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_DeviceWatcher, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_DeviceWatcherEvent, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_DeviceWatcherTriggerDetails, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_EnclosureLocation, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_IDevicePairingSettings, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }


    return module.detach();
}
