// WARNING: Please don't edit this file. It was generated by Python/WinRT v0.0.0

#include "pybase.h"
#include "py.Windows.ApplicationModel.Contacts.h"


namespace py::cpp::Windows::ApplicationModel::Contacts
{
    // ----- AggregateContactManager class --------------------

    static PyObject* _new_AggregateContactManager(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::ApplicationModel::Contacts::AggregateContactManager>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::ApplicationModel::Contacts::AggregateContactManager>::type_name);
        return nullptr;
    }

    static void _dealloc_AggregateContactManager(py::wrapper::Windows::ApplicationModel::Contacts::AggregateContactManager* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* AggregateContactManager_FindRawContactsAsync(py::wrapper::Windows::ApplicationModel::Contacts::AggregateContactManager* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.ApplicationModel.Contacts.AggregateContactManager", L"FindRawContactsAsync", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::ApplicationModel::Contacts::Contact>(args, 0);

                return py::convert(self->obj.FindRawContactsAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AggregateContactManager_SetRemoteIdentificationInformationAsync(py::wrapper::Windows::ApplicationModel::Contacts::AggregateContactManager* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 3)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.ApplicationModel.Contacts.AggregateContactManager", L"SetRemoteIdentificationInformationAsync", 3))
            {
                py::set_arg_count_version_error(3);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::hstring>(args, 1);
                auto param2 = py::convert_to<winrt::hstring>(args, 2);

                return py::convert(self->obj.SetRemoteIdentificationInformationAsync(param0, param1, param2));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AggregateContactManager_TryLinkContactsAsync(py::wrapper::Windows::ApplicationModel::Contacts::AggregateContactManager* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.ApplicationModel.Contacts.AggregateContactManager", L"TryLinkContactsAsync", 2))
            {
                py::set_arg_count_version_error(2);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::ApplicationModel::Contacts::Contact>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::ApplicationModel::Contacts::Contact>(args, 1);

                return py::convert(self->obj.TryLinkContactsAsync(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AggregateContactManager_TrySetPreferredSourceForPictureAsync(py::wrapper::Windows::ApplicationModel::Contacts::AggregateContactManager* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.ApplicationModel.Contacts.AggregateContactManager", L"TrySetPreferredSourceForPictureAsync", 2))
            {
                py::set_arg_count_version_error(2);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::ApplicationModel::Contacts::Contact>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::ApplicationModel::Contacts::Contact>(args, 1);

                return py::convert(self->obj.TrySetPreferredSourceForPictureAsync(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AggregateContactManager_UnlinkRawContactAsync(py::wrapper::Windows::ApplicationModel::Contacts::AggregateContactManager* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.ApplicationModel.Contacts.AggregateContactManager", L"UnlinkRawContactAsync", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::ApplicationModel::Contacts::Contact>(args, 0);

                return py::convert(self->obj.UnlinkRawContactAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* _assign_array_AggregateContactManager(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::ApplicationModel::Contacts::AggregateContactManager>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_AggregateContactManager(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::Contacts::AggregateContactManager>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_AggregateContactManager[] = {
        { "find_raw_contacts_async", reinterpret_cast<PyCFunction>(AggregateContactManager_FindRawContactsAsync), METH_VARARGS, nullptr },
        { "set_remote_identification_information_async", reinterpret_cast<PyCFunction>(AggregateContactManager_SetRemoteIdentificationInformationAsync), METH_VARARGS, nullptr },
        { "try_link_contacts_async", reinterpret_cast<PyCFunction>(AggregateContactManager_TryLinkContactsAsync), METH_VARARGS, nullptr },
        { "try_set_preferred_source_for_picture_async", reinterpret_cast<PyCFunction>(AggregateContactManager_TrySetPreferredSourceForPictureAsync), METH_VARARGS, nullptr },
        { "unlink_raw_contact_async", reinterpret_cast<PyCFunction>(AggregateContactManager_UnlinkRawContactAsync), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_AggregateContactManager, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_AggregateContactManager), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_AggregateContactManager[] = {
        { }
    };

    static PyType_Slot _type_slots_AggregateContactManager[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_AggregateContactManager) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_AggregateContactManager) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_AggregateContactManager) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_AggregateContactManager) },
        { },
    };

    static PyType_Spec type_spec_AggregateContactManager =
    {
        "_winrt_windows_applicationmodel_contacts.AggregateContactManager",
        sizeof(py::wrapper::Windows::ApplicationModel::Contacts::AggregateContactManager),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_AggregateContactManager
    };

    // ----- Contact class --------------------

    static PyObject* _new_Contact(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 0)
        {
            try
            {
                winrt::Windows::ApplicationModel::Contacts::Contact instance{  };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_Contact(py::wrapper::Windows::ApplicationModel::Contacts::Contact* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* Contact_get_Thumbnail(py::wrapper::Windows::ApplicationModel::Contacts::Contact* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Contacts.Contact", L"Thumbnail"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Thumbnail());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int Contact_put_Thumbnail(py::wrapper::Windows::ApplicationModel::Contacts::Contact* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Contacts.Contact", L"Thumbnail"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Storage::Streams::IRandomAccessStreamReference>(arg);

            self->obj.Thumbnail(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* Contact_get_Name(py::wrapper::Windows::ApplicationModel::Contacts::Contact* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Contacts.Contact", L"Name"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Name());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int Contact_put_Name(py::wrapper::Windows::ApplicationModel::Contacts::Contact* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Contacts.Contact", L"Name"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.Name(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* Contact_get_Fields(py::wrapper::Windows::ApplicationModel::Contacts::Contact* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Contacts.Contact", L"Fields"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Fields());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* Contact_get_Id(py::wrapper::Windows::ApplicationModel::Contacts::Contact* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Contacts.Contact", L"Id"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Id());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int Contact_put_Id(py::wrapper::Windows::ApplicationModel::Contacts::Contact* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Contacts.Contact", L"Id"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.Id(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* Contact_get_Notes(py::wrapper::Windows::ApplicationModel::Contacts::Contact* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Contacts.Contact", L"Notes"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Notes());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int Contact_put_Notes(py::wrapper::Windows::ApplicationModel::Contacts::Contact* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Contacts.Contact", L"Notes"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.Notes(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* Contact_get_ConnectedServiceAccounts(py::wrapper::Windows::ApplicationModel::Contacts::Contact* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Contacts.Contact", L"ConnectedServiceAccounts"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.ConnectedServiceAccounts());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* Contact_get_Emails(py::wrapper::Windows::ApplicationModel::Contacts::Contact* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Contacts.Contact", L"Emails"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Emails());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* Contact_get_Addresses(py::wrapper::Windows::ApplicationModel::Contacts::Contact* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Contacts.Contact", L"Addresses"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Addresses());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* Contact_get_ImportantDates(py::wrapper::Windows::ApplicationModel::Contacts::Contact* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Contacts.Contact", L"ImportantDates"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.ImportantDates());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* Contact_get_JobInfo(py::wrapper::Windows::ApplicationModel::Contacts::Contact* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Contacts.Contact", L"JobInfo"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.JobInfo());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* Contact_get_DataSuppliers(py::wrapper::Windows::ApplicationModel::Contacts::Contact* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Contacts.Contact", L"DataSuppliers"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.DataSuppliers());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* Contact_get_Phones(py::wrapper::Windows::ApplicationModel::Contacts::Contact* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Contacts.Contact", L"Phones"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Phones());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* Contact_get_ProviderProperties(py::wrapper::Windows::ApplicationModel::Contacts::Contact* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Contacts.Contact", L"ProviderProperties"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.ProviderProperties());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* Contact_get_SignificantOthers(py::wrapper::Windows::ApplicationModel::Contacts::Contact* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Contacts.Contact", L"SignificantOthers"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.SignificantOthers());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* Contact_get_Websites(py::wrapper::Windows::ApplicationModel::Contacts::Contact* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Contacts.Contact", L"Websites"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Websites());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* Contact_get_SourceDisplayPicture(py::wrapper::Windows::ApplicationModel::Contacts::Contact* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Contacts.Contact", L"SourceDisplayPicture"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.SourceDisplayPicture());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int Contact_put_SourceDisplayPicture(py::wrapper::Windows::ApplicationModel::Contacts::Contact* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Contacts.Contact", L"SourceDisplayPicture"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Storage::Streams::IRandomAccessStreamReference>(arg);

            self->obj.SourceDisplayPicture(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* Contact_get_TextToneToken(py::wrapper::Windows::ApplicationModel::Contacts::Contact* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Contacts.Contact", L"TextToneToken"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.TextToneToken());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int Contact_put_TextToneToken(py::wrapper::Windows::ApplicationModel::Contacts::Contact* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Contacts.Contact", L"TextToneToken"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.TextToneToken(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* Contact_get_DisplayNameOverride(py::wrapper::Windows::ApplicationModel::Contacts::Contact* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Contacts.Contact", L"DisplayNameOverride"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.DisplayNameOverride());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int Contact_put_DisplayNameOverride(py::wrapper::Windows::ApplicationModel::Contacts::Contact* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Contacts.Contact", L"DisplayNameOverride"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.DisplayNameOverride(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* Contact_get_DisplayPictureUserUpdateTime(py::wrapper::Windows::ApplicationModel::Contacts::Contact* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Contacts.Contact", L"DisplayPictureUserUpdateTime"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.DisplayPictureUserUpdateTime());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int Contact_put_DisplayPictureUserUpdateTime(py::wrapper::Windows::ApplicationModel::Contacts::Contact* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Contacts.Contact", L"DisplayPictureUserUpdateTime"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::DateTime>(arg);

            self->obj.DisplayPictureUserUpdateTime(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* Contact_get_Nickname(py::wrapper::Windows::ApplicationModel::Contacts::Contact* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Contacts.Contact", L"Nickname"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Nickname());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int Contact_put_Nickname(py::wrapper::Windows::ApplicationModel::Contacts::Contact* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Contacts.Contact", L"Nickname"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.Nickname(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* Contact_get_RemoteId(py::wrapper::Windows::ApplicationModel::Contacts::Contact* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Contacts.Contact", L"RemoteId"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.RemoteId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int Contact_put_RemoteId(py::wrapper::Windows::ApplicationModel::Contacts::Contact* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Contacts.Contact", L"RemoteId"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.RemoteId(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* Contact_get_RingToneToken(py::wrapper::Windows::ApplicationModel::Contacts::Contact* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Contacts.Contact", L"RingToneToken"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.RingToneToken());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int Contact_put_RingToneToken(py::wrapper::Windows::ApplicationModel::Contacts::Contact* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Contacts.Contact", L"RingToneToken"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.RingToneToken(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* Contact_get_ContactListId(py::wrapper::Windows::ApplicationModel::Contacts::Contact* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Contacts.Contact", L"ContactListId"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.ContactListId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* Contact_get_LargeDisplayPicture(py::wrapper::Windows::ApplicationModel::Contacts::Contact* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Contacts.Contact", L"LargeDisplayPicture"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.LargeDisplayPicture());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* Contact_get_SmallDisplayPicture(py::wrapper::Windows::ApplicationModel::Contacts::Contact* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Contacts.Contact", L"SmallDisplayPicture"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.SmallDisplayPicture());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* Contact_get_SortName(py::wrapper::Windows::ApplicationModel::Contacts::Contact* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Contacts.Contact", L"SortName"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.SortName());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* Contact_get_AggregateId(py::wrapper::Windows::ApplicationModel::Contacts::Contact* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Contacts.Contact", L"AggregateId"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.AggregateId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* Contact_get_FullName(py::wrapper::Windows::ApplicationModel::Contacts::Contact* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Contacts.Contact", L"FullName"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.FullName());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* Contact_get_IsAggregate(py::wrapper::Windows::ApplicationModel::Contacts::Contact* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Contacts.Contact", L"IsAggregate"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.IsAggregate());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* Contact_get_IsDisplayPictureManuallySet(py::wrapper::Windows::ApplicationModel::Contacts::Contact* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Contacts.Contact", L"IsDisplayPictureManuallySet"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.IsDisplayPictureManuallySet());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* Contact_get_IsMe(py::wrapper::Windows::ApplicationModel::Contacts::Contact* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Contacts.Contact", L"IsMe"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.IsMe());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* Contact_get_YomiGivenName(py::wrapper::Windows::ApplicationModel::Contacts::Contact* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Contacts.Contact", L"YomiGivenName"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.YomiGivenName());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int Contact_put_YomiGivenName(py::wrapper::Windows::ApplicationModel::Contacts::Contact* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Contacts.Contact", L"YomiGivenName"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.YomiGivenName(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* Contact_get_HonorificNameSuffix(py::wrapper::Windows::ApplicationModel::Contacts::Contact* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Contacts.Contact", L"HonorificNameSuffix"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.HonorificNameSuffix());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int Contact_put_HonorificNameSuffix(py::wrapper::Windows::ApplicationModel::Contacts::Contact* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Contacts.Contact", L"HonorificNameSuffix"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.HonorificNameSuffix(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* Contact_get_YomiFamilyName(py::wrapper::Windows::ApplicationModel::Contacts::Contact* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Contacts.Contact", L"YomiFamilyName"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.YomiFamilyName());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int Contact_put_YomiFamilyName(py::wrapper::Windows::ApplicationModel::Contacts::Contact* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Contacts.Contact", L"YomiFamilyName"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.YomiFamilyName(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* Contact_get_MiddleName(py::wrapper::Windows::ApplicationModel::Contacts::Contact* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Contacts.Contact", L"MiddleName"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.MiddleName());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int Contact_put_MiddleName(py::wrapper::Windows::ApplicationModel::Contacts::Contact* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Contacts.Contact", L"MiddleName"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.MiddleName(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* Contact_get_LastName(py::wrapper::Windows::ApplicationModel::Contacts::Contact* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Contacts.Contact", L"LastName"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.LastName());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int Contact_put_LastName(py::wrapper::Windows::ApplicationModel::Contacts::Contact* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Contacts.Contact", L"LastName"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.LastName(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* Contact_get_HonorificNamePrefix(py::wrapper::Windows::ApplicationModel::Contacts::Contact* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Contacts.Contact", L"HonorificNamePrefix"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.HonorificNamePrefix());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int Contact_put_HonorificNamePrefix(py::wrapper::Windows::ApplicationModel::Contacts::Contact* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Contacts.Contact", L"HonorificNamePrefix"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.HonorificNamePrefix(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* Contact_get_FirstName(py::wrapper::Windows::ApplicationModel::Contacts::Contact* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Contacts.Contact", L"FirstName"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.FirstName());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int Contact_put_FirstName(py::wrapper::Windows::ApplicationModel::Contacts::Contact* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Contacts.Contact", L"FirstName"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.FirstName(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* Contact_get_DisplayName(py::wrapper::Windows::ApplicationModel::Contacts::Contact* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Contacts.Contact", L"DisplayName"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.DisplayName());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* Contact_get_YomiDisplayName(py::wrapper::Windows::ApplicationModel::Contacts::Contact* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Contacts.Contact", L"YomiDisplayName"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.YomiDisplayName());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_Contact(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::ApplicationModel::Contacts::Contact>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_Contact(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::Contacts::Contact>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_Contact[] = {
        { "_assign_array_", _assign_array_Contact, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_Contact), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_Contact[] = {
        { "thumbnail", reinterpret_cast<getter>(Contact_get_Thumbnail), reinterpret_cast<setter>(Contact_put_Thumbnail), nullptr, nullptr },
        { "name", reinterpret_cast<getter>(Contact_get_Name), reinterpret_cast<setter>(Contact_put_Name), nullptr, nullptr },
        { "fields", reinterpret_cast<getter>(Contact_get_Fields), nullptr, nullptr, nullptr },
        { "id", reinterpret_cast<getter>(Contact_get_Id), reinterpret_cast<setter>(Contact_put_Id), nullptr, nullptr },
        { "notes", reinterpret_cast<getter>(Contact_get_Notes), reinterpret_cast<setter>(Contact_put_Notes), nullptr, nullptr },
        { "connected_service_accounts", reinterpret_cast<getter>(Contact_get_ConnectedServiceAccounts), nullptr, nullptr, nullptr },
        { "emails", reinterpret_cast<getter>(Contact_get_Emails), nullptr, nullptr, nullptr },
        { "addresses", reinterpret_cast<getter>(Contact_get_Addresses), nullptr, nullptr, nullptr },
        { "important_dates", reinterpret_cast<getter>(Contact_get_ImportantDates), nullptr, nullptr, nullptr },
        { "job_info", reinterpret_cast<getter>(Contact_get_JobInfo), nullptr, nullptr, nullptr },
        { "data_suppliers", reinterpret_cast<getter>(Contact_get_DataSuppliers), nullptr, nullptr, nullptr },
        { "phones", reinterpret_cast<getter>(Contact_get_Phones), nullptr, nullptr, nullptr },
        { "provider_properties", reinterpret_cast<getter>(Contact_get_ProviderProperties), nullptr, nullptr, nullptr },
        { "significant_others", reinterpret_cast<getter>(Contact_get_SignificantOthers), nullptr, nullptr, nullptr },
        { "websites", reinterpret_cast<getter>(Contact_get_Websites), nullptr, nullptr, nullptr },
        { "source_display_picture", reinterpret_cast<getter>(Contact_get_SourceDisplayPicture), reinterpret_cast<setter>(Contact_put_SourceDisplayPicture), nullptr, nullptr },
        { "text_tone_token", reinterpret_cast<getter>(Contact_get_TextToneToken), reinterpret_cast<setter>(Contact_put_TextToneToken), nullptr, nullptr },
        { "display_name_override", reinterpret_cast<getter>(Contact_get_DisplayNameOverride), reinterpret_cast<setter>(Contact_put_DisplayNameOverride), nullptr, nullptr },
        { "display_picture_user_update_time", reinterpret_cast<getter>(Contact_get_DisplayPictureUserUpdateTime), reinterpret_cast<setter>(Contact_put_DisplayPictureUserUpdateTime), nullptr, nullptr },
        { "nickname", reinterpret_cast<getter>(Contact_get_Nickname), reinterpret_cast<setter>(Contact_put_Nickname), nullptr, nullptr },
        { "remote_id", reinterpret_cast<getter>(Contact_get_RemoteId), reinterpret_cast<setter>(Contact_put_RemoteId), nullptr, nullptr },
        { "ring_tone_token", reinterpret_cast<getter>(Contact_get_RingToneToken), reinterpret_cast<setter>(Contact_put_RingToneToken), nullptr, nullptr },
        { "contact_list_id", reinterpret_cast<getter>(Contact_get_ContactListId), nullptr, nullptr, nullptr },
        { "large_display_picture", reinterpret_cast<getter>(Contact_get_LargeDisplayPicture), nullptr, nullptr, nullptr },
        { "small_display_picture", reinterpret_cast<getter>(Contact_get_SmallDisplayPicture), nullptr, nullptr, nullptr },
        { "sort_name", reinterpret_cast<getter>(Contact_get_SortName), nullptr, nullptr, nullptr },
        { "aggregate_id", reinterpret_cast<getter>(Contact_get_AggregateId), nullptr, nullptr, nullptr },
        { "full_name", reinterpret_cast<getter>(Contact_get_FullName), nullptr, nullptr, nullptr },
        { "is_aggregate", reinterpret_cast<getter>(Contact_get_IsAggregate), nullptr, nullptr, nullptr },
        { "is_display_picture_manually_set", reinterpret_cast<getter>(Contact_get_IsDisplayPictureManuallySet), nullptr, nullptr, nullptr },
        { "is_me", reinterpret_cast<getter>(Contact_get_IsMe), nullptr, nullptr, nullptr },
        { "yomi_given_name", reinterpret_cast<getter>(Contact_get_YomiGivenName), reinterpret_cast<setter>(Contact_put_YomiGivenName), nullptr, nullptr },
        { "honorific_name_suffix", reinterpret_cast<getter>(Contact_get_HonorificNameSuffix), reinterpret_cast<setter>(Contact_put_HonorificNameSuffix), nullptr, nullptr },
        { "yomi_family_name", reinterpret_cast<getter>(Contact_get_YomiFamilyName), reinterpret_cast<setter>(Contact_put_YomiFamilyName), nullptr, nullptr },
        { "middle_name", reinterpret_cast<getter>(Contact_get_MiddleName), reinterpret_cast<setter>(Contact_put_MiddleName), nullptr, nullptr },
        { "last_name", reinterpret_cast<getter>(Contact_get_LastName), reinterpret_cast<setter>(Contact_put_LastName), nullptr, nullptr },
        { "honorific_name_prefix", reinterpret_cast<getter>(Contact_get_HonorificNamePrefix), reinterpret_cast<setter>(Contact_put_HonorificNamePrefix), nullptr, nullptr },
        { "first_name", reinterpret_cast<getter>(Contact_get_FirstName), reinterpret_cast<setter>(Contact_put_FirstName), nullptr, nullptr },
        { "display_name", reinterpret_cast<getter>(Contact_get_DisplayName), nullptr, nullptr, nullptr },
        { "yomi_display_name", reinterpret_cast<getter>(Contact_get_YomiDisplayName), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_Contact[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_Contact) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_Contact) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_Contact) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_Contact) },
        { },
    };

    static PyType_Spec type_spec_Contact =
    {
        "_winrt_windows_applicationmodel_contacts.Contact",
        sizeof(py::wrapper::Windows::ApplicationModel::Contacts::Contact),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_Contact
    };

    // ----- ContactAddress class --------------------

    static PyObject* _new_ContactAddress(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 0)
        {
            try
            {
                winrt::Windows::ApplicationModel::Contacts::ContactAddress instance{  };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_ContactAddress(py::wrapper::Windows::ApplicationModel::Contacts::ContactAddress* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* ContactAddress_get_StreetAddress(py::wrapper::Windows::ApplicationModel::Contacts::ContactAddress* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Contacts.ContactAddress", L"StreetAddress"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.StreetAddress());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ContactAddress_put_StreetAddress(py::wrapper::Windows::ApplicationModel::Contacts::ContactAddress* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Contacts.ContactAddress", L"StreetAddress"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.StreetAddress(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ContactAddress_get_Region(py::wrapper::Windows::ApplicationModel::Contacts::ContactAddress* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Contacts.ContactAddress", L"Region"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Region());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ContactAddress_put_Region(py::wrapper::Windows::ApplicationModel::Contacts::ContactAddress* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Contacts.ContactAddress", L"Region"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.Region(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ContactAddress_get_PostalCode(py::wrapper::Windows::ApplicationModel::Contacts::ContactAddress* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Contacts.ContactAddress", L"PostalCode"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.PostalCode());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ContactAddress_put_PostalCode(py::wrapper::Windows::ApplicationModel::Contacts::ContactAddress* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Contacts.ContactAddress", L"PostalCode"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.PostalCode(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ContactAddress_get_Locality(py::wrapper::Windows::ApplicationModel::Contacts::ContactAddress* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Contacts.ContactAddress", L"Locality"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Locality());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ContactAddress_put_Locality(py::wrapper::Windows::ApplicationModel::Contacts::ContactAddress* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Contacts.ContactAddress", L"Locality"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.Locality(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ContactAddress_get_Kind(py::wrapper::Windows::ApplicationModel::Contacts::ContactAddress* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Contacts.ContactAddress", L"Kind"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Kind());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ContactAddress_put_Kind(py::wrapper::Windows::ApplicationModel::Contacts::ContactAddress* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Contacts.ContactAddress", L"Kind"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::ApplicationModel::Contacts::ContactAddressKind>(arg);

            self->obj.Kind(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ContactAddress_get_Description(py::wrapper::Windows::ApplicationModel::Contacts::ContactAddress* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Contacts.ContactAddress", L"Description"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Description());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ContactAddress_put_Description(py::wrapper::Windows::ApplicationModel::Contacts::ContactAddress* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Contacts.ContactAddress", L"Description"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.Description(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ContactAddress_get_Country(py::wrapper::Windows::ApplicationModel::Contacts::ContactAddress* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Contacts.ContactAddress", L"Country"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Country());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ContactAddress_put_Country(py::wrapper::Windows::ApplicationModel::Contacts::ContactAddress* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Contacts.ContactAddress", L"Country"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.Country(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* _assign_array_ContactAddress(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::ApplicationModel::Contacts::ContactAddress>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_ContactAddress(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::Contacts::ContactAddress>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_ContactAddress[] = {
        { "_assign_array_", _assign_array_ContactAddress, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_ContactAddress), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_ContactAddress[] = {
        { "street_address", reinterpret_cast<getter>(ContactAddress_get_StreetAddress), reinterpret_cast<setter>(ContactAddress_put_StreetAddress), nullptr, nullptr },
        { "region", reinterpret_cast<getter>(ContactAddress_get_Region), reinterpret_cast<setter>(ContactAddress_put_Region), nullptr, nullptr },
        { "postal_code", reinterpret_cast<getter>(ContactAddress_get_PostalCode), reinterpret_cast<setter>(ContactAddress_put_PostalCode), nullptr, nullptr },
        { "locality", reinterpret_cast<getter>(ContactAddress_get_Locality), reinterpret_cast<setter>(ContactAddress_put_Locality), nullptr, nullptr },
        { "kind", reinterpret_cast<getter>(ContactAddress_get_Kind), reinterpret_cast<setter>(ContactAddress_put_Kind), nullptr, nullptr },
        { "description", reinterpret_cast<getter>(ContactAddress_get_Description), reinterpret_cast<setter>(ContactAddress_put_Description), nullptr, nullptr },
        { "country", reinterpret_cast<getter>(ContactAddress_get_Country), reinterpret_cast<setter>(ContactAddress_put_Country), nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_ContactAddress[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_ContactAddress) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_ContactAddress) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_ContactAddress) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_ContactAddress) },
        { },
    };

    static PyType_Spec type_spec_ContactAddress =
    {
        "_winrt_windows_applicationmodel_contacts.ContactAddress",
        sizeof(py::wrapper::Windows::ApplicationModel::Contacts::ContactAddress),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_ContactAddress
    };

    // ----- ContactAnnotation class --------------------

    static PyObject* _new_ContactAnnotation(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 0)
        {
            try
            {
                winrt::Windows::ApplicationModel::Contacts::ContactAnnotation instance{  };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_ContactAnnotation(py::wrapper::Windows::ApplicationModel::Contacts::ContactAnnotation* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* ContactAnnotation_get_SupportedOperations(py::wrapper::Windows::ApplicationModel::Contacts::ContactAnnotation* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Contacts.ContactAnnotation", L"SupportedOperations"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.SupportedOperations());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ContactAnnotation_put_SupportedOperations(py::wrapper::Windows::ApplicationModel::Contacts::ContactAnnotation* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Contacts.ContactAnnotation", L"SupportedOperations"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::ApplicationModel::Contacts::ContactAnnotationOperations>(arg);

            self->obj.SupportedOperations(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ContactAnnotation_get_RemoteId(py::wrapper::Windows::ApplicationModel::Contacts::ContactAnnotation* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Contacts.ContactAnnotation", L"RemoteId"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.RemoteId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ContactAnnotation_put_RemoteId(py::wrapper::Windows::ApplicationModel::Contacts::ContactAnnotation* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Contacts.ContactAnnotation", L"RemoteId"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.RemoteId(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ContactAnnotation_get_ContactId(py::wrapper::Windows::ApplicationModel::Contacts::ContactAnnotation* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Contacts.ContactAnnotation", L"ContactId"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.ContactId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ContactAnnotation_put_ContactId(py::wrapper::Windows::ApplicationModel::Contacts::ContactAnnotation* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Contacts.ContactAnnotation", L"ContactId"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.ContactId(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ContactAnnotation_get_AnnotationListId(py::wrapper::Windows::ApplicationModel::Contacts::ContactAnnotation* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Contacts.ContactAnnotation", L"AnnotationListId"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.AnnotationListId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ContactAnnotation_get_Id(py::wrapper::Windows::ApplicationModel::Contacts::ContactAnnotation* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Contacts.ContactAnnotation", L"Id"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Id());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ContactAnnotation_get_IsDisabled(py::wrapper::Windows::ApplicationModel::Contacts::ContactAnnotation* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Contacts.ContactAnnotation", L"IsDisabled"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.IsDisabled());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ContactAnnotation_get_ProviderProperties(py::wrapper::Windows::ApplicationModel::Contacts::ContactAnnotation* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Contacts.ContactAnnotation", L"ProviderProperties"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.ProviderProperties());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ContactAnnotation_get_ContactListId(py::wrapper::Windows::ApplicationModel::Contacts::ContactAnnotation* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Contacts.ContactAnnotation", L"ContactListId"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.ContactListId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ContactAnnotation_put_ContactListId(py::wrapper::Windows::ApplicationModel::Contacts::ContactAnnotation* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Contacts.ContactAnnotation", L"ContactListId"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.ContactListId(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* _assign_array_ContactAnnotation(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::ApplicationModel::Contacts::ContactAnnotation>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_ContactAnnotation(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::Contacts::ContactAnnotation>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_ContactAnnotation[] = {
        { "_assign_array_", _assign_array_ContactAnnotation, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_ContactAnnotation), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_ContactAnnotation[] = {
        { "supported_operations", reinterpret_cast<getter>(ContactAnnotation_get_SupportedOperations), reinterpret_cast<setter>(ContactAnnotation_put_SupportedOperations), nullptr, nullptr },
        { "remote_id", reinterpret_cast<getter>(ContactAnnotation_get_RemoteId), reinterpret_cast<setter>(ContactAnnotation_put_RemoteId), nullptr, nullptr },
        { "contact_id", reinterpret_cast<getter>(ContactAnnotation_get_ContactId), reinterpret_cast<setter>(ContactAnnotation_put_ContactId), nullptr, nullptr },
        { "annotation_list_id", reinterpret_cast<getter>(ContactAnnotation_get_AnnotationListId), nullptr, nullptr, nullptr },
        { "id", reinterpret_cast<getter>(ContactAnnotation_get_Id), nullptr, nullptr, nullptr },
        { "is_disabled", reinterpret_cast<getter>(ContactAnnotation_get_IsDisabled), nullptr, nullptr, nullptr },
        { "provider_properties", reinterpret_cast<getter>(ContactAnnotation_get_ProviderProperties), nullptr, nullptr, nullptr },
        { "contact_list_id", reinterpret_cast<getter>(ContactAnnotation_get_ContactListId), reinterpret_cast<setter>(ContactAnnotation_put_ContactListId), nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_ContactAnnotation[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_ContactAnnotation) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_ContactAnnotation) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_ContactAnnotation) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_ContactAnnotation) },
        { },
    };

    static PyType_Spec type_spec_ContactAnnotation =
    {
        "_winrt_windows_applicationmodel_contacts.ContactAnnotation",
        sizeof(py::wrapper::Windows::ApplicationModel::Contacts::ContactAnnotation),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_ContactAnnotation
    };

    // ----- ContactAnnotationList class --------------------

    static PyObject* _new_ContactAnnotationList(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::ApplicationModel::Contacts::ContactAnnotationList>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::ApplicationModel::Contacts::ContactAnnotationList>::type_name);
        return nullptr;
    }

    static void _dealloc_ContactAnnotationList(py::wrapper::Windows::ApplicationModel::Contacts::ContactAnnotationList* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* ContactAnnotationList_DeleteAnnotationAsync(py::wrapper::Windows::ApplicationModel::Contacts::ContactAnnotationList* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.ApplicationModel.Contacts.ContactAnnotationList", L"DeleteAnnotationAsync", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::ApplicationModel::Contacts::ContactAnnotation>(args, 0);

                return py::convert(self->obj.DeleteAnnotationAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ContactAnnotationList_DeleteAsync(py::wrapper::Windows::ApplicationModel::Contacts::ContactAnnotationList* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.ApplicationModel.Contacts.ContactAnnotationList", L"DeleteAsync", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(self->obj.DeleteAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ContactAnnotationList_FindAnnotationsAsync(py::wrapper::Windows::ApplicationModel::Contacts::ContactAnnotationList* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.ApplicationModel.Contacts.ContactAnnotationList", L"FindAnnotationsAsync", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(self->obj.FindAnnotationsAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ContactAnnotationList_FindAnnotationsByRemoteIdAsync(py::wrapper::Windows::ApplicationModel::Contacts::ContactAnnotationList* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.ApplicationModel.Contacts.ContactAnnotationList", L"FindAnnotationsByRemoteIdAsync", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                return py::convert(self->obj.FindAnnotationsByRemoteIdAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ContactAnnotationList_GetAnnotationAsync(py::wrapper::Windows::ApplicationModel::Contacts::ContactAnnotationList* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.ApplicationModel.Contacts.ContactAnnotationList", L"GetAnnotationAsync", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                return py::convert(self->obj.GetAnnotationAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ContactAnnotationList_TrySaveAnnotationAsync(py::wrapper::Windows::ApplicationModel::Contacts::ContactAnnotationList* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.ApplicationModel.Contacts.ContactAnnotationList", L"TrySaveAnnotationAsync", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::ApplicationModel::Contacts::ContactAnnotation>(args, 0);

                return py::convert(self->obj.TrySaveAnnotationAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ContactAnnotationList_get_Id(py::wrapper::Windows::ApplicationModel::Contacts::ContactAnnotationList* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Contacts.ContactAnnotationList", L"Id"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Id());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ContactAnnotationList_get_ProviderPackageFamilyName(py::wrapper::Windows::ApplicationModel::Contacts::ContactAnnotationList* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Contacts.ContactAnnotationList", L"ProviderPackageFamilyName"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.ProviderPackageFamilyName());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ContactAnnotationList_get_UserDataAccountId(py::wrapper::Windows::ApplicationModel::Contacts::ContactAnnotationList* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Contacts.ContactAnnotationList", L"UserDataAccountId"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.UserDataAccountId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_ContactAnnotationList(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::ApplicationModel::Contacts::ContactAnnotationList>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_ContactAnnotationList(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::Contacts::ContactAnnotationList>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_ContactAnnotationList[] = {
        { "delete_annotation_async", reinterpret_cast<PyCFunction>(ContactAnnotationList_DeleteAnnotationAsync), METH_VARARGS, nullptr },
        { "delete_async", reinterpret_cast<PyCFunction>(ContactAnnotationList_DeleteAsync), METH_VARARGS, nullptr },
        { "find_annotations_async", reinterpret_cast<PyCFunction>(ContactAnnotationList_FindAnnotationsAsync), METH_VARARGS, nullptr },
        { "find_annotations_by_remote_id_async", reinterpret_cast<PyCFunction>(ContactAnnotationList_FindAnnotationsByRemoteIdAsync), METH_VARARGS, nullptr },
        { "get_annotation_async", reinterpret_cast<PyCFunction>(ContactAnnotationList_GetAnnotationAsync), METH_VARARGS, nullptr },
        { "try_save_annotation_async", reinterpret_cast<PyCFunction>(ContactAnnotationList_TrySaveAnnotationAsync), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_ContactAnnotationList, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_ContactAnnotationList), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_ContactAnnotationList[] = {
        { "id", reinterpret_cast<getter>(ContactAnnotationList_get_Id), nullptr, nullptr, nullptr },
        { "provider_package_family_name", reinterpret_cast<getter>(ContactAnnotationList_get_ProviderPackageFamilyName), nullptr, nullptr, nullptr },
        { "user_data_account_id", reinterpret_cast<getter>(ContactAnnotationList_get_UserDataAccountId), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_ContactAnnotationList[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_ContactAnnotationList) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_ContactAnnotationList) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_ContactAnnotationList) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_ContactAnnotationList) },
        { },
    };

    static PyType_Spec type_spec_ContactAnnotationList =
    {
        "_winrt_windows_applicationmodel_contacts.ContactAnnotationList",
        sizeof(py::wrapper::Windows::ApplicationModel::Contacts::ContactAnnotationList),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_ContactAnnotationList
    };

    // ----- ContactAnnotationStore class --------------------

    static PyObject* _new_ContactAnnotationStore(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::ApplicationModel::Contacts::ContactAnnotationStore>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::ApplicationModel::Contacts::ContactAnnotationStore>::type_name);
        return nullptr;
    }

    static void _dealloc_ContactAnnotationStore(py::wrapper::Windows::ApplicationModel::Contacts::ContactAnnotationStore* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* ContactAnnotationStore_CreateAnnotationListAsync(py::wrapper::Windows::ApplicationModel::Contacts::ContactAnnotationStore* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.ApplicationModel.Contacts.ContactAnnotationStore", L"CreateAnnotationListAsync", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(self->obj.CreateAnnotationListAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.ApplicationModel.Contacts.ContactAnnotationStore", L"CreateAnnotationListAsync", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                return py::convert(self->obj.CreateAnnotationListAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ContactAnnotationStore_DisableAnnotationAsync(py::wrapper::Windows::ApplicationModel::Contacts::ContactAnnotationStore* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.ApplicationModel.Contacts.ContactAnnotationStore", L"DisableAnnotationAsync", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::ApplicationModel::Contacts::ContactAnnotation>(args, 0);

                return py::convert(self->obj.DisableAnnotationAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ContactAnnotationStore_FindAnnotationListsAsync(py::wrapper::Windows::ApplicationModel::Contacts::ContactAnnotationStore* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.ApplicationModel.Contacts.ContactAnnotationStore", L"FindAnnotationListsAsync", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(self->obj.FindAnnotationListsAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ContactAnnotationStore_FindAnnotationsForContactAsync(py::wrapper::Windows::ApplicationModel::Contacts::ContactAnnotationStore* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.ApplicationModel.Contacts.ContactAnnotationStore", L"FindAnnotationsForContactAsync", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::ApplicationModel::Contacts::Contact>(args, 0);

                return py::convert(self->obj.FindAnnotationsForContactAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ContactAnnotationStore_FindAnnotationsForContactListAsync(py::wrapper::Windows::ApplicationModel::Contacts::ContactAnnotationStore* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.ApplicationModel.Contacts.ContactAnnotationStore", L"FindAnnotationsForContactListAsync", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                return py::convert(self->obj.FindAnnotationsForContactListAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ContactAnnotationStore_FindContactIdsByEmailAsync(py::wrapper::Windows::ApplicationModel::Contacts::ContactAnnotationStore* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.ApplicationModel.Contacts.ContactAnnotationStore", L"FindContactIdsByEmailAsync", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                return py::convert(self->obj.FindContactIdsByEmailAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ContactAnnotationStore_FindContactIdsByPhoneNumberAsync(py::wrapper::Windows::ApplicationModel::Contacts::ContactAnnotationStore* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.ApplicationModel.Contacts.ContactAnnotationStore", L"FindContactIdsByPhoneNumberAsync", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                return py::convert(self->obj.FindContactIdsByPhoneNumberAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ContactAnnotationStore_GetAnnotationListAsync(py::wrapper::Windows::ApplicationModel::Contacts::ContactAnnotationStore* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.ApplicationModel.Contacts.ContactAnnotationStore", L"GetAnnotationListAsync", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                return py::convert(self->obj.GetAnnotationListAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* _assign_array_ContactAnnotationStore(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::ApplicationModel::Contacts::ContactAnnotationStore>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_ContactAnnotationStore(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::Contacts::ContactAnnotationStore>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_ContactAnnotationStore[] = {
        { "create_annotation_list_async", reinterpret_cast<PyCFunction>(ContactAnnotationStore_CreateAnnotationListAsync), METH_VARARGS, nullptr },
        { "disable_annotation_async", reinterpret_cast<PyCFunction>(ContactAnnotationStore_DisableAnnotationAsync), METH_VARARGS, nullptr },
        { "find_annotation_lists_async", reinterpret_cast<PyCFunction>(ContactAnnotationStore_FindAnnotationListsAsync), METH_VARARGS, nullptr },
        { "find_annotations_for_contact_async", reinterpret_cast<PyCFunction>(ContactAnnotationStore_FindAnnotationsForContactAsync), METH_VARARGS, nullptr },
        { "find_annotations_for_contact_list_async", reinterpret_cast<PyCFunction>(ContactAnnotationStore_FindAnnotationsForContactListAsync), METH_VARARGS, nullptr },
        { "find_contact_ids_by_email_async", reinterpret_cast<PyCFunction>(ContactAnnotationStore_FindContactIdsByEmailAsync), METH_VARARGS, nullptr },
        { "find_contact_ids_by_phone_number_async", reinterpret_cast<PyCFunction>(ContactAnnotationStore_FindContactIdsByPhoneNumberAsync), METH_VARARGS, nullptr },
        { "get_annotation_list_async", reinterpret_cast<PyCFunction>(ContactAnnotationStore_GetAnnotationListAsync), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_ContactAnnotationStore, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_ContactAnnotationStore), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_ContactAnnotationStore[] = {
        { }
    };

    static PyType_Slot _type_slots_ContactAnnotationStore[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_ContactAnnotationStore) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_ContactAnnotationStore) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_ContactAnnotationStore) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_ContactAnnotationStore) },
        { },
    };

    static PyType_Spec type_spec_ContactAnnotationStore =
    {
        "_winrt_windows_applicationmodel_contacts.ContactAnnotationStore",
        sizeof(py::wrapper::Windows::ApplicationModel::Contacts::ContactAnnotationStore),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_ContactAnnotationStore
    };

    // ----- ContactBatch class --------------------

    static PyObject* _new_ContactBatch(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::ApplicationModel::Contacts::ContactBatch>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::ApplicationModel::Contacts::ContactBatch>::type_name);
        return nullptr;
    }

    static void _dealloc_ContactBatch(py::wrapper::Windows::ApplicationModel::Contacts::ContactBatch* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* ContactBatch_get_Contacts(py::wrapper::Windows::ApplicationModel::Contacts::ContactBatch* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Contacts.ContactBatch", L"Contacts"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Contacts());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ContactBatch_get_Status(py::wrapper::Windows::ApplicationModel::Contacts::ContactBatch* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Contacts.ContactBatch", L"Status"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Status());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_ContactBatch(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::ApplicationModel::Contacts::ContactBatch>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_ContactBatch(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::Contacts::ContactBatch>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_ContactBatch[] = {
        { "_assign_array_", _assign_array_ContactBatch, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_ContactBatch), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_ContactBatch[] = {
        { "contacts", reinterpret_cast<getter>(ContactBatch_get_Contacts), nullptr, nullptr, nullptr },
        { "status", reinterpret_cast<getter>(ContactBatch_get_Status), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_ContactBatch[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_ContactBatch) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_ContactBatch) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_ContactBatch) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_ContactBatch) },
        { },
    };

    static PyType_Spec type_spec_ContactBatch =
    {
        "_winrt_windows_applicationmodel_contacts.ContactBatch",
        sizeof(py::wrapper::Windows::ApplicationModel::Contacts::ContactBatch),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_ContactBatch
    };

    // ----- ContactCardDelayedDataLoader class --------------------

    static PyObject* _new_ContactCardDelayedDataLoader(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::ApplicationModel::Contacts::ContactCardDelayedDataLoader>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::ApplicationModel::Contacts::ContactCardDelayedDataLoader>::type_name);
        return nullptr;
    }

    static void _dealloc_ContactCardDelayedDataLoader(py::wrapper::Windows::ApplicationModel::Contacts::ContactCardDelayedDataLoader* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* ContactCardDelayedDataLoader_Close(py::wrapper::Windows::ApplicationModel::Contacts::ContactCardDelayedDataLoader* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.ApplicationModel.Contacts.ContactCardDelayedDataLoader", L"Close", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                self->obj.Close();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ContactCardDelayedDataLoader_SetData(py::wrapper::Windows::ApplicationModel::Contacts::ContactCardDelayedDataLoader* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.ApplicationModel.Contacts.ContactCardDelayedDataLoader", L"SetData", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::ApplicationModel::Contacts::Contact>(args, 0);

                self->obj.SetData(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* _assign_array_ContactCardDelayedDataLoader(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::ApplicationModel::Contacts::ContactCardDelayedDataLoader>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_ContactCardDelayedDataLoader(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::Contacts::ContactCardDelayedDataLoader>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _enter_ContactCardDelayedDataLoader(py::wrapper::Windows::ApplicationModel::Contacts::ContactCardDelayedDataLoader* self, PyObject* /*unused*/) noexcept
    {
        return Py_NewRef(self);
    }

    static PyObject* _exit_ContactCardDelayedDataLoader(py::wrapper::Windows::ApplicationModel::Contacts::ContactCardDelayedDataLoader* self, PyObject* /*unused*/) noexcept
    {
        try
        {
            self->obj.Close();
            Py_RETURN_FALSE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_ContactCardDelayedDataLoader[] = {
        { "close", reinterpret_cast<PyCFunction>(ContactCardDelayedDataLoader_Close), METH_VARARGS, nullptr },
        { "set_data", reinterpret_cast<PyCFunction>(ContactCardDelayedDataLoader_SetData), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_ContactCardDelayedDataLoader, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_ContactCardDelayedDataLoader), METH_O | METH_STATIC, nullptr },
        { "__enter__", reinterpret_cast<PyCFunction>(_enter_ContactCardDelayedDataLoader), METH_NOARGS, nullptr },
        { "__exit__",  reinterpret_cast<PyCFunction>(_exit_ContactCardDelayedDataLoader), METH_VARARGS, nullptr },
        { }
    };

    static PyGetSetDef _getset_ContactCardDelayedDataLoader[] = {
        { }
    };

    static PyType_Slot _type_slots_ContactCardDelayedDataLoader[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_ContactCardDelayedDataLoader) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_ContactCardDelayedDataLoader) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_ContactCardDelayedDataLoader) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_ContactCardDelayedDataLoader) },
        { },
    };

    static PyType_Spec type_spec_ContactCardDelayedDataLoader =
    {
        "_winrt_windows_applicationmodel_contacts.ContactCardDelayedDataLoader",
        sizeof(py::wrapper::Windows::ApplicationModel::Contacts::ContactCardDelayedDataLoader),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_ContactCardDelayedDataLoader
    };

    // ----- ContactCardOptions class --------------------

    static PyObject* _new_ContactCardOptions(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 0)
        {
            try
            {
                winrt::Windows::ApplicationModel::Contacts::ContactCardOptions instance{  };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_ContactCardOptions(py::wrapper::Windows::ApplicationModel::Contacts::ContactCardOptions* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* ContactCardOptions_get_InitialTabKind(py::wrapper::Windows::ApplicationModel::Contacts::ContactCardOptions* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Contacts.ContactCardOptions", L"InitialTabKind"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.InitialTabKind());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ContactCardOptions_put_InitialTabKind(py::wrapper::Windows::ApplicationModel::Contacts::ContactCardOptions* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Contacts.ContactCardOptions", L"InitialTabKind"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::ApplicationModel::Contacts::ContactCardTabKind>(arg);

            self->obj.InitialTabKind(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ContactCardOptions_get_HeaderKind(py::wrapper::Windows::ApplicationModel::Contacts::ContactCardOptions* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Contacts.ContactCardOptions", L"HeaderKind"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.HeaderKind());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ContactCardOptions_put_HeaderKind(py::wrapper::Windows::ApplicationModel::Contacts::ContactCardOptions* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Contacts.ContactCardOptions", L"HeaderKind"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::ApplicationModel::Contacts::ContactCardHeaderKind>(arg);

            self->obj.HeaderKind(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ContactCardOptions_get_ServerSearchContactListIds(py::wrapper::Windows::ApplicationModel::Contacts::ContactCardOptions* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Contacts.ContactCardOptions", L"ServerSearchContactListIds"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.ServerSearchContactListIds());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_ContactCardOptions(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::ApplicationModel::Contacts::ContactCardOptions>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_ContactCardOptions(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::Contacts::ContactCardOptions>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_ContactCardOptions[] = {
        { "_assign_array_", _assign_array_ContactCardOptions, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_ContactCardOptions), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_ContactCardOptions[] = {
        { "initial_tab_kind", reinterpret_cast<getter>(ContactCardOptions_get_InitialTabKind), reinterpret_cast<setter>(ContactCardOptions_put_InitialTabKind), nullptr, nullptr },
        { "header_kind", reinterpret_cast<getter>(ContactCardOptions_get_HeaderKind), reinterpret_cast<setter>(ContactCardOptions_put_HeaderKind), nullptr, nullptr },
        { "server_search_contact_list_ids", reinterpret_cast<getter>(ContactCardOptions_get_ServerSearchContactListIds), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_ContactCardOptions[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_ContactCardOptions) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_ContactCardOptions) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_ContactCardOptions) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_ContactCardOptions) },
        { },
    };

    static PyType_Spec type_spec_ContactCardOptions =
    {
        "_winrt_windows_applicationmodel_contacts.ContactCardOptions",
        sizeof(py::wrapper::Windows::ApplicationModel::Contacts::ContactCardOptions),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_ContactCardOptions
    };

    // ----- ContactChange class --------------------

    static PyObject* _new_ContactChange(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::ApplicationModel::Contacts::ContactChange>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::ApplicationModel::Contacts::ContactChange>::type_name);
        return nullptr;
    }

    static void _dealloc_ContactChange(py::wrapper::Windows::ApplicationModel::Contacts::ContactChange* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* ContactChange_get_ChangeType(py::wrapper::Windows::ApplicationModel::Contacts::ContactChange* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Contacts.ContactChange", L"ChangeType"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.ChangeType());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ContactChange_get_Contact(py::wrapper::Windows::ApplicationModel::Contacts::ContactChange* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Contacts.ContactChange", L"Contact"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Contact());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_ContactChange(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::ApplicationModel::Contacts::ContactChange>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_ContactChange(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::Contacts::ContactChange>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_ContactChange[] = {
        { "_assign_array_", _assign_array_ContactChange, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_ContactChange), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_ContactChange[] = {
        { "change_type", reinterpret_cast<getter>(ContactChange_get_ChangeType), nullptr, nullptr, nullptr },
        { "contact", reinterpret_cast<getter>(ContactChange_get_Contact), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_ContactChange[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_ContactChange) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_ContactChange) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_ContactChange) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_ContactChange) },
        { },
    };

    static PyType_Spec type_spec_ContactChange =
    {
        "_winrt_windows_applicationmodel_contacts.ContactChange",
        sizeof(py::wrapper::Windows::ApplicationModel::Contacts::ContactChange),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_ContactChange
    };

    // ----- ContactChangeReader class --------------------

    static PyObject* _new_ContactChangeReader(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::ApplicationModel::Contacts::ContactChangeReader>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::ApplicationModel::Contacts::ContactChangeReader>::type_name);
        return nullptr;
    }

    static void _dealloc_ContactChangeReader(py::wrapper::Windows::ApplicationModel::Contacts::ContactChangeReader* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* ContactChangeReader_AcceptChanges(py::wrapper::Windows::ApplicationModel::Contacts::ContactChangeReader* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.ApplicationModel.Contacts.ContactChangeReader", L"AcceptChanges", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                self->obj.AcceptChanges();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ContactChangeReader_AcceptChangesThrough(py::wrapper::Windows::ApplicationModel::Contacts::ContactChangeReader* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.ApplicationModel.Contacts.ContactChangeReader", L"AcceptChangesThrough", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::ApplicationModel::Contacts::ContactChange>(args, 0);

                self->obj.AcceptChangesThrough(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ContactChangeReader_ReadBatchAsync(py::wrapper::Windows::ApplicationModel::Contacts::ContactChangeReader* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.ApplicationModel.Contacts.ContactChangeReader", L"ReadBatchAsync", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(self->obj.ReadBatchAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* _assign_array_ContactChangeReader(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::ApplicationModel::Contacts::ContactChangeReader>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_ContactChangeReader(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::Contacts::ContactChangeReader>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_ContactChangeReader[] = {
        { "accept_changes", reinterpret_cast<PyCFunction>(ContactChangeReader_AcceptChanges), METH_VARARGS, nullptr },
        { "accept_changes_through", reinterpret_cast<PyCFunction>(ContactChangeReader_AcceptChangesThrough), METH_VARARGS, nullptr },
        { "read_batch_async", reinterpret_cast<PyCFunction>(ContactChangeReader_ReadBatchAsync), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_ContactChangeReader, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_ContactChangeReader), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_ContactChangeReader[] = {
        { }
    };

    static PyType_Slot _type_slots_ContactChangeReader[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_ContactChangeReader) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_ContactChangeReader) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_ContactChangeReader) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_ContactChangeReader) },
        { },
    };

    static PyType_Spec type_spec_ContactChangeReader =
    {
        "_winrt_windows_applicationmodel_contacts.ContactChangeReader",
        sizeof(py::wrapper::Windows::ApplicationModel::Contacts::ContactChangeReader),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_ContactChangeReader
    };

    // ----- ContactChangeTracker class --------------------

    static PyObject* _new_ContactChangeTracker(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::ApplicationModel::Contacts::ContactChangeTracker>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::ApplicationModel::Contacts::ContactChangeTracker>::type_name);
        return nullptr;
    }

    static void _dealloc_ContactChangeTracker(py::wrapper::Windows::ApplicationModel::Contacts::ContactChangeTracker* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* ContactChangeTracker_Enable(py::wrapper::Windows::ApplicationModel::Contacts::ContactChangeTracker* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.ApplicationModel.Contacts.ContactChangeTracker", L"Enable", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                self->obj.Enable();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ContactChangeTracker_GetChangeReader(py::wrapper::Windows::ApplicationModel::Contacts::ContactChangeTracker* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.ApplicationModel.Contacts.ContactChangeTracker", L"GetChangeReader", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(self->obj.GetChangeReader());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ContactChangeTracker_Reset(py::wrapper::Windows::ApplicationModel::Contacts::ContactChangeTracker* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.ApplicationModel.Contacts.ContactChangeTracker", L"Reset", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                self->obj.Reset();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ContactChangeTracker_get_IsTracking(py::wrapper::Windows::ApplicationModel::Contacts::ContactChangeTracker* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Contacts.ContactChangeTracker", L"IsTracking"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.IsTracking());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_ContactChangeTracker(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::ApplicationModel::Contacts::ContactChangeTracker>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_ContactChangeTracker(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::Contacts::ContactChangeTracker>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_ContactChangeTracker[] = {
        { "enable", reinterpret_cast<PyCFunction>(ContactChangeTracker_Enable), METH_VARARGS, nullptr },
        { "get_change_reader", reinterpret_cast<PyCFunction>(ContactChangeTracker_GetChangeReader), METH_VARARGS, nullptr },
        { "reset", reinterpret_cast<PyCFunction>(ContactChangeTracker_Reset), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_ContactChangeTracker, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_ContactChangeTracker), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_ContactChangeTracker[] = {
        { "is_tracking", reinterpret_cast<getter>(ContactChangeTracker_get_IsTracking), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_ContactChangeTracker[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_ContactChangeTracker) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_ContactChangeTracker) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_ContactChangeTracker) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_ContactChangeTracker) },
        { },
    };

    static PyType_Spec type_spec_ContactChangeTracker =
    {
        "_winrt_windows_applicationmodel_contacts.ContactChangeTracker",
        sizeof(py::wrapper::Windows::ApplicationModel::Contacts::ContactChangeTracker),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_ContactChangeTracker
    };

    // ----- ContactChangedDeferral class --------------------

    static PyObject* _new_ContactChangedDeferral(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::ApplicationModel::Contacts::ContactChangedDeferral>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::ApplicationModel::Contacts::ContactChangedDeferral>::type_name);
        return nullptr;
    }

    static void _dealloc_ContactChangedDeferral(py::wrapper::Windows::ApplicationModel::Contacts::ContactChangedDeferral* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* ContactChangedDeferral_Complete(py::wrapper::Windows::ApplicationModel::Contacts::ContactChangedDeferral* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.ApplicationModel.Contacts.ContactChangedDeferral", L"Complete", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                self->obj.Complete();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* _assign_array_ContactChangedDeferral(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::ApplicationModel::Contacts::ContactChangedDeferral>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_ContactChangedDeferral(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::Contacts::ContactChangedDeferral>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_ContactChangedDeferral[] = {
        { "complete", reinterpret_cast<PyCFunction>(ContactChangedDeferral_Complete), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_ContactChangedDeferral, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_ContactChangedDeferral), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_ContactChangedDeferral[] = {
        { }
    };

    static PyType_Slot _type_slots_ContactChangedDeferral[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_ContactChangedDeferral) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_ContactChangedDeferral) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_ContactChangedDeferral) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_ContactChangedDeferral) },
        { },
    };

    static PyType_Spec type_spec_ContactChangedDeferral =
    {
        "_winrt_windows_applicationmodel_contacts.ContactChangedDeferral",
        sizeof(py::wrapper::Windows::ApplicationModel::Contacts::ContactChangedDeferral),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_ContactChangedDeferral
    };

    // ----- ContactChangedEventArgs class --------------------

    static PyObject* _new_ContactChangedEventArgs(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::ApplicationModel::Contacts::ContactChangedEventArgs>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::ApplicationModel::Contacts::ContactChangedEventArgs>::type_name);
        return nullptr;
    }

    static void _dealloc_ContactChangedEventArgs(py::wrapper::Windows::ApplicationModel::Contacts::ContactChangedEventArgs* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* ContactChangedEventArgs_GetDeferral(py::wrapper::Windows::ApplicationModel::Contacts::ContactChangedEventArgs* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.ApplicationModel.Contacts.ContactChangedEventArgs", L"GetDeferral", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(self->obj.GetDeferral());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* _assign_array_ContactChangedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::ApplicationModel::Contacts::ContactChangedEventArgs>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_ContactChangedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::Contacts::ContactChangedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_ContactChangedEventArgs[] = {
        { "get_deferral", reinterpret_cast<PyCFunction>(ContactChangedEventArgs_GetDeferral), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_ContactChangedEventArgs, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_ContactChangedEventArgs), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_ContactChangedEventArgs[] = {
        { }
    };

    static PyType_Slot _type_slots_ContactChangedEventArgs[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_ContactChangedEventArgs) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_ContactChangedEventArgs) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_ContactChangedEventArgs) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_ContactChangedEventArgs) },
        { },
    };

    static PyType_Spec type_spec_ContactChangedEventArgs =
    {
        "_winrt_windows_applicationmodel_contacts.ContactChangedEventArgs",
        sizeof(py::wrapper::Windows::ApplicationModel::Contacts::ContactChangedEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_ContactChangedEventArgs
    };

    // ----- ContactConnectedServiceAccount class --------------------

    static PyObject* _new_ContactConnectedServiceAccount(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 0)
        {
            try
            {
                winrt::Windows::ApplicationModel::Contacts::ContactConnectedServiceAccount instance{  };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_ContactConnectedServiceAccount(py::wrapper::Windows::ApplicationModel::Contacts::ContactConnectedServiceAccount* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* ContactConnectedServiceAccount_get_ServiceName(py::wrapper::Windows::ApplicationModel::Contacts::ContactConnectedServiceAccount* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Contacts.ContactConnectedServiceAccount", L"ServiceName"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.ServiceName());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ContactConnectedServiceAccount_put_ServiceName(py::wrapper::Windows::ApplicationModel::Contacts::ContactConnectedServiceAccount* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Contacts.ContactConnectedServiceAccount", L"ServiceName"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.ServiceName(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ContactConnectedServiceAccount_get_Id(py::wrapper::Windows::ApplicationModel::Contacts::ContactConnectedServiceAccount* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Contacts.ContactConnectedServiceAccount", L"Id"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Id());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ContactConnectedServiceAccount_put_Id(py::wrapper::Windows::ApplicationModel::Contacts::ContactConnectedServiceAccount* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Contacts.ContactConnectedServiceAccount", L"Id"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.Id(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* _assign_array_ContactConnectedServiceAccount(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::ApplicationModel::Contacts::ContactConnectedServiceAccount>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_ContactConnectedServiceAccount(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::Contacts::ContactConnectedServiceAccount>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_ContactConnectedServiceAccount[] = {
        { "_assign_array_", _assign_array_ContactConnectedServiceAccount, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_ContactConnectedServiceAccount), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_ContactConnectedServiceAccount[] = {
        { "service_name", reinterpret_cast<getter>(ContactConnectedServiceAccount_get_ServiceName), reinterpret_cast<setter>(ContactConnectedServiceAccount_put_ServiceName), nullptr, nullptr },
        { "id", reinterpret_cast<getter>(ContactConnectedServiceAccount_get_Id), reinterpret_cast<setter>(ContactConnectedServiceAccount_put_Id), nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_ContactConnectedServiceAccount[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_ContactConnectedServiceAccount) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_ContactConnectedServiceAccount) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_ContactConnectedServiceAccount) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_ContactConnectedServiceAccount) },
        { },
    };

    static PyType_Spec type_spec_ContactConnectedServiceAccount =
    {
        "_winrt_windows_applicationmodel_contacts.ContactConnectedServiceAccount",
        sizeof(py::wrapper::Windows::ApplicationModel::Contacts::ContactConnectedServiceAccount),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_ContactConnectedServiceAccount
    };

    // ----- ContactDate class --------------------

    static PyObject* _new_ContactDate(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 0)
        {
            try
            {
                winrt::Windows::ApplicationModel::Contacts::ContactDate instance{  };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_ContactDate(py::wrapper::Windows::ApplicationModel::Contacts::ContactDate* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* ContactDate_get_Year(py::wrapper::Windows::ApplicationModel::Contacts::ContactDate* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Contacts.ContactDate", L"Year"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Year());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ContactDate_put_Year(py::wrapper::Windows::ApplicationModel::Contacts::ContactDate* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Contacts.ContactDate", L"Year"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::IReference<int32_t>>(arg);

            self->obj.Year(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ContactDate_get_Month(py::wrapper::Windows::ApplicationModel::Contacts::ContactDate* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Contacts.ContactDate", L"Month"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Month());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ContactDate_put_Month(py::wrapper::Windows::ApplicationModel::Contacts::ContactDate* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Contacts.ContactDate", L"Month"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::IReference<uint32_t>>(arg);

            self->obj.Month(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ContactDate_get_Kind(py::wrapper::Windows::ApplicationModel::Contacts::ContactDate* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Contacts.ContactDate", L"Kind"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Kind());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ContactDate_put_Kind(py::wrapper::Windows::ApplicationModel::Contacts::ContactDate* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Contacts.ContactDate", L"Kind"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::ApplicationModel::Contacts::ContactDateKind>(arg);

            self->obj.Kind(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ContactDate_get_Description(py::wrapper::Windows::ApplicationModel::Contacts::ContactDate* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Contacts.ContactDate", L"Description"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Description());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ContactDate_put_Description(py::wrapper::Windows::ApplicationModel::Contacts::ContactDate* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Contacts.ContactDate", L"Description"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.Description(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ContactDate_get_Day(py::wrapper::Windows::ApplicationModel::Contacts::ContactDate* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Contacts.ContactDate", L"Day"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Day());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ContactDate_put_Day(py::wrapper::Windows::ApplicationModel::Contacts::ContactDate* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Contacts.ContactDate", L"Day"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::IReference<uint32_t>>(arg);

            self->obj.Day(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* _assign_array_ContactDate(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::ApplicationModel::Contacts::ContactDate>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_ContactDate(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::Contacts::ContactDate>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_ContactDate[] = {
        { "_assign_array_", _assign_array_ContactDate, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_ContactDate), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_ContactDate[] = {
        { "year", reinterpret_cast<getter>(ContactDate_get_Year), reinterpret_cast<setter>(ContactDate_put_Year), nullptr, nullptr },
        { "month", reinterpret_cast<getter>(ContactDate_get_Month), reinterpret_cast<setter>(ContactDate_put_Month), nullptr, nullptr },
        { "kind", reinterpret_cast<getter>(ContactDate_get_Kind), reinterpret_cast<setter>(ContactDate_put_Kind), nullptr, nullptr },
        { "description", reinterpret_cast<getter>(ContactDate_get_Description), reinterpret_cast<setter>(ContactDate_put_Description), nullptr, nullptr },
        { "day", reinterpret_cast<getter>(ContactDate_get_Day), reinterpret_cast<setter>(ContactDate_put_Day), nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_ContactDate[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_ContactDate) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_ContactDate) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_ContactDate) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_ContactDate) },
        { },
    };

    static PyType_Spec type_spec_ContactDate =
    {
        "_winrt_windows_applicationmodel_contacts.ContactDate",
        sizeof(py::wrapper::Windows::ApplicationModel::Contacts::ContactDate),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_ContactDate
    };

    // ----- ContactEmail class --------------------

    static PyObject* _new_ContactEmail(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 0)
        {
            try
            {
                winrt::Windows::ApplicationModel::Contacts::ContactEmail instance{  };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_ContactEmail(py::wrapper::Windows::ApplicationModel::Contacts::ContactEmail* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* ContactEmail_get_Kind(py::wrapper::Windows::ApplicationModel::Contacts::ContactEmail* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Contacts.ContactEmail", L"Kind"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Kind());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ContactEmail_put_Kind(py::wrapper::Windows::ApplicationModel::Contacts::ContactEmail* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Contacts.ContactEmail", L"Kind"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::ApplicationModel::Contacts::ContactEmailKind>(arg);

            self->obj.Kind(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ContactEmail_get_Description(py::wrapper::Windows::ApplicationModel::Contacts::ContactEmail* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Contacts.ContactEmail", L"Description"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Description());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ContactEmail_put_Description(py::wrapper::Windows::ApplicationModel::Contacts::ContactEmail* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Contacts.ContactEmail", L"Description"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.Description(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ContactEmail_get_Address(py::wrapper::Windows::ApplicationModel::Contacts::ContactEmail* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Contacts.ContactEmail", L"Address"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Address());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ContactEmail_put_Address(py::wrapper::Windows::ApplicationModel::Contacts::ContactEmail* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Contacts.ContactEmail", L"Address"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.Address(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* _assign_array_ContactEmail(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::ApplicationModel::Contacts::ContactEmail>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_ContactEmail(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::Contacts::ContactEmail>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_ContactEmail[] = {
        { "_assign_array_", _assign_array_ContactEmail, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_ContactEmail), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_ContactEmail[] = {
        { "kind", reinterpret_cast<getter>(ContactEmail_get_Kind), reinterpret_cast<setter>(ContactEmail_put_Kind), nullptr, nullptr },
        { "description", reinterpret_cast<getter>(ContactEmail_get_Description), reinterpret_cast<setter>(ContactEmail_put_Description), nullptr, nullptr },
        { "address", reinterpret_cast<getter>(ContactEmail_get_Address), reinterpret_cast<setter>(ContactEmail_put_Address), nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_ContactEmail[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_ContactEmail) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_ContactEmail) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_ContactEmail) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_ContactEmail) },
        { },
    };

    static PyType_Spec type_spec_ContactEmail =
    {
        "_winrt_windows_applicationmodel_contacts.ContactEmail",
        sizeof(py::wrapper::Windows::ApplicationModel::Contacts::ContactEmail),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_ContactEmail
    };

    // ----- ContactField class --------------------

    static PyObject* _new_ContactField(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::ApplicationModel::Contacts::ContactFieldType>(args, 1);

                winrt::Windows::ApplicationModel::Contacts::ContactField instance{ param0, param1 };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 3)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::ApplicationModel::Contacts::ContactFieldType>(args, 1);
                auto param2 = py::convert_to<winrt::Windows::ApplicationModel::Contacts::ContactFieldCategory>(args, 2);

                winrt::Windows::ApplicationModel::Contacts::ContactField instance{ param0, param1, param2 };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 4)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::hstring>(args, 1);
                auto param2 = py::convert_to<winrt::Windows::ApplicationModel::Contacts::ContactFieldType>(args, 2);
                auto param3 = py::convert_to<winrt::Windows::ApplicationModel::Contacts::ContactFieldCategory>(args, 3);

                winrt::Windows::ApplicationModel::Contacts::ContactField instance{ param0, param1, param2, param3 };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_ContactField(py::wrapper::Windows::ApplicationModel::Contacts::ContactField* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* ContactField_get_Category(py::wrapper::Windows::ApplicationModel::Contacts::ContactField* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Contacts.ContactField", L"Category"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Category());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ContactField_get_Name(py::wrapper::Windows::ApplicationModel::Contacts::ContactField* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Contacts.ContactField", L"Name"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Name());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ContactField_get_Type(py::wrapper::Windows::ApplicationModel::Contacts::ContactField* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Contacts.ContactField", L"Type"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Type());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ContactField_get_Value(py::wrapper::Windows::ApplicationModel::Contacts::ContactField* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Contacts.ContactField", L"Value"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Value());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_ContactField(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::ApplicationModel::Contacts::ContactField>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_ContactField(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::Contacts::ContactField>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_ContactField[] = {
        { "_assign_array_", _assign_array_ContactField, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_ContactField), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_ContactField[] = {
        { "category", reinterpret_cast<getter>(ContactField_get_Category), nullptr, nullptr, nullptr },
        { "name", reinterpret_cast<getter>(ContactField_get_Name), nullptr, nullptr, nullptr },
        { "type", reinterpret_cast<getter>(ContactField_get_Type), nullptr, nullptr, nullptr },
        { "value", reinterpret_cast<getter>(ContactField_get_Value), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_ContactField[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_ContactField) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_ContactField) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_ContactField) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_ContactField) },
        { },
    };

    static PyType_Spec type_spec_ContactField =
    {
        "_winrt_windows_applicationmodel_contacts.ContactField",
        sizeof(py::wrapper::Windows::ApplicationModel::Contacts::ContactField),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_ContactField
    };

    // ----- ContactFieldFactory class --------------------

    static PyObject* _new_ContactFieldFactory(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 0)
        {
            try
            {
                winrt::Windows::ApplicationModel::Contacts::ContactFieldFactory instance{  };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_ContactFieldFactory(py::wrapper::Windows::ApplicationModel::Contacts::ContactFieldFactory* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* ContactFieldFactory_CreateField(py::wrapper::Windows::ApplicationModel::Contacts::ContactFieldFactory* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.ApplicationModel.Contacts.ContactFieldFactory", L"CreateField", 2))
            {
                py::set_arg_count_version_error(2);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::ApplicationModel::Contacts::ContactFieldType>(args, 1);

                return py::convert(self->obj.CreateField(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 3)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.ApplicationModel.Contacts.ContactFieldFactory", L"CreateField", 3))
            {
                py::set_arg_count_version_error(3);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::ApplicationModel::Contacts::ContactFieldType>(args, 1);
                auto param2 = py::convert_to<winrt::Windows::ApplicationModel::Contacts::ContactFieldCategory>(args, 2);

                return py::convert(self->obj.CreateField(param0, param1, param2));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 4)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.ApplicationModel.Contacts.ContactFieldFactory", L"CreateField", 4))
            {
                py::set_arg_count_version_error(4);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::hstring>(args, 1);
                auto param2 = py::convert_to<winrt::Windows::ApplicationModel::Contacts::ContactFieldType>(args, 2);
                auto param3 = py::convert_to<winrt::Windows::ApplicationModel::Contacts::ContactFieldCategory>(args, 3);

                return py::convert(self->obj.CreateField(param0, param1, param2, param3));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ContactFieldFactory_CreateInstantMessage(py::wrapper::Windows::ApplicationModel::Contacts::ContactFieldFactory* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.ApplicationModel.Contacts.ContactFieldFactory", L"CreateInstantMessage", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                return py::convert(self->obj.CreateInstantMessage(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 2)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.ApplicationModel.Contacts.ContactFieldFactory", L"CreateInstantMessage", 2))
            {
                py::set_arg_count_version_error(2);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::ApplicationModel::Contacts::ContactFieldCategory>(args, 1);

                return py::convert(self->obj.CreateInstantMessage(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 5)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.ApplicationModel.Contacts.ContactFieldFactory", L"CreateInstantMessage", 5))
            {
                py::set_arg_count_version_error(5);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::ApplicationModel::Contacts::ContactFieldCategory>(args, 1);
                auto param2 = py::convert_to<winrt::hstring>(args, 2);
                auto param3 = py::convert_to<winrt::hstring>(args, 3);
                auto param4 = py::convert_to<winrt::Windows::Foundation::Uri>(args, 4);

                return py::convert(self->obj.CreateInstantMessage(param0, param1, param2, param3, param4));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ContactFieldFactory_CreateLocation(py::wrapper::Windows::ApplicationModel::Contacts::ContactFieldFactory* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.ApplicationModel.Contacts.ContactFieldFactory", L"CreateLocation", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                return py::convert(self->obj.CreateLocation(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 2)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.ApplicationModel.Contacts.ContactFieldFactory", L"CreateLocation", 2))
            {
                py::set_arg_count_version_error(2);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::ApplicationModel::Contacts::ContactFieldCategory>(args, 1);

                return py::convert(self->obj.CreateLocation(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 7)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.ApplicationModel.Contacts.ContactFieldFactory", L"CreateLocation", 7))
            {
                py::set_arg_count_version_error(7);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::ApplicationModel::Contacts::ContactFieldCategory>(args, 1);
                auto param2 = py::convert_to<winrt::hstring>(args, 2);
                auto param3 = py::convert_to<winrt::hstring>(args, 3);
                auto param4 = py::convert_to<winrt::hstring>(args, 4);
                auto param5 = py::convert_to<winrt::hstring>(args, 5);
                auto param6 = py::convert_to<winrt::hstring>(args, 6);

                return py::convert(self->obj.CreateLocation(param0, param1, param2, param3, param4, param5, param6));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* _assign_array_ContactFieldFactory(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::ApplicationModel::Contacts::ContactFieldFactory>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_ContactFieldFactory(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::Contacts::ContactFieldFactory>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_ContactFieldFactory[] = {
        { "create_field", reinterpret_cast<PyCFunction>(ContactFieldFactory_CreateField), METH_VARARGS, nullptr },
        { "create_instant_message", reinterpret_cast<PyCFunction>(ContactFieldFactory_CreateInstantMessage), METH_VARARGS, nullptr },
        { "create_location", reinterpret_cast<PyCFunction>(ContactFieldFactory_CreateLocation), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_ContactFieldFactory, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_ContactFieldFactory), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_ContactFieldFactory[] = {
        { }
    };

    static PyType_Slot _type_slots_ContactFieldFactory[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_ContactFieldFactory) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_ContactFieldFactory) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_ContactFieldFactory) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_ContactFieldFactory) },
        { },
    };

    static PyType_Spec type_spec_ContactFieldFactory =
    {
        "_winrt_windows_applicationmodel_contacts.ContactFieldFactory",
        sizeof(py::wrapper::Windows::ApplicationModel::Contacts::ContactFieldFactory),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_ContactFieldFactory
    };

    // ----- ContactGroup class --------------------

    static PyObject* _new_ContactGroup(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::ApplicationModel::Contacts::ContactGroup>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::ApplicationModel::Contacts::ContactGroup>::type_name);
        return nullptr;
    }

    static void _dealloc_ContactGroup(py::wrapper::Windows::ApplicationModel::Contacts::ContactGroup* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* _assign_array_ContactGroup(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::ApplicationModel::Contacts::ContactGroup>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_ContactGroup(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::Contacts::ContactGroup>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_ContactGroup[] = {
        { "_assign_array_", _assign_array_ContactGroup, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_ContactGroup), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_ContactGroup[] = {
        { }
    };

    static PyType_Slot _type_slots_ContactGroup[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_ContactGroup) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_ContactGroup) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_ContactGroup) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_ContactGroup) },
        { },
    };

    static PyType_Spec type_spec_ContactGroup =
    {
        "_winrt_windows_applicationmodel_contacts.ContactGroup",
        sizeof(py::wrapper::Windows::ApplicationModel::Contacts::ContactGroup),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_ContactGroup
    };

    // ----- ContactInformation class --------------------

    static PyObject* _new_ContactInformation(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::ApplicationModel::Contacts::ContactInformation>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::ApplicationModel::Contacts::ContactInformation>::type_name);
        return nullptr;
    }

    static void _dealloc_ContactInformation(py::wrapper::Windows::ApplicationModel::Contacts::ContactInformation* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* ContactInformation_GetThumbnailAsync(py::wrapper::Windows::ApplicationModel::Contacts::ContactInformation* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.ApplicationModel.Contacts.ContactInformation", L"GetThumbnailAsync", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(self->obj.GetThumbnailAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ContactInformation_QueryCustomFields(py::wrapper::Windows::ApplicationModel::Contacts::ContactInformation* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.ApplicationModel.Contacts.ContactInformation", L"QueryCustomFields", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                return py::convert(self->obj.QueryCustomFields(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ContactInformation_get_CustomFields(py::wrapper::Windows::ApplicationModel::Contacts::ContactInformation* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Contacts.ContactInformation", L"CustomFields"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.CustomFields());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ContactInformation_get_Emails(py::wrapper::Windows::ApplicationModel::Contacts::ContactInformation* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Contacts.ContactInformation", L"Emails"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Emails());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ContactInformation_get_InstantMessages(py::wrapper::Windows::ApplicationModel::Contacts::ContactInformation* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Contacts.ContactInformation", L"InstantMessages"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.InstantMessages());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ContactInformation_get_Locations(py::wrapper::Windows::ApplicationModel::Contacts::ContactInformation* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Contacts.ContactInformation", L"Locations"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Locations());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ContactInformation_get_Name(py::wrapper::Windows::ApplicationModel::Contacts::ContactInformation* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Contacts.ContactInformation", L"Name"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Name());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ContactInformation_get_PhoneNumbers(py::wrapper::Windows::ApplicationModel::Contacts::ContactInformation* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Contacts.ContactInformation", L"PhoneNumbers"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.PhoneNumbers());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_ContactInformation(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::ApplicationModel::Contacts::ContactInformation>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_ContactInformation(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::Contacts::ContactInformation>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_ContactInformation[] = {
        { "get_thumbnail_async", reinterpret_cast<PyCFunction>(ContactInformation_GetThumbnailAsync), METH_VARARGS, nullptr },
        { "query_custom_fields", reinterpret_cast<PyCFunction>(ContactInformation_QueryCustomFields), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_ContactInformation, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_ContactInformation), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_ContactInformation[] = {
        { "custom_fields", reinterpret_cast<getter>(ContactInformation_get_CustomFields), nullptr, nullptr, nullptr },
        { "emails", reinterpret_cast<getter>(ContactInformation_get_Emails), nullptr, nullptr, nullptr },
        { "instant_messages", reinterpret_cast<getter>(ContactInformation_get_InstantMessages), nullptr, nullptr, nullptr },
        { "locations", reinterpret_cast<getter>(ContactInformation_get_Locations), nullptr, nullptr, nullptr },
        { "name", reinterpret_cast<getter>(ContactInformation_get_Name), nullptr, nullptr, nullptr },
        { "phone_numbers", reinterpret_cast<getter>(ContactInformation_get_PhoneNumbers), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_ContactInformation[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_ContactInformation) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_ContactInformation) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_ContactInformation) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_ContactInformation) },
        { },
    };

    static PyType_Spec type_spec_ContactInformation =
    {
        "_winrt_windows_applicationmodel_contacts.ContactInformation",
        sizeof(py::wrapper::Windows::ApplicationModel::Contacts::ContactInformation),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_ContactInformation
    };

    // ----- ContactInstantMessageField class --------------------

    static PyObject* _new_ContactInstantMessageField(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                winrt::Windows::ApplicationModel::Contacts::ContactInstantMessageField instance{ param0 };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::ApplicationModel::Contacts::ContactFieldCategory>(args, 1);

                winrt::Windows::ApplicationModel::Contacts::ContactInstantMessageField instance{ param0, param1 };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 5)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::ApplicationModel::Contacts::ContactFieldCategory>(args, 1);
                auto param2 = py::convert_to<winrt::hstring>(args, 2);
                auto param3 = py::convert_to<winrt::hstring>(args, 3);
                auto param4 = py::convert_to<winrt::Windows::Foundation::Uri>(args, 4);

                winrt::Windows::ApplicationModel::Contacts::ContactInstantMessageField instance{ param0, param1, param2, param3, param4 };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_ContactInstantMessageField(py::wrapper::Windows::ApplicationModel::Contacts::ContactInstantMessageField* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* ContactInstantMessageField_get_Category(py::wrapper::Windows::ApplicationModel::Contacts::ContactInstantMessageField* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Contacts.ContactInstantMessageField", L"Category"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Category());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ContactInstantMessageField_get_Name(py::wrapper::Windows::ApplicationModel::Contacts::ContactInstantMessageField* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Contacts.ContactInstantMessageField", L"Name"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Name());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ContactInstantMessageField_get_Type(py::wrapper::Windows::ApplicationModel::Contacts::ContactInstantMessageField* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Contacts.ContactInstantMessageField", L"Type"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Type());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ContactInstantMessageField_get_Value(py::wrapper::Windows::ApplicationModel::Contacts::ContactInstantMessageField* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Contacts.ContactInstantMessageField", L"Value"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Value());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ContactInstantMessageField_get_DisplayText(py::wrapper::Windows::ApplicationModel::Contacts::ContactInstantMessageField* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Contacts.ContactInstantMessageField", L"DisplayText"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.DisplayText());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ContactInstantMessageField_get_LaunchUri(py::wrapper::Windows::ApplicationModel::Contacts::ContactInstantMessageField* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Contacts.ContactInstantMessageField", L"LaunchUri"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.LaunchUri());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ContactInstantMessageField_get_Service(py::wrapper::Windows::ApplicationModel::Contacts::ContactInstantMessageField* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Contacts.ContactInstantMessageField", L"Service"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Service());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ContactInstantMessageField_get_UserName(py::wrapper::Windows::ApplicationModel::Contacts::ContactInstantMessageField* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Contacts.ContactInstantMessageField", L"UserName"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.UserName());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_ContactInstantMessageField(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::ApplicationModel::Contacts::ContactInstantMessageField>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_ContactInstantMessageField(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::Contacts::ContactInstantMessageField>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_ContactInstantMessageField[] = {
        { "_assign_array_", _assign_array_ContactInstantMessageField, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_ContactInstantMessageField), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_ContactInstantMessageField[] = {
        { "category", reinterpret_cast<getter>(ContactInstantMessageField_get_Category), nullptr, nullptr, nullptr },
        { "name", reinterpret_cast<getter>(ContactInstantMessageField_get_Name), nullptr, nullptr, nullptr },
        { "type", reinterpret_cast<getter>(ContactInstantMessageField_get_Type), nullptr, nullptr, nullptr },
        { "value", reinterpret_cast<getter>(ContactInstantMessageField_get_Value), nullptr, nullptr, nullptr },
        { "display_text", reinterpret_cast<getter>(ContactInstantMessageField_get_DisplayText), nullptr, nullptr, nullptr },
        { "launch_uri", reinterpret_cast<getter>(ContactInstantMessageField_get_LaunchUri), nullptr, nullptr, nullptr },
        { "service", reinterpret_cast<getter>(ContactInstantMessageField_get_Service), nullptr, nullptr, nullptr },
        { "user_name", reinterpret_cast<getter>(ContactInstantMessageField_get_UserName), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_ContactInstantMessageField[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_ContactInstantMessageField) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_ContactInstantMessageField) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_ContactInstantMessageField) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_ContactInstantMessageField) },
        { },
    };

    static PyType_Spec type_spec_ContactInstantMessageField =
    {
        "_winrt_windows_applicationmodel_contacts.ContactInstantMessageField",
        sizeof(py::wrapper::Windows::ApplicationModel::Contacts::ContactInstantMessageField),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_ContactInstantMessageField
    };

    // ----- ContactJobInfo class --------------------

    static PyObject* _new_ContactJobInfo(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 0)
        {
            try
            {
                winrt::Windows::ApplicationModel::Contacts::ContactJobInfo instance{  };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_ContactJobInfo(py::wrapper::Windows::ApplicationModel::Contacts::ContactJobInfo* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* ContactJobInfo_get_Title(py::wrapper::Windows::ApplicationModel::Contacts::ContactJobInfo* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Contacts.ContactJobInfo", L"Title"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Title());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ContactJobInfo_put_Title(py::wrapper::Windows::ApplicationModel::Contacts::ContactJobInfo* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Contacts.ContactJobInfo", L"Title"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.Title(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ContactJobInfo_get_Office(py::wrapper::Windows::ApplicationModel::Contacts::ContactJobInfo* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Contacts.ContactJobInfo", L"Office"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Office());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ContactJobInfo_put_Office(py::wrapper::Windows::ApplicationModel::Contacts::ContactJobInfo* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Contacts.ContactJobInfo", L"Office"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.Office(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ContactJobInfo_get_Manager(py::wrapper::Windows::ApplicationModel::Contacts::ContactJobInfo* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Contacts.ContactJobInfo", L"Manager"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Manager());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ContactJobInfo_put_Manager(py::wrapper::Windows::ApplicationModel::Contacts::ContactJobInfo* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Contacts.ContactJobInfo", L"Manager"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.Manager(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ContactJobInfo_get_Description(py::wrapper::Windows::ApplicationModel::Contacts::ContactJobInfo* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Contacts.ContactJobInfo", L"Description"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Description());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ContactJobInfo_put_Description(py::wrapper::Windows::ApplicationModel::Contacts::ContactJobInfo* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Contacts.ContactJobInfo", L"Description"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.Description(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ContactJobInfo_get_Department(py::wrapper::Windows::ApplicationModel::Contacts::ContactJobInfo* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Contacts.ContactJobInfo", L"Department"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Department());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ContactJobInfo_put_Department(py::wrapper::Windows::ApplicationModel::Contacts::ContactJobInfo* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Contacts.ContactJobInfo", L"Department"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.Department(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ContactJobInfo_get_CompanyYomiName(py::wrapper::Windows::ApplicationModel::Contacts::ContactJobInfo* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Contacts.ContactJobInfo", L"CompanyYomiName"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.CompanyYomiName());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ContactJobInfo_put_CompanyYomiName(py::wrapper::Windows::ApplicationModel::Contacts::ContactJobInfo* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Contacts.ContactJobInfo", L"CompanyYomiName"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.CompanyYomiName(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ContactJobInfo_get_CompanyName(py::wrapper::Windows::ApplicationModel::Contacts::ContactJobInfo* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Contacts.ContactJobInfo", L"CompanyName"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.CompanyName());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ContactJobInfo_put_CompanyName(py::wrapper::Windows::ApplicationModel::Contacts::ContactJobInfo* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Contacts.ContactJobInfo", L"CompanyName"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.CompanyName(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ContactJobInfo_get_CompanyAddress(py::wrapper::Windows::ApplicationModel::Contacts::ContactJobInfo* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Contacts.ContactJobInfo", L"CompanyAddress"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.CompanyAddress());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ContactJobInfo_put_CompanyAddress(py::wrapper::Windows::ApplicationModel::Contacts::ContactJobInfo* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Contacts.ContactJobInfo", L"CompanyAddress"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.CompanyAddress(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* _assign_array_ContactJobInfo(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::ApplicationModel::Contacts::ContactJobInfo>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_ContactJobInfo(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::Contacts::ContactJobInfo>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_ContactJobInfo[] = {
        { "_assign_array_", _assign_array_ContactJobInfo, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_ContactJobInfo), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_ContactJobInfo[] = {
        { "title", reinterpret_cast<getter>(ContactJobInfo_get_Title), reinterpret_cast<setter>(ContactJobInfo_put_Title), nullptr, nullptr },
        { "office", reinterpret_cast<getter>(ContactJobInfo_get_Office), reinterpret_cast<setter>(ContactJobInfo_put_Office), nullptr, nullptr },
        { "manager", reinterpret_cast<getter>(ContactJobInfo_get_Manager), reinterpret_cast<setter>(ContactJobInfo_put_Manager), nullptr, nullptr },
        { "description", reinterpret_cast<getter>(ContactJobInfo_get_Description), reinterpret_cast<setter>(ContactJobInfo_put_Description), nullptr, nullptr },
        { "department", reinterpret_cast<getter>(ContactJobInfo_get_Department), reinterpret_cast<setter>(ContactJobInfo_put_Department), nullptr, nullptr },
        { "company_yomi_name", reinterpret_cast<getter>(ContactJobInfo_get_CompanyYomiName), reinterpret_cast<setter>(ContactJobInfo_put_CompanyYomiName), nullptr, nullptr },
        { "company_name", reinterpret_cast<getter>(ContactJobInfo_get_CompanyName), reinterpret_cast<setter>(ContactJobInfo_put_CompanyName), nullptr, nullptr },
        { "company_address", reinterpret_cast<getter>(ContactJobInfo_get_CompanyAddress), reinterpret_cast<setter>(ContactJobInfo_put_CompanyAddress), nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_ContactJobInfo[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_ContactJobInfo) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_ContactJobInfo) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_ContactJobInfo) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_ContactJobInfo) },
        { },
    };

    static PyType_Spec type_spec_ContactJobInfo =
    {
        "_winrt_windows_applicationmodel_contacts.ContactJobInfo",
        sizeof(py::wrapper::Windows::ApplicationModel::Contacts::ContactJobInfo),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_ContactJobInfo
    };

    // ----- ContactLaunchActionVerbs class --------------------

    static PyObject* _new_ContactLaunchActionVerbs(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::ApplicationModel::Contacts::ContactLaunchActionVerbs>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::ApplicationModel::Contacts::ContactLaunchActionVerbs>::type_name);
        return nullptr;
    }

    static PyObject* ContactLaunchActionVerbs_get_Call(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Contacts.ContactLaunchActionVerbs", L"Call"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Windows::ApplicationModel::Contacts::ContactLaunchActionVerbs::Call());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ContactLaunchActionVerbs_get_Map(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Contacts.ContactLaunchActionVerbs", L"Map"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Windows::ApplicationModel::Contacts::ContactLaunchActionVerbs::Map());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ContactLaunchActionVerbs_get_Message(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Contacts.ContactLaunchActionVerbs", L"Message"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Windows::ApplicationModel::Contacts::ContactLaunchActionVerbs::Message());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ContactLaunchActionVerbs_get_Post(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Contacts.ContactLaunchActionVerbs", L"Post"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Windows::ApplicationModel::Contacts::ContactLaunchActionVerbs::Post());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ContactLaunchActionVerbs_get_VideoCall(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Contacts.ContactLaunchActionVerbs", L"VideoCall"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Windows::ApplicationModel::Contacts::ContactLaunchActionVerbs::VideoCall());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_ContactLaunchActionVerbs[] = {
        { }
    };

    static PyGetSetDef _getset_ContactLaunchActionVerbs[] = {
        { }
    };

    static PyType_Slot _type_slots_ContactLaunchActionVerbs[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_ContactLaunchActionVerbs) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_ContactLaunchActionVerbs) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_ContactLaunchActionVerbs) },
        { },
    };

    static PyType_Spec type_spec_ContactLaunchActionVerbs =
    {
        "_winrt_windows_applicationmodel_contacts.ContactLaunchActionVerbs",
        0,
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_ContactLaunchActionVerbs
    };

    static PyGetSetDef getset_ContactLaunchActionVerbs_Meta[] = {
        { "call", reinterpret_cast<getter>(ContactLaunchActionVerbs_get_Call), nullptr, nullptr, nullptr },
        { "map", reinterpret_cast<getter>(ContactLaunchActionVerbs_get_Map), nullptr, nullptr, nullptr },
        { "message", reinterpret_cast<getter>(ContactLaunchActionVerbs_get_Message), nullptr, nullptr, nullptr },
        { "post", reinterpret_cast<getter>(ContactLaunchActionVerbs_get_Post), nullptr, nullptr, nullptr },
        { "video_call", reinterpret_cast<getter>(ContactLaunchActionVerbs_get_VideoCall), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot type_slots_ContactLaunchActionVerbs_Meta[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_ContactLaunchActionVerbs_Meta) },
        { }
    };

    static PyType_Spec type_spec_ContactLaunchActionVerbs_Meta =
    {
        "_winrt_windows_applicationmodel_contacts.ContactLaunchActionVerbs_Meta",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT,
        type_slots_ContactLaunchActionVerbs_Meta
    };

    // ----- ContactList class --------------------

    static PyObject* _new_ContactList(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::ApplicationModel::Contacts::ContactList>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::ApplicationModel::Contacts::ContactList>::type_name);
        return nullptr;
    }

    static void _dealloc_ContactList(py::wrapper::Windows::ApplicationModel::Contacts::ContactList* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* ContactList_DeleteAsync(py::wrapper::Windows::ApplicationModel::Contacts::ContactList* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.ApplicationModel.Contacts.ContactList", L"DeleteAsync", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(self->obj.DeleteAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ContactList_DeleteContactAsync(py::wrapper::Windows::ApplicationModel::Contacts::ContactList* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.ApplicationModel.Contacts.ContactList", L"DeleteContactAsync", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::ApplicationModel::Contacts::Contact>(args, 0);

                return py::convert(self->obj.DeleteContactAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ContactList_GetChangeTracker(py::wrapper::Windows::ApplicationModel::Contacts::ContactList* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.ApplicationModel.Contacts.ContactList", L"GetChangeTracker", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                return py::convert(self->obj.GetChangeTracker(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ContactList_GetContactAsync(py::wrapper::Windows::ApplicationModel::Contacts::ContactList* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.ApplicationModel.Contacts.ContactList", L"GetContactAsync", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                return py::convert(self->obj.GetContactAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ContactList_GetContactFromRemoteIdAsync(py::wrapper::Windows::ApplicationModel::Contacts::ContactList* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.ApplicationModel.Contacts.ContactList", L"GetContactFromRemoteIdAsync", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                return py::convert(self->obj.GetContactFromRemoteIdAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ContactList_GetContactReader(py::wrapper::Windows::ApplicationModel::Contacts::ContactList* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.ApplicationModel.Contacts.ContactList", L"GetContactReader", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(self->obj.GetContactReader());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.ApplicationModel.Contacts.ContactList", L"GetContactReader", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::ApplicationModel::Contacts::ContactQueryOptions>(args, 0);

                return py::convert(self->obj.GetContactReader(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ContactList_GetMeContactAsync(py::wrapper::Windows::ApplicationModel::Contacts::ContactList* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.ApplicationModel.Contacts.ContactList", L"GetMeContactAsync", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(self->obj.GetMeContactAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ContactList_RegisterSyncManagerAsync(py::wrapper::Windows::ApplicationModel::Contacts::ContactList* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.ApplicationModel.Contacts.ContactList", L"RegisterSyncManagerAsync", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(self->obj.RegisterSyncManagerAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ContactList_SaveAsync(py::wrapper::Windows::ApplicationModel::Contacts::ContactList* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.ApplicationModel.Contacts.ContactList", L"SaveAsync", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(self->obj.SaveAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ContactList_SaveContactAsync(py::wrapper::Windows::ApplicationModel::Contacts::ContactList* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.ApplicationModel.Contacts.ContactList", L"SaveContactAsync", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::ApplicationModel::Contacts::Contact>(args, 0);

                return py::convert(self->obj.SaveContactAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ContactList_get_SupportsServerSearch(py::wrapper::Windows::ApplicationModel::Contacts::ContactList* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Contacts.ContactList", L"SupportsServerSearch"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.SupportsServerSearch());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ContactList_put_SupportsServerSearch(py::wrapper::Windows::ApplicationModel::Contacts::ContactList* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Contacts.ContactList", L"SupportsServerSearch"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<bool>(arg);

            self->obj.SupportsServerSearch(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ContactList_get_IsHidden(py::wrapper::Windows::ApplicationModel::Contacts::ContactList* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Contacts.ContactList", L"IsHidden"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.IsHidden());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ContactList_put_IsHidden(py::wrapper::Windows::ApplicationModel::Contacts::ContactList* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Contacts.ContactList", L"IsHidden"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<bool>(arg);

            self->obj.IsHidden(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ContactList_get_OtherAppWriteAccess(py::wrapper::Windows::ApplicationModel::Contacts::ContactList* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Contacts.ContactList", L"OtherAppWriteAccess"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.OtherAppWriteAccess());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ContactList_put_OtherAppWriteAccess(py::wrapper::Windows::ApplicationModel::Contacts::ContactList* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Contacts.ContactList", L"OtherAppWriteAccess"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::ApplicationModel::Contacts::ContactListOtherAppWriteAccess>(arg);

            self->obj.OtherAppWriteAccess(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ContactList_get_DisplayName(py::wrapper::Windows::ApplicationModel::Contacts::ContactList* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Contacts.ContactList", L"DisplayName"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.DisplayName());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ContactList_put_DisplayName(py::wrapper::Windows::ApplicationModel::Contacts::ContactList* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Contacts.ContactList", L"DisplayName"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.DisplayName(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ContactList_get_OtherAppReadAccess(py::wrapper::Windows::ApplicationModel::Contacts::ContactList* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Contacts.ContactList", L"OtherAppReadAccess"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.OtherAppReadAccess());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ContactList_put_OtherAppReadAccess(py::wrapper::Windows::ApplicationModel::Contacts::ContactList* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Contacts.ContactList", L"OtherAppReadAccess"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::ApplicationModel::Contacts::ContactListOtherAppReadAccess>(arg);

            self->obj.OtherAppReadAccess(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ContactList_get_ChangeTracker(py::wrapper::Windows::ApplicationModel::Contacts::ContactList* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Contacts.ContactList", L"ChangeTracker"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.ChangeTracker());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ContactList_get_SourceDisplayName(py::wrapper::Windows::ApplicationModel::Contacts::ContactList* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Contacts.ContactList", L"SourceDisplayName"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.SourceDisplayName());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ContactList_get_Id(py::wrapper::Windows::ApplicationModel::Contacts::ContactList* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Contacts.ContactList", L"Id"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Id());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ContactList_get_SyncManager(py::wrapper::Windows::ApplicationModel::Contacts::ContactList* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Contacts.ContactList", L"SyncManager"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.SyncManager());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ContactList_get_UserDataAccountId(py::wrapper::Windows::ApplicationModel::Contacts::ContactList* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Contacts.ContactList", L"UserDataAccountId"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.UserDataAccountId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ContactList_get_SyncConstraints(py::wrapper::Windows::ApplicationModel::Contacts::ContactList* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Contacts.ContactList", L"SyncConstraints"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.SyncConstraints());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ContactList_get_LimitedWriteOperations(py::wrapper::Windows::ApplicationModel::Contacts::ContactList* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Contacts.ContactList", L"LimitedWriteOperations"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.LimitedWriteOperations());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ContactList_add_ContactChanged(py::wrapper::Windows::ApplicationModel::Contacts::ContactList* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.ApplicationModel.Contacts.ContactList", L"ContactChanged"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::ApplicationModel::Contacts::ContactList, winrt::Windows::ApplicationModel::Contacts::ContactChangedEventArgs>>(arg);

            return py::convert(self->obj.ContactChanged(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ContactList_remove_ContactChanged(py::wrapper::Windows::ApplicationModel::Contacts::ContactList* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.ApplicationModel.Contacts.ContactList", L"ContactChanged"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.ContactChanged(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_ContactList(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::ApplicationModel::Contacts::ContactList>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_ContactList(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::Contacts::ContactList>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_ContactList[] = {
        { "delete_async", reinterpret_cast<PyCFunction>(ContactList_DeleteAsync), METH_VARARGS, nullptr },
        { "delete_contact_async", reinterpret_cast<PyCFunction>(ContactList_DeleteContactAsync), METH_VARARGS, nullptr },
        { "get_change_tracker", reinterpret_cast<PyCFunction>(ContactList_GetChangeTracker), METH_VARARGS, nullptr },
        { "get_contact_async", reinterpret_cast<PyCFunction>(ContactList_GetContactAsync), METH_VARARGS, nullptr },
        { "get_contact_from_remote_id_async", reinterpret_cast<PyCFunction>(ContactList_GetContactFromRemoteIdAsync), METH_VARARGS, nullptr },
        { "get_contact_reader", reinterpret_cast<PyCFunction>(ContactList_GetContactReader), METH_VARARGS, nullptr },
        { "get_me_contact_async", reinterpret_cast<PyCFunction>(ContactList_GetMeContactAsync), METH_VARARGS, nullptr },
        { "register_sync_manager_async", reinterpret_cast<PyCFunction>(ContactList_RegisterSyncManagerAsync), METH_VARARGS, nullptr },
        { "save_async", reinterpret_cast<PyCFunction>(ContactList_SaveAsync), METH_VARARGS, nullptr },
        { "save_contact_async", reinterpret_cast<PyCFunction>(ContactList_SaveContactAsync), METH_VARARGS, nullptr },
        { "add_contact_changed", reinterpret_cast<PyCFunction>(ContactList_add_ContactChanged), METH_O, nullptr },
        { "remove_contact_changed", reinterpret_cast<PyCFunction>(ContactList_remove_ContactChanged), METH_O, nullptr },
        { "_assign_array_", _assign_array_ContactList, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_ContactList), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_ContactList[] = {
        { "supports_server_search", reinterpret_cast<getter>(ContactList_get_SupportsServerSearch), reinterpret_cast<setter>(ContactList_put_SupportsServerSearch), nullptr, nullptr },
        { "is_hidden", reinterpret_cast<getter>(ContactList_get_IsHidden), reinterpret_cast<setter>(ContactList_put_IsHidden), nullptr, nullptr },
        { "other_app_write_access", reinterpret_cast<getter>(ContactList_get_OtherAppWriteAccess), reinterpret_cast<setter>(ContactList_put_OtherAppWriteAccess), nullptr, nullptr },
        { "display_name", reinterpret_cast<getter>(ContactList_get_DisplayName), reinterpret_cast<setter>(ContactList_put_DisplayName), nullptr, nullptr },
        { "other_app_read_access", reinterpret_cast<getter>(ContactList_get_OtherAppReadAccess), reinterpret_cast<setter>(ContactList_put_OtherAppReadAccess), nullptr, nullptr },
        { "change_tracker", reinterpret_cast<getter>(ContactList_get_ChangeTracker), nullptr, nullptr, nullptr },
        { "source_display_name", reinterpret_cast<getter>(ContactList_get_SourceDisplayName), nullptr, nullptr, nullptr },
        { "id", reinterpret_cast<getter>(ContactList_get_Id), nullptr, nullptr, nullptr },
        { "sync_manager", reinterpret_cast<getter>(ContactList_get_SyncManager), nullptr, nullptr, nullptr },
        { "user_data_account_id", reinterpret_cast<getter>(ContactList_get_UserDataAccountId), nullptr, nullptr, nullptr },
        { "sync_constraints", reinterpret_cast<getter>(ContactList_get_SyncConstraints), nullptr, nullptr, nullptr },
        { "limited_write_operations", reinterpret_cast<getter>(ContactList_get_LimitedWriteOperations), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_ContactList[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_ContactList) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_ContactList) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_ContactList) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_ContactList) },
        { },
    };

    static PyType_Spec type_spec_ContactList =
    {
        "_winrt_windows_applicationmodel_contacts.ContactList",
        sizeof(py::wrapper::Windows::ApplicationModel::Contacts::ContactList),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_ContactList
    };

    // ----- ContactListLimitedWriteOperations class --------------------

    static PyObject* _new_ContactListLimitedWriteOperations(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::ApplicationModel::Contacts::ContactListLimitedWriteOperations>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::ApplicationModel::Contacts::ContactListLimitedWriteOperations>::type_name);
        return nullptr;
    }

    static void _dealloc_ContactListLimitedWriteOperations(py::wrapper::Windows::ApplicationModel::Contacts::ContactListLimitedWriteOperations* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* ContactListLimitedWriteOperations_TryCreateOrUpdateContactAsync(py::wrapper::Windows::ApplicationModel::Contacts::ContactListLimitedWriteOperations* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.ApplicationModel.Contacts.ContactListLimitedWriteOperations", L"TryCreateOrUpdateContactAsync", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::ApplicationModel::Contacts::Contact>(args, 0);

                return py::convert(self->obj.TryCreateOrUpdateContactAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ContactListLimitedWriteOperations_TryDeleteContactAsync(py::wrapper::Windows::ApplicationModel::Contacts::ContactListLimitedWriteOperations* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.ApplicationModel.Contacts.ContactListLimitedWriteOperations", L"TryDeleteContactAsync", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                return py::convert(self->obj.TryDeleteContactAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* _assign_array_ContactListLimitedWriteOperations(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::ApplicationModel::Contacts::ContactListLimitedWriteOperations>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_ContactListLimitedWriteOperations(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::Contacts::ContactListLimitedWriteOperations>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_ContactListLimitedWriteOperations[] = {
        { "try_create_or_update_contact_async", reinterpret_cast<PyCFunction>(ContactListLimitedWriteOperations_TryCreateOrUpdateContactAsync), METH_VARARGS, nullptr },
        { "try_delete_contact_async", reinterpret_cast<PyCFunction>(ContactListLimitedWriteOperations_TryDeleteContactAsync), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_ContactListLimitedWriteOperations, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_ContactListLimitedWriteOperations), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_ContactListLimitedWriteOperations[] = {
        { }
    };

    static PyType_Slot _type_slots_ContactListLimitedWriteOperations[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_ContactListLimitedWriteOperations) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_ContactListLimitedWriteOperations) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_ContactListLimitedWriteOperations) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_ContactListLimitedWriteOperations) },
        { },
    };

    static PyType_Spec type_spec_ContactListLimitedWriteOperations =
    {
        "_winrt_windows_applicationmodel_contacts.ContactListLimitedWriteOperations",
        sizeof(py::wrapper::Windows::ApplicationModel::Contacts::ContactListLimitedWriteOperations),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_ContactListLimitedWriteOperations
    };

    // ----- ContactListSyncConstraints class --------------------

    static PyObject* _new_ContactListSyncConstraints(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::ApplicationModel::Contacts::ContactListSyncConstraints>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::ApplicationModel::Contacts::ContactListSyncConstraints>::type_name);
        return nullptr;
    }

    static void _dealloc_ContactListSyncConstraints(py::wrapper::Windows::ApplicationModel::Contacts::ContactListSyncConstraints* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* ContactListSyncConstraints_get_CanSyncDescriptions(py::wrapper::Windows::ApplicationModel::Contacts::ContactListSyncConstraints* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Contacts.ContactListSyncConstraints", L"CanSyncDescriptions"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.CanSyncDescriptions());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ContactListSyncConstraints_put_CanSyncDescriptions(py::wrapper::Windows::ApplicationModel::Contacts::ContactListSyncConstraints* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Contacts.ContactListSyncConstraints", L"CanSyncDescriptions"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<bool>(arg);

            self->obj.CanSyncDescriptions(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ContactListSyncConstraints_get_MaxCompanyPhoneNumbers(py::wrapper::Windows::ApplicationModel::Contacts::ContactListSyncConstraints* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Contacts.ContactListSyncConstraints", L"MaxCompanyPhoneNumbers"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.MaxCompanyPhoneNumbers());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ContactListSyncConstraints_put_MaxCompanyPhoneNumbers(py::wrapper::Windows::ApplicationModel::Contacts::ContactListSyncConstraints* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Contacts.ContactListSyncConstraints", L"MaxCompanyPhoneNumbers"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::IReference<int32_t>>(arg);

            self->obj.MaxCompanyPhoneNumbers(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ContactListSyncConstraints_get_MaxChildRelationships(py::wrapper::Windows::ApplicationModel::Contacts::ContactListSyncConstraints* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Contacts.ContactListSyncConstraints", L"MaxChildRelationships"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.MaxChildRelationships());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ContactListSyncConstraints_put_MaxChildRelationships(py::wrapper::Windows::ApplicationModel::Contacts::ContactListSyncConstraints* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Contacts.ContactListSyncConstraints", L"MaxChildRelationships"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::IReference<int32_t>>(arg);

            self->obj.MaxChildRelationships(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ContactListSyncConstraints_get_MaxBusinessFaxPhoneNumbers(py::wrapper::Windows::ApplicationModel::Contacts::ContactListSyncConstraints* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Contacts.ContactListSyncConstraints", L"MaxBusinessFaxPhoneNumbers"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.MaxBusinessFaxPhoneNumbers());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ContactListSyncConstraints_put_MaxBusinessFaxPhoneNumbers(py::wrapper::Windows::ApplicationModel::Contacts::ContactListSyncConstraints* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Contacts.ContactListSyncConstraints", L"MaxBusinessFaxPhoneNumbers"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::IReference<int32_t>>(arg);

            self->obj.MaxBusinessFaxPhoneNumbers(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ContactListSyncConstraints_get_MaxBirthdayDates(py::wrapper::Windows::ApplicationModel::Contacts::ContactListSyncConstraints* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Contacts.ContactListSyncConstraints", L"MaxBirthdayDates"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.MaxBirthdayDates());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ContactListSyncConstraints_put_MaxBirthdayDates(py::wrapper::Windows::ApplicationModel::Contacts::ContactListSyncConstraints* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Contacts.ContactListSyncConstraints", L"MaxBirthdayDates"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::IReference<int32_t>>(arg);

            self->obj.MaxBirthdayDates(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ContactListSyncConstraints_get_MaxAssistantPhoneNumbers(py::wrapper::Windows::ApplicationModel::Contacts::ContactListSyncConstraints* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Contacts.ContactListSyncConstraints", L"MaxAssistantPhoneNumbers"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.MaxAssistantPhoneNumbers());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ContactListSyncConstraints_put_MaxAssistantPhoneNumbers(py::wrapper::Windows::ApplicationModel::Contacts::ContactListSyncConstraints* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Contacts.ContactListSyncConstraints", L"MaxAssistantPhoneNumbers"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::IReference<int32_t>>(arg);

            self->obj.MaxAssistantPhoneNumbers(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ContactListSyncConstraints_get_MaxOtherAddresses(py::wrapper::Windows::ApplicationModel::Contacts::ContactListSyncConstraints* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Contacts.ContactListSyncConstraints", L"MaxOtherAddresses"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.MaxOtherAddresses());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ContactListSyncConstraints_put_MaxOtherAddresses(py::wrapper::Windows::ApplicationModel::Contacts::ContactListSyncConstraints* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Contacts.ContactListSyncConstraints", L"MaxOtherAddresses"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::IReference<int32_t>>(arg);

            self->obj.MaxOtherAddresses(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ContactListSyncConstraints_get_MaxAnniversaryDates(py::wrapper::Windows::ApplicationModel::Contacts::ContactListSyncConstraints* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Contacts.ContactListSyncConstraints", L"MaxAnniversaryDates"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.MaxAnniversaryDates());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ContactListSyncConstraints_put_MaxAnniversaryDates(py::wrapper::Windows::ApplicationModel::Contacts::ContactListSyncConstraints* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Contacts.ContactListSyncConstraints", L"MaxAnniversaryDates"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::IReference<int32_t>>(arg);

            self->obj.MaxAnniversaryDates(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ContactListSyncConstraints_get_MaxHomeAddresses(py::wrapper::Windows::ApplicationModel::Contacts::ContactListSyncConstraints* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Contacts.ContactListSyncConstraints", L"MaxHomeAddresses"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.MaxHomeAddresses());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ContactListSyncConstraints_put_MaxHomeAddresses(py::wrapper::Windows::ApplicationModel::Contacts::ContactListSyncConstraints* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Contacts.ContactListSyncConstraints", L"MaxHomeAddresses"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::IReference<int32_t>>(arg);

            self->obj.MaxHomeAddresses(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ContactListSyncConstraints_get_MaxOtherDates(py::wrapper::Windows::ApplicationModel::Contacts::ContactListSyncConstraints* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Contacts.ContactListSyncConstraints", L"MaxOtherDates"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.MaxOtherDates());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ContactListSyncConstraints_put_MaxOtherDates(py::wrapper::Windows::ApplicationModel::Contacts::ContactListSyncConstraints* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Contacts.ContactListSyncConstraints", L"MaxOtherDates"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::IReference<int32_t>>(arg);

            self->obj.MaxOtherDates(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ContactListSyncConstraints_get_MaxMobilePhoneNumbers(py::wrapper::Windows::ApplicationModel::Contacts::ContactListSyncConstraints* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Contacts.ContactListSyncConstraints", L"MaxMobilePhoneNumbers"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.MaxMobilePhoneNumbers());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ContactListSyncConstraints_put_MaxMobilePhoneNumbers(py::wrapper::Windows::ApplicationModel::Contacts::ContactListSyncConstraints* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Contacts.ContactListSyncConstraints", L"MaxMobilePhoneNumbers"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::IReference<int32_t>>(arg);

            self->obj.MaxMobilePhoneNumbers(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ContactListSyncConstraints_get_MaxJobInfo(py::wrapper::Windows::ApplicationModel::Contacts::ContactListSyncConstraints* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Contacts.ContactListSyncConstraints", L"MaxJobInfo"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.MaxJobInfo());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ContactListSyncConstraints_put_MaxJobInfo(py::wrapper::Windows::ApplicationModel::Contacts::ContactListSyncConstraints* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Contacts.ContactListSyncConstraints", L"MaxJobInfo"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::IReference<int32_t>>(arg);

            self->obj.MaxJobInfo(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ContactListSyncConstraints_get_MaxHomePhoneNumbers(py::wrapper::Windows::ApplicationModel::Contacts::ContactListSyncConstraints* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Contacts.ContactListSyncConstraints", L"MaxHomePhoneNumbers"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.MaxHomePhoneNumbers());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ContactListSyncConstraints_put_MaxHomePhoneNumbers(py::wrapper::Windows::ApplicationModel::Contacts::ContactListSyncConstraints* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Contacts.ContactListSyncConstraints", L"MaxHomePhoneNumbers"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::IReference<int32_t>>(arg);

            self->obj.MaxHomePhoneNumbers(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ContactListSyncConstraints_get_MaxHomeFaxPhoneNumbers(py::wrapper::Windows::ApplicationModel::Contacts::ContactListSyncConstraints* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Contacts.ContactListSyncConstraints", L"MaxHomeFaxPhoneNumbers"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.MaxHomeFaxPhoneNumbers());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ContactListSyncConstraints_put_MaxHomeFaxPhoneNumbers(py::wrapper::Windows::ApplicationModel::Contacts::ContactListSyncConstraints* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Contacts.ContactListSyncConstraints", L"MaxHomeFaxPhoneNumbers"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::IReference<int32_t>>(arg);

            self->obj.MaxHomeFaxPhoneNumbers(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ContactListSyncConstraints_get_MaxOtherEmailAddresses(py::wrapper::Windows::ApplicationModel::Contacts::ContactListSyncConstraints* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Contacts.ContactListSyncConstraints", L"MaxOtherEmailAddresses"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.MaxOtherEmailAddresses());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ContactListSyncConstraints_put_MaxOtherEmailAddresses(py::wrapper::Windows::ApplicationModel::Contacts::ContactListSyncConstraints* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Contacts.ContactListSyncConstraints", L"MaxOtherEmailAddresses"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::IReference<int32_t>>(arg);

            self->obj.MaxOtherEmailAddresses(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ContactListSyncConstraints_get_MaxPersonalEmailAddresses(py::wrapper::Windows::ApplicationModel::Contacts::ContactListSyncConstraints* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Contacts.ContactListSyncConstraints", L"MaxPersonalEmailAddresses"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.MaxPersonalEmailAddresses());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ContactListSyncConstraints_put_MaxPersonalEmailAddresses(py::wrapper::Windows::ApplicationModel::Contacts::ContactListSyncConstraints* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Contacts.ContactListSyncConstraints", L"MaxPersonalEmailAddresses"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::IReference<int32_t>>(arg);

            self->obj.MaxPersonalEmailAddresses(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ContactListSyncConstraints_get_MaxPartnerRelationships(py::wrapper::Windows::ApplicationModel::Contacts::ContactListSyncConstraints* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Contacts.ContactListSyncConstraints", L"MaxPartnerRelationships"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.MaxPartnerRelationships());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ContactListSyncConstraints_put_MaxPartnerRelationships(py::wrapper::Windows::ApplicationModel::Contacts::ContactListSyncConstraints* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Contacts.ContactListSyncConstraints", L"MaxPartnerRelationships"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::IReference<int32_t>>(arg);

            self->obj.MaxPartnerRelationships(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ContactListSyncConstraints_get_MaxParentRelationships(py::wrapper::Windows::ApplicationModel::Contacts::ContactListSyncConstraints* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Contacts.ContactListSyncConstraints", L"MaxParentRelationships"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.MaxParentRelationships());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ContactListSyncConstraints_put_MaxParentRelationships(py::wrapper::Windows::ApplicationModel::Contacts::ContactListSyncConstraints* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Contacts.ContactListSyncConstraints", L"MaxParentRelationships"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::IReference<int32_t>>(arg);

            self->obj.MaxParentRelationships(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ContactListSyncConstraints_get_MaxPagerPhoneNumbers(py::wrapper::Windows::ApplicationModel::Contacts::ContactListSyncConstraints* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Contacts.ContactListSyncConstraints", L"MaxPagerPhoneNumbers"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.MaxPagerPhoneNumbers());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ContactListSyncConstraints_put_MaxPagerPhoneNumbers(py::wrapper::Windows::ApplicationModel::Contacts::ContactListSyncConstraints* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Contacts.ContactListSyncConstraints", L"MaxPagerPhoneNumbers"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::IReference<int32_t>>(arg);

            self->obj.MaxPagerPhoneNumbers(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ContactListSyncConstraints_get_MaxOtherRelationships(py::wrapper::Windows::ApplicationModel::Contacts::ContactListSyncConstraints* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Contacts.ContactListSyncConstraints", L"MaxOtherRelationships"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.MaxOtherRelationships());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ContactListSyncConstraints_put_MaxOtherRelationships(py::wrapper::Windows::ApplicationModel::Contacts::ContactListSyncConstraints* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Contacts.ContactListSyncConstraints", L"MaxOtherRelationships"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::IReference<int32_t>>(arg);

            self->obj.MaxOtherRelationships(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ContactListSyncConstraints_get_MaxOtherPhoneNumbers(py::wrapper::Windows::ApplicationModel::Contacts::ContactListSyncConstraints* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Contacts.ContactListSyncConstraints", L"MaxOtherPhoneNumbers"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.MaxOtherPhoneNumbers());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ContactListSyncConstraints_put_MaxOtherPhoneNumbers(py::wrapper::Windows::ApplicationModel::Contacts::ContactListSyncConstraints* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Contacts.ContactListSyncConstraints", L"MaxOtherPhoneNumbers"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::IReference<int32_t>>(arg);

            self->obj.MaxOtherPhoneNumbers(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ContactListSyncConstraints_get_MaxRadioPhoneNumbers(py::wrapper::Windows::ApplicationModel::Contacts::ContactListSyncConstraints* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Contacts.ContactListSyncConstraints", L"MaxRadioPhoneNumbers"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.MaxRadioPhoneNumbers());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ContactListSyncConstraints_put_MaxRadioPhoneNumbers(py::wrapper::Windows::ApplicationModel::Contacts::ContactListSyncConstraints* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Contacts.ContactListSyncConstraints", L"MaxRadioPhoneNumbers"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::IReference<int32_t>>(arg);

            self->obj.MaxRadioPhoneNumbers(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ContactListSyncConstraints_get_MaxWorkPhoneNumbers(py::wrapper::Windows::ApplicationModel::Contacts::ContactListSyncConstraints* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Contacts.ContactListSyncConstraints", L"MaxWorkPhoneNumbers"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.MaxWorkPhoneNumbers());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ContactListSyncConstraints_put_MaxWorkPhoneNumbers(py::wrapper::Windows::ApplicationModel::Contacts::ContactListSyncConstraints* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Contacts.ContactListSyncConstraints", L"MaxWorkPhoneNumbers"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::IReference<int32_t>>(arg);

            self->obj.MaxWorkPhoneNumbers(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ContactListSyncConstraints_get_MaxWorkEmailAddresses(py::wrapper::Windows::ApplicationModel::Contacts::ContactListSyncConstraints* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Contacts.ContactListSyncConstraints", L"MaxWorkEmailAddresses"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.MaxWorkEmailAddresses());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ContactListSyncConstraints_put_MaxWorkEmailAddresses(py::wrapper::Windows::ApplicationModel::Contacts::ContactListSyncConstraints* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Contacts.ContactListSyncConstraints", L"MaxWorkEmailAddresses"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::IReference<int32_t>>(arg);

            self->obj.MaxWorkEmailAddresses(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ContactListSyncConstraints_get_MaxWorkAddresses(py::wrapper::Windows::ApplicationModel::Contacts::ContactListSyncConstraints* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Contacts.ContactListSyncConstraints", L"MaxWorkAddresses"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.MaxWorkAddresses());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ContactListSyncConstraints_put_MaxWorkAddresses(py::wrapper::Windows::ApplicationModel::Contacts::ContactListSyncConstraints* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Contacts.ContactListSyncConstraints", L"MaxWorkAddresses"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::IReference<int32_t>>(arg);

            self->obj.MaxWorkAddresses(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ContactListSyncConstraints_get_MaxWebsites(py::wrapper::Windows::ApplicationModel::Contacts::ContactListSyncConstraints* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Contacts.ContactListSyncConstraints", L"MaxWebsites"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.MaxWebsites());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ContactListSyncConstraints_put_MaxWebsites(py::wrapper::Windows::ApplicationModel::Contacts::ContactListSyncConstraints* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Contacts.ContactListSyncConstraints", L"MaxWebsites"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::IReference<int32_t>>(arg);

            self->obj.MaxWebsites(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ContactListSyncConstraints_get_MaxSpouseRelationships(py::wrapper::Windows::ApplicationModel::Contacts::ContactListSyncConstraints* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Contacts.ContactListSyncConstraints", L"MaxSpouseRelationships"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.MaxSpouseRelationships());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ContactListSyncConstraints_put_MaxSpouseRelationships(py::wrapper::Windows::ApplicationModel::Contacts::ContactListSyncConstraints* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Contacts.ContactListSyncConstraints", L"MaxSpouseRelationships"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::IReference<int32_t>>(arg);

            self->obj.MaxSpouseRelationships(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ContactListSyncConstraints_get_MaxSiblingRelationships(py::wrapper::Windows::ApplicationModel::Contacts::ContactListSyncConstraints* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Contacts.ContactListSyncConstraints", L"MaxSiblingRelationships"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.MaxSiblingRelationships());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ContactListSyncConstraints_put_MaxSiblingRelationships(py::wrapper::Windows::ApplicationModel::Contacts::ContactListSyncConstraints* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Contacts.ContactListSyncConstraints", L"MaxSiblingRelationships"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::IReference<int32_t>>(arg);

            self->obj.MaxSiblingRelationships(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* _assign_array_ContactListSyncConstraints(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::ApplicationModel::Contacts::ContactListSyncConstraints>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_ContactListSyncConstraints(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::Contacts::ContactListSyncConstraints>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_ContactListSyncConstraints[] = {
        { "_assign_array_", _assign_array_ContactListSyncConstraints, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_ContactListSyncConstraints), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_ContactListSyncConstraints[] = {
        { "can_sync_descriptions", reinterpret_cast<getter>(ContactListSyncConstraints_get_CanSyncDescriptions), reinterpret_cast<setter>(ContactListSyncConstraints_put_CanSyncDescriptions), nullptr, nullptr },
        { "max_company_phone_numbers", reinterpret_cast<getter>(ContactListSyncConstraints_get_MaxCompanyPhoneNumbers), reinterpret_cast<setter>(ContactListSyncConstraints_put_MaxCompanyPhoneNumbers), nullptr, nullptr },
        { "max_child_relationships", reinterpret_cast<getter>(ContactListSyncConstraints_get_MaxChildRelationships), reinterpret_cast<setter>(ContactListSyncConstraints_put_MaxChildRelationships), nullptr, nullptr },
        { "max_business_fax_phone_numbers", reinterpret_cast<getter>(ContactListSyncConstraints_get_MaxBusinessFaxPhoneNumbers), reinterpret_cast<setter>(ContactListSyncConstraints_put_MaxBusinessFaxPhoneNumbers), nullptr, nullptr },
        { "max_birthday_dates", reinterpret_cast<getter>(ContactListSyncConstraints_get_MaxBirthdayDates), reinterpret_cast<setter>(ContactListSyncConstraints_put_MaxBirthdayDates), nullptr, nullptr },
        { "max_assistant_phone_numbers", reinterpret_cast<getter>(ContactListSyncConstraints_get_MaxAssistantPhoneNumbers), reinterpret_cast<setter>(ContactListSyncConstraints_put_MaxAssistantPhoneNumbers), nullptr, nullptr },
        { "max_other_addresses", reinterpret_cast<getter>(ContactListSyncConstraints_get_MaxOtherAddresses), reinterpret_cast<setter>(ContactListSyncConstraints_put_MaxOtherAddresses), nullptr, nullptr },
        { "max_anniversary_dates", reinterpret_cast<getter>(ContactListSyncConstraints_get_MaxAnniversaryDates), reinterpret_cast<setter>(ContactListSyncConstraints_put_MaxAnniversaryDates), nullptr, nullptr },
        { "max_home_addresses", reinterpret_cast<getter>(ContactListSyncConstraints_get_MaxHomeAddresses), reinterpret_cast<setter>(ContactListSyncConstraints_put_MaxHomeAddresses), nullptr, nullptr },
        { "max_other_dates", reinterpret_cast<getter>(ContactListSyncConstraints_get_MaxOtherDates), reinterpret_cast<setter>(ContactListSyncConstraints_put_MaxOtherDates), nullptr, nullptr },
        { "max_mobile_phone_numbers", reinterpret_cast<getter>(ContactListSyncConstraints_get_MaxMobilePhoneNumbers), reinterpret_cast<setter>(ContactListSyncConstraints_put_MaxMobilePhoneNumbers), nullptr, nullptr },
        { "max_job_info", reinterpret_cast<getter>(ContactListSyncConstraints_get_MaxJobInfo), reinterpret_cast<setter>(ContactListSyncConstraints_put_MaxJobInfo), nullptr, nullptr },
        { "max_home_phone_numbers", reinterpret_cast<getter>(ContactListSyncConstraints_get_MaxHomePhoneNumbers), reinterpret_cast<setter>(ContactListSyncConstraints_put_MaxHomePhoneNumbers), nullptr, nullptr },
        { "max_home_fax_phone_numbers", reinterpret_cast<getter>(ContactListSyncConstraints_get_MaxHomeFaxPhoneNumbers), reinterpret_cast<setter>(ContactListSyncConstraints_put_MaxHomeFaxPhoneNumbers), nullptr, nullptr },
        { "max_other_email_addresses", reinterpret_cast<getter>(ContactListSyncConstraints_get_MaxOtherEmailAddresses), reinterpret_cast<setter>(ContactListSyncConstraints_put_MaxOtherEmailAddresses), nullptr, nullptr },
        { "max_personal_email_addresses", reinterpret_cast<getter>(ContactListSyncConstraints_get_MaxPersonalEmailAddresses), reinterpret_cast<setter>(ContactListSyncConstraints_put_MaxPersonalEmailAddresses), nullptr, nullptr },
        { "max_partner_relationships", reinterpret_cast<getter>(ContactListSyncConstraints_get_MaxPartnerRelationships), reinterpret_cast<setter>(ContactListSyncConstraints_put_MaxPartnerRelationships), nullptr, nullptr },
        { "max_parent_relationships", reinterpret_cast<getter>(ContactListSyncConstraints_get_MaxParentRelationships), reinterpret_cast<setter>(ContactListSyncConstraints_put_MaxParentRelationships), nullptr, nullptr },
        { "max_pager_phone_numbers", reinterpret_cast<getter>(ContactListSyncConstraints_get_MaxPagerPhoneNumbers), reinterpret_cast<setter>(ContactListSyncConstraints_put_MaxPagerPhoneNumbers), nullptr, nullptr },
        { "max_other_relationships", reinterpret_cast<getter>(ContactListSyncConstraints_get_MaxOtherRelationships), reinterpret_cast<setter>(ContactListSyncConstraints_put_MaxOtherRelationships), nullptr, nullptr },
        { "max_other_phone_numbers", reinterpret_cast<getter>(ContactListSyncConstraints_get_MaxOtherPhoneNumbers), reinterpret_cast<setter>(ContactListSyncConstraints_put_MaxOtherPhoneNumbers), nullptr, nullptr },
        { "max_radio_phone_numbers", reinterpret_cast<getter>(ContactListSyncConstraints_get_MaxRadioPhoneNumbers), reinterpret_cast<setter>(ContactListSyncConstraints_put_MaxRadioPhoneNumbers), nullptr, nullptr },
        { "max_work_phone_numbers", reinterpret_cast<getter>(ContactListSyncConstraints_get_MaxWorkPhoneNumbers), reinterpret_cast<setter>(ContactListSyncConstraints_put_MaxWorkPhoneNumbers), nullptr, nullptr },
        { "max_work_email_addresses", reinterpret_cast<getter>(ContactListSyncConstraints_get_MaxWorkEmailAddresses), reinterpret_cast<setter>(ContactListSyncConstraints_put_MaxWorkEmailAddresses), nullptr, nullptr },
        { "max_work_addresses", reinterpret_cast<getter>(ContactListSyncConstraints_get_MaxWorkAddresses), reinterpret_cast<setter>(ContactListSyncConstraints_put_MaxWorkAddresses), nullptr, nullptr },
        { "max_websites", reinterpret_cast<getter>(ContactListSyncConstraints_get_MaxWebsites), reinterpret_cast<setter>(ContactListSyncConstraints_put_MaxWebsites), nullptr, nullptr },
        { "max_spouse_relationships", reinterpret_cast<getter>(ContactListSyncConstraints_get_MaxSpouseRelationships), reinterpret_cast<setter>(ContactListSyncConstraints_put_MaxSpouseRelationships), nullptr, nullptr },
        { "max_sibling_relationships", reinterpret_cast<getter>(ContactListSyncConstraints_get_MaxSiblingRelationships), reinterpret_cast<setter>(ContactListSyncConstraints_put_MaxSiblingRelationships), nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_ContactListSyncConstraints[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_ContactListSyncConstraints) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_ContactListSyncConstraints) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_ContactListSyncConstraints) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_ContactListSyncConstraints) },
        { },
    };

    static PyType_Spec type_spec_ContactListSyncConstraints =
    {
        "_winrt_windows_applicationmodel_contacts.ContactListSyncConstraints",
        sizeof(py::wrapper::Windows::ApplicationModel::Contacts::ContactListSyncConstraints),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_ContactListSyncConstraints
    };

    // ----- ContactListSyncManager class --------------------

    static PyObject* _new_ContactListSyncManager(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::ApplicationModel::Contacts::ContactListSyncManager>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::ApplicationModel::Contacts::ContactListSyncManager>::type_name);
        return nullptr;
    }

    static void _dealloc_ContactListSyncManager(py::wrapper::Windows::ApplicationModel::Contacts::ContactListSyncManager* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* ContactListSyncManager_SyncAsync(py::wrapper::Windows::ApplicationModel::Contacts::ContactListSyncManager* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.ApplicationModel.Contacts.ContactListSyncManager", L"SyncAsync", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(self->obj.SyncAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ContactListSyncManager_get_Status(py::wrapper::Windows::ApplicationModel::Contacts::ContactListSyncManager* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Contacts.ContactListSyncManager", L"Status"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Status());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ContactListSyncManager_put_Status(py::wrapper::Windows::ApplicationModel::Contacts::ContactListSyncManager* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Contacts.ContactListSyncManager", L"Status"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::ApplicationModel::Contacts::ContactListSyncStatus>(arg);

            self->obj.Status(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ContactListSyncManager_get_LastSuccessfulSyncTime(py::wrapper::Windows::ApplicationModel::Contacts::ContactListSyncManager* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Contacts.ContactListSyncManager", L"LastSuccessfulSyncTime"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.LastSuccessfulSyncTime());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ContactListSyncManager_put_LastSuccessfulSyncTime(py::wrapper::Windows::ApplicationModel::Contacts::ContactListSyncManager* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Contacts.ContactListSyncManager", L"LastSuccessfulSyncTime"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::DateTime>(arg);

            self->obj.LastSuccessfulSyncTime(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ContactListSyncManager_get_LastAttemptedSyncTime(py::wrapper::Windows::ApplicationModel::Contacts::ContactListSyncManager* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Contacts.ContactListSyncManager", L"LastAttemptedSyncTime"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.LastAttemptedSyncTime());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ContactListSyncManager_put_LastAttemptedSyncTime(py::wrapper::Windows::ApplicationModel::Contacts::ContactListSyncManager* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Contacts.ContactListSyncManager", L"LastAttemptedSyncTime"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::DateTime>(arg);

            self->obj.LastAttemptedSyncTime(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ContactListSyncManager_add_SyncStatusChanged(py::wrapper::Windows::ApplicationModel::Contacts::ContactListSyncManager* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.ApplicationModel.Contacts.ContactListSyncManager", L"SyncStatusChanged"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::ApplicationModel::Contacts::ContactListSyncManager, winrt::Windows::Foundation::IInspectable>>(arg);

            return py::convert(self->obj.SyncStatusChanged(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ContactListSyncManager_remove_SyncStatusChanged(py::wrapper::Windows::ApplicationModel::Contacts::ContactListSyncManager* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.ApplicationModel.Contacts.ContactListSyncManager", L"SyncStatusChanged"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.SyncStatusChanged(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_ContactListSyncManager(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::ApplicationModel::Contacts::ContactListSyncManager>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_ContactListSyncManager(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::Contacts::ContactListSyncManager>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_ContactListSyncManager[] = {
        { "sync_async", reinterpret_cast<PyCFunction>(ContactListSyncManager_SyncAsync), METH_VARARGS, nullptr },
        { "add_sync_status_changed", reinterpret_cast<PyCFunction>(ContactListSyncManager_add_SyncStatusChanged), METH_O, nullptr },
        { "remove_sync_status_changed", reinterpret_cast<PyCFunction>(ContactListSyncManager_remove_SyncStatusChanged), METH_O, nullptr },
        { "_assign_array_", _assign_array_ContactListSyncManager, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_ContactListSyncManager), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_ContactListSyncManager[] = {
        { "status", reinterpret_cast<getter>(ContactListSyncManager_get_Status), reinterpret_cast<setter>(ContactListSyncManager_put_Status), nullptr, nullptr },
        { "last_successful_sync_time", reinterpret_cast<getter>(ContactListSyncManager_get_LastSuccessfulSyncTime), reinterpret_cast<setter>(ContactListSyncManager_put_LastSuccessfulSyncTime), nullptr, nullptr },
        { "last_attempted_sync_time", reinterpret_cast<getter>(ContactListSyncManager_get_LastAttemptedSyncTime), reinterpret_cast<setter>(ContactListSyncManager_put_LastAttemptedSyncTime), nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_ContactListSyncManager[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_ContactListSyncManager) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_ContactListSyncManager) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_ContactListSyncManager) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_ContactListSyncManager) },
        { },
    };

    static PyType_Spec type_spec_ContactListSyncManager =
    {
        "_winrt_windows_applicationmodel_contacts.ContactListSyncManager",
        sizeof(py::wrapper::Windows::ApplicationModel::Contacts::ContactListSyncManager),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_ContactListSyncManager
    };

    // ----- ContactLocationField class --------------------

    static PyObject* _new_ContactLocationField(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                winrt::Windows::ApplicationModel::Contacts::ContactLocationField instance{ param0 };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::ApplicationModel::Contacts::ContactFieldCategory>(args, 1);

                winrt::Windows::ApplicationModel::Contacts::ContactLocationField instance{ param0, param1 };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 7)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::ApplicationModel::Contacts::ContactFieldCategory>(args, 1);
                auto param2 = py::convert_to<winrt::hstring>(args, 2);
                auto param3 = py::convert_to<winrt::hstring>(args, 3);
                auto param4 = py::convert_to<winrt::hstring>(args, 4);
                auto param5 = py::convert_to<winrt::hstring>(args, 5);
                auto param6 = py::convert_to<winrt::hstring>(args, 6);

                winrt::Windows::ApplicationModel::Contacts::ContactLocationField instance{ param0, param1, param2, param3, param4, param5, param6 };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_ContactLocationField(py::wrapper::Windows::ApplicationModel::Contacts::ContactLocationField* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* ContactLocationField_get_Category(py::wrapper::Windows::ApplicationModel::Contacts::ContactLocationField* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Contacts.ContactLocationField", L"Category"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Category());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ContactLocationField_get_Name(py::wrapper::Windows::ApplicationModel::Contacts::ContactLocationField* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Contacts.ContactLocationField", L"Name"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Name());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ContactLocationField_get_Type(py::wrapper::Windows::ApplicationModel::Contacts::ContactLocationField* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Contacts.ContactLocationField", L"Type"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Type());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ContactLocationField_get_Value(py::wrapper::Windows::ApplicationModel::Contacts::ContactLocationField* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Contacts.ContactLocationField", L"Value"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Value());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ContactLocationField_get_City(py::wrapper::Windows::ApplicationModel::Contacts::ContactLocationField* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Contacts.ContactLocationField", L"City"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.City());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ContactLocationField_get_Country(py::wrapper::Windows::ApplicationModel::Contacts::ContactLocationField* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Contacts.ContactLocationField", L"Country"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Country());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ContactLocationField_get_PostalCode(py::wrapper::Windows::ApplicationModel::Contacts::ContactLocationField* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Contacts.ContactLocationField", L"PostalCode"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.PostalCode());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ContactLocationField_get_Region(py::wrapper::Windows::ApplicationModel::Contacts::ContactLocationField* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Contacts.ContactLocationField", L"Region"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Region());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ContactLocationField_get_Street(py::wrapper::Windows::ApplicationModel::Contacts::ContactLocationField* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Contacts.ContactLocationField", L"Street"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Street());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ContactLocationField_get_UnstructuredAddress(py::wrapper::Windows::ApplicationModel::Contacts::ContactLocationField* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Contacts.ContactLocationField", L"UnstructuredAddress"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.UnstructuredAddress());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_ContactLocationField(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::ApplicationModel::Contacts::ContactLocationField>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_ContactLocationField(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::Contacts::ContactLocationField>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_ContactLocationField[] = {
        { "_assign_array_", _assign_array_ContactLocationField, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_ContactLocationField), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_ContactLocationField[] = {
        { "category", reinterpret_cast<getter>(ContactLocationField_get_Category), nullptr, nullptr, nullptr },
        { "name", reinterpret_cast<getter>(ContactLocationField_get_Name), nullptr, nullptr, nullptr },
        { "type", reinterpret_cast<getter>(ContactLocationField_get_Type), nullptr, nullptr, nullptr },
        { "value", reinterpret_cast<getter>(ContactLocationField_get_Value), nullptr, nullptr, nullptr },
        { "city", reinterpret_cast<getter>(ContactLocationField_get_City), nullptr, nullptr, nullptr },
        { "country", reinterpret_cast<getter>(ContactLocationField_get_Country), nullptr, nullptr, nullptr },
        { "postal_code", reinterpret_cast<getter>(ContactLocationField_get_PostalCode), nullptr, nullptr, nullptr },
        { "region", reinterpret_cast<getter>(ContactLocationField_get_Region), nullptr, nullptr, nullptr },
        { "street", reinterpret_cast<getter>(ContactLocationField_get_Street), nullptr, nullptr, nullptr },
        { "unstructured_address", reinterpret_cast<getter>(ContactLocationField_get_UnstructuredAddress), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_ContactLocationField[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_ContactLocationField) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_ContactLocationField) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_ContactLocationField) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_ContactLocationField) },
        { },
    };

    static PyType_Spec type_spec_ContactLocationField =
    {
        "_winrt_windows_applicationmodel_contacts.ContactLocationField",
        sizeof(py::wrapper::Windows::ApplicationModel::Contacts::ContactLocationField),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_ContactLocationField
    };

    // ----- ContactManager class --------------------

    static PyObject* _new_ContactManager(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::ApplicationModel::Contacts::ContactManager>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::ApplicationModel::Contacts::ContactManager>::type_name);
        return nullptr;
    }

    static PyObject* ContactManager_ConvertContactToVCardAsync(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.ApplicationModel.Contacts.ContactManager", L"ConvertContactToVCardAsync", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::ApplicationModel::Contacts::Contact>(args, 0);

                return py::convert(winrt::Windows::ApplicationModel::Contacts::ContactManager::ConvertContactToVCardAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 2)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.ApplicationModel.Contacts.ContactManager", L"ConvertContactToVCardAsync", 2))
            {
                py::set_arg_count_version_error(2);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::ApplicationModel::Contacts::Contact>(args, 0);
                auto param1 = py::convert_to<uint32_t>(args, 1);

                return py::convert(winrt::Windows::ApplicationModel::Contacts::ContactManager::ConvertContactToVCardAsync(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ContactManager_ConvertVCardToContactAsync(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.ApplicationModel.Contacts.ContactManager", L"ConvertVCardToContactAsync", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::Storage::Streams::IRandomAccessStreamReference>(args, 0);

                return py::convert(winrt::Windows::ApplicationModel::Contacts::ContactManager::ConvertVCardToContactAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ContactManager_GetForUser(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.ApplicationModel.Contacts.ContactManager", L"GetForUser", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::System::User>(args, 0);

                return py::convert(winrt::Windows::ApplicationModel::Contacts::ContactManager::GetForUser(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ContactManager_IsShowContactCardSupported(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.ApplicationModel.Contacts.ContactManager", L"IsShowContactCardSupported", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(winrt::Windows::ApplicationModel::Contacts::ContactManager::IsShowContactCardSupported());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ContactManager_IsShowDelayLoadedContactCardSupported(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.ApplicationModel.Contacts.ContactManager", L"IsShowDelayLoadedContactCardSupported", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(winrt::Windows::ApplicationModel::Contacts::ContactManager::IsShowDelayLoadedContactCardSupported());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ContactManager_IsShowFullContactCardSupportedAsync(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.ApplicationModel.Contacts.ContactManager", L"IsShowFullContactCardSupportedAsync", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(winrt::Windows::ApplicationModel::Contacts::ContactManager::IsShowFullContactCardSupportedAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ContactManager_RequestAnnotationStoreAsync(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.ApplicationModel.Contacts.ContactManager", L"RequestAnnotationStoreAsync", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::ApplicationModel::Contacts::ContactAnnotationStoreAccessType>(args, 0);

                return py::convert(winrt::Windows::ApplicationModel::Contacts::ContactManager::RequestAnnotationStoreAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ContactManager_RequestStoreAsync(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.ApplicationModel.Contacts.ContactManager", L"RequestStoreAsync", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(winrt::Windows::ApplicationModel::Contacts::ContactManager::RequestStoreAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.ApplicationModel.Contacts.ContactManager", L"RequestStoreAsync", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::ApplicationModel::Contacts::ContactStoreAccessType>(args, 0);

                return py::convert(winrt::Windows::ApplicationModel::Contacts::ContactManager::RequestStoreAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ContactManager_ShowContactCard(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.ApplicationModel.Contacts.ContactManager", L"ShowContactCard", 2))
            {
                py::set_arg_count_version_error(2);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::ApplicationModel::Contacts::Contact>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Foundation::Rect>(args, 1);

                winrt::Windows::ApplicationModel::Contacts::ContactManager::ShowContactCard(param0, param1);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 3)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.ApplicationModel.Contacts.ContactManager", L"ShowContactCard", 3))
            {
                py::set_arg_count_version_error(3);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::ApplicationModel::Contacts::Contact>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Foundation::Rect>(args, 1);
                auto param2 = py::convert_to<winrt::Windows::UI::Popups::Placement>(args, 2);

                winrt::Windows::ApplicationModel::Contacts::ContactManager::ShowContactCard(param0, param1, param2);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 4)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.ApplicationModel.Contacts.ContactManager", L"ShowContactCard", 4))
            {
                py::set_arg_count_version_error(4);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::ApplicationModel::Contacts::Contact>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Foundation::Rect>(args, 1);
                auto param2 = py::convert_to<winrt::Windows::UI::Popups::Placement>(args, 2);
                auto param3 = py::convert_to<winrt::Windows::ApplicationModel::Contacts::ContactCardOptions>(args, 3);

                winrt::Windows::ApplicationModel::Contacts::ContactManager::ShowContactCard(param0, param1, param2, param3);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ContactManager_ShowDelayLoadedContactCard(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 3)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.ApplicationModel.Contacts.ContactManager", L"ShowDelayLoadedContactCard", 3))
            {
                py::set_arg_count_version_error(3);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::ApplicationModel::Contacts::Contact>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Foundation::Rect>(args, 1);
                auto param2 = py::convert_to<winrt::Windows::UI::Popups::Placement>(args, 2);

                return py::convert(winrt::Windows::ApplicationModel::Contacts::ContactManager::ShowDelayLoadedContactCard(param0, param1, param2));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 4)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.ApplicationModel.Contacts.ContactManager", L"ShowDelayLoadedContactCard", 4))
            {
                py::set_arg_count_version_error(4);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::ApplicationModel::Contacts::Contact>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Foundation::Rect>(args, 1);
                auto param2 = py::convert_to<winrt::Windows::UI::Popups::Placement>(args, 2);
                auto param3 = py::convert_to<winrt::Windows::ApplicationModel::Contacts::ContactCardOptions>(args, 3);

                return py::convert(winrt::Windows::ApplicationModel::Contacts::ContactManager::ShowDelayLoadedContactCard(param0, param1, param2, param3));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ContactManager_ShowFullContactCard(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.ApplicationModel.Contacts.ContactManager", L"ShowFullContactCard", 2))
            {
                py::set_arg_count_version_error(2);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::ApplicationModel::Contacts::Contact>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::ApplicationModel::Contacts::FullContactCardOptions>(args, 1);

                winrt::Windows::ApplicationModel::Contacts::ContactManager::ShowFullContactCard(param0, param1);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ContactManager_get_SystemSortOrder(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Contacts.ContactManager", L"SystemSortOrder"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Windows::ApplicationModel::Contacts::ContactManager::SystemSortOrder());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ContactManager_put_SystemSortOrder(PyObject* /*unused*/, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Contacts.ContactManager", L"SystemSortOrder"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::ApplicationModel::Contacts::ContactNameOrder>(arg);

            winrt::Windows::ApplicationModel::Contacts::ContactManager::SystemSortOrder(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ContactManager_get_SystemDisplayNameOrder(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Contacts.ContactManager", L"SystemDisplayNameOrder"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Windows::ApplicationModel::Contacts::ContactManager::SystemDisplayNameOrder());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ContactManager_put_SystemDisplayNameOrder(PyObject* /*unused*/, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Contacts.ContactManager", L"SystemDisplayNameOrder"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::ApplicationModel::Contacts::ContactNameOrder>(arg);

            winrt::Windows::ApplicationModel::Contacts::ContactManager::SystemDisplayNameOrder(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ContactManager_get_IncludeMiddleNameInSystemDisplayAndSort(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Contacts.ContactManager", L"IncludeMiddleNameInSystemDisplayAndSort"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Windows::ApplicationModel::Contacts::ContactManager::IncludeMiddleNameInSystemDisplayAndSort());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ContactManager_put_IncludeMiddleNameInSystemDisplayAndSort(PyObject* /*unused*/, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Contacts.ContactManager", L"IncludeMiddleNameInSystemDisplayAndSort"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<bool>(arg);

            winrt::Windows::ApplicationModel::Contacts::ContactManager::IncludeMiddleNameInSystemDisplayAndSort(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyMethodDef _methods_ContactManager[] = {
        { "convert_contact_to_v_card_async", reinterpret_cast<PyCFunction>(ContactManager_ConvertContactToVCardAsync), METH_VARARGS | METH_STATIC, nullptr },
        { "convert_v_card_to_contact_async", reinterpret_cast<PyCFunction>(ContactManager_ConvertVCardToContactAsync), METH_VARARGS | METH_STATIC, nullptr },
        { "get_for_user", reinterpret_cast<PyCFunction>(ContactManager_GetForUser), METH_VARARGS | METH_STATIC, nullptr },
        { "is_show_contact_card_supported", reinterpret_cast<PyCFunction>(ContactManager_IsShowContactCardSupported), METH_VARARGS | METH_STATIC, nullptr },
        { "is_show_delay_loaded_contact_card_supported", reinterpret_cast<PyCFunction>(ContactManager_IsShowDelayLoadedContactCardSupported), METH_VARARGS | METH_STATIC, nullptr },
        { "is_show_full_contact_card_supported_async", reinterpret_cast<PyCFunction>(ContactManager_IsShowFullContactCardSupportedAsync), METH_VARARGS | METH_STATIC, nullptr },
        { "request_annotation_store_async", reinterpret_cast<PyCFunction>(ContactManager_RequestAnnotationStoreAsync), METH_VARARGS | METH_STATIC, nullptr },
        { "request_store_async", reinterpret_cast<PyCFunction>(ContactManager_RequestStoreAsync), METH_VARARGS | METH_STATIC, nullptr },
        { "show_contact_card", reinterpret_cast<PyCFunction>(ContactManager_ShowContactCard), METH_VARARGS | METH_STATIC, nullptr },
        { "show_delay_loaded_contact_card", reinterpret_cast<PyCFunction>(ContactManager_ShowDelayLoadedContactCard), METH_VARARGS | METH_STATIC, nullptr },
        { "show_full_contact_card", reinterpret_cast<PyCFunction>(ContactManager_ShowFullContactCard), METH_VARARGS | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_ContactManager[] = {
        { }
    };

    static PyType_Slot _type_slots_ContactManager[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_ContactManager) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_ContactManager) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_ContactManager) },
        { },
    };

    static PyType_Spec type_spec_ContactManager =
    {
        "_winrt_windows_applicationmodel_contacts.ContactManager",
        0,
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_ContactManager
    };

    static PyGetSetDef getset_ContactManager_Meta[] = {
        { "system_sort_order", reinterpret_cast<getter>(ContactManager_get_SystemSortOrder), reinterpret_cast<setter>(ContactManager_put_SystemSortOrder), nullptr, nullptr },
        { "system_display_name_order", reinterpret_cast<getter>(ContactManager_get_SystemDisplayNameOrder), reinterpret_cast<setter>(ContactManager_put_SystemDisplayNameOrder), nullptr, nullptr },
        { "include_middle_name_in_system_display_and_sort", reinterpret_cast<getter>(ContactManager_get_IncludeMiddleNameInSystemDisplayAndSort), reinterpret_cast<setter>(ContactManager_put_IncludeMiddleNameInSystemDisplayAndSort), nullptr, nullptr },
        { }
    };

    static PyType_Slot type_slots_ContactManager_Meta[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_ContactManager_Meta) },
        { }
    };

    static PyType_Spec type_spec_ContactManager_Meta =
    {
        "_winrt_windows_applicationmodel_contacts.ContactManager_Meta",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT,
        type_slots_ContactManager_Meta
    };

    // ----- ContactManagerForUser class --------------------

    static PyObject* _new_ContactManagerForUser(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::ApplicationModel::Contacts::ContactManagerForUser>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::ApplicationModel::Contacts::ContactManagerForUser>::type_name);
        return nullptr;
    }

    static void _dealloc_ContactManagerForUser(py::wrapper::Windows::ApplicationModel::Contacts::ContactManagerForUser* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* ContactManagerForUser_ConvertContactToVCardAsync(py::wrapper::Windows::ApplicationModel::Contacts::ContactManagerForUser* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.ApplicationModel.Contacts.ContactManagerForUser", L"ConvertContactToVCardAsync", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::ApplicationModel::Contacts::Contact>(args, 0);

                return py::convert(self->obj.ConvertContactToVCardAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 2)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.ApplicationModel.Contacts.ContactManagerForUser", L"ConvertContactToVCardAsync", 2))
            {
                py::set_arg_count_version_error(2);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::ApplicationModel::Contacts::Contact>(args, 0);
                auto param1 = py::convert_to<uint32_t>(args, 1);

                return py::convert(self->obj.ConvertContactToVCardAsync(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ContactManagerForUser_ConvertVCardToContactAsync(py::wrapper::Windows::ApplicationModel::Contacts::ContactManagerForUser* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.ApplicationModel.Contacts.ContactManagerForUser", L"ConvertVCardToContactAsync", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::Storage::Streams::IRandomAccessStreamReference>(args, 0);

                return py::convert(self->obj.ConvertVCardToContactAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ContactManagerForUser_RequestAnnotationStoreAsync(py::wrapper::Windows::ApplicationModel::Contacts::ContactManagerForUser* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.ApplicationModel.Contacts.ContactManagerForUser", L"RequestAnnotationStoreAsync", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::ApplicationModel::Contacts::ContactAnnotationStoreAccessType>(args, 0);

                return py::convert(self->obj.RequestAnnotationStoreAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ContactManagerForUser_RequestStoreAsync(py::wrapper::Windows::ApplicationModel::Contacts::ContactManagerForUser* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.ApplicationModel.Contacts.ContactManagerForUser", L"RequestStoreAsync", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::ApplicationModel::Contacts::ContactStoreAccessType>(args, 0);

                return py::convert(self->obj.RequestStoreAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ContactManagerForUser_ShowFullContactCard(py::wrapper::Windows::ApplicationModel::Contacts::ContactManagerForUser* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.ApplicationModel.Contacts.ContactManagerForUser", L"ShowFullContactCard", 2))
            {
                py::set_arg_count_version_error(2);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::ApplicationModel::Contacts::Contact>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::ApplicationModel::Contacts::FullContactCardOptions>(args, 1);

                self->obj.ShowFullContactCard(param0, param1);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ContactManagerForUser_get_SystemSortOrder(py::wrapper::Windows::ApplicationModel::Contacts::ContactManagerForUser* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Contacts.ContactManagerForUser", L"SystemSortOrder"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.SystemSortOrder());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ContactManagerForUser_put_SystemSortOrder(py::wrapper::Windows::ApplicationModel::Contacts::ContactManagerForUser* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Contacts.ContactManagerForUser", L"SystemSortOrder"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::ApplicationModel::Contacts::ContactNameOrder>(arg);

            self->obj.SystemSortOrder(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ContactManagerForUser_get_SystemDisplayNameOrder(py::wrapper::Windows::ApplicationModel::Contacts::ContactManagerForUser* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Contacts.ContactManagerForUser", L"SystemDisplayNameOrder"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.SystemDisplayNameOrder());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ContactManagerForUser_put_SystemDisplayNameOrder(py::wrapper::Windows::ApplicationModel::Contacts::ContactManagerForUser* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Contacts.ContactManagerForUser", L"SystemDisplayNameOrder"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::ApplicationModel::Contacts::ContactNameOrder>(arg);

            self->obj.SystemDisplayNameOrder(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ContactManagerForUser_get_User(py::wrapper::Windows::ApplicationModel::Contacts::ContactManagerForUser* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Contacts.ContactManagerForUser", L"User"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.User());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_ContactManagerForUser(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::ApplicationModel::Contacts::ContactManagerForUser>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_ContactManagerForUser(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::Contacts::ContactManagerForUser>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_ContactManagerForUser[] = {
        { "convert_contact_to_v_card_async", reinterpret_cast<PyCFunction>(ContactManagerForUser_ConvertContactToVCardAsync), METH_VARARGS, nullptr },
        { "convert_v_card_to_contact_async", reinterpret_cast<PyCFunction>(ContactManagerForUser_ConvertVCardToContactAsync), METH_VARARGS, nullptr },
        { "request_annotation_store_async", reinterpret_cast<PyCFunction>(ContactManagerForUser_RequestAnnotationStoreAsync), METH_VARARGS, nullptr },
        { "request_store_async", reinterpret_cast<PyCFunction>(ContactManagerForUser_RequestStoreAsync), METH_VARARGS, nullptr },
        { "show_full_contact_card", reinterpret_cast<PyCFunction>(ContactManagerForUser_ShowFullContactCard), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_ContactManagerForUser, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_ContactManagerForUser), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_ContactManagerForUser[] = {
        { "system_sort_order", reinterpret_cast<getter>(ContactManagerForUser_get_SystemSortOrder), reinterpret_cast<setter>(ContactManagerForUser_put_SystemSortOrder), nullptr, nullptr },
        { "system_display_name_order", reinterpret_cast<getter>(ContactManagerForUser_get_SystemDisplayNameOrder), reinterpret_cast<setter>(ContactManagerForUser_put_SystemDisplayNameOrder), nullptr, nullptr },
        { "user", reinterpret_cast<getter>(ContactManagerForUser_get_User), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_ContactManagerForUser[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_ContactManagerForUser) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_ContactManagerForUser) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_ContactManagerForUser) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_ContactManagerForUser) },
        { },
    };

    static PyType_Spec type_spec_ContactManagerForUser =
    {
        "_winrt_windows_applicationmodel_contacts.ContactManagerForUser",
        sizeof(py::wrapper::Windows::ApplicationModel::Contacts::ContactManagerForUser),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_ContactManagerForUser
    };

    // ----- ContactMatchReason class --------------------

    static PyObject* _new_ContactMatchReason(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::ApplicationModel::Contacts::ContactMatchReason>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::ApplicationModel::Contacts::ContactMatchReason>::type_name);
        return nullptr;
    }

    static void _dealloc_ContactMatchReason(py::wrapper::Windows::ApplicationModel::Contacts::ContactMatchReason* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* ContactMatchReason_get_Field(py::wrapper::Windows::ApplicationModel::Contacts::ContactMatchReason* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Contacts.ContactMatchReason", L"Field"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Field());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ContactMatchReason_get_Segments(py::wrapper::Windows::ApplicationModel::Contacts::ContactMatchReason* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Contacts.ContactMatchReason", L"Segments"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Segments());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ContactMatchReason_get_Text(py::wrapper::Windows::ApplicationModel::Contacts::ContactMatchReason* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Contacts.ContactMatchReason", L"Text"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Text());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_ContactMatchReason(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::ApplicationModel::Contacts::ContactMatchReason>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_ContactMatchReason(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::Contacts::ContactMatchReason>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_ContactMatchReason[] = {
        { "_assign_array_", _assign_array_ContactMatchReason, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_ContactMatchReason), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_ContactMatchReason[] = {
        { "field", reinterpret_cast<getter>(ContactMatchReason_get_Field), nullptr, nullptr, nullptr },
        { "segments", reinterpret_cast<getter>(ContactMatchReason_get_Segments), nullptr, nullptr, nullptr },
        { "text", reinterpret_cast<getter>(ContactMatchReason_get_Text), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_ContactMatchReason[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_ContactMatchReason) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_ContactMatchReason) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_ContactMatchReason) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_ContactMatchReason) },
        { },
    };

    static PyType_Spec type_spec_ContactMatchReason =
    {
        "_winrt_windows_applicationmodel_contacts.ContactMatchReason",
        sizeof(py::wrapper::Windows::ApplicationModel::Contacts::ContactMatchReason),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_ContactMatchReason
    };

    // ----- ContactPanel class --------------------

    static PyObject* _new_ContactPanel(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::ApplicationModel::Contacts::ContactPanel>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::ApplicationModel::Contacts::ContactPanel>::type_name);
        return nullptr;
    }

    static void _dealloc_ContactPanel(py::wrapper::Windows::ApplicationModel::Contacts::ContactPanel* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* ContactPanel_ClosePanel(py::wrapper::Windows::ApplicationModel::Contacts::ContactPanel* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.ApplicationModel.Contacts.ContactPanel", L"ClosePanel", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                self->obj.ClosePanel();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ContactPanel_get_HeaderColor(py::wrapper::Windows::ApplicationModel::Contacts::ContactPanel* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Contacts.ContactPanel", L"HeaderColor"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.HeaderColor());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ContactPanel_put_HeaderColor(py::wrapper::Windows::ApplicationModel::Contacts::ContactPanel* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Contacts.ContactPanel", L"HeaderColor"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::IReference<winrt::Windows::UI::Color>>(arg);

            self->obj.HeaderColor(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ContactPanel_add_Closing(py::wrapper::Windows::ApplicationModel::Contacts::ContactPanel* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.ApplicationModel.Contacts.ContactPanel", L"Closing"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::ApplicationModel::Contacts::ContactPanel, winrt::Windows::ApplicationModel::Contacts::ContactPanelClosingEventArgs>>(arg);

            return py::convert(self->obj.Closing(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ContactPanel_remove_Closing(py::wrapper::Windows::ApplicationModel::Contacts::ContactPanel* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.ApplicationModel.Contacts.ContactPanel", L"Closing"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.Closing(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ContactPanel_add_LaunchFullAppRequested(py::wrapper::Windows::ApplicationModel::Contacts::ContactPanel* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.ApplicationModel.Contacts.ContactPanel", L"LaunchFullAppRequested"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::ApplicationModel::Contacts::ContactPanel, winrt::Windows::ApplicationModel::Contacts::ContactPanelLaunchFullAppRequestedEventArgs>>(arg);

            return py::convert(self->obj.LaunchFullAppRequested(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ContactPanel_remove_LaunchFullAppRequested(py::wrapper::Windows::ApplicationModel::Contacts::ContactPanel* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.ApplicationModel.Contacts.ContactPanel", L"LaunchFullAppRequested"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.LaunchFullAppRequested(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_ContactPanel(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::ApplicationModel::Contacts::ContactPanel>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_ContactPanel(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::Contacts::ContactPanel>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_ContactPanel[] = {
        { "close_panel", reinterpret_cast<PyCFunction>(ContactPanel_ClosePanel), METH_VARARGS, nullptr },
        { "add_closing", reinterpret_cast<PyCFunction>(ContactPanel_add_Closing), METH_O, nullptr },
        { "remove_closing", reinterpret_cast<PyCFunction>(ContactPanel_remove_Closing), METH_O, nullptr },
        { "add_launch_full_app_requested", reinterpret_cast<PyCFunction>(ContactPanel_add_LaunchFullAppRequested), METH_O, nullptr },
        { "remove_launch_full_app_requested", reinterpret_cast<PyCFunction>(ContactPanel_remove_LaunchFullAppRequested), METH_O, nullptr },
        { "_assign_array_", _assign_array_ContactPanel, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_ContactPanel), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_ContactPanel[] = {
        { "header_color", reinterpret_cast<getter>(ContactPanel_get_HeaderColor), reinterpret_cast<setter>(ContactPanel_put_HeaderColor), nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_ContactPanel[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_ContactPanel) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_ContactPanel) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_ContactPanel) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_ContactPanel) },
        { },
    };

    static PyType_Spec type_spec_ContactPanel =
    {
        "_winrt_windows_applicationmodel_contacts.ContactPanel",
        sizeof(py::wrapper::Windows::ApplicationModel::Contacts::ContactPanel),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_ContactPanel
    };

    // ----- ContactPanelClosingEventArgs class --------------------

    static PyObject* _new_ContactPanelClosingEventArgs(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::ApplicationModel::Contacts::ContactPanelClosingEventArgs>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::ApplicationModel::Contacts::ContactPanelClosingEventArgs>::type_name);
        return nullptr;
    }

    static void _dealloc_ContactPanelClosingEventArgs(py::wrapper::Windows::ApplicationModel::Contacts::ContactPanelClosingEventArgs* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* ContactPanelClosingEventArgs_GetDeferral(py::wrapper::Windows::ApplicationModel::Contacts::ContactPanelClosingEventArgs* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.ApplicationModel.Contacts.ContactPanelClosingEventArgs", L"GetDeferral", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(self->obj.GetDeferral());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* _assign_array_ContactPanelClosingEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::ApplicationModel::Contacts::ContactPanelClosingEventArgs>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_ContactPanelClosingEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::Contacts::ContactPanelClosingEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_ContactPanelClosingEventArgs[] = {
        { "get_deferral", reinterpret_cast<PyCFunction>(ContactPanelClosingEventArgs_GetDeferral), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_ContactPanelClosingEventArgs, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_ContactPanelClosingEventArgs), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_ContactPanelClosingEventArgs[] = {
        { }
    };

    static PyType_Slot _type_slots_ContactPanelClosingEventArgs[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_ContactPanelClosingEventArgs) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_ContactPanelClosingEventArgs) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_ContactPanelClosingEventArgs) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_ContactPanelClosingEventArgs) },
        { },
    };

    static PyType_Spec type_spec_ContactPanelClosingEventArgs =
    {
        "_winrt_windows_applicationmodel_contacts.ContactPanelClosingEventArgs",
        sizeof(py::wrapper::Windows::ApplicationModel::Contacts::ContactPanelClosingEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_ContactPanelClosingEventArgs
    };

    // ----- ContactPanelLaunchFullAppRequestedEventArgs class --------------------

    static PyObject* _new_ContactPanelLaunchFullAppRequestedEventArgs(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::ApplicationModel::Contacts::ContactPanelLaunchFullAppRequestedEventArgs>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::ApplicationModel::Contacts::ContactPanelLaunchFullAppRequestedEventArgs>::type_name);
        return nullptr;
    }

    static void _dealloc_ContactPanelLaunchFullAppRequestedEventArgs(py::wrapper::Windows::ApplicationModel::Contacts::ContactPanelLaunchFullAppRequestedEventArgs* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* ContactPanelLaunchFullAppRequestedEventArgs_get_Handled(py::wrapper::Windows::ApplicationModel::Contacts::ContactPanelLaunchFullAppRequestedEventArgs* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Contacts.ContactPanelLaunchFullAppRequestedEventArgs", L"Handled"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Handled());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ContactPanelLaunchFullAppRequestedEventArgs_put_Handled(py::wrapper::Windows::ApplicationModel::Contacts::ContactPanelLaunchFullAppRequestedEventArgs* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Contacts.ContactPanelLaunchFullAppRequestedEventArgs", L"Handled"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<bool>(arg);

            self->obj.Handled(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* _assign_array_ContactPanelLaunchFullAppRequestedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::ApplicationModel::Contacts::ContactPanelLaunchFullAppRequestedEventArgs>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_ContactPanelLaunchFullAppRequestedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::Contacts::ContactPanelLaunchFullAppRequestedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_ContactPanelLaunchFullAppRequestedEventArgs[] = {
        { "_assign_array_", _assign_array_ContactPanelLaunchFullAppRequestedEventArgs, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_ContactPanelLaunchFullAppRequestedEventArgs), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_ContactPanelLaunchFullAppRequestedEventArgs[] = {
        { "handled", reinterpret_cast<getter>(ContactPanelLaunchFullAppRequestedEventArgs_get_Handled), reinterpret_cast<setter>(ContactPanelLaunchFullAppRequestedEventArgs_put_Handled), nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_ContactPanelLaunchFullAppRequestedEventArgs[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_ContactPanelLaunchFullAppRequestedEventArgs) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_ContactPanelLaunchFullAppRequestedEventArgs) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_ContactPanelLaunchFullAppRequestedEventArgs) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_ContactPanelLaunchFullAppRequestedEventArgs) },
        { },
    };

    static PyType_Spec type_spec_ContactPanelLaunchFullAppRequestedEventArgs =
    {
        "_winrt_windows_applicationmodel_contacts.ContactPanelLaunchFullAppRequestedEventArgs",
        sizeof(py::wrapper::Windows::ApplicationModel::Contacts::ContactPanelLaunchFullAppRequestedEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_ContactPanelLaunchFullAppRequestedEventArgs
    };

    // ----- ContactPhone class --------------------

    static PyObject* _new_ContactPhone(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 0)
        {
            try
            {
                winrt::Windows::ApplicationModel::Contacts::ContactPhone instance{  };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_ContactPhone(py::wrapper::Windows::ApplicationModel::Contacts::ContactPhone* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* ContactPhone_get_Number(py::wrapper::Windows::ApplicationModel::Contacts::ContactPhone* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Contacts.ContactPhone", L"Number"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Number());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ContactPhone_put_Number(py::wrapper::Windows::ApplicationModel::Contacts::ContactPhone* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Contacts.ContactPhone", L"Number"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.Number(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ContactPhone_get_Kind(py::wrapper::Windows::ApplicationModel::Contacts::ContactPhone* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Contacts.ContactPhone", L"Kind"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Kind());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ContactPhone_put_Kind(py::wrapper::Windows::ApplicationModel::Contacts::ContactPhone* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Contacts.ContactPhone", L"Kind"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::ApplicationModel::Contacts::ContactPhoneKind>(arg);

            self->obj.Kind(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ContactPhone_get_Description(py::wrapper::Windows::ApplicationModel::Contacts::ContactPhone* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Contacts.ContactPhone", L"Description"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Description());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ContactPhone_put_Description(py::wrapper::Windows::ApplicationModel::Contacts::ContactPhone* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Contacts.ContactPhone", L"Description"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.Description(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* _assign_array_ContactPhone(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::ApplicationModel::Contacts::ContactPhone>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_ContactPhone(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::Contacts::ContactPhone>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_ContactPhone[] = {
        { "_assign_array_", _assign_array_ContactPhone, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_ContactPhone), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_ContactPhone[] = {
        { "number", reinterpret_cast<getter>(ContactPhone_get_Number), reinterpret_cast<setter>(ContactPhone_put_Number), nullptr, nullptr },
        { "kind", reinterpret_cast<getter>(ContactPhone_get_Kind), reinterpret_cast<setter>(ContactPhone_put_Kind), nullptr, nullptr },
        { "description", reinterpret_cast<getter>(ContactPhone_get_Description), reinterpret_cast<setter>(ContactPhone_put_Description), nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_ContactPhone[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_ContactPhone) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_ContactPhone) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_ContactPhone) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_ContactPhone) },
        { },
    };

    static PyType_Spec type_spec_ContactPhone =
    {
        "_winrt_windows_applicationmodel_contacts.ContactPhone",
        sizeof(py::wrapper::Windows::ApplicationModel::Contacts::ContactPhone),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_ContactPhone
    };

    // ----- ContactPicker class --------------------

    static PyObject* _new_ContactPicker(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 0)
        {
            try
            {
                winrt::Windows::ApplicationModel::Contacts::ContactPicker instance{  };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_ContactPicker(py::wrapper::Windows::ApplicationModel::Contacts::ContactPicker* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* ContactPicker_CreateForUser(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.ApplicationModel.Contacts.ContactPicker", L"CreateForUser", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::System::User>(args, 0);

                return py::convert(winrt::Windows::ApplicationModel::Contacts::ContactPicker::CreateForUser(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ContactPicker_IsSupportedAsync(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.ApplicationModel.Contacts.ContactPicker", L"IsSupportedAsync", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(winrt::Windows::ApplicationModel::Contacts::ContactPicker::IsSupportedAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ContactPicker_PickContactAsync(py::wrapper::Windows::ApplicationModel::Contacts::ContactPicker* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.ApplicationModel.Contacts.ContactPicker", L"PickContactAsync", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(self->obj.PickContactAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ContactPicker_PickContactsAsync(py::wrapper::Windows::ApplicationModel::Contacts::ContactPicker* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.ApplicationModel.Contacts.ContactPicker", L"PickContactsAsync", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(self->obj.PickContactsAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ContactPicker_PickMultipleContactsAsync(py::wrapper::Windows::ApplicationModel::Contacts::ContactPicker* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.ApplicationModel.Contacts.ContactPicker", L"PickMultipleContactsAsync", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(self->obj.PickMultipleContactsAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ContactPicker_PickSingleContactAsync(py::wrapper::Windows::ApplicationModel::Contacts::ContactPicker* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.ApplicationModel.Contacts.ContactPicker", L"PickSingleContactAsync", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(self->obj.PickSingleContactAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ContactPicker_get_SelectionMode(py::wrapper::Windows::ApplicationModel::Contacts::ContactPicker* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Contacts.ContactPicker", L"SelectionMode"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.SelectionMode());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ContactPicker_put_SelectionMode(py::wrapper::Windows::ApplicationModel::Contacts::ContactPicker* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Contacts.ContactPicker", L"SelectionMode"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::ApplicationModel::Contacts::ContactSelectionMode>(arg);

            self->obj.SelectionMode(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ContactPicker_get_CommitButtonText(py::wrapper::Windows::ApplicationModel::Contacts::ContactPicker* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Contacts.ContactPicker", L"CommitButtonText"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.CommitButtonText());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ContactPicker_put_CommitButtonText(py::wrapper::Windows::ApplicationModel::Contacts::ContactPicker* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Contacts.ContactPicker", L"CommitButtonText"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.CommitButtonText(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ContactPicker_get_DesiredFields(py::wrapper::Windows::ApplicationModel::Contacts::ContactPicker* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Contacts.ContactPicker", L"DesiredFields"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.DesiredFields());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ContactPicker_get_DesiredFieldsWithContactFieldType(py::wrapper::Windows::ApplicationModel::Contacts::ContactPicker* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Contacts.ContactPicker", L"DesiredFieldsWithContactFieldType"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.DesiredFieldsWithContactFieldType());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ContactPicker_get_User(py::wrapper::Windows::ApplicationModel::Contacts::ContactPicker* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Contacts.ContactPicker", L"User"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.User());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_ContactPicker(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::ApplicationModel::Contacts::ContactPicker>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_ContactPicker(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::Contacts::ContactPicker>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_ContactPicker[] = {
        { "create_for_user", reinterpret_cast<PyCFunction>(ContactPicker_CreateForUser), METH_VARARGS | METH_STATIC, nullptr },
        { "is_supported_async", reinterpret_cast<PyCFunction>(ContactPicker_IsSupportedAsync), METH_VARARGS | METH_STATIC, nullptr },
        { "pick_contact_async", reinterpret_cast<PyCFunction>(ContactPicker_PickContactAsync), METH_VARARGS, nullptr },
        { "pick_contacts_async", reinterpret_cast<PyCFunction>(ContactPicker_PickContactsAsync), METH_VARARGS, nullptr },
        { "pick_multiple_contacts_async", reinterpret_cast<PyCFunction>(ContactPicker_PickMultipleContactsAsync), METH_VARARGS, nullptr },
        { "pick_single_contact_async", reinterpret_cast<PyCFunction>(ContactPicker_PickSingleContactAsync), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_ContactPicker, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_ContactPicker), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_ContactPicker[] = {
        { "selection_mode", reinterpret_cast<getter>(ContactPicker_get_SelectionMode), reinterpret_cast<setter>(ContactPicker_put_SelectionMode), nullptr, nullptr },
        { "commit_button_text", reinterpret_cast<getter>(ContactPicker_get_CommitButtonText), reinterpret_cast<setter>(ContactPicker_put_CommitButtonText), nullptr, nullptr },
        { "desired_fields", reinterpret_cast<getter>(ContactPicker_get_DesiredFields), nullptr, nullptr, nullptr },
        { "desired_fields_with_contact_field_type", reinterpret_cast<getter>(ContactPicker_get_DesiredFieldsWithContactFieldType), nullptr, nullptr, nullptr },
        { "user", reinterpret_cast<getter>(ContactPicker_get_User), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_ContactPicker[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_ContactPicker) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_ContactPicker) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_ContactPicker) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_ContactPicker) },
        { },
    };

    static PyType_Spec type_spec_ContactPicker =
    {
        "_winrt_windows_applicationmodel_contacts.ContactPicker",
        sizeof(py::wrapper::Windows::ApplicationModel::Contacts::ContactPicker),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_ContactPicker
    };

    // ----- ContactQueryOptions class --------------------

    static PyObject* _new_ContactQueryOptions(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                winrt::Windows::ApplicationModel::Contacts::ContactQueryOptions instance{ param0 };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::ApplicationModel::Contacts::ContactQuerySearchFields>(args, 1);

                winrt::Windows::ApplicationModel::Contacts::ContactQueryOptions instance{ param0, param1 };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 0)
        {
            try
            {
                winrt::Windows::ApplicationModel::Contacts::ContactQueryOptions instance{  };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_ContactQueryOptions(py::wrapper::Windows::ApplicationModel::Contacts::ContactQueryOptions* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* ContactQueryOptions_get_IncludeContactsFromHiddenLists(py::wrapper::Windows::ApplicationModel::Contacts::ContactQueryOptions* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Contacts.ContactQueryOptions", L"IncludeContactsFromHiddenLists"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.IncludeContactsFromHiddenLists());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ContactQueryOptions_put_IncludeContactsFromHiddenLists(py::wrapper::Windows::ApplicationModel::Contacts::ContactQueryOptions* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Contacts.ContactQueryOptions", L"IncludeContactsFromHiddenLists"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<bool>(arg);

            self->obj.IncludeContactsFromHiddenLists(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ContactQueryOptions_get_DesiredOperations(py::wrapper::Windows::ApplicationModel::Contacts::ContactQueryOptions* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Contacts.ContactQueryOptions", L"DesiredOperations"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.DesiredOperations());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ContactQueryOptions_put_DesiredOperations(py::wrapper::Windows::ApplicationModel::Contacts::ContactQueryOptions* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Contacts.ContactQueryOptions", L"DesiredOperations"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::ApplicationModel::Contacts::ContactAnnotationOperations>(arg);

            self->obj.DesiredOperations(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ContactQueryOptions_get_DesiredFields(py::wrapper::Windows::ApplicationModel::Contacts::ContactQueryOptions* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Contacts.ContactQueryOptions", L"DesiredFields"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.DesiredFields());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ContactQueryOptions_put_DesiredFields(py::wrapper::Windows::ApplicationModel::Contacts::ContactQueryOptions* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Contacts.ContactQueryOptions", L"DesiredFields"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::ApplicationModel::Contacts::ContactQueryDesiredFields>(arg);

            self->obj.DesiredFields(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ContactQueryOptions_get_AnnotationListIds(py::wrapper::Windows::ApplicationModel::Contacts::ContactQueryOptions* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Contacts.ContactQueryOptions", L"AnnotationListIds"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.AnnotationListIds());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ContactQueryOptions_get_ContactListIds(py::wrapper::Windows::ApplicationModel::Contacts::ContactQueryOptions* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Contacts.ContactQueryOptions", L"ContactListIds"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.ContactListIds());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ContactQueryOptions_get_TextSearch(py::wrapper::Windows::ApplicationModel::Contacts::ContactQueryOptions* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Contacts.ContactQueryOptions", L"TextSearch"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.TextSearch());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_ContactQueryOptions(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::ApplicationModel::Contacts::ContactQueryOptions>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_ContactQueryOptions(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::Contacts::ContactQueryOptions>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_ContactQueryOptions[] = {
        { "_assign_array_", _assign_array_ContactQueryOptions, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_ContactQueryOptions), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_ContactQueryOptions[] = {
        { "include_contacts_from_hidden_lists", reinterpret_cast<getter>(ContactQueryOptions_get_IncludeContactsFromHiddenLists), reinterpret_cast<setter>(ContactQueryOptions_put_IncludeContactsFromHiddenLists), nullptr, nullptr },
        { "desired_operations", reinterpret_cast<getter>(ContactQueryOptions_get_DesiredOperations), reinterpret_cast<setter>(ContactQueryOptions_put_DesiredOperations), nullptr, nullptr },
        { "desired_fields", reinterpret_cast<getter>(ContactQueryOptions_get_DesiredFields), reinterpret_cast<setter>(ContactQueryOptions_put_DesiredFields), nullptr, nullptr },
        { "annotation_list_ids", reinterpret_cast<getter>(ContactQueryOptions_get_AnnotationListIds), nullptr, nullptr, nullptr },
        { "contact_list_ids", reinterpret_cast<getter>(ContactQueryOptions_get_ContactListIds), nullptr, nullptr, nullptr },
        { "text_search", reinterpret_cast<getter>(ContactQueryOptions_get_TextSearch), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_ContactQueryOptions[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_ContactQueryOptions) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_ContactQueryOptions) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_ContactQueryOptions) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_ContactQueryOptions) },
        { },
    };

    static PyType_Spec type_spec_ContactQueryOptions =
    {
        "_winrt_windows_applicationmodel_contacts.ContactQueryOptions",
        sizeof(py::wrapper::Windows::ApplicationModel::Contacts::ContactQueryOptions),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_ContactQueryOptions
    };

    // ----- ContactQueryTextSearch class --------------------

    static PyObject* _new_ContactQueryTextSearch(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::ApplicationModel::Contacts::ContactQueryTextSearch>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::ApplicationModel::Contacts::ContactQueryTextSearch>::type_name);
        return nullptr;
    }

    static void _dealloc_ContactQueryTextSearch(py::wrapper::Windows::ApplicationModel::Contacts::ContactQueryTextSearch* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* ContactQueryTextSearch_get_Text(py::wrapper::Windows::ApplicationModel::Contacts::ContactQueryTextSearch* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Contacts.ContactQueryTextSearch", L"Text"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Text());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ContactQueryTextSearch_put_Text(py::wrapper::Windows::ApplicationModel::Contacts::ContactQueryTextSearch* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Contacts.ContactQueryTextSearch", L"Text"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.Text(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ContactQueryTextSearch_get_SearchScope(py::wrapper::Windows::ApplicationModel::Contacts::ContactQueryTextSearch* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Contacts.ContactQueryTextSearch", L"SearchScope"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.SearchScope());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ContactQueryTextSearch_put_SearchScope(py::wrapper::Windows::ApplicationModel::Contacts::ContactQueryTextSearch* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Contacts.ContactQueryTextSearch", L"SearchScope"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::ApplicationModel::Contacts::ContactQuerySearchScope>(arg);

            self->obj.SearchScope(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ContactQueryTextSearch_get_Fields(py::wrapper::Windows::ApplicationModel::Contacts::ContactQueryTextSearch* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Contacts.ContactQueryTextSearch", L"Fields"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Fields());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ContactQueryTextSearch_put_Fields(py::wrapper::Windows::ApplicationModel::Contacts::ContactQueryTextSearch* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Contacts.ContactQueryTextSearch", L"Fields"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::ApplicationModel::Contacts::ContactQuerySearchFields>(arg);

            self->obj.Fields(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* _assign_array_ContactQueryTextSearch(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::ApplicationModel::Contacts::ContactQueryTextSearch>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_ContactQueryTextSearch(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::Contacts::ContactQueryTextSearch>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_ContactQueryTextSearch[] = {
        { "_assign_array_", _assign_array_ContactQueryTextSearch, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_ContactQueryTextSearch), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_ContactQueryTextSearch[] = {
        { "text", reinterpret_cast<getter>(ContactQueryTextSearch_get_Text), reinterpret_cast<setter>(ContactQueryTextSearch_put_Text), nullptr, nullptr },
        { "search_scope", reinterpret_cast<getter>(ContactQueryTextSearch_get_SearchScope), reinterpret_cast<setter>(ContactQueryTextSearch_put_SearchScope), nullptr, nullptr },
        { "fields", reinterpret_cast<getter>(ContactQueryTextSearch_get_Fields), reinterpret_cast<setter>(ContactQueryTextSearch_put_Fields), nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_ContactQueryTextSearch[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_ContactQueryTextSearch) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_ContactQueryTextSearch) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_ContactQueryTextSearch) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_ContactQueryTextSearch) },
        { },
    };

    static PyType_Spec type_spec_ContactQueryTextSearch =
    {
        "_winrt_windows_applicationmodel_contacts.ContactQueryTextSearch",
        sizeof(py::wrapper::Windows::ApplicationModel::Contacts::ContactQueryTextSearch),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_ContactQueryTextSearch
    };

    // ----- ContactReader class --------------------

    static PyObject* _new_ContactReader(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::ApplicationModel::Contacts::ContactReader>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::ApplicationModel::Contacts::ContactReader>::type_name);
        return nullptr;
    }

    static void _dealloc_ContactReader(py::wrapper::Windows::ApplicationModel::Contacts::ContactReader* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* ContactReader_GetMatchingPropertiesWithMatchReason(py::wrapper::Windows::ApplicationModel::Contacts::ContactReader* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.ApplicationModel.Contacts.ContactReader", L"GetMatchingPropertiesWithMatchReason", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::ApplicationModel::Contacts::Contact>(args, 0);

                return py::convert(self->obj.GetMatchingPropertiesWithMatchReason(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ContactReader_ReadBatchAsync(py::wrapper::Windows::ApplicationModel::Contacts::ContactReader* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.ApplicationModel.Contacts.ContactReader", L"ReadBatchAsync", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(self->obj.ReadBatchAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* _assign_array_ContactReader(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::ApplicationModel::Contacts::ContactReader>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_ContactReader(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::Contacts::ContactReader>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_ContactReader[] = {
        { "get_matching_properties_with_match_reason", reinterpret_cast<PyCFunction>(ContactReader_GetMatchingPropertiesWithMatchReason), METH_VARARGS, nullptr },
        { "read_batch_async", reinterpret_cast<PyCFunction>(ContactReader_ReadBatchAsync), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_ContactReader, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_ContactReader), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_ContactReader[] = {
        { }
    };

    static PyType_Slot _type_slots_ContactReader[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_ContactReader) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_ContactReader) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_ContactReader) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_ContactReader) },
        { },
    };

    static PyType_Spec type_spec_ContactReader =
    {
        "_winrt_windows_applicationmodel_contacts.ContactReader",
        sizeof(py::wrapper::Windows::ApplicationModel::Contacts::ContactReader),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_ContactReader
    };

    // ----- ContactSignificantOther class --------------------

    static PyObject* _new_ContactSignificantOther(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 0)
        {
            try
            {
                winrt::Windows::ApplicationModel::Contacts::ContactSignificantOther instance{  };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_ContactSignificantOther(py::wrapper::Windows::ApplicationModel::Contacts::ContactSignificantOther* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* ContactSignificantOther_get_Name(py::wrapper::Windows::ApplicationModel::Contacts::ContactSignificantOther* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Contacts.ContactSignificantOther", L"Name"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Name());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ContactSignificantOther_put_Name(py::wrapper::Windows::ApplicationModel::Contacts::ContactSignificantOther* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Contacts.ContactSignificantOther", L"Name"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.Name(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ContactSignificantOther_get_Description(py::wrapper::Windows::ApplicationModel::Contacts::ContactSignificantOther* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Contacts.ContactSignificantOther", L"Description"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Description());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ContactSignificantOther_put_Description(py::wrapper::Windows::ApplicationModel::Contacts::ContactSignificantOther* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Contacts.ContactSignificantOther", L"Description"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.Description(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ContactSignificantOther_get_Relationship(py::wrapper::Windows::ApplicationModel::Contacts::ContactSignificantOther* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Contacts.ContactSignificantOther", L"Relationship"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Relationship());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ContactSignificantOther_put_Relationship(py::wrapper::Windows::ApplicationModel::Contacts::ContactSignificantOther* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Contacts.ContactSignificantOther", L"Relationship"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::ApplicationModel::Contacts::ContactRelationship>(arg);

            self->obj.Relationship(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* _assign_array_ContactSignificantOther(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::ApplicationModel::Contacts::ContactSignificantOther>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_ContactSignificantOther(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::Contacts::ContactSignificantOther>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_ContactSignificantOther[] = {
        { "_assign_array_", _assign_array_ContactSignificantOther, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_ContactSignificantOther), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_ContactSignificantOther[] = {
        { "name", reinterpret_cast<getter>(ContactSignificantOther_get_Name), reinterpret_cast<setter>(ContactSignificantOther_put_Name), nullptr, nullptr },
        { "description", reinterpret_cast<getter>(ContactSignificantOther_get_Description), reinterpret_cast<setter>(ContactSignificantOther_put_Description), nullptr, nullptr },
        { "relationship", reinterpret_cast<getter>(ContactSignificantOther_get_Relationship), reinterpret_cast<setter>(ContactSignificantOther_put_Relationship), nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_ContactSignificantOther[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_ContactSignificantOther) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_ContactSignificantOther) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_ContactSignificantOther) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_ContactSignificantOther) },
        { },
    };

    static PyType_Spec type_spec_ContactSignificantOther =
    {
        "_winrt_windows_applicationmodel_contacts.ContactSignificantOther",
        sizeof(py::wrapper::Windows::ApplicationModel::Contacts::ContactSignificantOther),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_ContactSignificantOther
    };

    // ----- ContactStore class --------------------

    static PyObject* _new_ContactStore(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::ApplicationModel::Contacts::ContactStore>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::ApplicationModel::Contacts::ContactStore>::type_name);
        return nullptr;
    }

    static void _dealloc_ContactStore(py::wrapper::Windows::ApplicationModel::Contacts::ContactStore* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* ContactStore_CreateContactListAsync(py::wrapper::Windows::ApplicationModel::Contacts::ContactStore* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.ApplicationModel.Contacts.ContactStore", L"CreateContactListAsync", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                return py::convert(self->obj.CreateContactListAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 2)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.ApplicationModel.Contacts.ContactStore", L"CreateContactListAsync", 2))
            {
                py::set_arg_count_version_error(2);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::hstring>(args, 1);

                return py::convert(self->obj.CreateContactListAsync(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ContactStore_FindContactListsAsync(py::wrapper::Windows::ApplicationModel::Contacts::ContactStore* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.ApplicationModel.Contacts.ContactStore", L"FindContactListsAsync", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(self->obj.FindContactListsAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ContactStore_FindContactsAsync(py::wrapper::Windows::ApplicationModel::Contacts::ContactStore* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.ApplicationModel.Contacts.ContactStore", L"FindContactsAsync", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(self->obj.FindContactsAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.ApplicationModel.Contacts.ContactStore", L"FindContactsAsync", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                return py::convert(self->obj.FindContactsAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ContactStore_GetChangeTracker(py::wrapper::Windows::ApplicationModel::Contacts::ContactStore* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.ApplicationModel.Contacts.ContactStore", L"GetChangeTracker", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                return py::convert(self->obj.GetChangeTracker(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ContactStore_GetContactAsync(py::wrapper::Windows::ApplicationModel::Contacts::ContactStore* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.ApplicationModel.Contacts.ContactStore", L"GetContactAsync", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                return py::convert(self->obj.GetContactAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ContactStore_GetContactListAsync(py::wrapper::Windows::ApplicationModel::Contacts::ContactStore* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.ApplicationModel.Contacts.ContactStore", L"GetContactListAsync", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                return py::convert(self->obj.GetContactListAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ContactStore_GetContactReader(py::wrapper::Windows::ApplicationModel::Contacts::ContactStore* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.ApplicationModel.Contacts.ContactStore", L"GetContactReader", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(self->obj.GetContactReader());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.ApplicationModel.Contacts.ContactStore", L"GetContactReader", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::ApplicationModel::Contacts::ContactQueryOptions>(args, 0);

                return py::convert(self->obj.GetContactReader(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ContactStore_GetMeContactAsync(py::wrapper::Windows::ApplicationModel::Contacts::ContactStore* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.ApplicationModel.Contacts.ContactStore", L"GetMeContactAsync", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(self->obj.GetMeContactAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ContactStore_get_AggregateContactManager(py::wrapper::Windows::ApplicationModel::Contacts::ContactStore* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Contacts.ContactStore", L"AggregateContactManager"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.AggregateContactManager());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ContactStore_get_ChangeTracker(py::wrapper::Windows::ApplicationModel::Contacts::ContactStore* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Contacts.ContactStore", L"ChangeTracker"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.ChangeTracker());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ContactStore_add_ContactChanged(py::wrapper::Windows::ApplicationModel::Contacts::ContactStore* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.ApplicationModel.Contacts.ContactStore", L"ContactChanged"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::ApplicationModel::Contacts::ContactStore, winrt::Windows::ApplicationModel::Contacts::ContactChangedEventArgs>>(arg);

            return py::convert(self->obj.ContactChanged(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ContactStore_remove_ContactChanged(py::wrapper::Windows::ApplicationModel::Contacts::ContactStore* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.ApplicationModel.Contacts.ContactStore", L"ContactChanged"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.ContactChanged(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_ContactStore(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::ApplicationModel::Contacts::ContactStore>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_ContactStore(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::Contacts::ContactStore>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_ContactStore[] = {
        { "create_contact_list_async", reinterpret_cast<PyCFunction>(ContactStore_CreateContactListAsync), METH_VARARGS, nullptr },
        { "find_contact_lists_async", reinterpret_cast<PyCFunction>(ContactStore_FindContactListsAsync), METH_VARARGS, nullptr },
        { "find_contacts_async", reinterpret_cast<PyCFunction>(ContactStore_FindContactsAsync), METH_VARARGS, nullptr },
        { "get_change_tracker", reinterpret_cast<PyCFunction>(ContactStore_GetChangeTracker), METH_VARARGS, nullptr },
        { "get_contact_async", reinterpret_cast<PyCFunction>(ContactStore_GetContactAsync), METH_VARARGS, nullptr },
        { "get_contact_list_async", reinterpret_cast<PyCFunction>(ContactStore_GetContactListAsync), METH_VARARGS, nullptr },
        { "get_contact_reader", reinterpret_cast<PyCFunction>(ContactStore_GetContactReader), METH_VARARGS, nullptr },
        { "get_me_contact_async", reinterpret_cast<PyCFunction>(ContactStore_GetMeContactAsync), METH_VARARGS, nullptr },
        { "add_contact_changed", reinterpret_cast<PyCFunction>(ContactStore_add_ContactChanged), METH_O, nullptr },
        { "remove_contact_changed", reinterpret_cast<PyCFunction>(ContactStore_remove_ContactChanged), METH_O, nullptr },
        { "_assign_array_", _assign_array_ContactStore, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_ContactStore), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_ContactStore[] = {
        { "aggregate_contact_manager", reinterpret_cast<getter>(ContactStore_get_AggregateContactManager), nullptr, nullptr, nullptr },
        { "change_tracker", reinterpret_cast<getter>(ContactStore_get_ChangeTracker), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_ContactStore[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_ContactStore) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_ContactStore) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_ContactStore) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_ContactStore) },
        { },
    };

    static PyType_Spec type_spec_ContactStore =
    {
        "_winrt_windows_applicationmodel_contacts.ContactStore",
        sizeof(py::wrapper::Windows::ApplicationModel::Contacts::ContactStore),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_ContactStore
    };

    // ----- ContactStoreNotificationTriggerDetails class --------------------

    static PyObject* _new_ContactStoreNotificationTriggerDetails(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::ApplicationModel::Contacts::ContactStoreNotificationTriggerDetails>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::ApplicationModel::Contacts::ContactStoreNotificationTriggerDetails>::type_name);
        return nullptr;
    }

    static void _dealloc_ContactStoreNotificationTriggerDetails(py::wrapper::Windows::ApplicationModel::Contacts::ContactStoreNotificationTriggerDetails* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* _assign_array_ContactStoreNotificationTriggerDetails(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::ApplicationModel::Contacts::ContactStoreNotificationTriggerDetails>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_ContactStoreNotificationTriggerDetails(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::Contacts::ContactStoreNotificationTriggerDetails>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_ContactStoreNotificationTriggerDetails[] = {
        { "_assign_array_", _assign_array_ContactStoreNotificationTriggerDetails, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_ContactStoreNotificationTriggerDetails), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_ContactStoreNotificationTriggerDetails[] = {
        { }
    };

    static PyType_Slot _type_slots_ContactStoreNotificationTriggerDetails[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_ContactStoreNotificationTriggerDetails) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_ContactStoreNotificationTriggerDetails) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_ContactStoreNotificationTriggerDetails) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_ContactStoreNotificationTriggerDetails) },
        { },
    };

    static PyType_Spec type_spec_ContactStoreNotificationTriggerDetails =
    {
        "_winrt_windows_applicationmodel_contacts.ContactStoreNotificationTriggerDetails",
        sizeof(py::wrapper::Windows::ApplicationModel::Contacts::ContactStoreNotificationTriggerDetails),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_ContactStoreNotificationTriggerDetails
    };

    // ----- ContactWebsite class --------------------

    static PyObject* _new_ContactWebsite(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 0)
        {
            try
            {
                winrt::Windows::ApplicationModel::Contacts::ContactWebsite instance{  };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_ContactWebsite(py::wrapper::Windows::ApplicationModel::Contacts::ContactWebsite* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* ContactWebsite_get_Uri(py::wrapper::Windows::ApplicationModel::Contacts::ContactWebsite* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Contacts.ContactWebsite", L"Uri"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Uri());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ContactWebsite_put_Uri(py::wrapper::Windows::ApplicationModel::Contacts::ContactWebsite* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Contacts.ContactWebsite", L"Uri"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::Uri>(arg);

            self->obj.Uri(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ContactWebsite_get_Description(py::wrapper::Windows::ApplicationModel::Contacts::ContactWebsite* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Contacts.ContactWebsite", L"Description"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Description());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ContactWebsite_put_Description(py::wrapper::Windows::ApplicationModel::Contacts::ContactWebsite* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Contacts.ContactWebsite", L"Description"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.Description(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ContactWebsite_get_RawValue(py::wrapper::Windows::ApplicationModel::Contacts::ContactWebsite* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Contacts.ContactWebsite", L"RawValue"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.RawValue());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ContactWebsite_put_RawValue(py::wrapper::Windows::ApplicationModel::Contacts::ContactWebsite* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Contacts.ContactWebsite", L"RawValue"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.RawValue(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* _assign_array_ContactWebsite(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::ApplicationModel::Contacts::ContactWebsite>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_ContactWebsite(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::Contacts::ContactWebsite>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_ContactWebsite[] = {
        { "_assign_array_", _assign_array_ContactWebsite, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_ContactWebsite), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_ContactWebsite[] = {
        { "uri", reinterpret_cast<getter>(ContactWebsite_get_Uri), reinterpret_cast<setter>(ContactWebsite_put_Uri), nullptr, nullptr },
        { "description", reinterpret_cast<getter>(ContactWebsite_get_Description), reinterpret_cast<setter>(ContactWebsite_put_Description), nullptr, nullptr },
        { "raw_value", reinterpret_cast<getter>(ContactWebsite_get_RawValue), reinterpret_cast<setter>(ContactWebsite_put_RawValue), nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_ContactWebsite[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_ContactWebsite) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_ContactWebsite) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_ContactWebsite) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_ContactWebsite) },
        { },
    };

    static PyType_Spec type_spec_ContactWebsite =
    {
        "_winrt_windows_applicationmodel_contacts.ContactWebsite",
        sizeof(py::wrapper::Windows::ApplicationModel::Contacts::ContactWebsite),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_ContactWebsite
    };

    // ----- FullContactCardOptions class --------------------

    static PyObject* _new_FullContactCardOptions(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 0)
        {
            try
            {
                winrt::Windows::ApplicationModel::Contacts::FullContactCardOptions instance{  };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_FullContactCardOptions(py::wrapper::Windows::ApplicationModel::Contacts::FullContactCardOptions* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* FullContactCardOptions_get_DesiredRemainingView(py::wrapper::Windows::ApplicationModel::Contacts::FullContactCardOptions* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Contacts.FullContactCardOptions", L"DesiredRemainingView"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.DesiredRemainingView());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int FullContactCardOptions_put_DesiredRemainingView(py::wrapper::Windows::ApplicationModel::Contacts::FullContactCardOptions* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Contacts.FullContactCardOptions", L"DesiredRemainingView"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::UI::ViewManagement::ViewSizePreference>(arg);

            self->obj.DesiredRemainingView(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* _assign_array_FullContactCardOptions(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::ApplicationModel::Contacts::FullContactCardOptions>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_FullContactCardOptions(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::Contacts::FullContactCardOptions>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_FullContactCardOptions[] = {
        { "_assign_array_", _assign_array_FullContactCardOptions, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_FullContactCardOptions), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_FullContactCardOptions[] = {
        { "desired_remaining_view", reinterpret_cast<getter>(FullContactCardOptions_get_DesiredRemainingView), reinterpret_cast<setter>(FullContactCardOptions_put_DesiredRemainingView), nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_FullContactCardOptions[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_FullContactCardOptions) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_FullContactCardOptions) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_FullContactCardOptions) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_FullContactCardOptions) },
        { },
    };

    static PyType_Spec type_spec_FullContactCardOptions =
    {
        "_winrt_windows_applicationmodel_contacts.FullContactCardOptions",
        sizeof(py::wrapper::Windows::ApplicationModel::Contacts::FullContactCardOptions),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_FullContactCardOptions
    };

    // ----- KnownContactField class --------------------

    static PyObject* _new_KnownContactField(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::ApplicationModel::Contacts::KnownContactField>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::ApplicationModel::Contacts::KnownContactField>::type_name);
        return nullptr;
    }

    static PyObject* KnownContactField_ConvertNameToType(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.ApplicationModel.Contacts.KnownContactField", L"ConvertNameToType", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                return py::convert(winrt::Windows::ApplicationModel::Contacts::KnownContactField::ConvertNameToType(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* KnownContactField_ConvertTypeToName(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.ApplicationModel.Contacts.KnownContactField", L"ConvertTypeToName", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::ApplicationModel::Contacts::ContactFieldType>(args, 0);

                return py::convert(winrt::Windows::ApplicationModel::Contacts::KnownContactField::ConvertTypeToName(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* KnownContactField_get_Email(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Contacts.KnownContactField", L"Email"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Windows::ApplicationModel::Contacts::KnownContactField::Email());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* KnownContactField_get_InstantMessage(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Contacts.KnownContactField", L"InstantMessage"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Windows::ApplicationModel::Contacts::KnownContactField::InstantMessage());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* KnownContactField_get_Location(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Contacts.KnownContactField", L"Location"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Windows::ApplicationModel::Contacts::KnownContactField::Location());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* KnownContactField_get_PhoneNumber(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Contacts.KnownContactField", L"PhoneNumber"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Windows::ApplicationModel::Contacts::KnownContactField::PhoneNumber());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_KnownContactField[] = {
        { "convert_name_to_type", reinterpret_cast<PyCFunction>(KnownContactField_ConvertNameToType), METH_VARARGS | METH_STATIC, nullptr },
        { "convert_type_to_name", reinterpret_cast<PyCFunction>(KnownContactField_ConvertTypeToName), METH_VARARGS | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_KnownContactField[] = {
        { }
    };

    static PyType_Slot _type_slots_KnownContactField[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_KnownContactField) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_KnownContactField) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_KnownContactField) },
        { },
    };

    static PyType_Spec type_spec_KnownContactField =
    {
        "_winrt_windows_applicationmodel_contacts.KnownContactField",
        0,
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_KnownContactField
    };

    static PyGetSetDef getset_KnownContactField_Meta[] = {
        { "email", reinterpret_cast<getter>(KnownContactField_get_Email), nullptr, nullptr, nullptr },
        { "instant_message", reinterpret_cast<getter>(KnownContactField_get_InstantMessage), nullptr, nullptr, nullptr },
        { "location", reinterpret_cast<getter>(KnownContactField_get_Location), nullptr, nullptr, nullptr },
        { "phone_number", reinterpret_cast<getter>(KnownContactField_get_PhoneNumber), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot type_slots_KnownContactField_Meta[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_KnownContactField_Meta) },
        { }
    };

    static PyType_Spec type_spec_KnownContactField_Meta =
    {
        "_winrt_windows_applicationmodel_contacts.KnownContactField_Meta",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT,
        type_slots_KnownContactField_Meta
    };

    // ----- PinnedContactIdsQueryResult class --------------------

    static PyObject* _new_PinnedContactIdsQueryResult(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::ApplicationModel::Contacts::PinnedContactIdsQueryResult>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::ApplicationModel::Contacts::PinnedContactIdsQueryResult>::type_name);
        return nullptr;
    }

    static void _dealloc_PinnedContactIdsQueryResult(py::wrapper::Windows::ApplicationModel::Contacts::PinnedContactIdsQueryResult* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* PinnedContactIdsQueryResult_get_ContactIds(py::wrapper::Windows::ApplicationModel::Contacts::PinnedContactIdsQueryResult* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Contacts.PinnedContactIdsQueryResult", L"ContactIds"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.ContactIds());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_PinnedContactIdsQueryResult(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::ApplicationModel::Contacts::PinnedContactIdsQueryResult>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_PinnedContactIdsQueryResult(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::Contacts::PinnedContactIdsQueryResult>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_PinnedContactIdsQueryResult[] = {
        { "_assign_array_", _assign_array_PinnedContactIdsQueryResult, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_PinnedContactIdsQueryResult), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_PinnedContactIdsQueryResult[] = {
        { "contact_ids", reinterpret_cast<getter>(PinnedContactIdsQueryResult_get_ContactIds), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_PinnedContactIdsQueryResult[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_PinnedContactIdsQueryResult) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_PinnedContactIdsQueryResult) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_PinnedContactIdsQueryResult) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_PinnedContactIdsQueryResult) },
        { },
    };

    static PyType_Spec type_spec_PinnedContactIdsQueryResult =
    {
        "_winrt_windows_applicationmodel_contacts.PinnedContactIdsQueryResult",
        sizeof(py::wrapper::Windows::ApplicationModel::Contacts::PinnedContactIdsQueryResult),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_PinnedContactIdsQueryResult
    };

    // ----- PinnedContactManager class --------------------

    static PyObject* _new_PinnedContactManager(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::ApplicationModel::Contacts::PinnedContactManager>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::ApplicationModel::Contacts::PinnedContactManager>::type_name);
        return nullptr;
    }

    static void _dealloc_PinnedContactManager(py::wrapper::Windows::ApplicationModel::Contacts::PinnedContactManager* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* PinnedContactManager_GetDefault(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.ApplicationModel.Contacts.PinnedContactManager", L"GetDefault", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(winrt::Windows::ApplicationModel::Contacts::PinnedContactManager::GetDefault());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PinnedContactManager_GetForUser(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.ApplicationModel.Contacts.PinnedContactManager", L"GetForUser", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::System::User>(args, 0);

                return py::convert(winrt::Windows::ApplicationModel::Contacts::PinnedContactManager::GetForUser(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PinnedContactManager_GetPinnedContactIdsAsync(py::wrapper::Windows::ApplicationModel::Contacts::PinnedContactManager* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.ApplicationModel.Contacts.PinnedContactManager", L"GetPinnedContactIdsAsync", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(self->obj.GetPinnedContactIdsAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PinnedContactManager_IsContactPinned(py::wrapper::Windows::ApplicationModel::Contacts::PinnedContactManager* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.ApplicationModel.Contacts.PinnedContactManager", L"IsContactPinned", 2))
            {
                py::set_arg_count_version_error(2);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::ApplicationModel::Contacts::Contact>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::ApplicationModel::Contacts::PinnedContactSurface>(args, 1);

                return py::convert(self->obj.IsContactPinned(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PinnedContactManager_IsPinSurfaceSupported(py::wrapper::Windows::ApplicationModel::Contacts::PinnedContactManager* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.ApplicationModel.Contacts.PinnedContactManager", L"IsPinSurfaceSupported", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::ApplicationModel::Contacts::PinnedContactSurface>(args, 0);

                return py::convert(self->obj.IsPinSurfaceSupported(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PinnedContactManager_IsSupported(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.ApplicationModel.Contacts.PinnedContactManager", L"IsSupported", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(winrt::Windows::ApplicationModel::Contacts::PinnedContactManager::IsSupported());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PinnedContactManager_RequestPinContactAsync(py::wrapper::Windows::ApplicationModel::Contacts::PinnedContactManager* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.ApplicationModel.Contacts.PinnedContactManager", L"RequestPinContactAsync", 2))
            {
                py::set_arg_count_version_error(2);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::ApplicationModel::Contacts::Contact>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::ApplicationModel::Contacts::PinnedContactSurface>(args, 1);

                return py::convert(self->obj.RequestPinContactAsync(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PinnedContactManager_RequestPinContactsAsync(py::wrapper::Windows::ApplicationModel::Contacts::PinnedContactManager* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.ApplicationModel.Contacts.PinnedContactManager", L"RequestPinContactsAsync", 2))
            {
                py::set_arg_count_version_error(2);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::Foundation::Collections::IIterable<winrt::Windows::ApplicationModel::Contacts::Contact>>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::ApplicationModel::Contacts::PinnedContactSurface>(args, 1);

                return py::convert(self->obj.RequestPinContactsAsync(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PinnedContactManager_RequestUnpinContactAsync(py::wrapper::Windows::ApplicationModel::Contacts::PinnedContactManager* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.ApplicationModel.Contacts.PinnedContactManager", L"RequestUnpinContactAsync", 2))
            {
                py::set_arg_count_version_error(2);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::ApplicationModel::Contacts::Contact>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::ApplicationModel::Contacts::PinnedContactSurface>(args, 1);

                return py::convert(self->obj.RequestUnpinContactAsync(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PinnedContactManager_SignalContactActivity(py::wrapper::Windows::ApplicationModel::Contacts::PinnedContactManager* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.ApplicationModel.Contacts.PinnedContactManager", L"SignalContactActivity", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::ApplicationModel::Contacts::Contact>(args, 0);

                self->obj.SignalContactActivity(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PinnedContactManager_get_User(py::wrapper::Windows::ApplicationModel::Contacts::PinnedContactManager* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Contacts.PinnedContactManager", L"User"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.User());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_PinnedContactManager(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::ApplicationModel::Contacts::PinnedContactManager>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_PinnedContactManager(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::Contacts::PinnedContactManager>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_PinnedContactManager[] = {
        { "get_default", reinterpret_cast<PyCFunction>(PinnedContactManager_GetDefault), METH_VARARGS | METH_STATIC, nullptr },
        { "get_for_user", reinterpret_cast<PyCFunction>(PinnedContactManager_GetForUser), METH_VARARGS | METH_STATIC, nullptr },
        { "get_pinned_contact_ids_async", reinterpret_cast<PyCFunction>(PinnedContactManager_GetPinnedContactIdsAsync), METH_VARARGS, nullptr },
        { "is_contact_pinned", reinterpret_cast<PyCFunction>(PinnedContactManager_IsContactPinned), METH_VARARGS, nullptr },
        { "is_pin_surface_supported", reinterpret_cast<PyCFunction>(PinnedContactManager_IsPinSurfaceSupported), METH_VARARGS, nullptr },
        { "is_supported", reinterpret_cast<PyCFunction>(PinnedContactManager_IsSupported), METH_VARARGS | METH_STATIC, nullptr },
        { "request_pin_contact_async", reinterpret_cast<PyCFunction>(PinnedContactManager_RequestPinContactAsync), METH_VARARGS, nullptr },
        { "request_pin_contacts_async", reinterpret_cast<PyCFunction>(PinnedContactManager_RequestPinContactsAsync), METH_VARARGS, nullptr },
        { "request_unpin_contact_async", reinterpret_cast<PyCFunction>(PinnedContactManager_RequestUnpinContactAsync), METH_VARARGS, nullptr },
        { "signal_contact_activity", reinterpret_cast<PyCFunction>(PinnedContactManager_SignalContactActivity), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_PinnedContactManager, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_PinnedContactManager), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_PinnedContactManager[] = {
        { "user", reinterpret_cast<getter>(PinnedContactManager_get_User), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_PinnedContactManager[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_PinnedContactManager) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_PinnedContactManager) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_PinnedContactManager) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_PinnedContactManager) },
        { },
    };

    static PyType_Spec type_spec_PinnedContactManager =
    {
        "_winrt_windows_applicationmodel_contacts.PinnedContactManager",
        sizeof(py::wrapper::Windows::ApplicationModel::Contacts::PinnedContactManager),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_PinnedContactManager
    };

    // ----- IContactField interface --------------------

    static PyObject* _new_IContactField(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::ApplicationModel::Contacts::IContactField>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::ApplicationModel::Contacts::IContactField>::type_name);
        return nullptr;
    }

    static void _dealloc_IContactField(py::wrapper::Windows::ApplicationModel::Contacts::IContactField* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* IContactField_get_Category(py::wrapper::Windows::ApplicationModel::Contacts::IContactField* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Contacts.IContactField", L"Category"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Category());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IContactField_get_Name(py::wrapper::Windows::ApplicationModel::Contacts::IContactField* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Contacts.IContactField", L"Name"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Name());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IContactField_get_Type(py::wrapper::Windows::ApplicationModel::Contacts::IContactField* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Contacts.IContactField", L"Type"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Type());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IContactField_get_Value(py::wrapper::Windows::ApplicationModel::Contacts::IContactField* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Contacts.IContactField", L"Value"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Value());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_IContactField(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::ApplicationModel::Contacts::IContactField>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_IContactField(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::Contacts::IContactField>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_IContactField[] = {
        { "_assign_array_", _assign_array_IContactField, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_IContactField), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_IContactField[] = {
        { "category", reinterpret_cast<getter>(IContactField_get_Category), nullptr, nullptr, nullptr },
        { "name", reinterpret_cast<getter>(IContactField_get_Name), nullptr, nullptr, nullptr },
        { "type", reinterpret_cast<getter>(IContactField_get_Type), nullptr, nullptr, nullptr },
        { "value", reinterpret_cast<getter>(IContactField_get_Value), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_IContactField[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_IContactField) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_IContactField) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_IContactField) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_IContactField) },
        { },
    };

    static PyType_Spec type_spec_IContactField =
    {
        "_winrt_windows_applicationmodel_contacts.IContactField",
        sizeof(py::wrapper::Windows::ApplicationModel::Contacts::IContactField),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_IContactField
    };

    // ----- IContactFieldFactory interface --------------------

    static PyObject* _new_IContactFieldFactory(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::ApplicationModel::Contacts::IContactFieldFactory>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::ApplicationModel::Contacts::IContactFieldFactory>::type_name);
        return nullptr;
    }

    static void _dealloc_IContactFieldFactory(py::wrapper::Windows::ApplicationModel::Contacts::IContactFieldFactory* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* IContactFieldFactory_CreateField(py::wrapper::Windows::ApplicationModel::Contacts::IContactFieldFactory* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.ApplicationModel.Contacts.IContactFieldFactory", L"CreateField", 2))
            {
                py::set_arg_count_version_error(2);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::ApplicationModel::Contacts::ContactFieldType>(args, 1);

                return py::convert(self->obj.CreateField(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 3)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.ApplicationModel.Contacts.IContactFieldFactory", L"CreateField", 3))
            {
                py::set_arg_count_version_error(3);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::ApplicationModel::Contacts::ContactFieldType>(args, 1);
                auto param2 = py::convert_to<winrt::Windows::ApplicationModel::Contacts::ContactFieldCategory>(args, 2);

                return py::convert(self->obj.CreateField(param0, param1, param2));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 4)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.ApplicationModel.Contacts.IContactFieldFactory", L"CreateField", 4))
            {
                py::set_arg_count_version_error(4);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::hstring>(args, 1);
                auto param2 = py::convert_to<winrt::Windows::ApplicationModel::Contacts::ContactFieldType>(args, 2);
                auto param3 = py::convert_to<winrt::Windows::ApplicationModel::Contacts::ContactFieldCategory>(args, 3);

                return py::convert(self->obj.CreateField(param0, param1, param2, param3));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* _assign_array_IContactFieldFactory(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::ApplicationModel::Contacts::IContactFieldFactory>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_IContactFieldFactory(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::Contacts::IContactFieldFactory>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_IContactFieldFactory[] = {
        { "create_field", reinterpret_cast<PyCFunction>(IContactFieldFactory_CreateField), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_IContactFieldFactory, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_IContactFieldFactory), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_IContactFieldFactory[] = {
        { }
    };

    static PyType_Slot _type_slots_IContactFieldFactory[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_IContactFieldFactory) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_IContactFieldFactory) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_IContactFieldFactory) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_IContactFieldFactory) },
        { },
    };

    static PyType_Spec type_spec_IContactFieldFactory =
    {
        "_winrt_windows_applicationmodel_contacts.IContactFieldFactory",
        sizeof(py::wrapper::Windows::ApplicationModel::Contacts::IContactFieldFactory),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_IContactFieldFactory
    };

    // ----- IContactInstantMessageFieldFactory interface --------------------

    static PyObject* _new_IContactInstantMessageFieldFactory(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::ApplicationModel::Contacts::IContactInstantMessageFieldFactory>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::ApplicationModel::Contacts::IContactInstantMessageFieldFactory>::type_name);
        return nullptr;
    }

    static void _dealloc_IContactInstantMessageFieldFactory(py::wrapper::Windows::ApplicationModel::Contacts::IContactInstantMessageFieldFactory* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* IContactInstantMessageFieldFactory_CreateInstantMessage(py::wrapper::Windows::ApplicationModel::Contacts::IContactInstantMessageFieldFactory* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.ApplicationModel.Contacts.IContactInstantMessageFieldFactory", L"CreateInstantMessage", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                return py::convert(self->obj.CreateInstantMessage(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 2)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.ApplicationModel.Contacts.IContactInstantMessageFieldFactory", L"CreateInstantMessage", 2))
            {
                py::set_arg_count_version_error(2);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::ApplicationModel::Contacts::ContactFieldCategory>(args, 1);

                return py::convert(self->obj.CreateInstantMessage(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 5)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.ApplicationModel.Contacts.IContactInstantMessageFieldFactory", L"CreateInstantMessage", 5))
            {
                py::set_arg_count_version_error(5);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::ApplicationModel::Contacts::ContactFieldCategory>(args, 1);
                auto param2 = py::convert_to<winrt::hstring>(args, 2);
                auto param3 = py::convert_to<winrt::hstring>(args, 3);
                auto param4 = py::convert_to<winrt::Windows::Foundation::Uri>(args, 4);

                return py::convert(self->obj.CreateInstantMessage(param0, param1, param2, param3, param4));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* _assign_array_IContactInstantMessageFieldFactory(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::ApplicationModel::Contacts::IContactInstantMessageFieldFactory>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_IContactInstantMessageFieldFactory(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::Contacts::IContactInstantMessageFieldFactory>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_IContactInstantMessageFieldFactory[] = {
        { "create_instant_message", reinterpret_cast<PyCFunction>(IContactInstantMessageFieldFactory_CreateInstantMessage), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_IContactInstantMessageFieldFactory, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_IContactInstantMessageFieldFactory), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_IContactInstantMessageFieldFactory[] = {
        { }
    };

    static PyType_Slot _type_slots_IContactInstantMessageFieldFactory[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_IContactInstantMessageFieldFactory) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_IContactInstantMessageFieldFactory) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_IContactInstantMessageFieldFactory) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_IContactInstantMessageFieldFactory) },
        { },
    };

    static PyType_Spec type_spec_IContactInstantMessageFieldFactory =
    {
        "_winrt_windows_applicationmodel_contacts.IContactInstantMessageFieldFactory",
        sizeof(py::wrapper::Windows::ApplicationModel::Contacts::IContactInstantMessageFieldFactory),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_IContactInstantMessageFieldFactory
    };

    // ----- IContactLocationFieldFactory interface --------------------

    static PyObject* _new_IContactLocationFieldFactory(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::ApplicationModel::Contacts::IContactLocationFieldFactory>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::ApplicationModel::Contacts::IContactLocationFieldFactory>::type_name);
        return nullptr;
    }

    static void _dealloc_IContactLocationFieldFactory(py::wrapper::Windows::ApplicationModel::Contacts::IContactLocationFieldFactory* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* IContactLocationFieldFactory_CreateLocation(py::wrapper::Windows::ApplicationModel::Contacts::IContactLocationFieldFactory* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.ApplicationModel.Contacts.IContactLocationFieldFactory", L"CreateLocation", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                return py::convert(self->obj.CreateLocation(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 2)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.ApplicationModel.Contacts.IContactLocationFieldFactory", L"CreateLocation", 2))
            {
                py::set_arg_count_version_error(2);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::ApplicationModel::Contacts::ContactFieldCategory>(args, 1);

                return py::convert(self->obj.CreateLocation(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 7)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.ApplicationModel.Contacts.IContactLocationFieldFactory", L"CreateLocation", 7))
            {
                py::set_arg_count_version_error(7);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::ApplicationModel::Contacts::ContactFieldCategory>(args, 1);
                auto param2 = py::convert_to<winrt::hstring>(args, 2);
                auto param3 = py::convert_to<winrt::hstring>(args, 3);
                auto param4 = py::convert_to<winrt::hstring>(args, 4);
                auto param5 = py::convert_to<winrt::hstring>(args, 5);
                auto param6 = py::convert_to<winrt::hstring>(args, 6);

                return py::convert(self->obj.CreateLocation(param0, param1, param2, param3, param4, param5, param6));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* _assign_array_IContactLocationFieldFactory(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::ApplicationModel::Contacts::IContactLocationFieldFactory>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_IContactLocationFieldFactory(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::Contacts::IContactLocationFieldFactory>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_IContactLocationFieldFactory[] = {
        { "create_location", reinterpret_cast<PyCFunction>(IContactLocationFieldFactory_CreateLocation), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_IContactLocationFieldFactory, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_IContactLocationFieldFactory), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_IContactLocationFieldFactory[] = {
        { }
    };

    static PyType_Slot _type_slots_IContactLocationFieldFactory[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_IContactLocationFieldFactory) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_IContactLocationFieldFactory) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_IContactLocationFieldFactory) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_IContactLocationFieldFactory) },
        { },
    };

    static PyType_Spec type_spec_IContactLocationFieldFactory =
    {
        "_winrt_windows_applicationmodel_contacts.IContactLocationFieldFactory",
        sizeof(py::wrapper::Windows::ApplicationModel::Contacts::IContactLocationFieldFactory),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_IContactLocationFieldFactory
    };

    // ----- Windows.ApplicationModel.Contacts Initialization --------------------
    PyDoc_STRVAR(module_doc, "Windows::ApplicationModel::Contacts");


    static PyModuleDef module_def
        = {PyModuleDef_HEAD_INIT,
           "_winrt_windows_applicationmodel_contacts",
           module_doc,
           0,
           nullptr,
           nullptr,
           nullptr,
           nullptr,
           nullptr};

} // py::cpp::Windows::ApplicationModel::Contacts

PyMODINIT_FUNC PyInit__winrt_windows_applicationmodel_contacts(void) noexcept
{
    using namespace py::cpp::Windows::ApplicationModel::Contacts;

    if (py::import_winrt_runtime() == -1)
    {
        return nullptr;
    }

    py::pyobj_handle module{PyModule_Create(&module_def)};

    if (!module)
    {
        return nullptr;
    }

    auto object_type = py::get_object_type();
    if (!object_type)
    {
        return nullptr;
    }

    py::pyobj_handle object_bases{PyTuple_Pack(1, object_type)};

    if (!object_bases)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_AggregateContactManager, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_Contact, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_ContactAddress, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_ContactAnnotation, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_ContactAnnotationList, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_ContactAnnotationStore, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_ContactBatch, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_ContactCardDelayedDataLoader, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_ContactCardOptions, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_ContactChange, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_ContactChangeReader, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_ContactChangeTracker, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_ContactChangedDeferral, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_ContactChangedEventArgs, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_ContactConnectedServiceAccount, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_ContactDate, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_ContactEmail, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_ContactField, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_ContactFieldFactory, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_ContactGroup, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_ContactInformation, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_ContactInstantMessageField, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_ContactJobInfo, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    py::pyobj_handle type_ContactLaunchActionVerbs_Meta{PyType_FromSpec(&type_spec_ContactLaunchActionVerbs_Meta)};
    if (!type_ContactLaunchActionVerbs_Meta)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_ContactLaunchActionVerbs, object_bases.get(), reinterpret_cast<PyTypeObject*>(type_ContactLaunchActionVerbs_Meta.get())) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_ContactList, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_ContactListLimitedWriteOperations, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_ContactListSyncConstraints, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_ContactListSyncManager, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_ContactLocationField, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    py::pyobj_handle type_ContactManager_Meta{PyType_FromSpec(&type_spec_ContactManager_Meta)};
    if (!type_ContactManager_Meta)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_ContactManager, object_bases.get(), reinterpret_cast<PyTypeObject*>(type_ContactManager_Meta.get())) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_ContactManagerForUser, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_ContactMatchReason, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_ContactPanel, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_ContactPanelClosingEventArgs, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_ContactPanelLaunchFullAppRequestedEventArgs, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_ContactPhone, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_ContactPicker, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_ContactQueryOptions, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_ContactQueryTextSearch, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_ContactReader, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_ContactSignificantOther, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_ContactStore, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_ContactStoreNotificationTriggerDetails, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_ContactWebsite, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_FullContactCardOptions, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    py::pyobj_handle type_KnownContactField_Meta{PyType_FromSpec(&type_spec_KnownContactField_Meta)};
    if (!type_KnownContactField_Meta)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_KnownContactField, object_bases.get(), reinterpret_cast<PyTypeObject*>(type_KnownContactField_Meta.get())) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_PinnedContactIdsQueryResult, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_PinnedContactManager, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_IContactField, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_IContactFieldFactory, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_IContactInstantMessageFieldFactory, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_IContactLocationFieldFactory, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }


    return module.detach();
}
