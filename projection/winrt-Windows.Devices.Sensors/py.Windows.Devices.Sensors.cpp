// WARNING: Please don't edit this file. It was generated by Python/WinRT v0.0.0

#include "py.Windows.Devices.Sensors.h"


namespace py::cpp::Windows::Devices::Sensors
{
    // ----- Accelerometer class --------------------

    static PyObject* _new_Accelerometer(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Devices::Sensors::Accelerometer>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Devices::Sensors::Accelerometer>::type_name);
        return nullptr;
    }

    static void _dealloc_Accelerometer(py::wrapper::Windows::Devices::Sensors::Accelerometer* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* Accelerometer_FromIdAsync(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.Sensors.Accelerometer", L"FromIdAsync", 1))
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                return py::convert(winrt::Windows::Devices::Sensors::Accelerometer::FromIdAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* Accelerometer_GetCurrentReading(py::wrapper::Windows::Devices::Sensors::Accelerometer* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.Sensors.Accelerometer", L"GetCurrentReading", 0))
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert(self->obj.GetCurrentReading());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* Accelerometer_GetDefault(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.Sensors.Accelerometer", L"GetDefault", 0))
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert(winrt::Windows::Devices::Sensors::Accelerometer::GetDefault());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 1)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.Sensors.Accelerometer", L"GetDefault", 1))
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Devices::Sensors::AccelerometerReadingType>(args, 0);

                return py::convert(winrt::Windows::Devices::Sensors::Accelerometer::GetDefault(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* Accelerometer_GetDeviceSelector(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.Sensors.Accelerometer", L"GetDeviceSelector", 1))
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Devices::Sensors::AccelerometerReadingType>(args, 0);

                return py::convert(winrt::Windows::Devices::Sensors::Accelerometer::GetDeviceSelector(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* Accelerometer_get_ReportInterval(py::wrapper::Windows::Devices::Sensors::Accelerometer* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Sensors.Accelerometer", L"ReportInterval"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.ReportInterval());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int Accelerometer_put_ReportInterval(py::wrapper::Windows::Devices::Sensors::Accelerometer* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Sensors.Accelerometer", L"ReportInterval"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<uint32_t>(arg);

            self->obj.ReportInterval(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* Accelerometer_get_MinimumReportInterval(py::wrapper::Windows::Devices::Sensors::Accelerometer* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Sensors.Accelerometer", L"MinimumReportInterval"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.MinimumReportInterval());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* Accelerometer_get_ReadingTransform(py::wrapper::Windows::Devices::Sensors::Accelerometer* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Sensors.Accelerometer", L"ReadingTransform"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.ReadingTransform());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int Accelerometer_put_ReadingTransform(py::wrapper::Windows::Devices::Sensors::Accelerometer* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Sensors.Accelerometer", L"ReadingTransform"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::Graphics::Display::DisplayOrientations>(arg);

            self->obj.ReadingTransform(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* Accelerometer_get_ReportLatency(py::wrapper::Windows::Devices::Sensors::Accelerometer* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Sensors.Accelerometer", L"ReportLatency"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.ReportLatency());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int Accelerometer_put_ReportLatency(py::wrapper::Windows::Devices::Sensors::Accelerometer* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Sensors.Accelerometer", L"ReportLatency"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<uint32_t>(arg);

            self->obj.ReportLatency(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* Accelerometer_get_MaxBatchSize(py::wrapper::Windows::Devices::Sensors::Accelerometer* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Sensors.Accelerometer", L"MaxBatchSize"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.MaxBatchSize());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* Accelerometer_get_ReadingType(py::wrapper::Windows::Devices::Sensors::Accelerometer* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Sensors.Accelerometer", L"ReadingType"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.ReadingType());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* Accelerometer_get_ReportThreshold(py::wrapper::Windows::Devices::Sensors::Accelerometer* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Sensors.Accelerometer", L"ReportThreshold"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.ReportThreshold());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* Accelerometer_get_DeviceId(py::wrapper::Windows::Devices::Sensors::Accelerometer* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Sensors.Accelerometer", L"DeviceId"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.DeviceId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* Accelerometer_add_ReadingChanged(py::wrapper::Windows::Devices::Sensors::Accelerometer* self, PyObject* arg) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Devices.Sensors.Accelerometer", L"ReadingChanged"))
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Devices::Sensors::Accelerometer, winrt::Windows::Devices::Sensors::AccelerometerReadingChangedEventArgs>>(arg);

            return py::convert(self->obj.ReadingChanged(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* Accelerometer_remove_ReadingChanged(py::wrapper::Windows::Devices::Sensors::Accelerometer* self, PyObject* arg) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Devices.Sensors.Accelerometer", L"ReadingChanged"))
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.ReadingChanged(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* Accelerometer_add_Shaken(py::wrapper::Windows::Devices::Sensors::Accelerometer* self, PyObject* arg) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Devices.Sensors.Accelerometer", L"Shaken"))
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Devices::Sensors::Accelerometer, winrt::Windows::Devices::Sensors::AccelerometerShakenEventArgs>>(arg);

            return py::convert(self->obj.Shaken(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* Accelerometer_remove_Shaken(py::wrapper::Windows::Devices::Sensors::Accelerometer* self, PyObject* arg) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Devices.Sensors.Accelerometer", L"Shaken"))
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.Shaken(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_Accelerometer(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Devices::Sensors::Accelerometer>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_Accelerometer(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Devices::Sensors::Accelerometer>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_Accelerometer[] = {
        { "get_current_reading", reinterpret_cast<PyCFunction>(Accelerometer_GetCurrentReading), METH_VARARGS, nullptr },
        { "add_reading_changed", reinterpret_cast<PyCFunction>(Accelerometer_add_ReadingChanged), METH_O, nullptr },
        { "remove_reading_changed", reinterpret_cast<PyCFunction>(Accelerometer_remove_ReadingChanged), METH_O, nullptr },
        { "add_shaken", reinterpret_cast<PyCFunction>(Accelerometer_add_Shaken), METH_O, nullptr },
        { "remove_shaken", reinterpret_cast<PyCFunction>(Accelerometer_remove_Shaken), METH_O, nullptr },
        { "_assign_array_", _assign_array_Accelerometer, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_Accelerometer), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_Accelerometer[] = {
        { "report_interval", reinterpret_cast<getter>(Accelerometer_get_ReportInterval), reinterpret_cast<setter>(Accelerometer_put_ReportInterval), nullptr, nullptr },
        { "minimum_report_interval", reinterpret_cast<getter>(Accelerometer_get_MinimumReportInterval), nullptr, nullptr, nullptr },
        { "reading_transform", reinterpret_cast<getter>(Accelerometer_get_ReadingTransform), reinterpret_cast<setter>(Accelerometer_put_ReadingTransform), nullptr, nullptr },
        { "report_latency", reinterpret_cast<getter>(Accelerometer_get_ReportLatency), reinterpret_cast<setter>(Accelerometer_put_ReportLatency), nullptr, nullptr },
        { "max_batch_size", reinterpret_cast<getter>(Accelerometer_get_MaxBatchSize), nullptr, nullptr, nullptr },
        { "reading_type", reinterpret_cast<getter>(Accelerometer_get_ReadingType), nullptr, nullptr, nullptr },
        { "report_threshold", reinterpret_cast<getter>(Accelerometer_get_ReportThreshold), nullptr, nullptr, nullptr },
        { "device_id", reinterpret_cast<getter>(Accelerometer_get_DeviceId), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_Accelerometer[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_Accelerometer) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_Accelerometer) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_Accelerometer) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_Accelerometer) },
        { },
    };

    static PyType_Spec type_spec_Accelerometer =
    {
        "winrt._winrt_windows_devices_sensors.Accelerometer",
        sizeof(py::wrapper::Windows::Devices::Sensors::Accelerometer),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_Accelerometer
    };

    static PyGetSetDef getset_Accelerometer_Static[] = {
        { }
    };

    static PyMethodDef methods_Accelerometer_Static[] = {
        { "from_id_async", reinterpret_cast<PyCFunction>(Accelerometer_FromIdAsync), METH_VARARGS, nullptr },
        { "get_default", reinterpret_cast<PyCFunction>(Accelerometer_GetDefault), METH_VARARGS, nullptr },
        { "get_device_selector", reinterpret_cast<PyCFunction>(Accelerometer_GetDeviceSelector), METH_VARARGS, nullptr },
        { }
    };

    static PyType_Slot type_slots_Accelerometer_Static[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_Accelerometer_Static) },
        { Py_tp_methods, reinterpret_cast<void*>(methods_Accelerometer_Static) },
        { }
    };

    static PyType_Spec type_spec_Accelerometer_Static =
    {
        "winrt._winrt_windows_devices_sensors.Accelerometer_Static",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT,
        type_slots_Accelerometer_Static
    };

    // ----- AccelerometerDataThreshold class --------------------

    static PyObject* _new_AccelerometerDataThreshold(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Devices::Sensors::AccelerometerDataThreshold>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Devices::Sensors::AccelerometerDataThreshold>::type_name);
        return nullptr;
    }

    static void _dealloc_AccelerometerDataThreshold(py::wrapper::Windows::Devices::Sensors::AccelerometerDataThreshold* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* AccelerometerDataThreshold_get_ZAxisInGForce(py::wrapper::Windows::Devices::Sensors::AccelerometerDataThreshold* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Sensors.AccelerometerDataThreshold", L"ZAxisInGForce"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.ZAxisInGForce());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int AccelerometerDataThreshold_put_ZAxisInGForce(py::wrapper::Windows::Devices::Sensors::AccelerometerDataThreshold* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Sensors.AccelerometerDataThreshold", L"ZAxisInGForce"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<double>(arg);

            self->obj.ZAxisInGForce(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* AccelerometerDataThreshold_get_YAxisInGForce(py::wrapper::Windows::Devices::Sensors::AccelerometerDataThreshold* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Sensors.AccelerometerDataThreshold", L"YAxisInGForce"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.YAxisInGForce());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int AccelerometerDataThreshold_put_YAxisInGForce(py::wrapper::Windows::Devices::Sensors::AccelerometerDataThreshold* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Sensors.AccelerometerDataThreshold", L"YAxisInGForce"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<double>(arg);

            self->obj.YAxisInGForce(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* AccelerometerDataThreshold_get_XAxisInGForce(py::wrapper::Windows::Devices::Sensors::AccelerometerDataThreshold* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Sensors.AccelerometerDataThreshold", L"XAxisInGForce"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.XAxisInGForce());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int AccelerometerDataThreshold_put_XAxisInGForce(py::wrapper::Windows::Devices::Sensors::AccelerometerDataThreshold* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Sensors.AccelerometerDataThreshold", L"XAxisInGForce"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<double>(arg);

            self->obj.XAxisInGForce(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* _assign_array_AccelerometerDataThreshold(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Devices::Sensors::AccelerometerDataThreshold>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_AccelerometerDataThreshold(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Devices::Sensors::AccelerometerDataThreshold>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_AccelerometerDataThreshold[] = {
        { "_assign_array_", _assign_array_AccelerometerDataThreshold, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_AccelerometerDataThreshold), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_AccelerometerDataThreshold[] = {
        { "z_axis_in_g_force", reinterpret_cast<getter>(AccelerometerDataThreshold_get_ZAxisInGForce), reinterpret_cast<setter>(AccelerometerDataThreshold_put_ZAxisInGForce), nullptr, nullptr },
        { "y_axis_in_g_force", reinterpret_cast<getter>(AccelerometerDataThreshold_get_YAxisInGForce), reinterpret_cast<setter>(AccelerometerDataThreshold_put_YAxisInGForce), nullptr, nullptr },
        { "x_axis_in_g_force", reinterpret_cast<getter>(AccelerometerDataThreshold_get_XAxisInGForce), reinterpret_cast<setter>(AccelerometerDataThreshold_put_XAxisInGForce), nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_AccelerometerDataThreshold[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_AccelerometerDataThreshold) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_AccelerometerDataThreshold) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_AccelerometerDataThreshold) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_AccelerometerDataThreshold) },
        { },
    };

    static PyType_Spec type_spec_AccelerometerDataThreshold =
    {
        "winrt._winrt_windows_devices_sensors.AccelerometerDataThreshold",
        sizeof(py::wrapper::Windows::Devices::Sensors::AccelerometerDataThreshold),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_AccelerometerDataThreshold
    };

    // ----- AccelerometerReading class --------------------

    static PyObject* _new_AccelerometerReading(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Devices::Sensors::AccelerometerReading>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Devices::Sensors::AccelerometerReading>::type_name);
        return nullptr;
    }

    static void _dealloc_AccelerometerReading(py::wrapper::Windows::Devices::Sensors::AccelerometerReading* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* AccelerometerReading_get_AccelerationX(py::wrapper::Windows::Devices::Sensors::AccelerometerReading* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Sensors.AccelerometerReading", L"AccelerationX"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.AccelerationX());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AccelerometerReading_get_AccelerationY(py::wrapper::Windows::Devices::Sensors::AccelerometerReading* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Sensors.AccelerometerReading", L"AccelerationY"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.AccelerationY());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AccelerometerReading_get_AccelerationZ(py::wrapper::Windows::Devices::Sensors::AccelerometerReading* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Sensors.AccelerometerReading", L"AccelerationZ"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.AccelerationZ());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AccelerometerReading_get_Timestamp(py::wrapper::Windows::Devices::Sensors::AccelerometerReading* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Sensors.AccelerometerReading", L"Timestamp"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Timestamp());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AccelerometerReading_get_PerformanceCount(py::wrapper::Windows::Devices::Sensors::AccelerometerReading* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Sensors.AccelerometerReading", L"PerformanceCount"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.PerformanceCount());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AccelerometerReading_get_Properties(py::wrapper::Windows::Devices::Sensors::AccelerometerReading* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Sensors.AccelerometerReading", L"Properties"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Properties());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_AccelerometerReading(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Devices::Sensors::AccelerometerReading>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_AccelerometerReading(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Devices::Sensors::AccelerometerReading>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_AccelerometerReading[] = {
        { "_assign_array_", _assign_array_AccelerometerReading, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_AccelerometerReading), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_AccelerometerReading[] = {
        { "acceleration_x", reinterpret_cast<getter>(AccelerometerReading_get_AccelerationX), nullptr, nullptr, nullptr },
        { "acceleration_y", reinterpret_cast<getter>(AccelerometerReading_get_AccelerationY), nullptr, nullptr, nullptr },
        { "acceleration_z", reinterpret_cast<getter>(AccelerometerReading_get_AccelerationZ), nullptr, nullptr, nullptr },
        { "timestamp", reinterpret_cast<getter>(AccelerometerReading_get_Timestamp), nullptr, nullptr, nullptr },
        { "performance_count", reinterpret_cast<getter>(AccelerometerReading_get_PerformanceCount), nullptr, nullptr, nullptr },
        { "properties", reinterpret_cast<getter>(AccelerometerReading_get_Properties), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_AccelerometerReading[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_AccelerometerReading) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_AccelerometerReading) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_AccelerometerReading) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_AccelerometerReading) },
        { },
    };

    static PyType_Spec type_spec_AccelerometerReading =
    {
        "winrt._winrt_windows_devices_sensors.AccelerometerReading",
        sizeof(py::wrapper::Windows::Devices::Sensors::AccelerometerReading),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_AccelerometerReading
    };

    // ----- AccelerometerReadingChangedEventArgs class --------------------

    static PyObject* _new_AccelerometerReadingChangedEventArgs(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Devices::Sensors::AccelerometerReadingChangedEventArgs>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Devices::Sensors::AccelerometerReadingChangedEventArgs>::type_name);
        return nullptr;
    }

    static void _dealloc_AccelerometerReadingChangedEventArgs(py::wrapper::Windows::Devices::Sensors::AccelerometerReadingChangedEventArgs* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* AccelerometerReadingChangedEventArgs_get_Reading(py::wrapper::Windows::Devices::Sensors::AccelerometerReadingChangedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Sensors.AccelerometerReadingChangedEventArgs", L"Reading"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Reading());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_AccelerometerReadingChangedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Devices::Sensors::AccelerometerReadingChangedEventArgs>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_AccelerometerReadingChangedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Devices::Sensors::AccelerometerReadingChangedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_AccelerometerReadingChangedEventArgs[] = {
        { "_assign_array_", _assign_array_AccelerometerReadingChangedEventArgs, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_AccelerometerReadingChangedEventArgs), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_AccelerometerReadingChangedEventArgs[] = {
        { "reading", reinterpret_cast<getter>(AccelerometerReadingChangedEventArgs_get_Reading), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_AccelerometerReadingChangedEventArgs[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_AccelerometerReadingChangedEventArgs) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_AccelerometerReadingChangedEventArgs) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_AccelerometerReadingChangedEventArgs) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_AccelerometerReadingChangedEventArgs) },
        { },
    };

    static PyType_Spec type_spec_AccelerometerReadingChangedEventArgs =
    {
        "winrt._winrt_windows_devices_sensors.AccelerometerReadingChangedEventArgs",
        sizeof(py::wrapper::Windows::Devices::Sensors::AccelerometerReadingChangedEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_AccelerometerReadingChangedEventArgs
    };

    // ----- AccelerometerShakenEventArgs class --------------------

    static PyObject* _new_AccelerometerShakenEventArgs(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Devices::Sensors::AccelerometerShakenEventArgs>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Devices::Sensors::AccelerometerShakenEventArgs>::type_name);
        return nullptr;
    }

    static void _dealloc_AccelerometerShakenEventArgs(py::wrapper::Windows::Devices::Sensors::AccelerometerShakenEventArgs* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* AccelerometerShakenEventArgs_get_Timestamp(py::wrapper::Windows::Devices::Sensors::AccelerometerShakenEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Sensors.AccelerometerShakenEventArgs", L"Timestamp"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Timestamp());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_AccelerometerShakenEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Devices::Sensors::AccelerometerShakenEventArgs>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_AccelerometerShakenEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Devices::Sensors::AccelerometerShakenEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_AccelerometerShakenEventArgs[] = {
        { "_assign_array_", _assign_array_AccelerometerShakenEventArgs, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_AccelerometerShakenEventArgs), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_AccelerometerShakenEventArgs[] = {
        { "timestamp", reinterpret_cast<getter>(AccelerometerShakenEventArgs_get_Timestamp), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_AccelerometerShakenEventArgs[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_AccelerometerShakenEventArgs) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_AccelerometerShakenEventArgs) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_AccelerometerShakenEventArgs) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_AccelerometerShakenEventArgs) },
        { },
    };

    static PyType_Spec type_spec_AccelerometerShakenEventArgs =
    {
        "winrt._winrt_windows_devices_sensors.AccelerometerShakenEventArgs",
        sizeof(py::wrapper::Windows::Devices::Sensors::AccelerometerShakenEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_AccelerometerShakenEventArgs
    };

    // ----- ActivitySensor class --------------------

    static PyObject* _new_ActivitySensor(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Devices::Sensors::ActivitySensor>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Devices::Sensors::ActivitySensor>::type_name);
        return nullptr;
    }

    static void _dealloc_ActivitySensor(py::wrapper::Windows::Devices::Sensors::ActivitySensor* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* ActivitySensor_FromIdAsync(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.Sensors.ActivitySensor", L"FromIdAsync", 1))
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                return py::convert(winrt::Windows::Devices::Sensors::ActivitySensor::FromIdAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ActivitySensor_GetCurrentReadingAsync(py::wrapper::Windows::Devices::Sensors::ActivitySensor* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.Sensors.ActivitySensor", L"GetCurrentReadingAsync", 0))
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert(self->obj.GetCurrentReadingAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ActivitySensor_GetDefaultAsync(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.Sensors.ActivitySensor", L"GetDefaultAsync", 0))
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert(winrt::Windows::Devices::Sensors::ActivitySensor::GetDefaultAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ActivitySensor_GetDeviceSelector(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.Sensors.ActivitySensor", L"GetDeviceSelector", 0))
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert(winrt::Windows::Devices::Sensors::ActivitySensor::GetDeviceSelector());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ActivitySensor_GetSystemHistoryAsync(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.Sensors.ActivitySensor", L"GetSystemHistoryAsync", 1))
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Foundation::DateTime>(args, 0);

                return py::convert(winrt::Windows::Devices::Sensors::ActivitySensor::GetSystemHistoryAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 2)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.Sensors.ActivitySensor", L"GetSystemHistoryAsync", 2))
                {
                    py::set_arg_count_version_error(2);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Foundation::DateTime>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Foundation::TimeSpan>(args, 1);

                return py::convert(winrt::Windows::Devices::Sensors::ActivitySensor::GetSystemHistoryAsync(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ActivitySensor_get_DeviceId(py::wrapper::Windows::Devices::Sensors::ActivitySensor* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Sensors.ActivitySensor", L"DeviceId"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.DeviceId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ActivitySensor_get_MinimumReportInterval(py::wrapper::Windows::Devices::Sensors::ActivitySensor* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Sensors.ActivitySensor", L"MinimumReportInterval"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.MinimumReportInterval());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ActivitySensor_get_PowerInMilliwatts(py::wrapper::Windows::Devices::Sensors::ActivitySensor* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Sensors.ActivitySensor", L"PowerInMilliwatts"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.PowerInMilliwatts());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ActivitySensor_get_SubscribedActivities(py::wrapper::Windows::Devices::Sensors::ActivitySensor* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Sensors.ActivitySensor", L"SubscribedActivities"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.SubscribedActivities());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ActivitySensor_get_SupportedActivities(py::wrapper::Windows::Devices::Sensors::ActivitySensor* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Sensors.ActivitySensor", L"SupportedActivities"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.SupportedActivities());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ActivitySensor_add_ReadingChanged(py::wrapper::Windows::Devices::Sensors::ActivitySensor* self, PyObject* arg) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Devices.Sensors.ActivitySensor", L"ReadingChanged"))
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Devices::Sensors::ActivitySensor, winrt::Windows::Devices::Sensors::ActivitySensorReadingChangedEventArgs>>(arg);

            return py::convert(self->obj.ReadingChanged(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ActivitySensor_remove_ReadingChanged(py::wrapper::Windows::Devices::Sensors::ActivitySensor* self, PyObject* arg) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Devices.Sensors.ActivitySensor", L"ReadingChanged"))
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.ReadingChanged(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_ActivitySensor(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Devices::Sensors::ActivitySensor>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_ActivitySensor(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Devices::Sensors::ActivitySensor>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_ActivitySensor[] = {
        { "get_current_reading_async", reinterpret_cast<PyCFunction>(ActivitySensor_GetCurrentReadingAsync), METH_VARARGS, nullptr },
        { "add_reading_changed", reinterpret_cast<PyCFunction>(ActivitySensor_add_ReadingChanged), METH_O, nullptr },
        { "remove_reading_changed", reinterpret_cast<PyCFunction>(ActivitySensor_remove_ReadingChanged), METH_O, nullptr },
        { "_assign_array_", _assign_array_ActivitySensor, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_ActivitySensor), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_ActivitySensor[] = {
        { "device_id", reinterpret_cast<getter>(ActivitySensor_get_DeviceId), nullptr, nullptr, nullptr },
        { "minimum_report_interval", reinterpret_cast<getter>(ActivitySensor_get_MinimumReportInterval), nullptr, nullptr, nullptr },
        { "power_in_milliwatts", reinterpret_cast<getter>(ActivitySensor_get_PowerInMilliwatts), nullptr, nullptr, nullptr },
        { "subscribed_activities", reinterpret_cast<getter>(ActivitySensor_get_SubscribedActivities), nullptr, nullptr, nullptr },
        { "supported_activities", reinterpret_cast<getter>(ActivitySensor_get_SupportedActivities), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_ActivitySensor[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_ActivitySensor) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_ActivitySensor) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_ActivitySensor) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_ActivitySensor) },
        { },
    };

    static PyType_Spec type_spec_ActivitySensor =
    {
        "winrt._winrt_windows_devices_sensors.ActivitySensor",
        sizeof(py::wrapper::Windows::Devices::Sensors::ActivitySensor),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_ActivitySensor
    };

    static PyGetSetDef getset_ActivitySensor_Static[] = {
        { }
    };

    static PyMethodDef methods_ActivitySensor_Static[] = {
        { "from_id_async", reinterpret_cast<PyCFunction>(ActivitySensor_FromIdAsync), METH_VARARGS, nullptr },
        { "get_default_async", reinterpret_cast<PyCFunction>(ActivitySensor_GetDefaultAsync), METH_VARARGS, nullptr },
        { "get_device_selector", reinterpret_cast<PyCFunction>(ActivitySensor_GetDeviceSelector), METH_VARARGS, nullptr },
        { "get_system_history_async", reinterpret_cast<PyCFunction>(ActivitySensor_GetSystemHistoryAsync), METH_VARARGS, nullptr },
        { }
    };

    static PyType_Slot type_slots_ActivitySensor_Static[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_ActivitySensor_Static) },
        { Py_tp_methods, reinterpret_cast<void*>(methods_ActivitySensor_Static) },
        { }
    };

    static PyType_Spec type_spec_ActivitySensor_Static =
    {
        "winrt._winrt_windows_devices_sensors.ActivitySensor_Static",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT,
        type_slots_ActivitySensor_Static
    };

    // ----- ActivitySensorReading class --------------------

    static PyObject* _new_ActivitySensorReading(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Devices::Sensors::ActivitySensorReading>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Devices::Sensors::ActivitySensorReading>::type_name);
        return nullptr;
    }

    static void _dealloc_ActivitySensorReading(py::wrapper::Windows::Devices::Sensors::ActivitySensorReading* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* ActivitySensorReading_get_Activity(py::wrapper::Windows::Devices::Sensors::ActivitySensorReading* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Sensors.ActivitySensorReading", L"Activity"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Activity());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ActivitySensorReading_get_Confidence(py::wrapper::Windows::Devices::Sensors::ActivitySensorReading* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Sensors.ActivitySensorReading", L"Confidence"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Confidence());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ActivitySensorReading_get_Timestamp(py::wrapper::Windows::Devices::Sensors::ActivitySensorReading* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Sensors.ActivitySensorReading", L"Timestamp"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Timestamp());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_ActivitySensorReading(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Devices::Sensors::ActivitySensorReading>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_ActivitySensorReading(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Devices::Sensors::ActivitySensorReading>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_ActivitySensorReading[] = {
        { "_assign_array_", _assign_array_ActivitySensorReading, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_ActivitySensorReading), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_ActivitySensorReading[] = {
        { "activity", reinterpret_cast<getter>(ActivitySensorReading_get_Activity), nullptr, nullptr, nullptr },
        { "confidence", reinterpret_cast<getter>(ActivitySensorReading_get_Confidence), nullptr, nullptr, nullptr },
        { "timestamp", reinterpret_cast<getter>(ActivitySensorReading_get_Timestamp), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_ActivitySensorReading[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_ActivitySensorReading) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_ActivitySensorReading) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_ActivitySensorReading) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_ActivitySensorReading) },
        { },
    };

    static PyType_Spec type_spec_ActivitySensorReading =
    {
        "winrt._winrt_windows_devices_sensors.ActivitySensorReading",
        sizeof(py::wrapper::Windows::Devices::Sensors::ActivitySensorReading),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_ActivitySensorReading
    };

    // ----- ActivitySensorReadingChangeReport class --------------------

    static PyObject* _new_ActivitySensorReadingChangeReport(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Devices::Sensors::ActivitySensorReadingChangeReport>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Devices::Sensors::ActivitySensorReadingChangeReport>::type_name);
        return nullptr;
    }

    static void _dealloc_ActivitySensorReadingChangeReport(py::wrapper::Windows::Devices::Sensors::ActivitySensorReadingChangeReport* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* ActivitySensorReadingChangeReport_get_Reading(py::wrapper::Windows::Devices::Sensors::ActivitySensorReadingChangeReport* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Sensors.ActivitySensorReadingChangeReport", L"Reading"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Reading());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_ActivitySensorReadingChangeReport(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Devices::Sensors::ActivitySensorReadingChangeReport>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_ActivitySensorReadingChangeReport(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Devices::Sensors::ActivitySensorReadingChangeReport>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_ActivitySensorReadingChangeReport[] = {
        { "_assign_array_", _assign_array_ActivitySensorReadingChangeReport, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_ActivitySensorReadingChangeReport), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_ActivitySensorReadingChangeReport[] = {
        { "reading", reinterpret_cast<getter>(ActivitySensorReadingChangeReport_get_Reading), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_ActivitySensorReadingChangeReport[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_ActivitySensorReadingChangeReport) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_ActivitySensorReadingChangeReport) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_ActivitySensorReadingChangeReport) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_ActivitySensorReadingChangeReport) },
        { },
    };

    static PyType_Spec type_spec_ActivitySensorReadingChangeReport =
    {
        "winrt._winrt_windows_devices_sensors.ActivitySensorReadingChangeReport",
        sizeof(py::wrapper::Windows::Devices::Sensors::ActivitySensorReadingChangeReport),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_ActivitySensorReadingChangeReport
    };

    // ----- ActivitySensorReadingChangedEventArgs class --------------------

    static PyObject* _new_ActivitySensorReadingChangedEventArgs(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Devices::Sensors::ActivitySensorReadingChangedEventArgs>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Devices::Sensors::ActivitySensorReadingChangedEventArgs>::type_name);
        return nullptr;
    }

    static void _dealloc_ActivitySensorReadingChangedEventArgs(py::wrapper::Windows::Devices::Sensors::ActivitySensorReadingChangedEventArgs* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* ActivitySensorReadingChangedEventArgs_get_Reading(py::wrapper::Windows::Devices::Sensors::ActivitySensorReadingChangedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Sensors.ActivitySensorReadingChangedEventArgs", L"Reading"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Reading());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_ActivitySensorReadingChangedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Devices::Sensors::ActivitySensorReadingChangedEventArgs>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_ActivitySensorReadingChangedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Devices::Sensors::ActivitySensorReadingChangedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_ActivitySensorReadingChangedEventArgs[] = {
        { "_assign_array_", _assign_array_ActivitySensorReadingChangedEventArgs, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_ActivitySensorReadingChangedEventArgs), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_ActivitySensorReadingChangedEventArgs[] = {
        { "reading", reinterpret_cast<getter>(ActivitySensorReadingChangedEventArgs_get_Reading), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_ActivitySensorReadingChangedEventArgs[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_ActivitySensorReadingChangedEventArgs) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_ActivitySensorReadingChangedEventArgs) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_ActivitySensorReadingChangedEventArgs) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_ActivitySensorReadingChangedEventArgs) },
        { },
    };

    static PyType_Spec type_spec_ActivitySensorReadingChangedEventArgs =
    {
        "winrt._winrt_windows_devices_sensors.ActivitySensorReadingChangedEventArgs",
        sizeof(py::wrapper::Windows::Devices::Sensors::ActivitySensorReadingChangedEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_ActivitySensorReadingChangedEventArgs
    };

    // ----- ActivitySensorTriggerDetails class --------------------

    static PyObject* _new_ActivitySensorTriggerDetails(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Devices::Sensors::ActivitySensorTriggerDetails>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Devices::Sensors::ActivitySensorTriggerDetails>::type_name);
        return nullptr;
    }

    static void _dealloc_ActivitySensorTriggerDetails(py::wrapper::Windows::Devices::Sensors::ActivitySensorTriggerDetails* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* ActivitySensorTriggerDetails_ReadReports(py::wrapper::Windows::Devices::Sensors::ActivitySensorTriggerDetails* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.Sensors.ActivitySensorTriggerDetails", L"ReadReports", 0))
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert(self->obj.ReadReports());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* _assign_array_ActivitySensorTriggerDetails(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Devices::Sensors::ActivitySensorTriggerDetails>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_ActivitySensorTriggerDetails(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Devices::Sensors::ActivitySensorTriggerDetails>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_ActivitySensorTriggerDetails[] = {
        { "read_reports", reinterpret_cast<PyCFunction>(ActivitySensorTriggerDetails_ReadReports), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_ActivitySensorTriggerDetails, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_ActivitySensorTriggerDetails), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_ActivitySensorTriggerDetails[] = {
        { }
    };

    static PyType_Slot _type_slots_ActivitySensorTriggerDetails[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_ActivitySensorTriggerDetails) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_ActivitySensorTriggerDetails) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_ActivitySensorTriggerDetails) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_ActivitySensorTriggerDetails) },
        { },
    };

    static PyType_Spec type_spec_ActivitySensorTriggerDetails =
    {
        "winrt._winrt_windows_devices_sensors.ActivitySensorTriggerDetails",
        sizeof(py::wrapper::Windows::Devices::Sensors::ActivitySensorTriggerDetails),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_ActivitySensorTriggerDetails
    };

    // ----- AdaptiveDimmingOptions class --------------------

    static PyObject* _new_AdaptiveDimmingOptions(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Devices::Sensors::AdaptiveDimmingOptions>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Devices::Sensors::AdaptiveDimmingOptions>::type_name);
        return nullptr;
    }

    static void _dealloc_AdaptiveDimmingOptions(py::wrapper::Windows::Devices::Sensors::AdaptiveDimmingOptions* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* AdaptiveDimmingOptions_get_AllowWhenExternalDisplayConnected(py::wrapper::Windows::Devices::Sensors::AdaptiveDimmingOptions* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Sensors.AdaptiveDimmingOptions", L"AllowWhenExternalDisplayConnected"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.AllowWhenExternalDisplayConnected());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int AdaptiveDimmingOptions_put_AllowWhenExternalDisplayConnected(py::wrapper::Windows::Devices::Sensors::AdaptiveDimmingOptions* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Sensors.AdaptiveDimmingOptions", L"AllowWhenExternalDisplayConnected"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<bool>(arg);

            self->obj.AllowWhenExternalDisplayConnected(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* _assign_array_AdaptiveDimmingOptions(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Devices::Sensors::AdaptiveDimmingOptions>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_AdaptiveDimmingOptions(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Devices::Sensors::AdaptiveDimmingOptions>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_AdaptiveDimmingOptions[] = {
        { "_assign_array_", _assign_array_AdaptiveDimmingOptions, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_AdaptiveDimmingOptions), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_AdaptiveDimmingOptions[] = {
        { "allow_when_external_display_connected", reinterpret_cast<getter>(AdaptiveDimmingOptions_get_AllowWhenExternalDisplayConnected), reinterpret_cast<setter>(AdaptiveDimmingOptions_put_AllowWhenExternalDisplayConnected), nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_AdaptiveDimmingOptions[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_AdaptiveDimmingOptions) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_AdaptiveDimmingOptions) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_AdaptiveDimmingOptions) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_AdaptiveDimmingOptions) },
        { },
    };

    static PyType_Spec type_spec_AdaptiveDimmingOptions =
    {
        "winrt._winrt_windows_devices_sensors.AdaptiveDimmingOptions",
        sizeof(py::wrapper::Windows::Devices::Sensors::AdaptiveDimmingOptions),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_AdaptiveDimmingOptions
    };

    // ----- Altimeter class --------------------

    static PyObject* _new_Altimeter(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Devices::Sensors::Altimeter>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Devices::Sensors::Altimeter>::type_name);
        return nullptr;
    }

    static void _dealloc_Altimeter(py::wrapper::Windows::Devices::Sensors::Altimeter* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* Altimeter_GetCurrentReading(py::wrapper::Windows::Devices::Sensors::Altimeter* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.Sensors.Altimeter", L"GetCurrentReading", 0))
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert(self->obj.GetCurrentReading());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* Altimeter_GetDefault(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.Sensors.Altimeter", L"GetDefault", 0))
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert(winrt::Windows::Devices::Sensors::Altimeter::GetDefault());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* Altimeter_get_ReportInterval(py::wrapper::Windows::Devices::Sensors::Altimeter* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Sensors.Altimeter", L"ReportInterval"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.ReportInterval());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int Altimeter_put_ReportInterval(py::wrapper::Windows::Devices::Sensors::Altimeter* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Sensors.Altimeter", L"ReportInterval"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<uint32_t>(arg);

            self->obj.ReportInterval(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* Altimeter_get_DeviceId(py::wrapper::Windows::Devices::Sensors::Altimeter* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Sensors.Altimeter", L"DeviceId"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.DeviceId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* Altimeter_get_MinimumReportInterval(py::wrapper::Windows::Devices::Sensors::Altimeter* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Sensors.Altimeter", L"MinimumReportInterval"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.MinimumReportInterval());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* Altimeter_get_ReportLatency(py::wrapper::Windows::Devices::Sensors::Altimeter* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Sensors.Altimeter", L"ReportLatency"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.ReportLatency());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int Altimeter_put_ReportLatency(py::wrapper::Windows::Devices::Sensors::Altimeter* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Sensors.Altimeter", L"ReportLatency"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<uint32_t>(arg);

            self->obj.ReportLatency(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* Altimeter_get_MaxBatchSize(py::wrapper::Windows::Devices::Sensors::Altimeter* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Sensors.Altimeter", L"MaxBatchSize"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.MaxBatchSize());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* Altimeter_add_ReadingChanged(py::wrapper::Windows::Devices::Sensors::Altimeter* self, PyObject* arg) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Devices.Sensors.Altimeter", L"ReadingChanged"))
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Devices::Sensors::Altimeter, winrt::Windows::Devices::Sensors::AltimeterReadingChangedEventArgs>>(arg);

            return py::convert(self->obj.ReadingChanged(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* Altimeter_remove_ReadingChanged(py::wrapper::Windows::Devices::Sensors::Altimeter* self, PyObject* arg) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Devices.Sensors.Altimeter", L"ReadingChanged"))
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.ReadingChanged(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_Altimeter(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Devices::Sensors::Altimeter>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_Altimeter(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Devices::Sensors::Altimeter>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_Altimeter[] = {
        { "get_current_reading", reinterpret_cast<PyCFunction>(Altimeter_GetCurrentReading), METH_VARARGS, nullptr },
        { "add_reading_changed", reinterpret_cast<PyCFunction>(Altimeter_add_ReadingChanged), METH_O, nullptr },
        { "remove_reading_changed", reinterpret_cast<PyCFunction>(Altimeter_remove_ReadingChanged), METH_O, nullptr },
        { "_assign_array_", _assign_array_Altimeter, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_Altimeter), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_Altimeter[] = {
        { "report_interval", reinterpret_cast<getter>(Altimeter_get_ReportInterval), reinterpret_cast<setter>(Altimeter_put_ReportInterval), nullptr, nullptr },
        { "device_id", reinterpret_cast<getter>(Altimeter_get_DeviceId), nullptr, nullptr, nullptr },
        { "minimum_report_interval", reinterpret_cast<getter>(Altimeter_get_MinimumReportInterval), nullptr, nullptr, nullptr },
        { "report_latency", reinterpret_cast<getter>(Altimeter_get_ReportLatency), reinterpret_cast<setter>(Altimeter_put_ReportLatency), nullptr, nullptr },
        { "max_batch_size", reinterpret_cast<getter>(Altimeter_get_MaxBatchSize), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_Altimeter[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_Altimeter) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_Altimeter) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_Altimeter) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_Altimeter) },
        { },
    };

    static PyType_Spec type_spec_Altimeter =
    {
        "winrt._winrt_windows_devices_sensors.Altimeter",
        sizeof(py::wrapper::Windows::Devices::Sensors::Altimeter),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_Altimeter
    };

    static PyGetSetDef getset_Altimeter_Static[] = {
        { }
    };

    static PyMethodDef methods_Altimeter_Static[] = {
        { "get_default", reinterpret_cast<PyCFunction>(Altimeter_GetDefault), METH_VARARGS, nullptr },
        { }
    };

    static PyType_Slot type_slots_Altimeter_Static[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_Altimeter_Static) },
        { Py_tp_methods, reinterpret_cast<void*>(methods_Altimeter_Static) },
        { }
    };

    static PyType_Spec type_spec_Altimeter_Static =
    {
        "winrt._winrt_windows_devices_sensors.Altimeter_Static",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT,
        type_slots_Altimeter_Static
    };

    // ----- AltimeterReading class --------------------

    static PyObject* _new_AltimeterReading(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Devices::Sensors::AltimeterReading>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Devices::Sensors::AltimeterReading>::type_name);
        return nullptr;
    }

    static void _dealloc_AltimeterReading(py::wrapper::Windows::Devices::Sensors::AltimeterReading* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* AltimeterReading_get_AltitudeChangeInMeters(py::wrapper::Windows::Devices::Sensors::AltimeterReading* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Sensors.AltimeterReading", L"AltitudeChangeInMeters"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.AltitudeChangeInMeters());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AltimeterReading_get_Timestamp(py::wrapper::Windows::Devices::Sensors::AltimeterReading* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Sensors.AltimeterReading", L"Timestamp"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Timestamp());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AltimeterReading_get_PerformanceCount(py::wrapper::Windows::Devices::Sensors::AltimeterReading* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Sensors.AltimeterReading", L"PerformanceCount"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.PerformanceCount());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AltimeterReading_get_Properties(py::wrapper::Windows::Devices::Sensors::AltimeterReading* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Sensors.AltimeterReading", L"Properties"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Properties());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_AltimeterReading(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Devices::Sensors::AltimeterReading>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_AltimeterReading(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Devices::Sensors::AltimeterReading>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_AltimeterReading[] = {
        { "_assign_array_", _assign_array_AltimeterReading, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_AltimeterReading), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_AltimeterReading[] = {
        { "altitude_change_in_meters", reinterpret_cast<getter>(AltimeterReading_get_AltitudeChangeInMeters), nullptr, nullptr, nullptr },
        { "timestamp", reinterpret_cast<getter>(AltimeterReading_get_Timestamp), nullptr, nullptr, nullptr },
        { "performance_count", reinterpret_cast<getter>(AltimeterReading_get_PerformanceCount), nullptr, nullptr, nullptr },
        { "properties", reinterpret_cast<getter>(AltimeterReading_get_Properties), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_AltimeterReading[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_AltimeterReading) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_AltimeterReading) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_AltimeterReading) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_AltimeterReading) },
        { },
    };

    static PyType_Spec type_spec_AltimeterReading =
    {
        "winrt._winrt_windows_devices_sensors.AltimeterReading",
        sizeof(py::wrapper::Windows::Devices::Sensors::AltimeterReading),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_AltimeterReading
    };

    // ----- AltimeterReadingChangedEventArgs class --------------------

    static PyObject* _new_AltimeterReadingChangedEventArgs(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Devices::Sensors::AltimeterReadingChangedEventArgs>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Devices::Sensors::AltimeterReadingChangedEventArgs>::type_name);
        return nullptr;
    }

    static void _dealloc_AltimeterReadingChangedEventArgs(py::wrapper::Windows::Devices::Sensors::AltimeterReadingChangedEventArgs* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* AltimeterReadingChangedEventArgs_get_Reading(py::wrapper::Windows::Devices::Sensors::AltimeterReadingChangedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Sensors.AltimeterReadingChangedEventArgs", L"Reading"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Reading());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_AltimeterReadingChangedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Devices::Sensors::AltimeterReadingChangedEventArgs>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_AltimeterReadingChangedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Devices::Sensors::AltimeterReadingChangedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_AltimeterReadingChangedEventArgs[] = {
        { "_assign_array_", _assign_array_AltimeterReadingChangedEventArgs, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_AltimeterReadingChangedEventArgs), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_AltimeterReadingChangedEventArgs[] = {
        { "reading", reinterpret_cast<getter>(AltimeterReadingChangedEventArgs_get_Reading), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_AltimeterReadingChangedEventArgs[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_AltimeterReadingChangedEventArgs) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_AltimeterReadingChangedEventArgs) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_AltimeterReadingChangedEventArgs) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_AltimeterReadingChangedEventArgs) },
        { },
    };

    static PyType_Spec type_spec_AltimeterReadingChangedEventArgs =
    {
        "winrt._winrt_windows_devices_sensors.AltimeterReadingChangedEventArgs",
        sizeof(py::wrapper::Windows::Devices::Sensors::AltimeterReadingChangedEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_AltimeterReadingChangedEventArgs
    };

    // ----- Barometer class --------------------

    static PyObject* _new_Barometer(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Devices::Sensors::Barometer>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Devices::Sensors::Barometer>::type_name);
        return nullptr;
    }

    static void _dealloc_Barometer(py::wrapper::Windows::Devices::Sensors::Barometer* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* Barometer_FromIdAsync(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.Sensors.Barometer", L"FromIdAsync", 1))
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                return py::convert(winrt::Windows::Devices::Sensors::Barometer::FromIdAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* Barometer_GetCurrentReading(py::wrapper::Windows::Devices::Sensors::Barometer* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.Sensors.Barometer", L"GetCurrentReading", 0))
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert(self->obj.GetCurrentReading());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* Barometer_GetDefault(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.Sensors.Barometer", L"GetDefault", 0))
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert(winrt::Windows::Devices::Sensors::Barometer::GetDefault());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* Barometer_GetDeviceSelector(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.Sensors.Barometer", L"GetDeviceSelector", 0))
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert(winrt::Windows::Devices::Sensors::Barometer::GetDeviceSelector());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* Barometer_get_ReportInterval(py::wrapper::Windows::Devices::Sensors::Barometer* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Sensors.Barometer", L"ReportInterval"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.ReportInterval());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int Barometer_put_ReportInterval(py::wrapper::Windows::Devices::Sensors::Barometer* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Sensors.Barometer", L"ReportInterval"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<uint32_t>(arg);

            self->obj.ReportInterval(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* Barometer_get_DeviceId(py::wrapper::Windows::Devices::Sensors::Barometer* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Sensors.Barometer", L"DeviceId"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.DeviceId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* Barometer_get_MinimumReportInterval(py::wrapper::Windows::Devices::Sensors::Barometer* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Sensors.Barometer", L"MinimumReportInterval"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.MinimumReportInterval());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* Barometer_get_ReportLatency(py::wrapper::Windows::Devices::Sensors::Barometer* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Sensors.Barometer", L"ReportLatency"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.ReportLatency());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int Barometer_put_ReportLatency(py::wrapper::Windows::Devices::Sensors::Barometer* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Sensors.Barometer", L"ReportLatency"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<uint32_t>(arg);

            self->obj.ReportLatency(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* Barometer_get_MaxBatchSize(py::wrapper::Windows::Devices::Sensors::Barometer* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Sensors.Barometer", L"MaxBatchSize"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.MaxBatchSize());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* Barometer_get_ReportThreshold(py::wrapper::Windows::Devices::Sensors::Barometer* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Sensors.Barometer", L"ReportThreshold"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.ReportThreshold());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* Barometer_add_ReadingChanged(py::wrapper::Windows::Devices::Sensors::Barometer* self, PyObject* arg) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Devices.Sensors.Barometer", L"ReadingChanged"))
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Devices::Sensors::Barometer, winrt::Windows::Devices::Sensors::BarometerReadingChangedEventArgs>>(arg);

            return py::convert(self->obj.ReadingChanged(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* Barometer_remove_ReadingChanged(py::wrapper::Windows::Devices::Sensors::Barometer* self, PyObject* arg) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Devices.Sensors.Barometer", L"ReadingChanged"))
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.ReadingChanged(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_Barometer(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Devices::Sensors::Barometer>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_Barometer(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Devices::Sensors::Barometer>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_Barometer[] = {
        { "get_current_reading", reinterpret_cast<PyCFunction>(Barometer_GetCurrentReading), METH_VARARGS, nullptr },
        { "add_reading_changed", reinterpret_cast<PyCFunction>(Barometer_add_ReadingChanged), METH_O, nullptr },
        { "remove_reading_changed", reinterpret_cast<PyCFunction>(Barometer_remove_ReadingChanged), METH_O, nullptr },
        { "_assign_array_", _assign_array_Barometer, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_Barometer), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_Barometer[] = {
        { "report_interval", reinterpret_cast<getter>(Barometer_get_ReportInterval), reinterpret_cast<setter>(Barometer_put_ReportInterval), nullptr, nullptr },
        { "device_id", reinterpret_cast<getter>(Barometer_get_DeviceId), nullptr, nullptr, nullptr },
        { "minimum_report_interval", reinterpret_cast<getter>(Barometer_get_MinimumReportInterval), nullptr, nullptr, nullptr },
        { "report_latency", reinterpret_cast<getter>(Barometer_get_ReportLatency), reinterpret_cast<setter>(Barometer_put_ReportLatency), nullptr, nullptr },
        { "max_batch_size", reinterpret_cast<getter>(Barometer_get_MaxBatchSize), nullptr, nullptr, nullptr },
        { "report_threshold", reinterpret_cast<getter>(Barometer_get_ReportThreshold), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_Barometer[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_Barometer) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_Barometer) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_Barometer) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_Barometer) },
        { },
    };

    static PyType_Spec type_spec_Barometer =
    {
        "winrt._winrt_windows_devices_sensors.Barometer",
        sizeof(py::wrapper::Windows::Devices::Sensors::Barometer),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_Barometer
    };

    static PyGetSetDef getset_Barometer_Static[] = {
        { }
    };

    static PyMethodDef methods_Barometer_Static[] = {
        { "from_id_async", reinterpret_cast<PyCFunction>(Barometer_FromIdAsync), METH_VARARGS, nullptr },
        { "get_default", reinterpret_cast<PyCFunction>(Barometer_GetDefault), METH_VARARGS, nullptr },
        { "get_device_selector", reinterpret_cast<PyCFunction>(Barometer_GetDeviceSelector), METH_VARARGS, nullptr },
        { }
    };

    static PyType_Slot type_slots_Barometer_Static[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_Barometer_Static) },
        { Py_tp_methods, reinterpret_cast<void*>(methods_Barometer_Static) },
        { }
    };

    static PyType_Spec type_spec_Barometer_Static =
    {
        "winrt._winrt_windows_devices_sensors.Barometer_Static",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT,
        type_slots_Barometer_Static
    };

    // ----- BarometerDataThreshold class --------------------

    static PyObject* _new_BarometerDataThreshold(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Devices::Sensors::BarometerDataThreshold>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Devices::Sensors::BarometerDataThreshold>::type_name);
        return nullptr;
    }

    static void _dealloc_BarometerDataThreshold(py::wrapper::Windows::Devices::Sensors::BarometerDataThreshold* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* BarometerDataThreshold_get_Hectopascals(py::wrapper::Windows::Devices::Sensors::BarometerDataThreshold* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Sensors.BarometerDataThreshold", L"Hectopascals"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Hectopascals());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int BarometerDataThreshold_put_Hectopascals(py::wrapper::Windows::Devices::Sensors::BarometerDataThreshold* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Sensors.BarometerDataThreshold", L"Hectopascals"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<double>(arg);

            self->obj.Hectopascals(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* _assign_array_BarometerDataThreshold(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Devices::Sensors::BarometerDataThreshold>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_BarometerDataThreshold(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Devices::Sensors::BarometerDataThreshold>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_BarometerDataThreshold[] = {
        { "_assign_array_", _assign_array_BarometerDataThreshold, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_BarometerDataThreshold), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_BarometerDataThreshold[] = {
        { "hectopascals", reinterpret_cast<getter>(BarometerDataThreshold_get_Hectopascals), reinterpret_cast<setter>(BarometerDataThreshold_put_Hectopascals), nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_BarometerDataThreshold[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_BarometerDataThreshold) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_BarometerDataThreshold) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_BarometerDataThreshold) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_BarometerDataThreshold) },
        { },
    };

    static PyType_Spec type_spec_BarometerDataThreshold =
    {
        "winrt._winrt_windows_devices_sensors.BarometerDataThreshold",
        sizeof(py::wrapper::Windows::Devices::Sensors::BarometerDataThreshold),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_BarometerDataThreshold
    };

    // ----- BarometerReading class --------------------

    static PyObject* _new_BarometerReading(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Devices::Sensors::BarometerReading>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Devices::Sensors::BarometerReading>::type_name);
        return nullptr;
    }

    static void _dealloc_BarometerReading(py::wrapper::Windows::Devices::Sensors::BarometerReading* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* BarometerReading_get_StationPressureInHectopascals(py::wrapper::Windows::Devices::Sensors::BarometerReading* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Sensors.BarometerReading", L"StationPressureInHectopascals"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.StationPressureInHectopascals());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* BarometerReading_get_Timestamp(py::wrapper::Windows::Devices::Sensors::BarometerReading* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Sensors.BarometerReading", L"Timestamp"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Timestamp());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* BarometerReading_get_PerformanceCount(py::wrapper::Windows::Devices::Sensors::BarometerReading* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Sensors.BarometerReading", L"PerformanceCount"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.PerformanceCount());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* BarometerReading_get_Properties(py::wrapper::Windows::Devices::Sensors::BarometerReading* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Sensors.BarometerReading", L"Properties"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Properties());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_BarometerReading(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Devices::Sensors::BarometerReading>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_BarometerReading(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Devices::Sensors::BarometerReading>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_BarometerReading[] = {
        { "_assign_array_", _assign_array_BarometerReading, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_BarometerReading), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_BarometerReading[] = {
        { "station_pressure_in_hectopascals", reinterpret_cast<getter>(BarometerReading_get_StationPressureInHectopascals), nullptr, nullptr, nullptr },
        { "timestamp", reinterpret_cast<getter>(BarometerReading_get_Timestamp), nullptr, nullptr, nullptr },
        { "performance_count", reinterpret_cast<getter>(BarometerReading_get_PerformanceCount), nullptr, nullptr, nullptr },
        { "properties", reinterpret_cast<getter>(BarometerReading_get_Properties), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_BarometerReading[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_BarometerReading) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_BarometerReading) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_BarometerReading) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_BarometerReading) },
        { },
    };

    static PyType_Spec type_spec_BarometerReading =
    {
        "winrt._winrt_windows_devices_sensors.BarometerReading",
        sizeof(py::wrapper::Windows::Devices::Sensors::BarometerReading),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_BarometerReading
    };

    // ----- BarometerReadingChangedEventArgs class --------------------

    static PyObject* _new_BarometerReadingChangedEventArgs(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Devices::Sensors::BarometerReadingChangedEventArgs>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Devices::Sensors::BarometerReadingChangedEventArgs>::type_name);
        return nullptr;
    }

    static void _dealloc_BarometerReadingChangedEventArgs(py::wrapper::Windows::Devices::Sensors::BarometerReadingChangedEventArgs* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* BarometerReadingChangedEventArgs_get_Reading(py::wrapper::Windows::Devices::Sensors::BarometerReadingChangedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Sensors.BarometerReadingChangedEventArgs", L"Reading"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Reading());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_BarometerReadingChangedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Devices::Sensors::BarometerReadingChangedEventArgs>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_BarometerReadingChangedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Devices::Sensors::BarometerReadingChangedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_BarometerReadingChangedEventArgs[] = {
        { "_assign_array_", _assign_array_BarometerReadingChangedEventArgs, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_BarometerReadingChangedEventArgs), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_BarometerReadingChangedEventArgs[] = {
        { "reading", reinterpret_cast<getter>(BarometerReadingChangedEventArgs_get_Reading), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_BarometerReadingChangedEventArgs[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_BarometerReadingChangedEventArgs) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_BarometerReadingChangedEventArgs) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_BarometerReadingChangedEventArgs) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_BarometerReadingChangedEventArgs) },
        { },
    };

    static PyType_Spec type_spec_BarometerReadingChangedEventArgs =
    {
        "winrt._winrt_windows_devices_sensors.BarometerReadingChangedEventArgs",
        sizeof(py::wrapper::Windows::Devices::Sensors::BarometerReadingChangedEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_BarometerReadingChangedEventArgs
    };

    // ----- Compass class --------------------

    static PyObject* _new_Compass(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Devices::Sensors::Compass>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Devices::Sensors::Compass>::type_name);
        return nullptr;
    }

    static void _dealloc_Compass(py::wrapper::Windows::Devices::Sensors::Compass* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* Compass_FromIdAsync(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.Sensors.Compass", L"FromIdAsync", 1))
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                return py::convert(winrt::Windows::Devices::Sensors::Compass::FromIdAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* Compass_GetCurrentReading(py::wrapper::Windows::Devices::Sensors::Compass* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.Sensors.Compass", L"GetCurrentReading", 0))
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert(self->obj.GetCurrentReading());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* Compass_GetDefault(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.Sensors.Compass", L"GetDefault", 0))
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert(winrt::Windows::Devices::Sensors::Compass::GetDefault());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* Compass_GetDeviceSelector(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.Sensors.Compass", L"GetDeviceSelector", 0))
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert(winrt::Windows::Devices::Sensors::Compass::GetDeviceSelector());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* Compass_get_ReportInterval(py::wrapper::Windows::Devices::Sensors::Compass* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Sensors.Compass", L"ReportInterval"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.ReportInterval());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int Compass_put_ReportInterval(py::wrapper::Windows::Devices::Sensors::Compass* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Sensors.Compass", L"ReportInterval"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<uint32_t>(arg);

            self->obj.ReportInterval(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* Compass_get_MinimumReportInterval(py::wrapper::Windows::Devices::Sensors::Compass* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Sensors.Compass", L"MinimumReportInterval"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.MinimumReportInterval());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* Compass_get_ReadingTransform(py::wrapper::Windows::Devices::Sensors::Compass* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Sensors.Compass", L"ReadingTransform"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.ReadingTransform());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int Compass_put_ReadingTransform(py::wrapper::Windows::Devices::Sensors::Compass* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Sensors.Compass", L"ReadingTransform"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::Graphics::Display::DisplayOrientations>(arg);

            self->obj.ReadingTransform(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* Compass_get_ReportLatency(py::wrapper::Windows::Devices::Sensors::Compass* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Sensors.Compass", L"ReportLatency"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.ReportLatency());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int Compass_put_ReportLatency(py::wrapper::Windows::Devices::Sensors::Compass* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Sensors.Compass", L"ReportLatency"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<uint32_t>(arg);

            self->obj.ReportLatency(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* Compass_get_MaxBatchSize(py::wrapper::Windows::Devices::Sensors::Compass* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Sensors.Compass", L"MaxBatchSize"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.MaxBatchSize());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* Compass_get_ReportThreshold(py::wrapper::Windows::Devices::Sensors::Compass* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Sensors.Compass", L"ReportThreshold"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.ReportThreshold());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* Compass_get_DeviceId(py::wrapper::Windows::Devices::Sensors::Compass* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Sensors.Compass", L"DeviceId"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.DeviceId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* Compass_add_ReadingChanged(py::wrapper::Windows::Devices::Sensors::Compass* self, PyObject* arg) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Devices.Sensors.Compass", L"ReadingChanged"))
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Devices::Sensors::Compass, winrt::Windows::Devices::Sensors::CompassReadingChangedEventArgs>>(arg);

            return py::convert(self->obj.ReadingChanged(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* Compass_remove_ReadingChanged(py::wrapper::Windows::Devices::Sensors::Compass* self, PyObject* arg) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Devices.Sensors.Compass", L"ReadingChanged"))
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.ReadingChanged(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_Compass(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Devices::Sensors::Compass>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_Compass(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Devices::Sensors::Compass>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_Compass[] = {
        { "get_current_reading", reinterpret_cast<PyCFunction>(Compass_GetCurrentReading), METH_VARARGS, nullptr },
        { "add_reading_changed", reinterpret_cast<PyCFunction>(Compass_add_ReadingChanged), METH_O, nullptr },
        { "remove_reading_changed", reinterpret_cast<PyCFunction>(Compass_remove_ReadingChanged), METH_O, nullptr },
        { "_assign_array_", _assign_array_Compass, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_Compass), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_Compass[] = {
        { "report_interval", reinterpret_cast<getter>(Compass_get_ReportInterval), reinterpret_cast<setter>(Compass_put_ReportInterval), nullptr, nullptr },
        { "minimum_report_interval", reinterpret_cast<getter>(Compass_get_MinimumReportInterval), nullptr, nullptr, nullptr },
        { "reading_transform", reinterpret_cast<getter>(Compass_get_ReadingTransform), reinterpret_cast<setter>(Compass_put_ReadingTransform), nullptr, nullptr },
        { "report_latency", reinterpret_cast<getter>(Compass_get_ReportLatency), reinterpret_cast<setter>(Compass_put_ReportLatency), nullptr, nullptr },
        { "max_batch_size", reinterpret_cast<getter>(Compass_get_MaxBatchSize), nullptr, nullptr, nullptr },
        { "report_threshold", reinterpret_cast<getter>(Compass_get_ReportThreshold), nullptr, nullptr, nullptr },
        { "device_id", reinterpret_cast<getter>(Compass_get_DeviceId), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_Compass[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_Compass) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_Compass) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_Compass) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_Compass) },
        { },
    };

    static PyType_Spec type_spec_Compass =
    {
        "winrt._winrt_windows_devices_sensors.Compass",
        sizeof(py::wrapper::Windows::Devices::Sensors::Compass),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_Compass
    };

    static PyGetSetDef getset_Compass_Static[] = {
        { }
    };

    static PyMethodDef methods_Compass_Static[] = {
        { "from_id_async", reinterpret_cast<PyCFunction>(Compass_FromIdAsync), METH_VARARGS, nullptr },
        { "get_default", reinterpret_cast<PyCFunction>(Compass_GetDefault), METH_VARARGS, nullptr },
        { "get_device_selector", reinterpret_cast<PyCFunction>(Compass_GetDeviceSelector), METH_VARARGS, nullptr },
        { }
    };

    static PyType_Slot type_slots_Compass_Static[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_Compass_Static) },
        { Py_tp_methods, reinterpret_cast<void*>(methods_Compass_Static) },
        { }
    };

    static PyType_Spec type_spec_Compass_Static =
    {
        "winrt._winrt_windows_devices_sensors.Compass_Static",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT,
        type_slots_Compass_Static
    };

    // ----- CompassDataThreshold class --------------------

    static PyObject* _new_CompassDataThreshold(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Devices::Sensors::CompassDataThreshold>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Devices::Sensors::CompassDataThreshold>::type_name);
        return nullptr;
    }

    static void _dealloc_CompassDataThreshold(py::wrapper::Windows::Devices::Sensors::CompassDataThreshold* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* CompassDataThreshold_get_Degrees(py::wrapper::Windows::Devices::Sensors::CompassDataThreshold* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Sensors.CompassDataThreshold", L"Degrees"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Degrees());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int CompassDataThreshold_put_Degrees(py::wrapper::Windows::Devices::Sensors::CompassDataThreshold* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Sensors.CompassDataThreshold", L"Degrees"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<double>(arg);

            self->obj.Degrees(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* _assign_array_CompassDataThreshold(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Devices::Sensors::CompassDataThreshold>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_CompassDataThreshold(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Devices::Sensors::CompassDataThreshold>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_CompassDataThreshold[] = {
        { "_assign_array_", _assign_array_CompassDataThreshold, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_CompassDataThreshold), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_CompassDataThreshold[] = {
        { "degrees", reinterpret_cast<getter>(CompassDataThreshold_get_Degrees), reinterpret_cast<setter>(CompassDataThreshold_put_Degrees), nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_CompassDataThreshold[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_CompassDataThreshold) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_CompassDataThreshold) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_CompassDataThreshold) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_CompassDataThreshold) },
        { },
    };

    static PyType_Spec type_spec_CompassDataThreshold =
    {
        "winrt._winrt_windows_devices_sensors.CompassDataThreshold",
        sizeof(py::wrapper::Windows::Devices::Sensors::CompassDataThreshold),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_CompassDataThreshold
    };

    // ----- CompassReading class --------------------

    static PyObject* _new_CompassReading(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Devices::Sensors::CompassReading>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Devices::Sensors::CompassReading>::type_name);
        return nullptr;
    }

    static void _dealloc_CompassReading(py::wrapper::Windows::Devices::Sensors::CompassReading* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* CompassReading_get_HeadingMagneticNorth(py::wrapper::Windows::Devices::Sensors::CompassReading* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Sensors.CompassReading", L"HeadingMagneticNorth"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.HeadingMagneticNorth());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CompassReading_get_HeadingTrueNorth(py::wrapper::Windows::Devices::Sensors::CompassReading* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Sensors.CompassReading", L"HeadingTrueNorth"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.HeadingTrueNorth());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CompassReading_get_Timestamp(py::wrapper::Windows::Devices::Sensors::CompassReading* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Sensors.CompassReading", L"Timestamp"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Timestamp());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CompassReading_get_PerformanceCount(py::wrapper::Windows::Devices::Sensors::CompassReading* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Sensors.CompassReading", L"PerformanceCount"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.PerformanceCount());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CompassReading_get_Properties(py::wrapper::Windows::Devices::Sensors::CompassReading* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Sensors.CompassReading", L"Properties"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Properties());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CompassReading_get_HeadingAccuracy(py::wrapper::Windows::Devices::Sensors::CompassReading* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Sensors.CompassReading", L"HeadingAccuracy"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.HeadingAccuracy());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_CompassReading(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Devices::Sensors::CompassReading>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_CompassReading(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Devices::Sensors::CompassReading>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_CompassReading[] = {
        { "_assign_array_", _assign_array_CompassReading, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_CompassReading), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_CompassReading[] = {
        { "heading_magnetic_north", reinterpret_cast<getter>(CompassReading_get_HeadingMagneticNorth), nullptr, nullptr, nullptr },
        { "heading_true_north", reinterpret_cast<getter>(CompassReading_get_HeadingTrueNorth), nullptr, nullptr, nullptr },
        { "timestamp", reinterpret_cast<getter>(CompassReading_get_Timestamp), nullptr, nullptr, nullptr },
        { "performance_count", reinterpret_cast<getter>(CompassReading_get_PerformanceCount), nullptr, nullptr, nullptr },
        { "properties", reinterpret_cast<getter>(CompassReading_get_Properties), nullptr, nullptr, nullptr },
        { "heading_accuracy", reinterpret_cast<getter>(CompassReading_get_HeadingAccuracy), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_CompassReading[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_CompassReading) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_CompassReading) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_CompassReading) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_CompassReading) },
        { },
    };

    static PyType_Spec type_spec_CompassReading =
    {
        "winrt._winrt_windows_devices_sensors.CompassReading",
        sizeof(py::wrapper::Windows::Devices::Sensors::CompassReading),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_CompassReading
    };

    // ----- CompassReadingChangedEventArgs class --------------------

    static PyObject* _new_CompassReadingChangedEventArgs(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Devices::Sensors::CompassReadingChangedEventArgs>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Devices::Sensors::CompassReadingChangedEventArgs>::type_name);
        return nullptr;
    }

    static void _dealloc_CompassReadingChangedEventArgs(py::wrapper::Windows::Devices::Sensors::CompassReadingChangedEventArgs* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* CompassReadingChangedEventArgs_get_Reading(py::wrapper::Windows::Devices::Sensors::CompassReadingChangedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Sensors.CompassReadingChangedEventArgs", L"Reading"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Reading());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_CompassReadingChangedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Devices::Sensors::CompassReadingChangedEventArgs>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_CompassReadingChangedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Devices::Sensors::CompassReadingChangedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_CompassReadingChangedEventArgs[] = {
        { "_assign_array_", _assign_array_CompassReadingChangedEventArgs, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_CompassReadingChangedEventArgs), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_CompassReadingChangedEventArgs[] = {
        { "reading", reinterpret_cast<getter>(CompassReadingChangedEventArgs_get_Reading), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_CompassReadingChangedEventArgs[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_CompassReadingChangedEventArgs) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_CompassReadingChangedEventArgs) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_CompassReadingChangedEventArgs) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_CompassReadingChangedEventArgs) },
        { },
    };

    static PyType_Spec type_spec_CompassReadingChangedEventArgs =
    {
        "winrt._winrt_windows_devices_sensors.CompassReadingChangedEventArgs",
        sizeof(py::wrapper::Windows::Devices::Sensors::CompassReadingChangedEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_CompassReadingChangedEventArgs
    };

    // ----- Gyrometer class --------------------

    static PyObject* _new_Gyrometer(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Devices::Sensors::Gyrometer>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Devices::Sensors::Gyrometer>::type_name);
        return nullptr;
    }

    static void _dealloc_Gyrometer(py::wrapper::Windows::Devices::Sensors::Gyrometer* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* Gyrometer_FromIdAsync(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.Sensors.Gyrometer", L"FromIdAsync", 1))
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                return py::convert(winrt::Windows::Devices::Sensors::Gyrometer::FromIdAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* Gyrometer_GetCurrentReading(py::wrapper::Windows::Devices::Sensors::Gyrometer* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.Sensors.Gyrometer", L"GetCurrentReading", 0))
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert(self->obj.GetCurrentReading());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* Gyrometer_GetDefault(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.Sensors.Gyrometer", L"GetDefault", 0))
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert(winrt::Windows::Devices::Sensors::Gyrometer::GetDefault());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* Gyrometer_GetDeviceSelector(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.Sensors.Gyrometer", L"GetDeviceSelector", 0))
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert(winrt::Windows::Devices::Sensors::Gyrometer::GetDeviceSelector());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* Gyrometer_get_ReportInterval(py::wrapper::Windows::Devices::Sensors::Gyrometer* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Sensors.Gyrometer", L"ReportInterval"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.ReportInterval());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int Gyrometer_put_ReportInterval(py::wrapper::Windows::Devices::Sensors::Gyrometer* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Sensors.Gyrometer", L"ReportInterval"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<uint32_t>(arg);

            self->obj.ReportInterval(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* Gyrometer_get_MinimumReportInterval(py::wrapper::Windows::Devices::Sensors::Gyrometer* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Sensors.Gyrometer", L"MinimumReportInterval"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.MinimumReportInterval());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* Gyrometer_get_ReadingTransform(py::wrapper::Windows::Devices::Sensors::Gyrometer* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Sensors.Gyrometer", L"ReadingTransform"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.ReadingTransform());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int Gyrometer_put_ReadingTransform(py::wrapper::Windows::Devices::Sensors::Gyrometer* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Sensors.Gyrometer", L"ReadingTransform"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::Graphics::Display::DisplayOrientations>(arg);

            self->obj.ReadingTransform(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* Gyrometer_get_ReportLatency(py::wrapper::Windows::Devices::Sensors::Gyrometer* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Sensors.Gyrometer", L"ReportLatency"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.ReportLatency());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int Gyrometer_put_ReportLatency(py::wrapper::Windows::Devices::Sensors::Gyrometer* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Sensors.Gyrometer", L"ReportLatency"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<uint32_t>(arg);

            self->obj.ReportLatency(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* Gyrometer_get_MaxBatchSize(py::wrapper::Windows::Devices::Sensors::Gyrometer* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Sensors.Gyrometer", L"MaxBatchSize"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.MaxBatchSize());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* Gyrometer_get_ReportThreshold(py::wrapper::Windows::Devices::Sensors::Gyrometer* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Sensors.Gyrometer", L"ReportThreshold"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.ReportThreshold());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* Gyrometer_get_DeviceId(py::wrapper::Windows::Devices::Sensors::Gyrometer* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Sensors.Gyrometer", L"DeviceId"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.DeviceId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* Gyrometer_add_ReadingChanged(py::wrapper::Windows::Devices::Sensors::Gyrometer* self, PyObject* arg) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Devices.Sensors.Gyrometer", L"ReadingChanged"))
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Devices::Sensors::Gyrometer, winrt::Windows::Devices::Sensors::GyrometerReadingChangedEventArgs>>(arg);

            return py::convert(self->obj.ReadingChanged(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* Gyrometer_remove_ReadingChanged(py::wrapper::Windows::Devices::Sensors::Gyrometer* self, PyObject* arg) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Devices.Sensors.Gyrometer", L"ReadingChanged"))
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.ReadingChanged(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_Gyrometer(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Devices::Sensors::Gyrometer>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_Gyrometer(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Devices::Sensors::Gyrometer>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_Gyrometer[] = {
        { "get_current_reading", reinterpret_cast<PyCFunction>(Gyrometer_GetCurrentReading), METH_VARARGS, nullptr },
        { "add_reading_changed", reinterpret_cast<PyCFunction>(Gyrometer_add_ReadingChanged), METH_O, nullptr },
        { "remove_reading_changed", reinterpret_cast<PyCFunction>(Gyrometer_remove_ReadingChanged), METH_O, nullptr },
        { "_assign_array_", _assign_array_Gyrometer, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_Gyrometer), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_Gyrometer[] = {
        { "report_interval", reinterpret_cast<getter>(Gyrometer_get_ReportInterval), reinterpret_cast<setter>(Gyrometer_put_ReportInterval), nullptr, nullptr },
        { "minimum_report_interval", reinterpret_cast<getter>(Gyrometer_get_MinimumReportInterval), nullptr, nullptr, nullptr },
        { "reading_transform", reinterpret_cast<getter>(Gyrometer_get_ReadingTransform), reinterpret_cast<setter>(Gyrometer_put_ReadingTransform), nullptr, nullptr },
        { "report_latency", reinterpret_cast<getter>(Gyrometer_get_ReportLatency), reinterpret_cast<setter>(Gyrometer_put_ReportLatency), nullptr, nullptr },
        { "max_batch_size", reinterpret_cast<getter>(Gyrometer_get_MaxBatchSize), nullptr, nullptr, nullptr },
        { "report_threshold", reinterpret_cast<getter>(Gyrometer_get_ReportThreshold), nullptr, nullptr, nullptr },
        { "device_id", reinterpret_cast<getter>(Gyrometer_get_DeviceId), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_Gyrometer[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_Gyrometer) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_Gyrometer) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_Gyrometer) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_Gyrometer) },
        { },
    };

    static PyType_Spec type_spec_Gyrometer =
    {
        "winrt._winrt_windows_devices_sensors.Gyrometer",
        sizeof(py::wrapper::Windows::Devices::Sensors::Gyrometer),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_Gyrometer
    };

    static PyGetSetDef getset_Gyrometer_Static[] = {
        { }
    };

    static PyMethodDef methods_Gyrometer_Static[] = {
        { "from_id_async", reinterpret_cast<PyCFunction>(Gyrometer_FromIdAsync), METH_VARARGS, nullptr },
        { "get_default", reinterpret_cast<PyCFunction>(Gyrometer_GetDefault), METH_VARARGS, nullptr },
        { "get_device_selector", reinterpret_cast<PyCFunction>(Gyrometer_GetDeviceSelector), METH_VARARGS, nullptr },
        { }
    };

    static PyType_Slot type_slots_Gyrometer_Static[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_Gyrometer_Static) },
        { Py_tp_methods, reinterpret_cast<void*>(methods_Gyrometer_Static) },
        { }
    };

    static PyType_Spec type_spec_Gyrometer_Static =
    {
        "winrt._winrt_windows_devices_sensors.Gyrometer_Static",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT,
        type_slots_Gyrometer_Static
    };

    // ----- GyrometerDataThreshold class --------------------

    static PyObject* _new_GyrometerDataThreshold(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Devices::Sensors::GyrometerDataThreshold>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Devices::Sensors::GyrometerDataThreshold>::type_name);
        return nullptr;
    }

    static void _dealloc_GyrometerDataThreshold(py::wrapper::Windows::Devices::Sensors::GyrometerDataThreshold* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* GyrometerDataThreshold_get_ZAxisInDegreesPerSecond(py::wrapper::Windows::Devices::Sensors::GyrometerDataThreshold* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Sensors.GyrometerDataThreshold", L"ZAxisInDegreesPerSecond"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.ZAxisInDegreesPerSecond());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int GyrometerDataThreshold_put_ZAxisInDegreesPerSecond(py::wrapper::Windows::Devices::Sensors::GyrometerDataThreshold* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Sensors.GyrometerDataThreshold", L"ZAxisInDegreesPerSecond"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<double>(arg);

            self->obj.ZAxisInDegreesPerSecond(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* GyrometerDataThreshold_get_YAxisInDegreesPerSecond(py::wrapper::Windows::Devices::Sensors::GyrometerDataThreshold* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Sensors.GyrometerDataThreshold", L"YAxisInDegreesPerSecond"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.YAxisInDegreesPerSecond());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int GyrometerDataThreshold_put_YAxisInDegreesPerSecond(py::wrapper::Windows::Devices::Sensors::GyrometerDataThreshold* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Sensors.GyrometerDataThreshold", L"YAxisInDegreesPerSecond"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<double>(arg);

            self->obj.YAxisInDegreesPerSecond(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* GyrometerDataThreshold_get_XAxisInDegreesPerSecond(py::wrapper::Windows::Devices::Sensors::GyrometerDataThreshold* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Sensors.GyrometerDataThreshold", L"XAxisInDegreesPerSecond"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.XAxisInDegreesPerSecond());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int GyrometerDataThreshold_put_XAxisInDegreesPerSecond(py::wrapper::Windows::Devices::Sensors::GyrometerDataThreshold* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Sensors.GyrometerDataThreshold", L"XAxisInDegreesPerSecond"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<double>(arg);

            self->obj.XAxisInDegreesPerSecond(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* _assign_array_GyrometerDataThreshold(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Devices::Sensors::GyrometerDataThreshold>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_GyrometerDataThreshold(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Devices::Sensors::GyrometerDataThreshold>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_GyrometerDataThreshold[] = {
        { "_assign_array_", _assign_array_GyrometerDataThreshold, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_GyrometerDataThreshold), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_GyrometerDataThreshold[] = {
        { "z_axis_in_degrees_per_second", reinterpret_cast<getter>(GyrometerDataThreshold_get_ZAxisInDegreesPerSecond), reinterpret_cast<setter>(GyrometerDataThreshold_put_ZAxisInDegreesPerSecond), nullptr, nullptr },
        { "y_axis_in_degrees_per_second", reinterpret_cast<getter>(GyrometerDataThreshold_get_YAxisInDegreesPerSecond), reinterpret_cast<setter>(GyrometerDataThreshold_put_YAxisInDegreesPerSecond), nullptr, nullptr },
        { "x_axis_in_degrees_per_second", reinterpret_cast<getter>(GyrometerDataThreshold_get_XAxisInDegreesPerSecond), reinterpret_cast<setter>(GyrometerDataThreshold_put_XAxisInDegreesPerSecond), nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_GyrometerDataThreshold[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_GyrometerDataThreshold) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_GyrometerDataThreshold) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_GyrometerDataThreshold) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_GyrometerDataThreshold) },
        { },
    };

    static PyType_Spec type_spec_GyrometerDataThreshold =
    {
        "winrt._winrt_windows_devices_sensors.GyrometerDataThreshold",
        sizeof(py::wrapper::Windows::Devices::Sensors::GyrometerDataThreshold),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_GyrometerDataThreshold
    };

    // ----- GyrometerReading class --------------------

    static PyObject* _new_GyrometerReading(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Devices::Sensors::GyrometerReading>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Devices::Sensors::GyrometerReading>::type_name);
        return nullptr;
    }

    static void _dealloc_GyrometerReading(py::wrapper::Windows::Devices::Sensors::GyrometerReading* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* GyrometerReading_get_AngularVelocityX(py::wrapper::Windows::Devices::Sensors::GyrometerReading* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Sensors.GyrometerReading", L"AngularVelocityX"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.AngularVelocityX());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* GyrometerReading_get_AngularVelocityY(py::wrapper::Windows::Devices::Sensors::GyrometerReading* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Sensors.GyrometerReading", L"AngularVelocityY"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.AngularVelocityY());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* GyrometerReading_get_AngularVelocityZ(py::wrapper::Windows::Devices::Sensors::GyrometerReading* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Sensors.GyrometerReading", L"AngularVelocityZ"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.AngularVelocityZ());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* GyrometerReading_get_Timestamp(py::wrapper::Windows::Devices::Sensors::GyrometerReading* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Sensors.GyrometerReading", L"Timestamp"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Timestamp());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* GyrometerReading_get_PerformanceCount(py::wrapper::Windows::Devices::Sensors::GyrometerReading* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Sensors.GyrometerReading", L"PerformanceCount"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.PerformanceCount());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* GyrometerReading_get_Properties(py::wrapper::Windows::Devices::Sensors::GyrometerReading* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Sensors.GyrometerReading", L"Properties"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Properties());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_GyrometerReading(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Devices::Sensors::GyrometerReading>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_GyrometerReading(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Devices::Sensors::GyrometerReading>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_GyrometerReading[] = {
        { "_assign_array_", _assign_array_GyrometerReading, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_GyrometerReading), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_GyrometerReading[] = {
        { "angular_velocity_x", reinterpret_cast<getter>(GyrometerReading_get_AngularVelocityX), nullptr, nullptr, nullptr },
        { "angular_velocity_y", reinterpret_cast<getter>(GyrometerReading_get_AngularVelocityY), nullptr, nullptr, nullptr },
        { "angular_velocity_z", reinterpret_cast<getter>(GyrometerReading_get_AngularVelocityZ), nullptr, nullptr, nullptr },
        { "timestamp", reinterpret_cast<getter>(GyrometerReading_get_Timestamp), nullptr, nullptr, nullptr },
        { "performance_count", reinterpret_cast<getter>(GyrometerReading_get_PerformanceCount), nullptr, nullptr, nullptr },
        { "properties", reinterpret_cast<getter>(GyrometerReading_get_Properties), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_GyrometerReading[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_GyrometerReading) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_GyrometerReading) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_GyrometerReading) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_GyrometerReading) },
        { },
    };

    static PyType_Spec type_spec_GyrometerReading =
    {
        "winrt._winrt_windows_devices_sensors.GyrometerReading",
        sizeof(py::wrapper::Windows::Devices::Sensors::GyrometerReading),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_GyrometerReading
    };

    // ----- GyrometerReadingChangedEventArgs class --------------------

    static PyObject* _new_GyrometerReadingChangedEventArgs(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Devices::Sensors::GyrometerReadingChangedEventArgs>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Devices::Sensors::GyrometerReadingChangedEventArgs>::type_name);
        return nullptr;
    }

    static void _dealloc_GyrometerReadingChangedEventArgs(py::wrapper::Windows::Devices::Sensors::GyrometerReadingChangedEventArgs* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* GyrometerReadingChangedEventArgs_get_Reading(py::wrapper::Windows::Devices::Sensors::GyrometerReadingChangedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Sensors.GyrometerReadingChangedEventArgs", L"Reading"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Reading());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_GyrometerReadingChangedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Devices::Sensors::GyrometerReadingChangedEventArgs>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_GyrometerReadingChangedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Devices::Sensors::GyrometerReadingChangedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_GyrometerReadingChangedEventArgs[] = {
        { "_assign_array_", _assign_array_GyrometerReadingChangedEventArgs, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_GyrometerReadingChangedEventArgs), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_GyrometerReadingChangedEventArgs[] = {
        { "reading", reinterpret_cast<getter>(GyrometerReadingChangedEventArgs_get_Reading), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_GyrometerReadingChangedEventArgs[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_GyrometerReadingChangedEventArgs) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_GyrometerReadingChangedEventArgs) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_GyrometerReadingChangedEventArgs) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_GyrometerReadingChangedEventArgs) },
        { },
    };

    static PyType_Spec type_spec_GyrometerReadingChangedEventArgs =
    {
        "winrt._winrt_windows_devices_sensors.GyrometerReadingChangedEventArgs",
        sizeof(py::wrapper::Windows::Devices::Sensors::GyrometerReadingChangedEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_GyrometerReadingChangedEventArgs
    };

    // ----- HingeAngleReading class --------------------

    static PyObject* _new_HingeAngleReading(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Devices::Sensors::HingeAngleReading>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Devices::Sensors::HingeAngleReading>::type_name);
        return nullptr;
    }

    static void _dealloc_HingeAngleReading(py::wrapper::Windows::Devices::Sensors::HingeAngleReading* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* HingeAngleReading_get_AngleInDegrees(py::wrapper::Windows::Devices::Sensors::HingeAngleReading* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Sensors.HingeAngleReading", L"AngleInDegrees"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.AngleInDegrees());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* HingeAngleReading_get_Properties(py::wrapper::Windows::Devices::Sensors::HingeAngleReading* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Sensors.HingeAngleReading", L"Properties"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Properties());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* HingeAngleReading_get_Timestamp(py::wrapper::Windows::Devices::Sensors::HingeAngleReading* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Sensors.HingeAngleReading", L"Timestamp"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Timestamp());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_HingeAngleReading(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Devices::Sensors::HingeAngleReading>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_HingeAngleReading(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Devices::Sensors::HingeAngleReading>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_HingeAngleReading[] = {
        { "_assign_array_", _assign_array_HingeAngleReading, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_HingeAngleReading), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_HingeAngleReading[] = {
        { "angle_in_degrees", reinterpret_cast<getter>(HingeAngleReading_get_AngleInDegrees), nullptr, nullptr, nullptr },
        { "properties", reinterpret_cast<getter>(HingeAngleReading_get_Properties), nullptr, nullptr, nullptr },
        { "timestamp", reinterpret_cast<getter>(HingeAngleReading_get_Timestamp), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_HingeAngleReading[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_HingeAngleReading) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_HingeAngleReading) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_HingeAngleReading) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_HingeAngleReading) },
        { },
    };

    static PyType_Spec type_spec_HingeAngleReading =
    {
        "winrt._winrt_windows_devices_sensors.HingeAngleReading",
        sizeof(py::wrapper::Windows::Devices::Sensors::HingeAngleReading),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_HingeAngleReading
    };

    // ----- HingeAngleSensor class --------------------

    static PyObject* _new_HingeAngleSensor(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Devices::Sensors::HingeAngleSensor>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Devices::Sensors::HingeAngleSensor>::type_name);
        return nullptr;
    }

    static void _dealloc_HingeAngleSensor(py::wrapper::Windows::Devices::Sensors::HingeAngleSensor* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* HingeAngleSensor_FromIdAsync(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.Sensors.HingeAngleSensor", L"FromIdAsync", 1))
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                return py::convert(winrt::Windows::Devices::Sensors::HingeAngleSensor::FromIdAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* HingeAngleSensor_GetCurrentReadingAsync(py::wrapper::Windows::Devices::Sensors::HingeAngleSensor* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.Sensors.HingeAngleSensor", L"GetCurrentReadingAsync", 0))
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert(self->obj.GetCurrentReadingAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* HingeAngleSensor_GetDefaultAsync(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.Sensors.HingeAngleSensor", L"GetDefaultAsync", 0))
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert(winrt::Windows::Devices::Sensors::HingeAngleSensor::GetDefaultAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* HingeAngleSensor_GetDeviceSelector(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.Sensors.HingeAngleSensor", L"GetDeviceSelector", 0))
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert(winrt::Windows::Devices::Sensors::HingeAngleSensor::GetDeviceSelector());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* HingeAngleSensor_GetRelatedToAdjacentPanelsAsync(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.Sensors.HingeAngleSensor", L"GetRelatedToAdjacentPanelsAsync", 2))
                {
                    py::set_arg_count_version_error(2);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::hstring>(args, 1);

                return py::convert(winrt::Windows::Devices::Sensors::HingeAngleSensor::GetRelatedToAdjacentPanelsAsync(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* HingeAngleSensor_get_ReportThresholdInDegrees(py::wrapper::Windows::Devices::Sensors::HingeAngleSensor* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Sensors.HingeAngleSensor", L"ReportThresholdInDegrees"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.ReportThresholdInDegrees());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int HingeAngleSensor_put_ReportThresholdInDegrees(py::wrapper::Windows::Devices::Sensors::HingeAngleSensor* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Sensors.HingeAngleSensor", L"ReportThresholdInDegrees"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<double>(arg);

            self->obj.ReportThresholdInDegrees(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* HingeAngleSensor_get_DeviceId(py::wrapper::Windows::Devices::Sensors::HingeAngleSensor* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Sensors.HingeAngleSensor", L"DeviceId"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.DeviceId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* HingeAngleSensor_get_MinReportThresholdInDegrees(py::wrapper::Windows::Devices::Sensors::HingeAngleSensor* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Sensors.HingeAngleSensor", L"MinReportThresholdInDegrees"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.MinReportThresholdInDegrees());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* HingeAngleSensor_add_ReadingChanged(py::wrapper::Windows::Devices::Sensors::HingeAngleSensor* self, PyObject* arg) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Devices.Sensors.HingeAngleSensor", L"ReadingChanged"))
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Devices::Sensors::HingeAngleSensor, winrt::Windows::Devices::Sensors::HingeAngleSensorReadingChangedEventArgs>>(arg);

            return py::convert(self->obj.ReadingChanged(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* HingeAngleSensor_remove_ReadingChanged(py::wrapper::Windows::Devices::Sensors::HingeAngleSensor* self, PyObject* arg) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Devices.Sensors.HingeAngleSensor", L"ReadingChanged"))
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.ReadingChanged(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_HingeAngleSensor(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Devices::Sensors::HingeAngleSensor>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_HingeAngleSensor(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Devices::Sensors::HingeAngleSensor>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_HingeAngleSensor[] = {
        { "get_current_reading_async", reinterpret_cast<PyCFunction>(HingeAngleSensor_GetCurrentReadingAsync), METH_VARARGS, nullptr },
        { "add_reading_changed", reinterpret_cast<PyCFunction>(HingeAngleSensor_add_ReadingChanged), METH_O, nullptr },
        { "remove_reading_changed", reinterpret_cast<PyCFunction>(HingeAngleSensor_remove_ReadingChanged), METH_O, nullptr },
        { "_assign_array_", _assign_array_HingeAngleSensor, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_HingeAngleSensor), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_HingeAngleSensor[] = {
        { "report_threshold_in_degrees", reinterpret_cast<getter>(HingeAngleSensor_get_ReportThresholdInDegrees), reinterpret_cast<setter>(HingeAngleSensor_put_ReportThresholdInDegrees), nullptr, nullptr },
        { "device_id", reinterpret_cast<getter>(HingeAngleSensor_get_DeviceId), nullptr, nullptr, nullptr },
        { "min_report_threshold_in_degrees", reinterpret_cast<getter>(HingeAngleSensor_get_MinReportThresholdInDegrees), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_HingeAngleSensor[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_HingeAngleSensor) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_HingeAngleSensor) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_HingeAngleSensor) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_HingeAngleSensor) },
        { },
    };

    static PyType_Spec type_spec_HingeAngleSensor =
    {
        "winrt._winrt_windows_devices_sensors.HingeAngleSensor",
        sizeof(py::wrapper::Windows::Devices::Sensors::HingeAngleSensor),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_HingeAngleSensor
    };

    static PyGetSetDef getset_HingeAngleSensor_Static[] = {
        { }
    };

    static PyMethodDef methods_HingeAngleSensor_Static[] = {
        { "from_id_async", reinterpret_cast<PyCFunction>(HingeAngleSensor_FromIdAsync), METH_VARARGS, nullptr },
        { "get_default_async", reinterpret_cast<PyCFunction>(HingeAngleSensor_GetDefaultAsync), METH_VARARGS, nullptr },
        { "get_device_selector", reinterpret_cast<PyCFunction>(HingeAngleSensor_GetDeviceSelector), METH_VARARGS, nullptr },
        { "get_related_to_adjacent_panels_async", reinterpret_cast<PyCFunction>(HingeAngleSensor_GetRelatedToAdjacentPanelsAsync), METH_VARARGS, nullptr },
        { }
    };

    static PyType_Slot type_slots_HingeAngleSensor_Static[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_HingeAngleSensor_Static) },
        { Py_tp_methods, reinterpret_cast<void*>(methods_HingeAngleSensor_Static) },
        { }
    };

    static PyType_Spec type_spec_HingeAngleSensor_Static =
    {
        "winrt._winrt_windows_devices_sensors.HingeAngleSensor_Static",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT,
        type_slots_HingeAngleSensor_Static
    };

    // ----- HingeAngleSensorReadingChangedEventArgs class --------------------

    static PyObject* _new_HingeAngleSensorReadingChangedEventArgs(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Devices::Sensors::HingeAngleSensorReadingChangedEventArgs>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Devices::Sensors::HingeAngleSensorReadingChangedEventArgs>::type_name);
        return nullptr;
    }

    static void _dealloc_HingeAngleSensorReadingChangedEventArgs(py::wrapper::Windows::Devices::Sensors::HingeAngleSensorReadingChangedEventArgs* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* HingeAngleSensorReadingChangedEventArgs_get_Reading(py::wrapper::Windows::Devices::Sensors::HingeAngleSensorReadingChangedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Sensors.HingeAngleSensorReadingChangedEventArgs", L"Reading"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Reading());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_HingeAngleSensorReadingChangedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Devices::Sensors::HingeAngleSensorReadingChangedEventArgs>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_HingeAngleSensorReadingChangedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Devices::Sensors::HingeAngleSensorReadingChangedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_HingeAngleSensorReadingChangedEventArgs[] = {
        { "_assign_array_", _assign_array_HingeAngleSensorReadingChangedEventArgs, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_HingeAngleSensorReadingChangedEventArgs), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_HingeAngleSensorReadingChangedEventArgs[] = {
        { "reading", reinterpret_cast<getter>(HingeAngleSensorReadingChangedEventArgs_get_Reading), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_HingeAngleSensorReadingChangedEventArgs[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_HingeAngleSensorReadingChangedEventArgs) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_HingeAngleSensorReadingChangedEventArgs) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_HingeAngleSensorReadingChangedEventArgs) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_HingeAngleSensorReadingChangedEventArgs) },
        { },
    };

    static PyType_Spec type_spec_HingeAngleSensorReadingChangedEventArgs =
    {
        "winrt._winrt_windows_devices_sensors.HingeAngleSensorReadingChangedEventArgs",
        sizeof(py::wrapper::Windows::Devices::Sensors::HingeAngleSensorReadingChangedEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_HingeAngleSensorReadingChangedEventArgs
    };

    // ----- HumanPresenceFeatures class --------------------

    static PyObject* _new_HumanPresenceFeatures(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Devices::Sensors::HumanPresenceFeatures>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Devices::Sensors::HumanPresenceFeatures>::type_name);
        return nullptr;
    }

    static void _dealloc_HumanPresenceFeatures(py::wrapper::Windows::Devices::Sensors::HumanPresenceFeatures* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* HumanPresenceFeatures_get_IsAttentionAwareDimmingSupported(py::wrapper::Windows::Devices::Sensors::HumanPresenceFeatures* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Sensors.HumanPresenceFeatures", L"IsAttentionAwareDimmingSupported"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.IsAttentionAwareDimmingSupported());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* HumanPresenceFeatures_get_IsLockOnLeaveSupported(py::wrapper::Windows::Devices::Sensors::HumanPresenceFeatures* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Sensors.HumanPresenceFeatures", L"IsLockOnLeaveSupported"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.IsLockOnLeaveSupported());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* HumanPresenceFeatures_get_IsWakeOnApproachSupported(py::wrapper::Windows::Devices::Sensors::HumanPresenceFeatures* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Sensors.HumanPresenceFeatures", L"IsWakeOnApproachSupported"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.IsWakeOnApproachSupported());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* HumanPresenceFeatures_get_SensorId(py::wrapper::Windows::Devices::Sensors::HumanPresenceFeatures* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Sensors.HumanPresenceFeatures", L"SensorId"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.SensorId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* HumanPresenceFeatures_get_SupportedWakeOrLockDistancesInMillimeters(py::wrapper::Windows::Devices::Sensors::HumanPresenceFeatures* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Sensors.HumanPresenceFeatures", L"SupportedWakeOrLockDistancesInMillimeters"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.SupportedWakeOrLockDistancesInMillimeters());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* HumanPresenceFeatures_get_IsAdaptiveDimmingSupported(py::wrapper::Windows::Devices::Sensors::HumanPresenceFeatures* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Sensors.HumanPresenceFeatures", L"IsAdaptiveDimmingSupported"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.IsAdaptiveDimmingSupported());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_HumanPresenceFeatures(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Devices::Sensors::HumanPresenceFeatures>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_HumanPresenceFeatures(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Devices::Sensors::HumanPresenceFeatures>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_HumanPresenceFeatures[] = {
        { "_assign_array_", _assign_array_HumanPresenceFeatures, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_HumanPresenceFeatures), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_HumanPresenceFeatures[] = {
        { "is_attention_aware_dimming_supported", reinterpret_cast<getter>(HumanPresenceFeatures_get_IsAttentionAwareDimmingSupported), nullptr, nullptr, nullptr },
        { "is_lock_on_leave_supported", reinterpret_cast<getter>(HumanPresenceFeatures_get_IsLockOnLeaveSupported), nullptr, nullptr, nullptr },
        { "is_wake_on_approach_supported", reinterpret_cast<getter>(HumanPresenceFeatures_get_IsWakeOnApproachSupported), nullptr, nullptr, nullptr },
        { "sensor_id", reinterpret_cast<getter>(HumanPresenceFeatures_get_SensorId), nullptr, nullptr, nullptr },
        { "supported_wake_or_lock_distances_in_millimeters", reinterpret_cast<getter>(HumanPresenceFeatures_get_SupportedWakeOrLockDistancesInMillimeters), nullptr, nullptr, nullptr },
        { "is_adaptive_dimming_supported", reinterpret_cast<getter>(HumanPresenceFeatures_get_IsAdaptiveDimmingSupported), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_HumanPresenceFeatures[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_HumanPresenceFeatures) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_HumanPresenceFeatures) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_HumanPresenceFeatures) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_HumanPresenceFeatures) },
        { },
    };

    static PyType_Spec type_spec_HumanPresenceFeatures =
    {
        "winrt._winrt_windows_devices_sensors.HumanPresenceFeatures",
        sizeof(py::wrapper::Windows::Devices::Sensors::HumanPresenceFeatures),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_HumanPresenceFeatures
    };

    // ----- HumanPresenceSensor class --------------------

    static PyObject* _new_HumanPresenceSensor(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Devices::Sensors::HumanPresenceSensor>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Devices::Sensors::HumanPresenceSensor>::type_name);
        return nullptr;
    }

    static void _dealloc_HumanPresenceSensor(py::wrapper::Windows::Devices::Sensors::HumanPresenceSensor* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* HumanPresenceSensor_FromId(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.Sensors.HumanPresenceSensor", L"FromId", 1))
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                return py::convert(winrt::Windows::Devices::Sensors::HumanPresenceSensor::FromId(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* HumanPresenceSensor_FromIdAsync(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.Sensors.HumanPresenceSensor", L"FromIdAsync", 1))
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                return py::convert(winrt::Windows::Devices::Sensors::HumanPresenceSensor::FromIdAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* HumanPresenceSensor_GetCurrentReading(py::wrapper::Windows::Devices::Sensors::HumanPresenceSensor* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.Sensors.HumanPresenceSensor", L"GetCurrentReading", 0))
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert(self->obj.GetCurrentReading());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* HumanPresenceSensor_GetDefault(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.Sensors.HumanPresenceSensor", L"GetDefault", 0))
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert(winrt::Windows::Devices::Sensors::HumanPresenceSensor::GetDefault());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* HumanPresenceSensor_GetDefaultAsync(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.Sensors.HumanPresenceSensor", L"GetDefaultAsync", 0))
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert(winrt::Windows::Devices::Sensors::HumanPresenceSensor::GetDefaultAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* HumanPresenceSensor_GetDeviceSelector(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.Sensors.HumanPresenceSensor", L"GetDeviceSelector", 0))
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert(winrt::Windows::Devices::Sensors::HumanPresenceSensor::GetDeviceSelector());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* HumanPresenceSensor_get_DeviceId(py::wrapper::Windows::Devices::Sensors::HumanPresenceSensor* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Sensors.HumanPresenceSensor", L"DeviceId"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.DeviceId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* HumanPresenceSensor_get_MaxDetectableDistanceInMillimeters(py::wrapper::Windows::Devices::Sensors::HumanPresenceSensor* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Sensors.HumanPresenceSensor", L"MaxDetectableDistanceInMillimeters"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.MaxDetectableDistanceInMillimeters());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* HumanPresenceSensor_get_MinDetectableDistanceInMillimeters(py::wrapper::Windows::Devices::Sensors::HumanPresenceSensor* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Sensors.HumanPresenceSensor", L"MinDetectableDistanceInMillimeters"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.MinDetectableDistanceInMillimeters());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* HumanPresenceSensor_get_IsEngagementSupported(py::wrapper::Windows::Devices::Sensors::HumanPresenceSensor* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Sensors.HumanPresenceSensor", L"IsEngagementSupported"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.IsEngagementSupported());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* HumanPresenceSensor_get_IsPresenceSupported(py::wrapper::Windows::Devices::Sensors::HumanPresenceSensor* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Sensors.HumanPresenceSensor", L"IsPresenceSupported"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.IsPresenceSupported());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* HumanPresenceSensor_add_ReadingChanged(py::wrapper::Windows::Devices::Sensors::HumanPresenceSensor* self, PyObject* arg) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Devices.Sensors.HumanPresenceSensor", L"ReadingChanged"))
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Devices::Sensors::HumanPresenceSensor, winrt::Windows::Devices::Sensors::HumanPresenceSensorReadingChangedEventArgs>>(arg);

            return py::convert(self->obj.ReadingChanged(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* HumanPresenceSensor_remove_ReadingChanged(py::wrapper::Windows::Devices::Sensors::HumanPresenceSensor* self, PyObject* arg) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Devices.Sensors.HumanPresenceSensor", L"ReadingChanged"))
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.ReadingChanged(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_HumanPresenceSensor(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Devices::Sensors::HumanPresenceSensor>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_HumanPresenceSensor(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Devices::Sensors::HumanPresenceSensor>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_HumanPresenceSensor[] = {
        { "get_current_reading", reinterpret_cast<PyCFunction>(HumanPresenceSensor_GetCurrentReading), METH_VARARGS, nullptr },
        { "add_reading_changed", reinterpret_cast<PyCFunction>(HumanPresenceSensor_add_ReadingChanged), METH_O, nullptr },
        { "remove_reading_changed", reinterpret_cast<PyCFunction>(HumanPresenceSensor_remove_ReadingChanged), METH_O, nullptr },
        { "_assign_array_", _assign_array_HumanPresenceSensor, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_HumanPresenceSensor), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_HumanPresenceSensor[] = {
        { "device_id", reinterpret_cast<getter>(HumanPresenceSensor_get_DeviceId), nullptr, nullptr, nullptr },
        { "max_detectable_distance_in_millimeters", reinterpret_cast<getter>(HumanPresenceSensor_get_MaxDetectableDistanceInMillimeters), nullptr, nullptr, nullptr },
        { "min_detectable_distance_in_millimeters", reinterpret_cast<getter>(HumanPresenceSensor_get_MinDetectableDistanceInMillimeters), nullptr, nullptr, nullptr },
        { "is_engagement_supported", reinterpret_cast<getter>(HumanPresenceSensor_get_IsEngagementSupported), nullptr, nullptr, nullptr },
        { "is_presence_supported", reinterpret_cast<getter>(HumanPresenceSensor_get_IsPresenceSupported), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_HumanPresenceSensor[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_HumanPresenceSensor) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_HumanPresenceSensor) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_HumanPresenceSensor) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_HumanPresenceSensor) },
        { },
    };

    static PyType_Spec type_spec_HumanPresenceSensor =
    {
        "winrt._winrt_windows_devices_sensors.HumanPresenceSensor",
        sizeof(py::wrapper::Windows::Devices::Sensors::HumanPresenceSensor),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_HumanPresenceSensor
    };

    static PyGetSetDef getset_HumanPresenceSensor_Static[] = {
        { }
    };

    static PyMethodDef methods_HumanPresenceSensor_Static[] = {
        { "from_id", reinterpret_cast<PyCFunction>(HumanPresenceSensor_FromId), METH_VARARGS, nullptr },
        { "from_id_async", reinterpret_cast<PyCFunction>(HumanPresenceSensor_FromIdAsync), METH_VARARGS, nullptr },
        { "get_default", reinterpret_cast<PyCFunction>(HumanPresenceSensor_GetDefault), METH_VARARGS, nullptr },
        { "get_default_async", reinterpret_cast<PyCFunction>(HumanPresenceSensor_GetDefaultAsync), METH_VARARGS, nullptr },
        { "get_device_selector", reinterpret_cast<PyCFunction>(HumanPresenceSensor_GetDeviceSelector), METH_VARARGS, nullptr },
        { }
    };

    static PyType_Slot type_slots_HumanPresenceSensor_Static[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_HumanPresenceSensor_Static) },
        { Py_tp_methods, reinterpret_cast<void*>(methods_HumanPresenceSensor_Static) },
        { }
    };

    static PyType_Spec type_spec_HumanPresenceSensor_Static =
    {
        "winrt._winrt_windows_devices_sensors.HumanPresenceSensor_Static",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT,
        type_slots_HumanPresenceSensor_Static
    };

    // ----- HumanPresenceSensorReading class --------------------

    static PyObject* _new_HumanPresenceSensorReading(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Devices::Sensors::HumanPresenceSensorReading>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Devices::Sensors::HumanPresenceSensorReading>::type_name);
        return nullptr;
    }

    static void _dealloc_HumanPresenceSensorReading(py::wrapper::Windows::Devices::Sensors::HumanPresenceSensorReading* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* HumanPresenceSensorReading_get_DistanceInMillimeters(py::wrapper::Windows::Devices::Sensors::HumanPresenceSensorReading* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Sensors.HumanPresenceSensorReading", L"DistanceInMillimeters"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.DistanceInMillimeters());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* HumanPresenceSensorReading_get_Engagement(py::wrapper::Windows::Devices::Sensors::HumanPresenceSensorReading* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Sensors.HumanPresenceSensorReading", L"Engagement"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Engagement());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* HumanPresenceSensorReading_get_Presence(py::wrapper::Windows::Devices::Sensors::HumanPresenceSensorReading* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Sensors.HumanPresenceSensorReading", L"Presence"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Presence());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* HumanPresenceSensorReading_get_Timestamp(py::wrapper::Windows::Devices::Sensors::HumanPresenceSensorReading* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Sensors.HumanPresenceSensorReading", L"Timestamp"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Timestamp());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* HumanPresenceSensorReading_get_Properties(py::wrapper::Windows::Devices::Sensors::HumanPresenceSensorReading* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Sensors.HumanPresenceSensorReading", L"Properties"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Properties());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_HumanPresenceSensorReading(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Devices::Sensors::HumanPresenceSensorReading>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_HumanPresenceSensorReading(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Devices::Sensors::HumanPresenceSensorReading>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_HumanPresenceSensorReading[] = {
        { "_assign_array_", _assign_array_HumanPresenceSensorReading, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_HumanPresenceSensorReading), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_HumanPresenceSensorReading[] = {
        { "distance_in_millimeters", reinterpret_cast<getter>(HumanPresenceSensorReading_get_DistanceInMillimeters), nullptr, nullptr, nullptr },
        { "engagement", reinterpret_cast<getter>(HumanPresenceSensorReading_get_Engagement), nullptr, nullptr, nullptr },
        { "presence", reinterpret_cast<getter>(HumanPresenceSensorReading_get_Presence), nullptr, nullptr, nullptr },
        { "timestamp", reinterpret_cast<getter>(HumanPresenceSensorReading_get_Timestamp), nullptr, nullptr, nullptr },
        { "properties", reinterpret_cast<getter>(HumanPresenceSensorReading_get_Properties), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_HumanPresenceSensorReading[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_HumanPresenceSensorReading) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_HumanPresenceSensorReading) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_HumanPresenceSensorReading) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_HumanPresenceSensorReading) },
        { },
    };

    static PyType_Spec type_spec_HumanPresenceSensorReading =
    {
        "winrt._winrt_windows_devices_sensors.HumanPresenceSensorReading",
        sizeof(py::wrapper::Windows::Devices::Sensors::HumanPresenceSensorReading),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_HumanPresenceSensorReading
    };

    // ----- HumanPresenceSensorReadingChangedEventArgs class --------------------

    static PyObject* _new_HumanPresenceSensorReadingChangedEventArgs(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Devices::Sensors::HumanPresenceSensorReadingChangedEventArgs>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Devices::Sensors::HumanPresenceSensorReadingChangedEventArgs>::type_name);
        return nullptr;
    }

    static void _dealloc_HumanPresenceSensorReadingChangedEventArgs(py::wrapper::Windows::Devices::Sensors::HumanPresenceSensorReadingChangedEventArgs* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* HumanPresenceSensorReadingChangedEventArgs_get_Reading(py::wrapper::Windows::Devices::Sensors::HumanPresenceSensorReadingChangedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Sensors.HumanPresenceSensorReadingChangedEventArgs", L"Reading"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Reading());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_HumanPresenceSensorReadingChangedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Devices::Sensors::HumanPresenceSensorReadingChangedEventArgs>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_HumanPresenceSensorReadingChangedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Devices::Sensors::HumanPresenceSensorReadingChangedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_HumanPresenceSensorReadingChangedEventArgs[] = {
        { "_assign_array_", _assign_array_HumanPresenceSensorReadingChangedEventArgs, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_HumanPresenceSensorReadingChangedEventArgs), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_HumanPresenceSensorReadingChangedEventArgs[] = {
        { "reading", reinterpret_cast<getter>(HumanPresenceSensorReadingChangedEventArgs_get_Reading), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_HumanPresenceSensorReadingChangedEventArgs[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_HumanPresenceSensorReadingChangedEventArgs) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_HumanPresenceSensorReadingChangedEventArgs) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_HumanPresenceSensorReadingChangedEventArgs) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_HumanPresenceSensorReadingChangedEventArgs) },
        { },
    };

    static PyType_Spec type_spec_HumanPresenceSensorReadingChangedEventArgs =
    {
        "winrt._winrt_windows_devices_sensors.HumanPresenceSensorReadingChangedEventArgs",
        sizeof(py::wrapper::Windows::Devices::Sensors::HumanPresenceSensorReadingChangedEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_HumanPresenceSensorReadingChangedEventArgs
    };

    // ----- HumanPresenceSensorReadingUpdate class --------------------

    static PyObject* _new_HumanPresenceSensorReadingUpdate(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 0)
        {
            try
            {
                winrt::Windows::Devices::Sensors::HumanPresenceSensorReadingUpdate instance{  };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_HumanPresenceSensorReadingUpdate(py::wrapper::Windows::Devices::Sensors::HumanPresenceSensorReadingUpdate* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* HumanPresenceSensorReadingUpdate_get_Timestamp(py::wrapper::Windows::Devices::Sensors::HumanPresenceSensorReadingUpdate* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Sensors.HumanPresenceSensorReadingUpdate", L"Timestamp"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Timestamp());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int HumanPresenceSensorReadingUpdate_put_Timestamp(py::wrapper::Windows::Devices::Sensors::HumanPresenceSensorReadingUpdate* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Sensors.HumanPresenceSensorReadingUpdate", L"Timestamp"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::IReference<winrt::Windows::Foundation::DateTime>>(arg);

            self->obj.Timestamp(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* HumanPresenceSensorReadingUpdate_get_Presence(py::wrapper::Windows::Devices::Sensors::HumanPresenceSensorReadingUpdate* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Sensors.HumanPresenceSensorReadingUpdate", L"Presence"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Presence());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int HumanPresenceSensorReadingUpdate_put_Presence(py::wrapper::Windows::Devices::Sensors::HumanPresenceSensorReadingUpdate* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Sensors.HumanPresenceSensorReadingUpdate", L"Presence"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::IReference<winrt::Windows::Devices::Sensors::HumanPresence>>(arg);

            self->obj.Presence(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* HumanPresenceSensorReadingUpdate_get_Engagement(py::wrapper::Windows::Devices::Sensors::HumanPresenceSensorReadingUpdate* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Sensors.HumanPresenceSensorReadingUpdate", L"Engagement"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Engagement());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int HumanPresenceSensorReadingUpdate_put_Engagement(py::wrapper::Windows::Devices::Sensors::HumanPresenceSensorReadingUpdate* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Sensors.HumanPresenceSensorReadingUpdate", L"Engagement"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::IReference<winrt::Windows::Devices::Sensors::HumanEngagement>>(arg);

            self->obj.Engagement(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* HumanPresenceSensorReadingUpdate_get_DistanceInMillimeters(py::wrapper::Windows::Devices::Sensors::HumanPresenceSensorReadingUpdate* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Sensors.HumanPresenceSensorReadingUpdate", L"DistanceInMillimeters"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.DistanceInMillimeters());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int HumanPresenceSensorReadingUpdate_put_DistanceInMillimeters(py::wrapper::Windows::Devices::Sensors::HumanPresenceSensorReadingUpdate* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Sensors.HumanPresenceSensorReadingUpdate", L"DistanceInMillimeters"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::IReference<uint32_t>>(arg);

            self->obj.DistanceInMillimeters(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* _assign_array_HumanPresenceSensorReadingUpdate(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Devices::Sensors::HumanPresenceSensorReadingUpdate>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_HumanPresenceSensorReadingUpdate(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Devices::Sensors::HumanPresenceSensorReadingUpdate>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_HumanPresenceSensorReadingUpdate[] = {
        { "_assign_array_", _assign_array_HumanPresenceSensorReadingUpdate, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_HumanPresenceSensorReadingUpdate), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_HumanPresenceSensorReadingUpdate[] = {
        { "timestamp", reinterpret_cast<getter>(HumanPresenceSensorReadingUpdate_get_Timestamp), reinterpret_cast<setter>(HumanPresenceSensorReadingUpdate_put_Timestamp), nullptr, nullptr },
        { "presence", reinterpret_cast<getter>(HumanPresenceSensorReadingUpdate_get_Presence), reinterpret_cast<setter>(HumanPresenceSensorReadingUpdate_put_Presence), nullptr, nullptr },
        { "engagement", reinterpret_cast<getter>(HumanPresenceSensorReadingUpdate_get_Engagement), reinterpret_cast<setter>(HumanPresenceSensorReadingUpdate_put_Engagement), nullptr, nullptr },
        { "distance_in_millimeters", reinterpret_cast<getter>(HumanPresenceSensorReadingUpdate_get_DistanceInMillimeters), reinterpret_cast<setter>(HumanPresenceSensorReadingUpdate_put_DistanceInMillimeters), nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_HumanPresenceSensorReadingUpdate[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_HumanPresenceSensorReadingUpdate) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_HumanPresenceSensorReadingUpdate) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_HumanPresenceSensorReadingUpdate) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_HumanPresenceSensorReadingUpdate) },
        { },
    };

    static PyType_Spec type_spec_HumanPresenceSensorReadingUpdate =
    {
        "winrt._winrt_windows_devices_sensors.HumanPresenceSensorReadingUpdate",
        sizeof(py::wrapper::Windows::Devices::Sensors::HumanPresenceSensorReadingUpdate),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_HumanPresenceSensorReadingUpdate
    };

    // ----- HumanPresenceSettings class --------------------

    static PyObject* _new_HumanPresenceSettings(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Devices::Sensors::HumanPresenceSettings>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Devices::Sensors::HumanPresenceSettings>::type_name);
        return nullptr;
    }

    static void _dealloc_HumanPresenceSettings(py::wrapper::Windows::Devices::Sensors::HumanPresenceSettings* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* HumanPresenceSettings_GetCurrentSettings(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.Sensors.HumanPresenceSettings", L"GetCurrentSettings", 0))
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert(winrt::Windows::Devices::Sensors::HumanPresenceSettings::GetCurrentSettings());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* HumanPresenceSettings_GetCurrentSettingsAsync(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.Sensors.HumanPresenceSettings", L"GetCurrentSettingsAsync", 0))
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert(winrt::Windows::Devices::Sensors::HumanPresenceSettings::GetCurrentSettingsAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* HumanPresenceSettings_GetSupportedFeaturesForSensorId(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.Sensors.HumanPresenceSettings", L"GetSupportedFeaturesForSensorId", 1))
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                return py::convert(winrt::Windows::Devices::Sensors::HumanPresenceSettings::GetSupportedFeaturesForSensorId(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* HumanPresenceSettings_GetSupportedFeaturesForSensorIdAsync(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.Sensors.HumanPresenceSettings", L"GetSupportedFeaturesForSensorIdAsync", 1))
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                return py::convert(winrt::Windows::Devices::Sensors::HumanPresenceSettings::GetSupportedFeaturesForSensorIdAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* HumanPresenceSettings_GetSupportedLockOnLeaveTimeouts(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.Sensors.HumanPresenceSettings", L"GetSupportedLockOnLeaveTimeouts", 0))
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert(winrt::Windows::Devices::Sensors::HumanPresenceSettings::GetSupportedLockOnLeaveTimeouts());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* HumanPresenceSettings_UpdateSettings(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.Sensors.HumanPresenceSettings", L"UpdateSettings", 1))
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Devices::Sensors::HumanPresenceSettings>(args, 0);

                winrt::Windows::Devices::Sensors::HumanPresenceSettings::UpdateSettings(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* HumanPresenceSettings_UpdateSettingsAsync(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.Sensors.HumanPresenceSettings", L"UpdateSettingsAsync", 1))
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Devices::Sensors::HumanPresenceSettings>(args, 0);

                return py::convert(winrt::Windows::Devices::Sensors::HumanPresenceSettings::UpdateSettingsAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* HumanPresenceSettings_get_WakeOnApproachDistanceInMillimeters(py::wrapper::Windows::Devices::Sensors::HumanPresenceSettings* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Sensors.HumanPresenceSettings", L"WakeOnApproachDistanceInMillimeters"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.WakeOnApproachDistanceInMillimeters());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int HumanPresenceSettings_put_WakeOnApproachDistanceInMillimeters(py::wrapper::Windows::Devices::Sensors::HumanPresenceSettings* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Sensors.HumanPresenceSettings", L"WakeOnApproachDistanceInMillimeters"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::IReference<uint32_t>>(arg);

            self->obj.WakeOnApproachDistanceInMillimeters(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* HumanPresenceSettings_get_SensorId(py::wrapper::Windows::Devices::Sensors::HumanPresenceSettings* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Sensors.HumanPresenceSettings", L"SensorId"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.SensorId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int HumanPresenceSettings_put_SensorId(py::wrapper::Windows::Devices::Sensors::HumanPresenceSettings* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Sensors.HumanPresenceSettings", L"SensorId"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.SensorId(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* HumanPresenceSettings_get_LockOnLeaveTimeout(py::wrapper::Windows::Devices::Sensors::HumanPresenceSettings* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Sensors.HumanPresenceSettings", L"LockOnLeaveTimeout"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.LockOnLeaveTimeout());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int HumanPresenceSettings_put_LockOnLeaveTimeout(py::wrapper::Windows::Devices::Sensors::HumanPresenceSettings* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Sensors.HumanPresenceSettings", L"LockOnLeaveTimeout"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::TimeSpan>(arg);

            self->obj.LockOnLeaveTimeout(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* HumanPresenceSettings_get_LockOnLeaveDistanceInMillimeters(py::wrapper::Windows::Devices::Sensors::HumanPresenceSettings* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Sensors.HumanPresenceSettings", L"LockOnLeaveDistanceInMillimeters"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.LockOnLeaveDistanceInMillimeters());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int HumanPresenceSettings_put_LockOnLeaveDistanceInMillimeters(py::wrapper::Windows::Devices::Sensors::HumanPresenceSettings* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Sensors.HumanPresenceSettings", L"LockOnLeaveDistanceInMillimeters"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::IReference<uint32_t>>(arg);

            self->obj.LockOnLeaveDistanceInMillimeters(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* HumanPresenceSettings_get_IsWakeOnApproachEnabled(py::wrapper::Windows::Devices::Sensors::HumanPresenceSettings* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Sensors.HumanPresenceSettings", L"IsWakeOnApproachEnabled"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.IsWakeOnApproachEnabled());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int HumanPresenceSettings_put_IsWakeOnApproachEnabled(py::wrapper::Windows::Devices::Sensors::HumanPresenceSettings* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Sensors.HumanPresenceSettings", L"IsWakeOnApproachEnabled"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<bool>(arg);

            self->obj.IsWakeOnApproachEnabled(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* HumanPresenceSettings_get_IsLockOnLeaveEnabled(py::wrapper::Windows::Devices::Sensors::HumanPresenceSettings* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Sensors.HumanPresenceSettings", L"IsLockOnLeaveEnabled"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.IsLockOnLeaveEnabled());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int HumanPresenceSettings_put_IsLockOnLeaveEnabled(py::wrapper::Windows::Devices::Sensors::HumanPresenceSettings* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Sensors.HumanPresenceSettings", L"IsLockOnLeaveEnabled"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<bool>(arg);

            self->obj.IsLockOnLeaveEnabled(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* HumanPresenceSettings_get_IsAttentionAwareDimmingEnabled(py::wrapper::Windows::Devices::Sensors::HumanPresenceSettings* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Sensors.HumanPresenceSettings", L"IsAttentionAwareDimmingEnabled"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.IsAttentionAwareDimmingEnabled());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int HumanPresenceSettings_put_IsAttentionAwareDimmingEnabled(py::wrapper::Windows::Devices::Sensors::HumanPresenceSettings* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Sensors.HumanPresenceSettings", L"IsAttentionAwareDimmingEnabled"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<bool>(arg);

            self->obj.IsAttentionAwareDimmingEnabled(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* HumanPresenceSettings_get_IsAdaptiveDimmingEnabled(py::wrapper::Windows::Devices::Sensors::HumanPresenceSettings* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Sensors.HumanPresenceSettings", L"IsAdaptiveDimmingEnabled"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.IsAdaptiveDimmingEnabled());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int HumanPresenceSettings_put_IsAdaptiveDimmingEnabled(py::wrapper::Windows::Devices::Sensors::HumanPresenceSettings* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Sensors.HumanPresenceSettings", L"IsAdaptiveDimmingEnabled"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<bool>(arg);

            self->obj.IsAdaptiveDimmingEnabled(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* HumanPresenceSettings_get_DimmingOptions(py::wrapper::Windows::Devices::Sensors::HumanPresenceSettings* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Sensors.HumanPresenceSettings", L"DimmingOptions"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.DimmingOptions());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* HumanPresenceSettings_get_LockOptions(py::wrapper::Windows::Devices::Sensors::HumanPresenceSettings* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Sensors.HumanPresenceSettings", L"LockOptions"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.LockOptions());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* HumanPresenceSettings_get_WakeOptions(py::wrapper::Windows::Devices::Sensors::HumanPresenceSettings* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Sensors.HumanPresenceSettings", L"WakeOptions"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.WakeOptions());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* HumanPresenceSettings_add_SettingsChanged(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Devices.Sensors.HumanPresenceSettings", L"SettingsChanged"))
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::EventHandler<winrt::Windows::Foundation::IInspectable>>(arg);

            return py::convert(winrt::Windows::Devices::Sensors::HumanPresenceSettings::SettingsChanged(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* HumanPresenceSettings_remove_SettingsChanged(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Devices.Sensors.HumanPresenceSettings", L"SettingsChanged"))
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::event_token>(arg);

            winrt::Windows::Devices::Sensors::HumanPresenceSettings::SettingsChanged(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_HumanPresenceSettings(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Devices::Sensors::HumanPresenceSettings>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_HumanPresenceSettings(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Devices::Sensors::HumanPresenceSettings>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_HumanPresenceSettings[] = {
        { "add_settings_changed", reinterpret_cast<PyCFunction>(HumanPresenceSettings_add_SettingsChanged), METH_O | METH_STATIC, nullptr },
        { "remove_settings_changed", reinterpret_cast<PyCFunction>(HumanPresenceSettings_remove_SettingsChanged), METH_O | METH_STATIC, nullptr },
        { "_assign_array_", _assign_array_HumanPresenceSettings, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_HumanPresenceSettings), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_HumanPresenceSettings[] = {
        { "wake_on_approach_distance_in_millimeters", reinterpret_cast<getter>(HumanPresenceSettings_get_WakeOnApproachDistanceInMillimeters), reinterpret_cast<setter>(HumanPresenceSettings_put_WakeOnApproachDistanceInMillimeters), nullptr, nullptr },
        { "sensor_id", reinterpret_cast<getter>(HumanPresenceSettings_get_SensorId), reinterpret_cast<setter>(HumanPresenceSettings_put_SensorId), nullptr, nullptr },
        { "lock_on_leave_timeout", reinterpret_cast<getter>(HumanPresenceSettings_get_LockOnLeaveTimeout), reinterpret_cast<setter>(HumanPresenceSettings_put_LockOnLeaveTimeout), nullptr, nullptr },
        { "lock_on_leave_distance_in_millimeters", reinterpret_cast<getter>(HumanPresenceSettings_get_LockOnLeaveDistanceInMillimeters), reinterpret_cast<setter>(HumanPresenceSettings_put_LockOnLeaveDistanceInMillimeters), nullptr, nullptr },
        { "is_wake_on_approach_enabled", reinterpret_cast<getter>(HumanPresenceSettings_get_IsWakeOnApproachEnabled), reinterpret_cast<setter>(HumanPresenceSettings_put_IsWakeOnApproachEnabled), nullptr, nullptr },
        { "is_lock_on_leave_enabled", reinterpret_cast<getter>(HumanPresenceSettings_get_IsLockOnLeaveEnabled), reinterpret_cast<setter>(HumanPresenceSettings_put_IsLockOnLeaveEnabled), nullptr, nullptr },
        { "is_attention_aware_dimming_enabled", reinterpret_cast<getter>(HumanPresenceSettings_get_IsAttentionAwareDimmingEnabled), reinterpret_cast<setter>(HumanPresenceSettings_put_IsAttentionAwareDimmingEnabled), nullptr, nullptr },
        { "is_adaptive_dimming_enabled", reinterpret_cast<getter>(HumanPresenceSettings_get_IsAdaptiveDimmingEnabled), reinterpret_cast<setter>(HumanPresenceSettings_put_IsAdaptiveDimmingEnabled), nullptr, nullptr },
        { "dimming_options", reinterpret_cast<getter>(HumanPresenceSettings_get_DimmingOptions), nullptr, nullptr, nullptr },
        { "lock_options", reinterpret_cast<getter>(HumanPresenceSettings_get_LockOptions), nullptr, nullptr, nullptr },
        { "wake_options", reinterpret_cast<getter>(HumanPresenceSettings_get_WakeOptions), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_HumanPresenceSettings[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_HumanPresenceSettings) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_HumanPresenceSettings) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_HumanPresenceSettings) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_HumanPresenceSettings) },
        { },
    };

    static PyType_Spec type_spec_HumanPresenceSettings =
    {
        "winrt._winrt_windows_devices_sensors.HumanPresenceSettings",
        sizeof(py::wrapper::Windows::Devices::Sensors::HumanPresenceSettings),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_HumanPresenceSettings
    };

    static PyGetSetDef getset_HumanPresenceSettings_Static[] = {
        { }
    };

    static PyMethodDef methods_HumanPresenceSettings_Static[] = {
        { "get_current_settings", reinterpret_cast<PyCFunction>(HumanPresenceSettings_GetCurrentSettings), METH_VARARGS, nullptr },
        { "get_current_settings_async", reinterpret_cast<PyCFunction>(HumanPresenceSettings_GetCurrentSettingsAsync), METH_VARARGS, nullptr },
        { "get_supported_features_for_sensor_id", reinterpret_cast<PyCFunction>(HumanPresenceSettings_GetSupportedFeaturesForSensorId), METH_VARARGS, nullptr },
        { "get_supported_features_for_sensor_id_async", reinterpret_cast<PyCFunction>(HumanPresenceSettings_GetSupportedFeaturesForSensorIdAsync), METH_VARARGS, nullptr },
        { "get_supported_lock_on_leave_timeouts", reinterpret_cast<PyCFunction>(HumanPresenceSettings_GetSupportedLockOnLeaveTimeouts), METH_VARARGS, nullptr },
        { "update_settings", reinterpret_cast<PyCFunction>(HumanPresenceSettings_UpdateSettings), METH_VARARGS, nullptr },
        { "update_settings_async", reinterpret_cast<PyCFunction>(HumanPresenceSettings_UpdateSettingsAsync), METH_VARARGS, nullptr },
        { }
    };

    static PyType_Slot type_slots_HumanPresenceSettings_Static[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_HumanPresenceSettings_Static) },
        { Py_tp_methods, reinterpret_cast<void*>(methods_HumanPresenceSettings_Static) },
        { }
    };

    static PyType_Spec type_spec_HumanPresenceSettings_Static =
    {
        "winrt._winrt_windows_devices_sensors.HumanPresenceSettings_Static",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT,
        type_slots_HumanPresenceSettings_Static
    };

    // ----- Inclinometer class --------------------

    static PyObject* _new_Inclinometer(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Devices::Sensors::Inclinometer>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Devices::Sensors::Inclinometer>::type_name);
        return nullptr;
    }

    static void _dealloc_Inclinometer(py::wrapper::Windows::Devices::Sensors::Inclinometer* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* Inclinometer_FromIdAsync(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.Sensors.Inclinometer", L"FromIdAsync", 1))
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                return py::convert(winrt::Windows::Devices::Sensors::Inclinometer::FromIdAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* Inclinometer_GetCurrentReading(py::wrapper::Windows::Devices::Sensors::Inclinometer* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.Sensors.Inclinometer", L"GetCurrentReading", 0))
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert(self->obj.GetCurrentReading());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* Inclinometer_GetDefault(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.Sensors.Inclinometer", L"GetDefault", 0))
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert(winrt::Windows::Devices::Sensors::Inclinometer::GetDefault());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 1)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.Sensors.Inclinometer", L"GetDefault", 1))
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Devices::Sensors::SensorReadingType>(args, 0);

                return py::convert(winrt::Windows::Devices::Sensors::Inclinometer::GetDefault(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* Inclinometer_GetDefaultForRelativeReadings(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.Sensors.Inclinometer", L"GetDefaultForRelativeReadings", 0))
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert(winrt::Windows::Devices::Sensors::Inclinometer::GetDefaultForRelativeReadings());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* Inclinometer_GetDeviceSelector(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.Sensors.Inclinometer", L"GetDeviceSelector", 1))
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Devices::Sensors::SensorReadingType>(args, 0);

                return py::convert(winrt::Windows::Devices::Sensors::Inclinometer::GetDeviceSelector(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* Inclinometer_get_ReportInterval(py::wrapper::Windows::Devices::Sensors::Inclinometer* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Sensors.Inclinometer", L"ReportInterval"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.ReportInterval());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int Inclinometer_put_ReportInterval(py::wrapper::Windows::Devices::Sensors::Inclinometer* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Sensors.Inclinometer", L"ReportInterval"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<uint32_t>(arg);

            self->obj.ReportInterval(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* Inclinometer_get_MinimumReportInterval(py::wrapper::Windows::Devices::Sensors::Inclinometer* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Sensors.Inclinometer", L"MinimumReportInterval"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.MinimumReportInterval());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* Inclinometer_get_ReadingTransform(py::wrapper::Windows::Devices::Sensors::Inclinometer* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Sensors.Inclinometer", L"ReadingTransform"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.ReadingTransform());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int Inclinometer_put_ReadingTransform(py::wrapper::Windows::Devices::Sensors::Inclinometer* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Sensors.Inclinometer", L"ReadingTransform"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::Graphics::Display::DisplayOrientations>(arg);

            self->obj.ReadingTransform(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* Inclinometer_get_ReadingType(py::wrapper::Windows::Devices::Sensors::Inclinometer* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Sensors.Inclinometer", L"ReadingType"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.ReadingType());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* Inclinometer_get_ReportLatency(py::wrapper::Windows::Devices::Sensors::Inclinometer* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Sensors.Inclinometer", L"ReportLatency"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.ReportLatency());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int Inclinometer_put_ReportLatency(py::wrapper::Windows::Devices::Sensors::Inclinometer* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Sensors.Inclinometer", L"ReportLatency"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<uint32_t>(arg);

            self->obj.ReportLatency(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* Inclinometer_get_MaxBatchSize(py::wrapper::Windows::Devices::Sensors::Inclinometer* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Sensors.Inclinometer", L"MaxBatchSize"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.MaxBatchSize());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* Inclinometer_get_ReportThreshold(py::wrapper::Windows::Devices::Sensors::Inclinometer* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Sensors.Inclinometer", L"ReportThreshold"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.ReportThreshold());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* Inclinometer_get_DeviceId(py::wrapper::Windows::Devices::Sensors::Inclinometer* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Sensors.Inclinometer", L"DeviceId"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.DeviceId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* Inclinometer_add_ReadingChanged(py::wrapper::Windows::Devices::Sensors::Inclinometer* self, PyObject* arg) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Devices.Sensors.Inclinometer", L"ReadingChanged"))
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Devices::Sensors::Inclinometer, winrt::Windows::Devices::Sensors::InclinometerReadingChangedEventArgs>>(arg);

            return py::convert(self->obj.ReadingChanged(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* Inclinometer_remove_ReadingChanged(py::wrapper::Windows::Devices::Sensors::Inclinometer* self, PyObject* arg) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Devices.Sensors.Inclinometer", L"ReadingChanged"))
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.ReadingChanged(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_Inclinometer(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Devices::Sensors::Inclinometer>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_Inclinometer(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Devices::Sensors::Inclinometer>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_Inclinometer[] = {
        { "get_current_reading", reinterpret_cast<PyCFunction>(Inclinometer_GetCurrentReading), METH_VARARGS, nullptr },
        { "add_reading_changed", reinterpret_cast<PyCFunction>(Inclinometer_add_ReadingChanged), METH_O, nullptr },
        { "remove_reading_changed", reinterpret_cast<PyCFunction>(Inclinometer_remove_ReadingChanged), METH_O, nullptr },
        { "_assign_array_", _assign_array_Inclinometer, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_Inclinometer), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_Inclinometer[] = {
        { "report_interval", reinterpret_cast<getter>(Inclinometer_get_ReportInterval), reinterpret_cast<setter>(Inclinometer_put_ReportInterval), nullptr, nullptr },
        { "minimum_report_interval", reinterpret_cast<getter>(Inclinometer_get_MinimumReportInterval), nullptr, nullptr, nullptr },
        { "reading_transform", reinterpret_cast<getter>(Inclinometer_get_ReadingTransform), reinterpret_cast<setter>(Inclinometer_put_ReadingTransform), nullptr, nullptr },
        { "reading_type", reinterpret_cast<getter>(Inclinometer_get_ReadingType), nullptr, nullptr, nullptr },
        { "report_latency", reinterpret_cast<getter>(Inclinometer_get_ReportLatency), reinterpret_cast<setter>(Inclinometer_put_ReportLatency), nullptr, nullptr },
        { "max_batch_size", reinterpret_cast<getter>(Inclinometer_get_MaxBatchSize), nullptr, nullptr, nullptr },
        { "report_threshold", reinterpret_cast<getter>(Inclinometer_get_ReportThreshold), nullptr, nullptr, nullptr },
        { "device_id", reinterpret_cast<getter>(Inclinometer_get_DeviceId), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_Inclinometer[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_Inclinometer) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_Inclinometer) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_Inclinometer) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_Inclinometer) },
        { },
    };

    static PyType_Spec type_spec_Inclinometer =
    {
        "winrt._winrt_windows_devices_sensors.Inclinometer",
        sizeof(py::wrapper::Windows::Devices::Sensors::Inclinometer),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_Inclinometer
    };

    static PyGetSetDef getset_Inclinometer_Static[] = {
        { }
    };

    static PyMethodDef methods_Inclinometer_Static[] = {
        { "from_id_async", reinterpret_cast<PyCFunction>(Inclinometer_FromIdAsync), METH_VARARGS, nullptr },
        { "get_default", reinterpret_cast<PyCFunction>(Inclinometer_GetDefault), METH_VARARGS, nullptr },
        { "get_default_for_relative_readings", reinterpret_cast<PyCFunction>(Inclinometer_GetDefaultForRelativeReadings), METH_VARARGS, nullptr },
        { "get_device_selector", reinterpret_cast<PyCFunction>(Inclinometer_GetDeviceSelector), METH_VARARGS, nullptr },
        { }
    };

    static PyType_Slot type_slots_Inclinometer_Static[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_Inclinometer_Static) },
        { Py_tp_methods, reinterpret_cast<void*>(methods_Inclinometer_Static) },
        { }
    };

    static PyType_Spec type_spec_Inclinometer_Static =
    {
        "winrt._winrt_windows_devices_sensors.Inclinometer_Static",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT,
        type_slots_Inclinometer_Static
    };

    // ----- InclinometerDataThreshold class --------------------

    static PyObject* _new_InclinometerDataThreshold(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Devices::Sensors::InclinometerDataThreshold>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Devices::Sensors::InclinometerDataThreshold>::type_name);
        return nullptr;
    }

    static void _dealloc_InclinometerDataThreshold(py::wrapper::Windows::Devices::Sensors::InclinometerDataThreshold* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* InclinometerDataThreshold_get_YawInDegrees(py::wrapper::Windows::Devices::Sensors::InclinometerDataThreshold* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Sensors.InclinometerDataThreshold", L"YawInDegrees"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.YawInDegrees());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int InclinometerDataThreshold_put_YawInDegrees(py::wrapper::Windows::Devices::Sensors::InclinometerDataThreshold* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Sensors.InclinometerDataThreshold", L"YawInDegrees"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<float>(arg);

            self->obj.YawInDegrees(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* InclinometerDataThreshold_get_RollInDegrees(py::wrapper::Windows::Devices::Sensors::InclinometerDataThreshold* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Sensors.InclinometerDataThreshold", L"RollInDegrees"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.RollInDegrees());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int InclinometerDataThreshold_put_RollInDegrees(py::wrapper::Windows::Devices::Sensors::InclinometerDataThreshold* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Sensors.InclinometerDataThreshold", L"RollInDegrees"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<float>(arg);

            self->obj.RollInDegrees(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* InclinometerDataThreshold_get_PitchInDegrees(py::wrapper::Windows::Devices::Sensors::InclinometerDataThreshold* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Sensors.InclinometerDataThreshold", L"PitchInDegrees"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.PitchInDegrees());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int InclinometerDataThreshold_put_PitchInDegrees(py::wrapper::Windows::Devices::Sensors::InclinometerDataThreshold* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Sensors.InclinometerDataThreshold", L"PitchInDegrees"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<float>(arg);

            self->obj.PitchInDegrees(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* _assign_array_InclinometerDataThreshold(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Devices::Sensors::InclinometerDataThreshold>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_InclinometerDataThreshold(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Devices::Sensors::InclinometerDataThreshold>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_InclinometerDataThreshold[] = {
        { "_assign_array_", _assign_array_InclinometerDataThreshold, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_InclinometerDataThreshold), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_InclinometerDataThreshold[] = {
        { "yaw_in_degrees", reinterpret_cast<getter>(InclinometerDataThreshold_get_YawInDegrees), reinterpret_cast<setter>(InclinometerDataThreshold_put_YawInDegrees), nullptr, nullptr },
        { "roll_in_degrees", reinterpret_cast<getter>(InclinometerDataThreshold_get_RollInDegrees), reinterpret_cast<setter>(InclinometerDataThreshold_put_RollInDegrees), nullptr, nullptr },
        { "pitch_in_degrees", reinterpret_cast<getter>(InclinometerDataThreshold_get_PitchInDegrees), reinterpret_cast<setter>(InclinometerDataThreshold_put_PitchInDegrees), nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_InclinometerDataThreshold[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_InclinometerDataThreshold) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_InclinometerDataThreshold) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_InclinometerDataThreshold) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_InclinometerDataThreshold) },
        { },
    };

    static PyType_Spec type_spec_InclinometerDataThreshold =
    {
        "winrt._winrt_windows_devices_sensors.InclinometerDataThreshold",
        sizeof(py::wrapper::Windows::Devices::Sensors::InclinometerDataThreshold),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_InclinometerDataThreshold
    };

    // ----- InclinometerReading class --------------------

    static PyObject* _new_InclinometerReading(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Devices::Sensors::InclinometerReading>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Devices::Sensors::InclinometerReading>::type_name);
        return nullptr;
    }

    static void _dealloc_InclinometerReading(py::wrapper::Windows::Devices::Sensors::InclinometerReading* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* InclinometerReading_get_PitchDegrees(py::wrapper::Windows::Devices::Sensors::InclinometerReading* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Sensors.InclinometerReading", L"PitchDegrees"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.PitchDegrees());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* InclinometerReading_get_RollDegrees(py::wrapper::Windows::Devices::Sensors::InclinometerReading* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Sensors.InclinometerReading", L"RollDegrees"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.RollDegrees());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* InclinometerReading_get_Timestamp(py::wrapper::Windows::Devices::Sensors::InclinometerReading* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Sensors.InclinometerReading", L"Timestamp"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Timestamp());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* InclinometerReading_get_YawDegrees(py::wrapper::Windows::Devices::Sensors::InclinometerReading* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Sensors.InclinometerReading", L"YawDegrees"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.YawDegrees());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* InclinometerReading_get_PerformanceCount(py::wrapper::Windows::Devices::Sensors::InclinometerReading* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Sensors.InclinometerReading", L"PerformanceCount"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.PerformanceCount());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* InclinometerReading_get_Properties(py::wrapper::Windows::Devices::Sensors::InclinometerReading* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Sensors.InclinometerReading", L"Properties"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Properties());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* InclinometerReading_get_YawAccuracy(py::wrapper::Windows::Devices::Sensors::InclinometerReading* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Sensors.InclinometerReading", L"YawAccuracy"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.YawAccuracy());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_InclinometerReading(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Devices::Sensors::InclinometerReading>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_InclinometerReading(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Devices::Sensors::InclinometerReading>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_InclinometerReading[] = {
        { "_assign_array_", _assign_array_InclinometerReading, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_InclinometerReading), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_InclinometerReading[] = {
        { "pitch_degrees", reinterpret_cast<getter>(InclinometerReading_get_PitchDegrees), nullptr, nullptr, nullptr },
        { "roll_degrees", reinterpret_cast<getter>(InclinometerReading_get_RollDegrees), nullptr, nullptr, nullptr },
        { "timestamp", reinterpret_cast<getter>(InclinometerReading_get_Timestamp), nullptr, nullptr, nullptr },
        { "yaw_degrees", reinterpret_cast<getter>(InclinometerReading_get_YawDegrees), nullptr, nullptr, nullptr },
        { "performance_count", reinterpret_cast<getter>(InclinometerReading_get_PerformanceCount), nullptr, nullptr, nullptr },
        { "properties", reinterpret_cast<getter>(InclinometerReading_get_Properties), nullptr, nullptr, nullptr },
        { "yaw_accuracy", reinterpret_cast<getter>(InclinometerReading_get_YawAccuracy), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_InclinometerReading[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_InclinometerReading) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_InclinometerReading) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_InclinometerReading) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_InclinometerReading) },
        { },
    };

    static PyType_Spec type_spec_InclinometerReading =
    {
        "winrt._winrt_windows_devices_sensors.InclinometerReading",
        sizeof(py::wrapper::Windows::Devices::Sensors::InclinometerReading),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_InclinometerReading
    };

    // ----- InclinometerReadingChangedEventArgs class --------------------

    static PyObject* _new_InclinometerReadingChangedEventArgs(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Devices::Sensors::InclinometerReadingChangedEventArgs>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Devices::Sensors::InclinometerReadingChangedEventArgs>::type_name);
        return nullptr;
    }

    static void _dealloc_InclinometerReadingChangedEventArgs(py::wrapper::Windows::Devices::Sensors::InclinometerReadingChangedEventArgs* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* InclinometerReadingChangedEventArgs_get_Reading(py::wrapper::Windows::Devices::Sensors::InclinometerReadingChangedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Sensors.InclinometerReadingChangedEventArgs", L"Reading"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Reading());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_InclinometerReadingChangedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Devices::Sensors::InclinometerReadingChangedEventArgs>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_InclinometerReadingChangedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Devices::Sensors::InclinometerReadingChangedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_InclinometerReadingChangedEventArgs[] = {
        { "_assign_array_", _assign_array_InclinometerReadingChangedEventArgs, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_InclinometerReadingChangedEventArgs), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_InclinometerReadingChangedEventArgs[] = {
        { "reading", reinterpret_cast<getter>(InclinometerReadingChangedEventArgs_get_Reading), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_InclinometerReadingChangedEventArgs[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_InclinometerReadingChangedEventArgs) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_InclinometerReadingChangedEventArgs) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_InclinometerReadingChangedEventArgs) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_InclinometerReadingChangedEventArgs) },
        { },
    };

    static PyType_Spec type_spec_InclinometerReadingChangedEventArgs =
    {
        "winrt._winrt_windows_devices_sensors.InclinometerReadingChangedEventArgs",
        sizeof(py::wrapper::Windows::Devices::Sensors::InclinometerReadingChangedEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_InclinometerReadingChangedEventArgs
    };

    // ----- LightSensor class --------------------

    static PyObject* _new_LightSensor(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Devices::Sensors::LightSensor>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Devices::Sensors::LightSensor>::type_name);
        return nullptr;
    }

    static void _dealloc_LightSensor(py::wrapper::Windows::Devices::Sensors::LightSensor* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* LightSensor_FromIdAsync(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.Sensors.LightSensor", L"FromIdAsync", 1))
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                return py::convert(winrt::Windows::Devices::Sensors::LightSensor::FromIdAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* LightSensor_GetCurrentReading(py::wrapper::Windows::Devices::Sensors::LightSensor* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.Sensors.LightSensor", L"GetCurrentReading", 0))
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert(self->obj.GetCurrentReading());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* LightSensor_GetDefault(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.Sensors.LightSensor", L"GetDefault", 0))
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert(winrt::Windows::Devices::Sensors::LightSensor::GetDefault());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* LightSensor_GetDeviceSelector(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.Sensors.LightSensor", L"GetDeviceSelector", 0))
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert(winrt::Windows::Devices::Sensors::LightSensor::GetDeviceSelector());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* LightSensor_get_ReportInterval(py::wrapper::Windows::Devices::Sensors::LightSensor* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Sensors.LightSensor", L"ReportInterval"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.ReportInterval());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int LightSensor_put_ReportInterval(py::wrapper::Windows::Devices::Sensors::LightSensor* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Sensors.LightSensor", L"ReportInterval"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<uint32_t>(arg);

            self->obj.ReportInterval(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* LightSensor_get_MinimumReportInterval(py::wrapper::Windows::Devices::Sensors::LightSensor* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Sensors.LightSensor", L"MinimumReportInterval"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.MinimumReportInterval());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* LightSensor_get_ReportLatency(py::wrapper::Windows::Devices::Sensors::LightSensor* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Sensors.LightSensor", L"ReportLatency"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.ReportLatency());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int LightSensor_put_ReportLatency(py::wrapper::Windows::Devices::Sensors::LightSensor* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Sensors.LightSensor", L"ReportLatency"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<uint32_t>(arg);

            self->obj.ReportLatency(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* LightSensor_get_MaxBatchSize(py::wrapper::Windows::Devices::Sensors::LightSensor* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Sensors.LightSensor", L"MaxBatchSize"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.MaxBatchSize());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* LightSensor_get_ReportThreshold(py::wrapper::Windows::Devices::Sensors::LightSensor* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Sensors.LightSensor", L"ReportThreshold"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.ReportThreshold());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* LightSensor_get_DeviceId(py::wrapper::Windows::Devices::Sensors::LightSensor* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Sensors.LightSensor", L"DeviceId"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.DeviceId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* LightSensor_add_ReadingChanged(py::wrapper::Windows::Devices::Sensors::LightSensor* self, PyObject* arg) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Devices.Sensors.LightSensor", L"ReadingChanged"))
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Devices::Sensors::LightSensor, winrt::Windows::Devices::Sensors::LightSensorReadingChangedEventArgs>>(arg);

            return py::convert(self->obj.ReadingChanged(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* LightSensor_remove_ReadingChanged(py::wrapper::Windows::Devices::Sensors::LightSensor* self, PyObject* arg) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Devices.Sensors.LightSensor", L"ReadingChanged"))
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.ReadingChanged(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_LightSensor(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Devices::Sensors::LightSensor>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_LightSensor(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Devices::Sensors::LightSensor>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_LightSensor[] = {
        { "get_current_reading", reinterpret_cast<PyCFunction>(LightSensor_GetCurrentReading), METH_VARARGS, nullptr },
        { "add_reading_changed", reinterpret_cast<PyCFunction>(LightSensor_add_ReadingChanged), METH_O, nullptr },
        { "remove_reading_changed", reinterpret_cast<PyCFunction>(LightSensor_remove_ReadingChanged), METH_O, nullptr },
        { "_assign_array_", _assign_array_LightSensor, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_LightSensor), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_LightSensor[] = {
        { "report_interval", reinterpret_cast<getter>(LightSensor_get_ReportInterval), reinterpret_cast<setter>(LightSensor_put_ReportInterval), nullptr, nullptr },
        { "minimum_report_interval", reinterpret_cast<getter>(LightSensor_get_MinimumReportInterval), nullptr, nullptr, nullptr },
        { "report_latency", reinterpret_cast<getter>(LightSensor_get_ReportLatency), reinterpret_cast<setter>(LightSensor_put_ReportLatency), nullptr, nullptr },
        { "max_batch_size", reinterpret_cast<getter>(LightSensor_get_MaxBatchSize), nullptr, nullptr, nullptr },
        { "report_threshold", reinterpret_cast<getter>(LightSensor_get_ReportThreshold), nullptr, nullptr, nullptr },
        { "device_id", reinterpret_cast<getter>(LightSensor_get_DeviceId), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_LightSensor[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_LightSensor) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_LightSensor) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_LightSensor) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_LightSensor) },
        { },
    };

    static PyType_Spec type_spec_LightSensor =
    {
        "winrt._winrt_windows_devices_sensors.LightSensor",
        sizeof(py::wrapper::Windows::Devices::Sensors::LightSensor),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_LightSensor
    };

    static PyGetSetDef getset_LightSensor_Static[] = {
        { }
    };

    static PyMethodDef methods_LightSensor_Static[] = {
        { "from_id_async", reinterpret_cast<PyCFunction>(LightSensor_FromIdAsync), METH_VARARGS, nullptr },
        { "get_default", reinterpret_cast<PyCFunction>(LightSensor_GetDefault), METH_VARARGS, nullptr },
        { "get_device_selector", reinterpret_cast<PyCFunction>(LightSensor_GetDeviceSelector), METH_VARARGS, nullptr },
        { }
    };

    static PyType_Slot type_slots_LightSensor_Static[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_LightSensor_Static) },
        { Py_tp_methods, reinterpret_cast<void*>(methods_LightSensor_Static) },
        { }
    };

    static PyType_Spec type_spec_LightSensor_Static =
    {
        "winrt._winrt_windows_devices_sensors.LightSensor_Static",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT,
        type_slots_LightSensor_Static
    };

    // ----- LightSensorDataThreshold class --------------------

    static PyObject* _new_LightSensorDataThreshold(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Devices::Sensors::LightSensorDataThreshold>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Devices::Sensors::LightSensorDataThreshold>::type_name);
        return nullptr;
    }

    static void _dealloc_LightSensorDataThreshold(py::wrapper::Windows::Devices::Sensors::LightSensorDataThreshold* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* LightSensorDataThreshold_get_LuxPercentage(py::wrapper::Windows::Devices::Sensors::LightSensorDataThreshold* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Sensors.LightSensorDataThreshold", L"LuxPercentage"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.LuxPercentage());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int LightSensorDataThreshold_put_LuxPercentage(py::wrapper::Windows::Devices::Sensors::LightSensorDataThreshold* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Sensors.LightSensorDataThreshold", L"LuxPercentage"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<float>(arg);

            self->obj.LuxPercentage(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* LightSensorDataThreshold_get_AbsoluteLux(py::wrapper::Windows::Devices::Sensors::LightSensorDataThreshold* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Sensors.LightSensorDataThreshold", L"AbsoluteLux"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.AbsoluteLux());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int LightSensorDataThreshold_put_AbsoluteLux(py::wrapper::Windows::Devices::Sensors::LightSensorDataThreshold* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Sensors.LightSensorDataThreshold", L"AbsoluteLux"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<float>(arg);

            self->obj.AbsoluteLux(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* _assign_array_LightSensorDataThreshold(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Devices::Sensors::LightSensorDataThreshold>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_LightSensorDataThreshold(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Devices::Sensors::LightSensorDataThreshold>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_LightSensorDataThreshold[] = {
        { "_assign_array_", _assign_array_LightSensorDataThreshold, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_LightSensorDataThreshold), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_LightSensorDataThreshold[] = {
        { "lux_percentage", reinterpret_cast<getter>(LightSensorDataThreshold_get_LuxPercentage), reinterpret_cast<setter>(LightSensorDataThreshold_put_LuxPercentage), nullptr, nullptr },
        { "absolute_lux", reinterpret_cast<getter>(LightSensorDataThreshold_get_AbsoluteLux), reinterpret_cast<setter>(LightSensorDataThreshold_put_AbsoluteLux), nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_LightSensorDataThreshold[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_LightSensorDataThreshold) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_LightSensorDataThreshold) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_LightSensorDataThreshold) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_LightSensorDataThreshold) },
        { },
    };

    static PyType_Spec type_spec_LightSensorDataThreshold =
    {
        "winrt._winrt_windows_devices_sensors.LightSensorDataThreshold",
        sizeof(py::wrapper::Windows::Devices::Sensors::LightSensorDataThreshold),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_LightSensorDataThreshold
    };

    // ----- LightSensorReading class --------------------

    static PyObject* _new_LightSensorReading(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Devices::Sensors::LightSensorReading>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Devices::Sensors::LightSensorReading>::type_name);
        return nullptr;
    }

    static void _dealloc_LightSensorReading(py::wrapper::Windows::Devices::Sensors::LightSensorReading* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* LightSensorReading_get_IlluminanceInLux(py::wrapper::Windows::Devices::Sensors::LightSensorReading* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Sensors.LightSensorReading", L"IlluminanceInLux"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.IlluminanceInLux());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* LightSensorReading_get_Timestamp(py::wrapper::Windows::Devices::Sensors::LightSensorReading* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Sensors.LightSensorReading", L"Timestamp"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Timestamp());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* LightSensorReading_get_PerformanceCount(py::wrapper::Windows::Devices::Sensors::LightSensorReading* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Sensors.LightSensorReading", L"PerformanceCount"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.PerformanceCount());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* LightSensorReading_get_Properties(py::wrapper::Windows::Devices::Sensors::LightSensorReading* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Sensors.LightSensorReading", L"Properties"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Properties());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_LightSensorReading(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Devices::Sensors::LightSensorReading>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_LightSensorReading(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Devices::Sensors::LightSensorReading>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_LightSensorReading[] = {
        { "_assign_array_", _assign_array_LightSensorReading, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_LightSensorReading), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_LightSensorReading[] = {
        { "illuminance_in_lux", reinterpret_cast<getter>(LightSensorReading_get_IlluminanceInLux), nullptr, nullptr, nullptr },
        { "timestamp", reinterpret_cast<getter>(LightSensorReading_get_Timestamp), nullptr, nullptr, nullptr },
        { "performance_count", reinterpret_cast<getter>(LightSensorReading_get_PerformanceCount), nullptr, nullptr, nullptr },
        { "properties", reinterpret_cast<getter>(LightSensorReading_get_Properties), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_LightSensorReading[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_LightSensorReading) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_LightSensorReading) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_LightSensorReading) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_LightSensorReading) },
        { },
    };

    static PyType_Spec type_spec_LightSensorReading =
    {
        "winrt._winrt_windows_devices_sensors.LightSensorReading",
        sizeof(py::wrapper::Windows::Devices::Sensors::LightSensorReading),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_LightSensorReading
    };

    // ----- LightSensorReadingChangedEventArgs class --------------------

    static PyObject* _new_LightSensorReadingChangedEventArgs(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Devices::Sensors::LightSensorReadingChangedEventArgs>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Devices::Sensors::LightSensorReadingChangedEventArgs>::type_name);
        return nullptr;
    }

    static void _dealloc_LightSensorReadingChangedEventArgs(py::wrapper::Windows::Devices::Sensors::LightSensorReadingChangedEventArgs* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* LightSensorReadingChangedEventArgs_get_Reading(py::wrapper::Windows::Devices::Sensors::LightSensorReadingChangedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Sensors.LightSensorReadingChangedEventArgs", L"Reading"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Reading());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_LightSensorReadingChangedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Devices::Sensors::LightSensorReadingChangedEventArgs>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_LightSensorReadingChangedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Devices::Sensors::LightSensorReadingChangedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_LightSensorReadingChangedEventArgs[] = {
        { "_assign_array_", _assign_array_LightSensorReadingChangedEventArgs, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_LightSensorReadingChangedEventArgs), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_LightSensorReadingChangedEventArgs[] = {
        { "reading", reinterpret_cast<getter>(LightSensorReadingChangedEventArgs_get_Reading), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_LightSensorReadingChangedEventArgs[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_LightSensorReadingChangedEventArgs) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_LightSensorReadingChangedEventArgs) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_LightSensorReadingChangedEventArgs) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_LightSensorReadingChangedEventArgs) },
        { },
    };

    static PyType_Spec type_spec_LightSensorReadingChangedEventArgs =
    {
        "winrt._winrt_windows_devices_sensors.LightSensorReadingChangedEventArgs",
        sizeof(py::wrapper::Windows::Devices::Sensors::LightSensorReadingChangedEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_LightSensorReadingChangedEventArgs
    };

    // ----- LockOnLeaveOptions class --------------------

    static PyObject* _new_LockOnLeaveOptions(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Devices::Sensors::LockOnLeaveOptions>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Devices::Sensors::LockOnLeaveOptions>::type_name);
        return nullptr;
    }

    static void _dealloc_LockOnLeaveOptions(py::wrapper::Windows::Devices::Sensors::LockOnLeaveOptions* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* LockOnLeaveOptions_get_AllowWhenExternalDisplayConnected(py::wrapper::Windows::Devices::Sensors::LockOnLeaveOptions* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Sensors.LockOnLeaveOptions", L"AllowWhenExternalDisplayConnected"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.AllowWhenExternalDisplayConnected());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int LockOnLeaveOptions_put_AllowWhenExternalDisplayConnected(py::wrapper::Windows::Devices::Sensors::LockOnLeaveOptions* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Sensors.LockOnLeaveOptions", L"AllowWhenExternalDisplayConnected"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<bool>(arg);

            self->obj.AllowWhenExternalDisplayConnected(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* _assign_array_LockOnLeaveOptions(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Devices::Sensors::LockOnLeaveOptions>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_LockOnLeaveOptions(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Devices::Sensors::LockOnLeaveOptions>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_LockOnLeaveOptions[] = {
        { "_assign_array_", _assign_array_LockOnLeaveOptions, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_LockOnLeaveOptions), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_LockOnLeaveOptions[] = {
        { "allow_when_external_display_connected", reinterpret_cast<getter>(LockOnLeaveOptions_get_AllowWhenExternalDisplayConnected), reinterpret_cast<setter>(LockOnLeaveOptions_put_AllowWhenExternalDisplayConnected), nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_LockOnLeaveOptions[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_LockOnLeaveOptions) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_LockOnLeaveOptions) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_LockOnLeaveOptions) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_LockOnLeaveOptions) },
        { },
    };

    static PyType_Spec type_spec_LockOnLeaveOptions =
    {
        "winrt._winrt_windows_devices_sensors.LockOnLeaveOptions",
        sizeof(py::wrapper::Windows::Devices::Sensors::LockOnLeaveOptions),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_LockOnLeaveOptions
    };

    // ----- Magnetometer class --------------------

    static PyObject* _new_Magnetometer(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Devices::Sensors::Magnetometer>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Devices::Sensors::Magnetometer>::type_name);
        return nullptr;
    }

    static void _dealloc_Magnetometer(py::wrapper::Windows::Devices::Sensors::Magnetometer* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* Magnetometer_FromIdAsync(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.Sensors.Magnetometer", L"FromIdAsync", 1))
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                return py::convert(winrt::Windows::Devices::Sensors::Magnetometer::FromIdAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* Magnetometer_GetCurrentReading(py::wrapper::Windows::Devices::Sensors::Magnetometer* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.Sensors.Magnetometer", L"GetCurrentReading", 0))
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert(self->obj.GetCurrentReading());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* Magnetometer_GetDefault(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.Sensors.Magnetometer", L"GetDefault", 0))
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert(winrt::Windows::Devices::Sensors::Magnetometer::GetDefault());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* Magnetometer_GetDeviceSelector(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.Sensors.Magnetometer", L"GetDeviceSelector", 0))
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert(winrt::Windows::Devices::Sensors::Magnetometer::GetDeviceSelector());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* Magnetometer_get_ReportInterval(py::wrapper::Windows::Devices::Sensors::Magnetometer* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Sensors.Magnetometer", L"ReportInterval"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.ReportInterval());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int Magnetometer_put_ReportInterval(py::wrapper::Windows::Devices::Sensors::Magnetometer* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Sensors.Magnetometer", L"ReportInterval"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<uint32_t>(arg);

            self->obj.ReportInterval(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* Magnetometer_get_MinimumReportInterval(py::wrapper::Windows::Devices::Sensors::Magnetometer* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Sensors.Magnetometer", L"MinimumReportInterval"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.MinimumReportInterval());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* Magnetometer_get_ReadingTransform(py::wrapper::Windows::Devices::Sensors::Magnetometer* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Sensors.Magnetometer", L"ReadingTransform"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.ReadingTransform());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int Magnetometer_put_ReadingTransform(py::wrapper::Windows::Devices::Sensors::Magnetometer* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Sensors.Magnetometer", L"ReadingTransform"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::Graphics::Display::DisplayOrientations>(arg);

            self->obj.ReadingTransform(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* Magnetometer_get_ReportLatency(py::wrapper::Windows::Devices::Sensors::Magnetometer* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Sensors.Magnetometer", L"ReportLatency"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.ReportLatency());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int Magnetometer_put_ReportLatency(py::wrapper::Windows::Devices::Sensors::Magnetometer* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Sensors.Magnetometer", L"ReportLatency"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<uint32_t>(arg);

            self->obj.ReportLatency(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* Magnetometer_get_MaxBatchSize(py::wrapper::Windows::Devices::Sensors::Magnetometer* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Sensors.Magnetometer", L"MaxBatchSize"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.MaxBatchSize());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* Magnetometer_get_ReportThreshold(py::wrapper::Windows::Devices::Sensors::Magnetometer* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Sensors.Magnetometer", L"ReportThreshold"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.ReportThreshold());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* Magnetometer_get_DeviceId(py::wrapper::Windows::Devices::Sensors::Magnetometer* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Sensors.Magnetometer", L"DeviceId"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.DeviceId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* Magnetometer_add_ReadingChanged(py::wrapper::Windows::Devices::Sensors::Magnetometer* self, PyObject* arg) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Devices.Sensors.Magnetometer", L"ReadingChanged"))
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Devices::Sensors::Magnetometer, winrt::Windows::Devices::Sensors::MagnetometerReadingChangedEventArgs>>(arg);

            return py::convert(self->obj.ReadingChanged(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* Magnetometer_remove_ReadingChanged(py::wrapper::Windows::Devices::Sensors::Magnetometer* self, PyObject* arg) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Devices.Sensors.Magnetometer", L"ReadingChanged"))
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.ReadingChanged(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_Magnetometer(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Devices::Sensors::Magnetometer>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_Magnetometer(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Devices::Sensors::Magnetometer>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_Magnetometer[] = {
        { "get_current_reading", reinterpret_cast<PyCFunction>(Magnetometer_GetCurrentReading), METH_VARARGS, nullptr },
        { "add_reading_changed", reinterpret_cast<PyCFunction>(Magnetometer_add_ReadingChanged), METH_O, nullptr },
        { "remove_reading_changed", reinterpret_cast<PyCFunction>(Magnetometer_remove_ReadingChanged), METH_O, nullptr },
        { "_assign_array_", _assign_array_Magnetometer, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_Magnetometer), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_Magnetometer[] = {
        { "report_interval", reinterpret_cast<getter>(Magnetometer_get_ReportInterval), reinterpret_cast<setter>(Magnetometer_put_ReportInterval), nullptr, nullptr },
        { "minimum_report_interval", reinterpret_cast<getter>(Magnetometer_get_MinimumReportInterval), nullptr, nullptr, nullptr },
        { "reading_transform", reinterpret_cast<getter>(Magnetometer_get_ReadingTransform), reinterpret_cast<setter>(Magnetometer_put_ReadingTransform), nullptr, nullptr },
        { "report_latency", reinterpret_cast<getter>(Magnetometer_get_ReportLatency), reinterpret_cast<setter>(Magnetometer_put_ReportLatency), nullptr, nullptr },
        { "max_batch_size", reinterpret_cast<getter>(Magnetometer_get_MaxBatchSize), nullptr, nullptr, nullptr },
        { "report_threshold", reinterpret_cast<getter>(Magnetometer_get_ReportThreshold), nullptr, nullptr, nullptr },
        { "device_id", reinterpret_cast<getter>(Magnetometer_get_DeviceId), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_Magnetometer[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_Magnetometer) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_Magnetometer) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_Magnetometer) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_Magnetometer) },
        { },
    };

    static PyType_Spec type_spec_Magnetometer =
    {
        "winrt._winrt_windows_devices_sensors.Magnetometer",
        sizeof(py::wrapper::Windows::Devices::Sensors::Magnetometer),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_Magnetometer
    };

    static PyGetSetDef getset_Magnetometer_Static[] = {
        { }
    };

    static PyMethodDef methods_Magnetometer_Static[] = {
        { "from_id_async", reinterpret_cast<PyCFunction>(Magnetometer_FromIdAsync), METH_VARARGS, nullptr },
        { "get_default", reinterpret_cast<PyCFunction>(Magnetometer_GetDefault), METH_VARARGS, nullptr },
        { "get_device_selector", reinterpret_cast<PyCFunction>(Magnetometer_GetDeviceSelector), METH_VARARGS, nullptr },
        { }
    };

    static PyType_Slot type_slots_Magnetometer_Static[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_Magnetometer_Static) },
        { Py_tp_methods, reinterpret_cast<void*>(methods_Magnetometer_Static) },
        { }
    };

    static PyType_Spec type_spec_Magnetometer_Static =
    {
        "winrt._winrt_windows_devices_sensors.Magnetometer_Static",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT,
        type_slots_Magnetometer_Static
    };

    // ----- MagnetometerDataThreshold class --------------------

    static PyObject* _new_MagnetometerDataThreshold(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Devices::Sensors::MagnetometerDataThreshold>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Devices::Sensors::MagnetometerDataThreshold>::type_name);
        return nullptr;
    }

    static void _dealloc_MagnetometerDataThreshold(py::wrapper::Windows::Devices::Sensors::MagnetometerDataThreshold* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* MagnetometerDataThreshold_get_ZAxisMicroteslas(py::wrapper::Windows::Devices::Sensors::MagnetometerDataThreshold* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Sensors.MagnetometerDataThreshold", L"ZAxisMicroteslas"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.ZAxisMicroteslas());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int MagnetometerDataThreshold_put_ZAxisMicroteslas(py::wrapper::Windows::Devices::Sensors::MagnetometerDataThreshold* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Sensors.MagnetometerDataThreshold", L"ZAxisMicroteslas"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<float>(arg);

            self->obj.ZAxisMicroteslas(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* MagnetometerDataThreshold_get_YAxisMicroteslas(py::wrapper::Windows::Devices::Sensors::MagnetometerDataThreshold* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Sensors.MagnetometerDataThreshold", L"YAxisMicroteslas"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.YAxisMicroteslas());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int MagnetometerDataThreshold_put_YAxisMicroteslas(py::wrapper::Windows::Devices::Sensors::MagnetometerDataThreshold* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Sensors.MagnetometerDataThreshold", L"YAxisMicroteslas"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<float>(arg);

            self->obj.YAxisMicroteslas(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* MagnetometerDataThreshold_get_XAxisMicroteslas(py::wrapper::Windows::Devices::Sensors::MagnetometerDataThreshold* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Sensors.MagnetometerDataThreshold", L"XAxisMicroteslas"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.XAxisMicroteslas());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int MagnetometerDataThreshold_put_XAxisMicroteslas(py::wrapper::Windows::Devices::Sensors::MagnetometerDataThreshold* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Sensors.MagnetometerDataThreshold", L"XAxisMicroteslas"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<float>(arg);

            self->obj.XAxisMicroteslas(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* _assign_array_MagnetometerDataThreshold(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Devices::Sensors::MagnetometerDataThreshold>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_MagnetometerDataThreshold(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Devices::Sensors::MagnetometerDataThreshold>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_MagnetometerDataThreshold[] = {
        { "_assign_array_", _assign_array_MagnetometerDataThreshold, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_MagnetometerDataThreshold), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_MagnetometerDataThreshold[] = {
        { "z_axis_microteslas", reinterpret_cast<getter>(MagnetometerDataThreshold_get_ZAxisMicroteslas), reinterpret_cast<setter>(MagnetometerDataThreshold_put_ZAxisMicroteslas), nullptr, nullptr },
        { "y_axis_microteslas", reinterpret_cast<getter>(MagnetometerDataThreshold_get_YAxisMicroteslas), reinterpret_cast<setter>(MagnetometerDataThreshold_put_YAxisMicroteslas), nullptr, nullptr },
        { "x_axis_microteslas", reinterpret_cast<getter>(MagnetometerDataThreshold_get_XAxisMicroteslas), reinterpret_cast<setter>(MagnetometerDataThreshold_put_XAxisMicroteslas), nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_MagnetometerDataThreshold[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_MagnetometerDataThreshold) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_MagnetometerDataThreshold) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_MagnetometerDataThreshold) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_MagnetometerDataThreshold) },
        { },
    };

    static PyType_Spec type_spec_MagnetometerDataThreshold =
    {
        "winrt._winrt_windows_devices_sensors.MagnetometerDataThreshold",
        sizeof(py::wrapper::Windows::Devices::Sensors::MagnetometerDataThreshold),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_MagnetometerDataThreshold
    };

    // ----- MagnetometerReading class --------------------

    static PyObject* _new_MagnetometerReading(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Devices::Sensors::MagnetometerReading>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Devices::Sensors::MagnetometerReading>::type_name);
        return nullptr;
    }

    static void _dealloc_MagnetometerReading(py::wrapper::Windows::Devices::Sensors::MagnetometerReading* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* MagnetometerReading_get_DirectionalAccuracy(py::wrapper::Windows::Devices::Sensors::MagnetometerReading* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Sensors.MagnetometerReading", L"DirectionalAccuracy"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.DirectionalAccuracy());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MagnetometerReading_get_MagneticFieldX(py::wrapper::Windows::Devices::Sensors::MagnetometerReading* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Sensors.MagnetometerReading", L"MagneticFieldX"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.MagneticFieldX());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MagnetometerReading_get_MagneticFieldY(py::wrapper::Windows::Devices::Sensors::MagnetometerReading* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Sensors.MagnetometerReading", L"MagneticFieldY"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.MagneticFieldY());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MagnetometerReading_get_MagneticFieldZ(py::wrapper::Windows::Devices::Sensors::MagnetometerReading* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Sensors.MagnetometerReading", L"MagneticFieldZ"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.MagneticFieldZ());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MagnetometerReading_get_Timestamp(py::wrapper::Windows::Devices::Sensors::MagnetometerReading* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Sensors.MagnetometerReading", L"Timestamp"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Timestamp());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MagnetometerReading_get_PerformanceCount(py::wrapper::Windows::Devices::Sensors::MagnetometerReading* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Sensors.MagnetometerReading", L"PerformanceCount"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.PerformanceCount());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MagnetometerReading_get_Properties(py::wrapper::Windows::Devices::Sensors::MagnetometerReading* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Sensors.MagnetometerReading", L"Properties"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Properties());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_MagnetometerReading(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Devices::Sensors::MagnetometerReading>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_MagnetometerReading(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Devices::Sensors::MagnetometerReading>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_MagnetometerReading[] = {
        { "_assign_array_", _assign_array_MagnetometerReading, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_MagnetometerReading), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_MagnetometerReading[] = {
        { "directional_accuracy", reinterpret_cast<getter>(MagnetometerReading_get_DirectionalAccuracy), nullptr, nullptr, nullptr },
        { "magnetic_field_x", reinterpret_cast<getter>(MagnetometerReading_get_MagneticFieldX), nullptr, nullptr, nullptr },
        { "magnetic_field_y", reinterpret_cast<getter>(MagnetometerReading_get_MagneticFieldY), nullptr, nullptr, nullptr },
        { "magnetic_field_z", reinterpret_cast<getter>(MagnetometerReading_get_MagneticFieldZ), nullptr, nullptr, nullptr },
        { "timestamp", reinterpret_cast<getter>(MagnetometerReading_get_Timestamp), nullptr, nullptr, nullptr },
        { "performance_count", reinterpret_cast<getter>(MagnetometerReading_get_PerformanceCount), nullptr, nullptr, nullptr },
        { "properties", reinterpret_cast<getter>(MagnetometerReading_get_Properties), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_MagnetometerReading[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_MagnetometerReading) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_MagnetometerReading) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_MagnetometerReading) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_MagnetometerReading) },
        { },
    };

    static PyType_Spec type_spec_MagnetometerReading =
    {
        "winrt._winrt_windows_devices_sensors.MagnetometerReading",
        sizeof(py::wrapper::Windows::Devices::Sensors::MagnetometerReading),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_MagnetometerReading
    };

    // ----- MagnetometerReadingChangedEventArgs class --------------------

    static PyObject* _new_MagnetometerReadingChangedEventArgs(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Devices::Sensors::MagnetometerReadingChangedEventArgs>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Devices::Sensors::MagnetometerReadingChangedEventArgs>::type_name);
        return nullptr;
    }

    static void _dealloc_MagnetometerReadingChangedEventArgs(py::wrapper::Windows::Devices::Sensors::MagnetometerReadingChangedEventArgs* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* MagnetometerReadingChangedEventArgs_get_Reading(py::wrapper::Windows::Devices::Sensors::MagnetometerReadingChangedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Sensors.MagnetometerReadingChangedEventArgs", L"Reading"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Reading());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_MagnetometerReadingChangedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Devices::Sensors::MagnetometerReadingChangedEventArgs>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_MagnetometerReadingChangedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Devices::Sensors::MagnetometerReadingChangedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_MagnetometerReadingChangedEventArgs[] = {
        { "_assign_array_", _assign_array_MagnetometerReadingChangedEventArgs, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_MagnetometerReadingChangedEventArgs), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_MagnetometerReadingChangedEventArgs[] = {
        { "reading", reinterpret_cast<getter>(MagnetometerReadingChangedEventArgs_get_Reading), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_MagnetometerReadingChangedEventArgs[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_MagnetometerReadingChangedEventArgs) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_MagnetometerReadingChangedEventArgs) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_MagnetometerReadingChangedEventArgs) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_MagnetometerReadingChangedEventArgs) },
        { },
    };

    static PyType_Spec type_spec_MagnetometerReadingChangedEventArgs =
    {
        "winrt._winrt_windows_devices_sensors.MagnetometerReadingChangedEventArgs",
        sizeof(py::wrapper::Windows::Devices::Sensors::MagnetometerReadingChangedEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_MagnetometerReadingChangedEventArgs
    };

    // ----- OrientationSensor class --------------------

    static PyObject* _new_OrientationSensor(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Devices::Sensors::OrientationSensor>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Devices::Sensors::OrientationSensor>::type_name);
        return nullptr;
    }

    static void _dealloc_OrientationSensor(py::wrapper::Windows::Devices::Sensors::OrientationSensor* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* OrientationSensor_FromIdAsync(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.Sensors.OrientationSensor", L"FromIdAsync", 1))
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                return py::convert(winrt::Windows::Devices::Sensors::OrientationSensor::FromIdAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* OrientationSensor_GetCurrentReading(py::wrapper::Windows::Devices::Sensors::OrientationSensor* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.Sensors.OrientationSensor", L"GetCurrentReading", 0))
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert(self->obj.GetCurrentReading());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* OrientationSensor_GetDefault(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.Sensors.OrientationSensor", L"GetDefault", 0))
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert(winrt::Windows::Devices::Sensors::OrientationSensor::GetDefault());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 1)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.Sensors.OrientationSensor", L"GetDefault", 1))
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Devices::Sensors::SensorReadingType>(args, 0);

                return py::convert(winrt::Windows::Devices::Sensors::OrientationSensor::GetDefault(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 2)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.Sensors.OrientationSensor", L"GetDefault", 2))
                {
                    py::set_arg_count_version_error(2);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Devices::Sensors::SensorReadingType>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Devices::Sensors::SensorOptimizationGoal>(args, 1);

                return py::convert(winrt::Windows::Devices::Sensors::OrientationSensor::GetDefault(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* OrientationSensor_GetDefaultForRelativeReadings(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.Sensors.OrientationSensor", L"GetDefaultForRelativeReadings", 0))
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert(winrt::Windows::Devices::Sensors::OrientationSensor::GetDefaultForRelativeReadings());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* OrientationSensor_GetDeviceSelector(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.Sensors.OrientationSensor", L"GetDeviceSelector", 1))
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Devices::Sensors::SensorReadingType>(args, 0);

                return py::convert(winrt::Windows::Devices::Sensors::OrientationSensor::GetDeviceSelector(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 2)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.Sensors.OrientationSensor", L"GetDeviceSelector", 2))
                {
                    py::set_arg_count_version_error(2);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Devices::Sensors::SensorReadingType>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Devices::Sensors::SensorOptimizationGoal>(args, 1);

                return py::convert(winrt::Windows::Devices::Sensors::OrientationSensor::GetDeviceSelector(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* OrientationSensor_get_ReportInterval(py::wrapper::Windows::Devices::Sensors::OrientationSensor* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Sensors.OrientationSensor", L"ReportInterval"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.ReportInterval());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int OrientationSensor_put_ReportInterval(py::wrapper::Windows::Devices::Sensors::OrientationSensor* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Sensors.OrientationSensor", L"ReportInterval"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<uint32_t>(arg);

            self->obj.ReportInterval(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* OrientationSensor_get_MinimumReportInterval(py::wrapper::Windows::Devices::Sensors::OrientationSensor* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Sensors.OrientationSensor", L"MinimumReportInterval"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.MinimumReportInterval());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* OrientationSensor_get_ReadingTransform(py::wrapper::Windows::Devices::Sensors::OrientationSensor* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Sensors.OrientationSensor", L"ReadingTransform"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.ReadingTransform());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int OrientationSensor_put_ReadingTransform(py::wrapper::Windows::Devices::Sensors::OrientationSensor* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Sensors.OrientationSensor", L"ReadingTransform"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::Graphics::Display::DisplayOrientations>(arg);

            self->obj.ReadingTransform(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* OrientationSensor_get_ReadingType(py::wrapper::Windows::Devices::Sensors::OrientationSensor* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Sensors.OrientationSensor", L"ReadingType"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.ReadingType());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* OrientationSensor_get_ReportLatency(py::wrapper::Windows::Devices::Sensors::OrientationSensor* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Sensors.OrientationSensor", L"ReportLatency"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.ReportLatency());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int OrientationSensor_put_ReportLatency(py::wrapper::Windows::Devices::Sensors::OrientationSensor* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Sensors.OrientationSensor", L"ReportLatency"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<uint32_t>(arg);

            self->obj.ReportLatency(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* OrientationSensor_get_MaxBatchSize(py::wrapper::Windows::Devices::Sensors::OrientationSensor* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Sensors.OrientationSensor", L"MaxBatchSize"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.MaxBatchSize());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* OrientationSensor_get_DeviceId(py::wrapper::Windows::Devices::Sensors::OrientationSensor* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Sensors.OrientationSensor", L"DeviceId"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.DeviceId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* OrientationSensor_add_ReadingChanged(py::wrapper::Windows::Devices::Sensors::OrientationSensor* self, PyObject* arg) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Devices.Sensors.OrientationSensor", L"ReadingChanged"))
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Devices::Sensors::OrientationSensor, winrt::Windows::Devices::Sensors::OrientationSensorReadingChangedEventArgs>>(arg);

            return py::convert(self->obj.ReadingChanged(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* OrientationSensor_remove_ReadingChanged(py::wrapper::Windows::Devices::Sensors::OrientationSensor* self, PyObject* arg) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Devices.Sensors.OrientationSensor", L"ReadingChanged"))
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.ReadingChanged(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_OrientationSensor(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Devices::Sensors::OrientationSensor>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_OrientationSensor(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Devices::Sensors::OrientationSensor>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_OrientationSensor[] = {
        { "get_current_reading", reinterpret_cast<PyCFunction>(OrientationSensor_GetCurrentReading), METH_VARARGS, nullptr },
        { "add_reading_changed", reinterpret_cast<PyCFunction>(OrientationSensor_add_ReadingChanged), METH_O, nullptr },
        { "remove_reading_changed", reinterpret_cast<PyCFunction>(OrientationSensor_remove_ReadingChanged), METH_O, nullptr },
        { "_assign_array_", _assign_array_OrientationSensor, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_OrientationSensor), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_OrientationSensor[] = {
        { "report_interval", reinterpret_cast<getter>(OrientationSensor_get_ReportInterval), reinterpret_cast<setter>(OrientationSensor_put_ReportInterval), nullptr, nullptr },
        { "minimum_report_interval", reinterpret_cast<getter>(OrientationSensor_get_MinimumReportInterval), nullptr, nullptr, nullptr },
        { "reading_transform", reinterpret_cast<getter>(OrientationSensor_get_ReadingTransform), reinterpret_cast<setter>(OrientationSensor_put_ReadingTransform), nullptr, nullptr },
        { "reading_type", reinterpret_cast<getter>(OrientationSensor_get_ReadingType), nullptr, nullptr, nullptr },
        { "report_latency", reinterpret_cast<getter>(OrientationSensor_get_ReportLatency), reinterpret_cast<setter>(OrientationSensor_put_ReportLatency), nullptr, nullptr },
        { "max_batch_size", reinterpret_cast<getter>(OrientationSensor_get_MaxBatchSize), nullptr, nullptr, nullptr },
        { "device_id", reinterpret_cast<getter>(OrientationSensor_get_DeviceId), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_OrientationSensor[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_OrientationSensor) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_OrientationSensor) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_OrientationSensor) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_OrientationSensor) },
        { },
    };

    static PyType_Spec type_spec_OrientationSensor =
    {
        "winrt._winrt_windows_devices_sensors.OrientationSensor",
        sizeof(py::wrapper::Windows::Devices::Sensors::OrientationSensor),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_OrientationSensor
    };

    static PyGetSetDef getset_OrientationSensor_Static[] = {
        { }
    };

    static PyMethodDef methods_OrientationSensor_Static[] = {
        { "from_id_async", reinterpret_cast<PyCFunction>(OrientationSensor_FromIdAsync), METH_VARARGS, nullptr },
        { "get_default", reinterpret_cast<PyCFunction>(OrientationSensor_GetDefault), METH_VARARGS, nullptr },
        { "get_default_for_relative_readings", reinterpret_cast<PyCFunction>(OrientationSensor_GetDefaultForRelativeReadings), METH_VARARGS, nullptr },
        { "get_device_selector", reinterpret_cast<PyCFunction>(OrientationSensor_GetDeviceSelector), METH_VARARGS, nullptr },
        { }
    };

    static PyType_Slot type_slots_OrientationSensor_Static[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_OrientationSensor_Static) },
        { Py_tp_methods, reinterpret_cast<void*>(methods_OrientationSensor_Static) },
        { }
    };

    static PyType_Spec type_spec_OrientationSensor_Static =
    {
        "winrt._winrt_windows_devices_sensors.OrientationSensor_Static",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT,
        type_slots_OrientationSensor_Static
    };

    // ----- OrientationSensorReading class --------------------

    static PyObject* _new_OrientationSensorReading(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Devices::Sensors::OrientationSensorReading>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Devices::Sensors::OrientationSensorReading>::type_name);
        return nullptr;
    }

    static void _dealloc_OrientationSensorReading(py::wrapper::Windows::Devices::Sensors::OrientationSensorReading* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* OrientationSensorReading_get_Quaternion(py::wrapper::Windows::Devices::Sensors::OrientationSensorReading* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Sensors.OrientationSensorReading", L"Quaternion"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Quaternion());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* OrientationSensorReading_get_RotationMatrix(py::wrapper::Windows::Devices::Sensors::OrientationSensorReading* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Sensors.OrientationSensorReading", L"RotationMatrix"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.RotationMatrix());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* OrientationSensorReading_get_Timestamp(py::wrapper::Windows::Devices::Sensors::OrientationSensorReading* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Sensors.OrientationSensorReading", L"Timestamp"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Timestamp());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* OrientationSensorReading_get_PerformanceCount(py::wrapper::Windows::Devices::Sensors::OrientationSensorReading* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Sensors.OrientationSensorReading", L"PerformanceCount"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.PerformanceCount());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* OrientationSensorReading_get_Properties(py::wrapper::Windows::Devices::Sensors::OrientationSensorReading* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Sensors.OrientationSensorReading", L"Properties"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Properties());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* OrientationSensorReading_get_YawAccuracy(py::wrapper::Windows::Devices::Sensors::OrientationSensorReading* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Sensors.OrientationSensorReading", L"YawAccuracy"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.YawAccuracy());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_OrientationSensorReading(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Devices::Sensors::OrientationSensorReading>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_OrientationSensorReading(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Devices::Sensors::OrientationSensorReading>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_OrientationSensorReading[] = {
        { "_assign_array_", _assign_array_OrientationSensorReading, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_OrientationSensorReading), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_OrientationSensorReading[] = {
        { "quaternion", reinterpret_cast<getter>(OrientationSensorReading_get_Quaternion), nullptr, nullptr, nullptr },
        { "rotation_matrix", reinterpret_cast<getter>(OrientationSensorReading_get_RotationMatrix), nullptr, nullptr, nullptr },
        { "timestamp", reinterpret_cast<getter>(OrientationSensorReading_get_Timestamp), nullptr, nullptr, nullptr },
        { "performance_count", reinterpret_cast<getter>(OrientationSensorReading_get_PerformanceCount), nullptr, nullptr, nullptr },
        { "properties", reinterpret_cast<getter>(OrientationSensorReading_get_Properties), nullptr, nullptr, nullptr },
        { "yaw_accuracy", reinterpret_cast<getter>(OrientationSensorReading_get_YawAccuracy), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_OrientationSensorReading[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_OrientationSensorReading) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_OrientationSensorReading) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_OrientationSensorReading) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_OrientationSensorReading) },
        { },
    };

    static PyType_Spec type_spec_OrientationSensorReading =
    {
        "winrt._winrt_windows_devices_sensors.OrientationSensorReading",
        sizeof(py::wrapper::Windows::Devices::Sensors::OrientationSensorReading),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_OrientationSensorReading
    };

    // ----- OrientationSensorReadingChangedEventArgs class --------------------

    static PyObject* _new_OrientationSensorReadingChangedEventArgs(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Devices::Sensors::OrientationSensorReadingChangedEventArgs>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Devices::Sensors::OrientationSensorReadingChangedEventArgs>::type_name);
        return nullptr;
    }

    static void _dealloc_OrientationSensorReadingChangedEventArgs(py::wrapper::Windows::Devices::Sensors::OrientationSensorReadingChangedEventArgs* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* OrientationSensorReadingChangedEventArgs_get_Reading(py::wrapper::Windows::Devices::Sensors::OrientationSensorReadingChangedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Sensors.OrientationSensorReadingChangedEventArgs", L"Reading"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Reading());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_OrientationSensorReadingChangedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Devices::Sensors::OrientationSensorReadingChangedEventArgs>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_OrientationSensorReadingChangedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Devices::Sensors::OrientationSensorReadingChangedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_OrientationSensorReadingChangedEventArgs[] = {
        { "_assign_array_", _assign_array_OrientationSensorReadingChangedEventArgs, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_OrientationSensorReadingChangedEventArgs), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_OrientationSensorReadingChangedEventArgs[] = {
        { "reading", reinterpret_cast<getter>(OrientationSensorReadingChangedEventArgs_get_Reading), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_OrientationSensorReadingChangedEventArgs[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_OrientationSensorReadingChangedEventArgs) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_OrientationSensorReadingChangedEventArgs) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_OrientationSensorReadingChangedEventArgs) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_OrientationSensorReadingChangedEventArgs) },
        { },
    };

    static PyType_Spec type_spec_OrientationSensorReadingChangedEventArgs =
    {
        "winrt._winrt_windows_devices_sensors.OrientationSensorReadingChangedEventArgs",
        sizeof(py::wrapper::Windows::Devices::Sensors::OrientationSensorReadingChangedEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_OrientationSensorReadingChangedEventArgs
    };

    // ----- Pedometer class --------------------

    static PyObject* _new_Pedometer(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Devices::Sensors::Pedometer>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Devices::Sensors::Pedometer>::type_name);
        return nullptr;
    }

    static void _dealloc_Pedometer(py::wrapper::Windows::Devices::Sensors::Pedometer* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* Pedometer_FromIdAsync(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.Sensors.Pedometer", L"FromIdAsync", 1))
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                return py::convert(winrt::Windows::Devices::Sensors::Pedometer::FromIdAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* Pedometer_GetCurrentReadings(py::wrapper::Windows::Devices::Sensors::Pedometer* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.Sensors.Pedometer", L"GetCurrentReadings", 0))
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert(self->obj.GetCurrentReadings());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* Pedometer_GetDefaultAsync(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.Sensors.Pedometer", L"GetDefaultAsync", 0))
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert(winrt::Windows::Devices::Sensors::Pedometer::GetDefaultAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* Pedometer_GetDeviceSelector(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.Sensors.Pedometer", L"GetDeviceSelector", 0))
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert(winrt::Windows::Devices::Sensors::Pedometer::GetDeviceSelector());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* Pedometer_GetReadingsFromTriggerDetails(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.Sensors.Pedometer", L"GetReadingsFromTriggerDetails", 1))
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Devices::Sensors::SensorDataThresholdTriggerDetails>(args, 0);

                return py::convert(winrt::Windows::Devices::Sensors::Pedometer::GetReadingsFromTriggerDetails(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* Pedometer_GetSystemHistoryAsync(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.Sensors.Pedometer", L"GetSystemHistoryAsync", 1))
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Foundation::DateTime>(args, 0);

                return py::convert(winrt::Windows::Devices::Sensors::Pedometer::GetSystemHistoryAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 2)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.Sensors.Pedometer", L"GetSystemHistoryAsync", 2))
                {
                    py::set_arg_count_version_error(2);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Foundation::DateTime>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Foundation::TimeSpan>(args, 1);

                return py::convert(winrt::Windows::Devices::Sensors::Pedometer::GetSystemHistoryAsync(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* Pedometer_get_ReportInterval(py::wrapper::Windows::Devices::Sensors::Pedometer* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Sensors.Pedometer", L"ReportInterval"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.ReportInterval());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int Pedometer_put_ReportInterval(py::wrapper::Windows::Devices::Sensors::Pedometer* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Sensors.Pedometer", L"ReportInterval"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<uint32_t>(arg);

            self->obj.ReportInterval(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* Pedometer_get_DeviceId(py::wrapper::Windows::Devices::Sensors::Pedometer* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Sensors.Pedometer", L"DeviceId"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.DeviceId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* Pedometer_get_MinimumReportInterval(py::wrapper::Windows::Devices::Sensors::Pedometer* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Sensors.Pedometer", L"MinimumReportInterval"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.MinimumReportInterval());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* Pedometer_get_PowerInMilliwatts(py::wrapper::Windows::Devices::Sensors::Pedometer* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Sensors.Pedometer", L"PowerInMilliwatts"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.PowerInMilliwatts());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* Pedometer_add_ReadingChanged(py::wrapper::Windows::Devices::Sensors::Pedometer* self, PyObject* arg) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Devices.Sensors.Pedometer", L"ReadingChanged"))
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Devices::Sensors::Pedometer, winrt::Windows::Devices::Sensors::PedometerReadingChangedEventArgs>>(arg);

            return py::convert(self->obj.ReadingChanged(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* Pedometer_remove_ReadingChanged(py::wrapper::Windows::Devices::Sensors::Pedometer* self, PyObject* arg) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Devices.Sensors.Pedometer", L"ReadingChanged"))
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.ReadingChanged(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_Pedometer(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Devices::Sensors::Pedometer>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_Pedometer(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Devices::Sensors::Pedometer>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_Pedometer[] = {
        { "get_current_readings", reinterpret_cast<PyCFunction>(Pedometer_GetCurrentReadings), METH_VARARGS, nullptr },
        { "add_reading_changed", reinterpret_cast<PyCFunction>(Pedometer_add_ReadingChanged), METH_O, nullptr },
        { "remove_reading_changed", reinterpret_cast<PyCFunction>(Pedometer_remove_ReadingChanged), METH_O, nullptr },
        { "_assign_array_", _assign_array_Pedometer, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_Pedometer), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_Pedometer[] = {
        { "report_interval", reinterpret_cast<getter>(Pedometer_get_ReportInterval), reinterpret_cast<setter>(Pedometer_put_ReportInterval), nullptr, nullptr },
        { "device_id", reinterpret_cast<getter>(Pedometer_get_DeviceId), nullptr, nullptr, nullptr },
        { "minimum_report_interval", reinterpret_cast<getter>(Pedometer_get_MinimumReportInterval), nullptr, nullptr, nullptr },
        { "power_in_milliwatts", reinterpret_cast<getter>(Pedometer_get_PowerInMilliwatts), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_Pedometer[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_Pedometer) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_Pedometer) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_Pedometer) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_Pedometer) },
        { },
    };

    static PyType_Spec type_spec_Pedometer =
    {
        "winrt._winrt_windows_devices_sensors.Pedometer",
        sizeof(py::wrapper::Windows::Devices::Sensors::Pedometer),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_Pedometer
    };

    static PyGetSetDef getset_Pedometer_Static[] = {
        { }
    };

    static PyMethodDef methods_Pedometer_Static[] = {
        { "from_id_async", reinterpret_cast<PyCFunction>(Pedometer_FromIdAsync), METH_VARARGS, nullptr },
        { "get_default_async", reinterpret_cast<PyCFunction>(Pedometer_GetDefaultAsync), METH_VARARGS, nullptr },
        { "get_device_selector", reinterpret_cast<PyCFunction>(Pedometer_GetDeviceSelector), METH_VARARGS, nullptr },
        { "get_readings_from_trigger_details", reinterpret_cast<PyCFunction>(Pedometer_GetReadingsFromTriggerDetails), METH_VARARGS, nullptr },
        { "get_system_history_async", reinterpret_cast<PyCFunction>(Pedometer_GetSystemHistoryAsync), METH_VARARGS, nullptr },
        { }
    };

    static PyType_Slot type_slots_Pedometer_Static[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_Pedometer_Static) },
        { Py_tp_methods, reinterpret_cast<void*>(methods_Pedometer_Static) },
        { }
    };

    static PyType_Spec type_spec_Pedometer_Static =
    {
        "winrt._winrt_windows_devices_sensors.Pedometer_Static",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT,
        type_slots_Pedometer_Static
    };

    // ----- PedometerDataThreshold class --------------------

    static PyObject* _new_PedometerDataThreshold(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Devices::Sensors::Pedometer>(args, 0);
                auto param1 = py::convert_to<int32_t>(args, 1);

                winrt::Windows::Devices::Sensors::PedometerDataThreshold instance{ param0, param1 };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_PedometerDataThreshold(py::wrapper::Windows::Devices::Sensors::PedometerDataThreshold* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* _assign_array_PedometerDataThreshold(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Devices::Sensors::PedometerDataThreshold>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_PedometerDataThreshold(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Devices::Sensors::PedometerDataThreshold>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_PedometerDataThreshold[] = {
        { "_assign_array_", _assign_array_PedometerDataThreshold, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_PedometerDataThreshold), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_PedometerDataThreshold[] = {
        { }
    };

    static PyType_Slot _type_slots_PedometerDataThreshold[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_PedometerDataThreshold) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_PedometerDataThreshold) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_PedometerDataThreshold) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_PedometerDataThreshold) },
        { },
    };

    static PyType_Spec type_spec_PedometerDataThreshold =
    {
        "winrt._winrt_windows_devices_sensors.PedometerDataThreshold",
        sizeof(py::wrapper::Windows::Devices::Sensors::PedometerDataThreshold),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_PedometerDataThreshold
    };

    // ----- PedometerReading class --------------------

    static PyObject* _new_PedometerReading(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Devices::Sensors::PedometerReading>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Devices::Sensors::PedometerReading>::type_name);
        return nullptr;
    }

    static void _dealloc_PedometerReading(py::wrapper::Windows::Devices::Sensors::PedometerReading* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* PedometerReading_get_CumulativeSteps(py::wrapper::Windows::Devices::Sensors::PedometerReading* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Sensors.PedometerReading", L"CumulativeSteps"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.CumulativeSteps());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PedometerReading_get_CumulativeStepsDuration(py::wrapper::Windows::Devices::Sensors::PedometerReading* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Sensors.PedometerReading", L"CumulativeStepsDuration"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.CumulativeStepsDuration());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PedometerReading_get_StepKind(py::wrapper::Windows::Devices::Sensors::PedometerReading* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Sensors.PedometerReading", L"StepKind"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.StepKind());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PedometerReading_get_Timestamp(py::wrapper::Windows::Devices::Sensors::PedometerReading* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Sensors.PedometerReading", L"Timestamp"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Timestamp());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_PedometerReading(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Devices::Sensors::PedometerReading>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_PedometerReading(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Devices::Sensors::PedometerReading>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_PedometerReading[] = {
        { "_assign_array_", _assign_array_PedometerReading, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_PedometerReading), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_PedometerReading[] = {
        { "cumulative_steps", reinterpret_cast<getter>(PedometerReading_get_CumulativeSteps), nullptr, nullptr, nullptr },
        { "cumulative_steps_duration", reinterpret_cast<getter>(PedometerReading_get_CumulativeStepsDuration), nullptr, nullptr, nullptr },
        { "step_kind", reinterpret_cast<getter>(PedometerReading_get_StepKind), nullptr, nullptr, nullptr },
        { "timestamp", reinterpret_cast<getter>(PedometerReading_get_Timestamp), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_PedometerReading[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_PedometerReading) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_PedometerReading) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_PedometerReading) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_PedometerReading) },
        { },
    };

    static PyType_Spec type_spec_PedometerReading =
    {
        "winrt._winrt_windows_devices_sensors.PedometerReading",
        sizeof(py::wrapper::Windows::Devices::Sensors::PedometerReading),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_PedometerReading
    };

    // ----- PedometerReadingChangedEventArgs class --------------------

    static PyObject* _new_PedometerReadingChangedEventArgs(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Devices::Sensors::PedometerReadingChangedEventArgs>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Devices::Sensors::PedometerReadingChangedEventArgs>::type_name);
        return nullptr;
    }

    static void _dealloc_PedometerReadingChangedEventArgs(py::wrapper::Windows::Devices::Sensors::PedometerReadingChangedEventArgs* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* PedometerReadingChangedEventArgs_get_Reading(py::wrapper::Windows::Devices::Sensors::PedometerReadingChangedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Sensors.PedometerReadingChangedEventArgs", L"Reading"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Reading());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_PedometerReadingChangedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Devices::Sensors::PedometerReadingChangedEventArgs>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_PedometerReadingChangedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Devices::Sensors::PedometerReadingChangedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_PedometerReadingChangedEventArgs[] = {
        { "_assign_array_", _assign_array_PedometerReadingChangedEventArgs, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_PedometerReadingChangedEventArgs), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_PedometerReadingChangedEventArgs[] = {
        { "reading", reinterpret_cast<getter>(PedometerReadingChangedEventArgs_get_Reading), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_PedometerReadingChangedEventArgs[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_PedometerReadingChangedEventArgs) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_PedometerReadingChangedEventArgs) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_PedometerReadingChangedEventArgs) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_PedometerReadingChangedEventArgs) },
        { },
    };

    static PyType_Spec type_spec_PedometerReadingChangedEventArgs =
    {
        "winrt._winrt_windows_devices_sensors.PedometerReadingChangedEventArgs",
        sizeof(py::wrapper::Windows::Devices::Sensors::PedometerReadingChangedEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_PedometerReadingChangedEventArgs
    };

    // ----- ProximitySensor class --------------------

    static PyObject* _new_ProximitySensor(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Devices::Sensors::ProximitySensor>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Devices::Sensors::ProximitySensor>::type_name);
        return nullptr;
    }

    static void _dealloc_ProximitySensor(py::wrapper::Windows::Devices::Sensors::ProximitySensor* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* ProximitySensor_CreateDisplayOnOffController(py::wrapper::Windows::Devices::Sensors::ProximitySensor* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.Sensors.ProximitySensor", L"CreateDisplayOnOffController", 0))
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert(self->obj.CreateDisplayOnOffController());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ProximitySensor_FromId(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.Sensors.ProximitySensor", L"FromId", 1))
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                return py::convert(winrt::Windows::Devices::Sensors::ProximitySensor::FromId(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ProximitySensor_GetCurrentReading(py::wrapper::Windows::Devices::Sensors::ProximitySensor* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.Sensors.ProximitySensor", L"GetCurrentReading", 0))
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert(self->obj.GetCurrentReading());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ProximitySensor_GetDeviceSelector(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.Sensors.ProximitySensor", L"GetDeviceSelector", 0))
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert(winrt::Windows::Devices::Sensors::ProximitySensor::GetDeviceSelector());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ProximitySensor_GetReadingsFromTriggerDetails(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.Sensors.ProximitySensor", L"GetReadingsFromTriggerDetails", 1))
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Devices::Sensors::SensorDataThresholdTriggerDetails>(args, 0);

                return py::convert(winrt::Windows::Devices::Sensors::ProximitySensor::GetReadingsFromTriggerDetails(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ProximitySensor_get_DeviceId(py::wrapper::Windows::Devices::Sensors::ProximitySensor* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Sensors.ProximitySensor", L"DeviceId"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.DeviceId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ProximitySensor_get_MaxDistanceInMillimeters(py::wrapper::Windows::Devices::Sensors::ProximitySensor* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Sensors.ProximitySensor", L"MaxDistanceInMillimeters"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.MaxDistanceInMillimeters());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ProximitySensor_get_MinDistanceInMillimeters(py::wrapper::Windows::Devices::Sensors::ProximitySensor* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Sensors.ProximitySensor", L"MinDistanceInMillimeters"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.MinDistanceInMillimeters());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ProximitySensor_add_ReadingChanged(py::wrapper::Windows::Devices::Sensors::ProximitySensor* self, PyObject* arg) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Devices.Sensors.ProximitySensor", L"ReadingChanged"))
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Devices::Sensors::ProximitySensor, winrt::Windows::Devices::Sensors::ProximitySensorReadingChangedEventArgs>>(arg);

            return py::convert(self->obj.ReadingChanged(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ProximitySensor_remove_ReadingChanged(py::wrapper::Windows::Devices::Sensors::ProximitySensor* self, PyObject* arg) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Devices.Sensors.ProximitySensor", L"ReadingChanged"))
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.ReadingChanged(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_ProximitySensor(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Devices::Sensors::ProximitySensor>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_ProximitySensor(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Devices::Sensors::ProximitySensor>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_ProximitySensor[] = {
        { "create_display_on_off_controller", reinterpret_cast<PyCFunction>(ProximitySensor_CreateDisplayOnOffController), METH_VARARGS, nullptr },
        { "get_current_reading", reinterpret_cast<PyCFunction>(ProximitySensor_GetCurrentReading), METH_VARARGS, nullptr },
        { "add_reading_changed", reinterpret_cast<PyCFunction>(ProximitySensor_add_ReadingChanged), METH_O, nullptr },
        { "remove_reading_changed", reinterpret_cast<PyCFunction>(ProximitySensor_remove_ReadingChanged), METH_O, nullptr },
        { "_assign_array_", _assign_array_ProximitySensor, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_ProximitySensor), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_ProximitySensor[] = {
        { "device_id", reinterpret_cast<getter>(ProximitySensor_get_DeviceId), nullptr, nullptr, nullptr },
        { "max_distance_in_millimeters", reinterpret_cast<getter>(ProximitySensor_get_MaxDistanceInMillimeters), nullptr, nullptr, nullptr },
        { "min_distance_in_millimeters", reinterpret_cast<getter>(ProximitySensor_get_MinDistanceInMillimeters), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_ProximitySensor[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_ProximitySensor) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_ProximitySensor) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_ProximitySensor) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_ProximitySensor) },
        { },
    };

    static PyType_Spec type_spec_ProximitySensor =
    {
        "winrt._winrt_windows_devices_sensors.ProximitySensor",
        sizeof(py::wrapper::Windows::Devices::Sensors::ProximitySensor),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_ProximitySensor
    };

    static PyGetSetDef getset_ProximitySensor_Static[] = {
        { }
    };

    static PyMethodDef methods_ProximitySensor_Static[] = {
        { "from_id", reinterpret_cast<PyCFunction>(ProximitySensor_FromId), METH_VARARGS, nullptr },
        { "get_device_selector", reinterpret_cast<PyCFunction>(ProximitySensor_GetDeviceSelector), METH_VARARGS, nullptr },
        { "get_readings_from_trigger_details", reinterpret_cast<PyCFunction>(ProximitySensor_GetReadingsFromTriggerDetails), METH_VARARGS, nullptr },
        { }
    };

    static PyType_Slot type_slots_ProximitySensor_Static[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_ProximitySensor_Static) },
        { Py_tp_methods, reinterpret_cast<void*>(methods_ProximitySensor_Static) },
        { }
    };

    static PyType_Spec type_spec_ProximitySensor_Static =
    {
        "winrt._winrt_windows_devices_sensors.ProximitySensor_Static",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT,
        type_slots_ProximitySensor_Static
    };

    // ----- ProximitySensorDataThreshold class --------------------

    static PyObject* _new_ProximitySensorDataThreshold(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Devices::Sensors::ProximitySensor>(args, 0);

                winrt::Windows::Devices::Sensors::ProximitySensorDataThreshold instance{ param0 };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_ProximitySensorDataThreshold(py::wrapper::Windows::Devices::Sensors::ProximitySensorDataThreshold* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* _assign_array_ProximitySensorDataThreshold(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Devices::Sensors::ProximitySensorDataThreshold>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_ProximitySensorDataThreshold(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Devices::Sensors::ProximitySensorDataThreshold>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_ProximitySensorDataThreshold[] = {
        { "_assign_array_", _assign_array_ProximitySensorDataThreshold, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_ProximitySensorDataThreshold), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_ProximitySensorDataThreshold[] = {
        { }
    };

    static PyType_Slot _type_slots_ProximitySensorDataThreshold[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_ProximitySensorDataThreshold) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_ProximitySensorDataThreshold) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_ProximitySensorDataThreshold) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_ProximitySensorDataThreshold) },
        { },
    };

    static PyType_Spec type_spec_ProximitySensorDataThreshold =
    {
        "winrt._winrt_windows_devices_sensors.ProximitySensorDataThreshold",
        sizeof(py::wrapper::Windows::Devices::Sensors::ProximitySensorDataThreshold),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_ProximitySensorDataThreshold
    };

    // ----- ProximitySensorDisplayOnOffController class --------------------

    static PyObject* _new_ProximitySensorDisplayOnOffController(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Devices::Sensors::ProximitySensorDisplayOnOffController>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Devices::Sensors::ProximitySensorDisplayOnOffController>::type_name);
        return nullptr;
    }

    static void _dealloc_ProximitySensorDisplayOnOffController(py::wrapper::Windows::Devices::Sensors::ProximitySensorDisplayOnOffController* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* ProximitySensorDisplayOnOffController_Close(py::wrapper::Windows::Devices::Sensors::ProximitySensorDisplayOnOffController* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.Sensors.ProximitySensorDisplayOnOffController", L"Close", 0))
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                self->obj.Close();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* _assign_array_ProximitySensorDisplayOnOffController(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Devices::Sensors::ProximitySensorDisplayOnOffController>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_ProximitySensorDisplayOnOffController(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Devices::Sensors::ProximitySensorDisplayOnOffController>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _enter_ProximitySensorDisplayOnOffController(py::wrapper::Windows::Devices::Sensors::ProximitySensorDisplayOnOffController* self, PyObject* /*unused*/) noexcept
    {
        return Py_NewRef(self);
    }

    static PyObject* _exit_ProximitySensorDisplayOnOffController(py::wrapper::Windows::Devices::Sensors::ProximitySensorDisplayOnOffController* self, PyObject* /*unused*/) noexcept
    {
        try
        {
            self->obj.Close();
            Py_RETURN_FALSE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_ProximitySensorDisplayOnOffController[] = {
        { "close", reinterpret_cast<PyCFunction>(ProximitySensorDisplayOnOffController_Close), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_ProximitySensorDisplayOnOffController, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_ProximitySensorDisplayOnOffController), METH_O | METH_STATIC, nullptr },
        { "__enter__", reinterpret_cast<PyCFunction>(_enter_ProximitySensorDisplayOnOffController), METH_NOARGS, nullptr },
        { "__exit__",  reinterpret_cast<PyCFunction>(_exit_ProximitySensorDisplayOnOffController), METH_VARARGS, nullptr },
        { }
    };

    static PyGetSetDef _getset_ProximitySensorDisplayOnOffController[] = {
        { }
    };

    static PyType_Slot _type_slots_ProximitySensorDisplayOnOffController[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_ProximitySensorDisplayOnOffController) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_ProximitySensorDisplayOnOffController) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_ProximitySensorDisplayOnOffController) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_ProximitySensorDisplayOnOffController) },
        { },
    };

    static PyType_Spec type_spec_ProximitySensorDisplayOnOffController =
    {
        "winrt._winrt_windows_devices_sensors.ProximitySensorDisplayOnOffController",
        sizeof(py::wrapper::Windows::Devices::Sensors::ProximitySensorDisplayOnOffController),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_ProximitySensorDisplayOnOffController
    };

    // ----- ProximitySensorReading class --------------------

    static PyObject* _new_ProximitySensorReading(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Devices::Sensors::ProximitySensorReading>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Devices::Sensors::ProximitySensorReading>::type_name);
        return nullptr;
    }

    static void _dealloc_ProximitySensorReading(py::wrapper::Windows::Devices::Sensors::ProximitySensorReading* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* ProximitySensorReading_get_DistanceInMillimeters(py::wrapper::Windows::Devices::Sensors::ProximitySensorReading* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Sensors.ProximitySensorReading", L"DistanceInMillimeters"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.DistanceInMillimeters());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ProximitySensorReading_get_IsDetected(py::wrapper::Windows::Devices::Sensors::ProximitySensorReading* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Sensors.ProximitySensorReading", L"IsDetected"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.IsDetected());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ProximitySensorReading_get_Timestamp(py::wrapper::Windows::Devices::Sensors::ProximitySensorReading* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Sensors.ProximitySensorReading", L"Timestamp"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Timestamp());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_ProximitySensorReading(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Devices::Sensors::ProximitySensorReading>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_ProximitySensorReading(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Devices::Sensors::ProximitySensorReading>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_ProximitySensorReading[] = {
        { "_assign_array_", _assign_array_ProximitySensorReading, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_ProximitySensorReading), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_ProximitySensorReading[] = {
        { "distance_in_millimeters", reinterpret_cast<getter>(ProximitySensorReading_get_DistanceInMillimeters), nullptr, nullptr, nullptr },
        { "is_detected", reinterpret_cast<getter>(ProximitySensorReading_get_IsDetected), nullptr, nullptr, nullptr },
        { "timestamp", reinterpret_cast<getter>(ProximitySensorReading_get_Timestamp), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_ProximitySensorReading[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_ProximitySensorReading) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_ProximitySensorReading) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_ProximitySensorReading) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_ProximitySensorReading) },
        { },
    };

    static PyType_Spec type_spec_ProximitySensorReading =
    {
        "winrt._winrt_windows_devices_sensors.ProximitySensorReading",
        sizeof(py::wrapper::Windows::Devices::Sensors::ProximitySensorReading),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_ProximitySensorReading
    };

    // ----- ProximitySensorReadingChangedEventArgs class --------------------

    static PyObject* _new_ProximitySensorReadingChangedEventArgs(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Devices::Sensors::ProximitySensorReadingChangedEventArgs>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Devices::Sensors::ProximitySensorReadingChangedEventArgs>::type_name);
        return nullptr;
    }

    static void _dealloc_ProximitySensorReadingChangedEventArgs(py::wrapper::Windows::Devices::Sensors::ProximitySensorReadingChangedEventArgs* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* ProximitySensorReadingChangedEventArgs_get_Reading(py::wrapper::Windows::Devices::Sensors::ProximitySensorReadingChangedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Sensors.ProximitySensorReadingChangedEventArgs", L"Reading"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Reading());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_ProximitySensorReadingChangedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Devices::Sensors::ProximitySensorReadingChangedEventArgs>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_ProximitySensorReadingChangedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Devices::Sensors::ProximitySensorReadingChangedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_ProximitySensorReadingChangedEventArgs[] = {
        { "_assign_array_", _assign_array_ProximitySensorReadingChangedEventArgs, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_ProximitySensorReadingChangedEventArgs), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_ProximitySensorReadingChangedEventArgs[] = {
        { "reading", reinterpret_cast<getter>(ProximitySensorReadingChangedEventArgs_get_Reading), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_ProximitySensorReadingChangedEventArgs[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_ProximitySensorReadingChangedEventArgs) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_ProximitySensorReadingChangedEventArgs) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_ProximitySensorReadingChangedEventArgs) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_ProximitySensorReadingChangedEventArgs) },
        { },
    };

    static PyType_Spec type_spec_ProximitySensorReadingChangedEventArgs =
    {
        "winrt._winrt_windows_devices_sensors.ProximitySensorReadingChangedEventArgs",
        sizeof(py::wrapper::Windows::Devices::Sensors::ProximitySensorReadingChangedEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_ProximitySensorReadingChangedEventArgs
    };

    // ----- SensorDataThresholdTriggerDetails class --------------------

    static PyObject* _new_SensorDataThresholdTriggerDetails(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Devices::Sensors::SensorDataThresholdTriggerDetails>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Devices::Sensors::SensorDataThresholdTriggerDetails>::type_name);
        return nullptr;
    }

    static void _dealloc_SensorDataThresholdTriggerDetails(py::wrapper::Windows::Devices::Sensors::SensorDataThresholdTriggerDetails* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* SensorDataThresholdTriggerDetails_get_DeviceId(py::wrapper::Windows::Devices::Sensors::SensorDataThresholdTriggerDetails* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Sensors.SensorDataThresholdTriggerDetails", L"DeviceId"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.DeviceId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SensorDataThresholdTriggerDetails_get_SensorType(py::wrapper::Windows::Devices::Sensors::SensorDataThresholdTriggerDetails* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Sensors.SensorDataThresholdTriggerDetails", L"SensorType"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.SensorType());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_SensorDataThresholdTriggerDetails(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Devices::Sensors::SensorDataThresholdTriggerDetails>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_SensorDataThresholdTriggerDetails(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Devices::Sensors::SensorDataThresholdTriggerDetails>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_SensorDataThresholdTriggerDetails[] = {
        { "_assign_array_", _assign_array_SensorDataThresholdTriggerDetails, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_SensorDataThresholdTriggerDetails), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_SensorDataThresholdTriggerDetails[] = {
        { "device_id", reinterpret_cast<getter>(SensorDataThresholdTriggerDetails_get_DeviceId), nullptr, nullptr, nullptr },
        { "sensor_type", reinterpret_cast<getter>(SensorDataThresholdTriggerDetails_get_SensorType), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_SensorDataThresholdTriggerDetails[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_SensorDataThresholdTriggerDetails) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_SensorDataThresholdTriggerDetails) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_SensorDataThresholdTriggerDetails) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_SensorDataThresholdTriggerDetails) },
        { },
    };

    static PyType_Spec type_spec_SensorDataThresholdTriggerDetails =
    {
        "winrt._winrt_windows_devices_sensors.SensorDataThresholdTriggerDetails",
        sizeof(py::wrapper::Windows::Devices::Sensors::SensorDataThresholdTriggerDetails),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_SensorDataThresholdTriggerDetails
    };

    // ----- SensorQuaternion class --------------------

    static PyObject* _new_SensorQuaternion(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Devices::Sensors::SensorQuaternion>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Devices::Sensors::SensorQuaternion>::type_name);
        return nullptr;
    }

    static void _dealloc_SensorQuaternion(py::wrapper::Windows::Devices::Sensors::SensorQuaternion* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* SensorQuaternion_get_W(py::wrapper::Windows::Devices::Sensors::SensorQuaternion* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Sensors.SensorQuaternion", L"W"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.W());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SensorQuaternion_get_X(py::wrapper::Windows::Devices::Sensors::SensorQuaternion* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Sensors.SensorQuaternion", L"X"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.X());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SensorQuaternion_get_Y(py::wrapper::Windows::Devices::Sensors::SensorQuaternion* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Sensors.SensorQuaternion", L"Y"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Y());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SensorQuaternion_get_Z(py::wrapper::Windows::Devices::Sensors::SensorQuaternion* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Sensors.SensorQuaternion", L"Z"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Z());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_SensorQuaternion(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Devices::Sensors::SensorQuaternion>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_SensorQuaternion(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Devices::Sensors::SensorQuaternion>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_SensorQuaternion[] = {
        { "_assign_array_", _assign_array_SensorQuaternion, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_SensorQuaternion), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_SensorQuaternion[] = {
        { "w", reinterpret_cast<getter>(SensorQuaternion_get_W), nullptr, nullptr, nullptr },
        { "x", reinterpret_cast<getter>(SensorQuaternion_get_X), nullptr, nullptr, nullptr },
        { "y", reinterpret_cast<getter>(SensorQuaternion_get_Y), nullptr, nullptr, nullptr },
        { "z", reinterpret_cast<getter>(SensorQuaternion_get_Z), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_SensorQuaternion[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_SensorQuaternion) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_SensorQuaternion) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_SensorQuaternion) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_SensorQuaternion) },
        { },
    };

    static PyType_Spec type_spec_SensorQuaternion =
    {
        "winrt._winrt_windows_devices_sensors.SensorQuaternion",
        sizeof(py::wrapper::Windows::Devices::Sensors::SensorQuaternion),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_SensorQuaternion
    };

    // ----- SensorRotationMatrix class --------------------

    static PyObject* _new_SensorRotationMatrix(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Devices::Sensors::SensorRotationMatrix>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Devices::Sensors::SensorRotationMatrix>::type_name);
        return nullptr;
    }

    static void _dealloc_SensorRotationMatrix(py::wrapper::Windows::Devices::Sensors::SensorRotationMatrix* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* SensorRotationMatrix_get_M11(py::wrapper::Windows::Devices::Sensors::SensorRotationMatrix* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Sensors.SensorRotationMatrix", L"M11"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.M11());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SensorRotationMatrix_get_M12(py::wrapper::Windows::Devices::Sensors::SensorRotationMatrix* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Sensors.SensorRotationMatrix", L"M12"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.M12());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SensorRotationMatrix_get_M13(py::wrapper::Windows::Devices::Sensors::SensorRotationMatrix* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Sensors.SensorRotationMatrix", L"M13"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.M13());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SensorRotationMatrix_get_M21(py::wrapper::Windows::Devices::Sensors::SensorRotationMatrix* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Sensors.SensorRotationMatrix", L"M21"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.M21());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SensorRotationMatrix_get_M22(py::wrapper::Windows::Devices::Sensors::SensorRotationMatrix* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Sensors.SensorRotationMatrix", L"M22"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.M22());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SensorRotationMatrix_get_M23(py::wrapper::Windows::Devices::Sensors::SensorRotationMatrix* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Sensors.SensorRotationMatrix", L"M23"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.M23());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SensorRotationMatrix_get_M31(py::wrapper::Windows::Devices::Sensors::SensorRotationMatrix* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Sensors.SensorRotationMatrix", L"M31"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.M31());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SensorRotationMatrix_get_M32(py::wrapper::Windows::Devices::Sensors::SensorRotationMatrix* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Sensors.SensorRotationMatrix", L"M32"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.M32());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SensorRotationMatrix_get_M33(py::wrapper::Windows::Devices::Sensors::SensorRotationMatrix* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Sensors.SensorRotationMatrix", L"M33"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.M33());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_SensorRotationMatrix(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Devices::Sensors::SensorRotationMatrix>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_SensorRotationMatrix(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Devices::Sensors::SensorRotationMatrix>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_SensorRotationMatrix[] = {
        { "_assign_array_", _assign_array_SensorRotationMatrix, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_SensorRotationMatrix), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_SensorRotationMatrix[] = {
        { "m11", reinterpret_cast<getter>(SensorRotationMatrix_get_M11), nullptr, nullptr, nullptr },
        { "m12", reinterpret_cast<getter>(SensorRotationMatrix_get_M12), nullptr, nullptr, nullptr },
        { "m13", reinterpret_cast<getter>(SensorRotationMatrix_get_M13), nullptr, nullptr, nullptr },
        { "m21", reinterpret_cast<getter>(SensorRotationMatrix_get_M21), nullptr, nullptr, nullptr },
        { "m22", reinterpret_cast<getter>(SensorRotationMatrix_get_M22), nullptr, nullptr, nullptr },
        { "m23", reinterpret_cast<getter>(SensorRotationMatrix_get_M23), nullptr, nullptr, nullptr },
        { "m31", reinterpret_cast<getter>(SensorRotationMatrix_get_M31), nullptr, nullptr, nullptr },
        { "m32", reinterpret_cast<getter>(SensorRotationMatrix_get_M32), nullptr, nullptr, nullptr },
        { "m33", reinterpret_cast<getter>(SensorRotationMatrix_get_M33), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_SensorRotationMatrix[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_SensorRotationMatrix) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_SensorRotationMatrix) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_SensorRotationMatrix) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_SensorRotationMatrix) },
        { },
    };

    static PyType_Spec type_spec_SensorRotationMatrix =
    {
        "winrt._winrt_windows_devices_sensors.SensorRotationMatrix",
        sizeof(py::wrapper::Windows::Devices::Sensors::SensorRotationMatrix),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_SensorRotationMatrix
    };

    // ----- SimpleOrientationSensor class --------------------

    static PyObject* _new_SimpleOrientationSensor(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Devices::Sensors::SimpleOrientationSensor>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Devices::Sensors::SimpleOrientationSensor>::type_name);
        return nullptr;
    }

    static void _dealloc_SimpleOrientationSensor(py::wrapper::Windows::Devices::Sensors::SimpleOrientationSensor* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* SimpleOrientationSensor_FromIdAsync(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.Sensors.SimpleOrientationSensor", L"FromIdAsync", 1))
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                return py::convert(winrt::Windows::Devices::Sensors::SimpleOrientationSensor::FromIdAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* SimpleOrientationSensor_GetCurrentOrientation(py::wrapper::Windows::Devices::Sensors::SimpleOrientationSensor* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.Sensors.SimpleOrientationSensor", L"GetCurrentOrientation", 0))
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert(self->obj.GetCurrentOrientation());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* SimpleOrientationSensor_GetDefault(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.Sensors.SimpleOrientationSensor", L"GetDefault", 0))
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert(winrt::Windows::Devices::Sensors::SimpleOrientationSensor::GetDefault());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* SimpleOrientationSensor_GetDeviceSelector(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.Sensors.SimpleOrientationSensor", L"GetDeviceSelector", 0))
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert(winrt::Windows::Devices::Sensors::SimpleOrientationSensor::GetDeviceSelector());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* SimpleOrientationSensor_get_ReadingTransform(py::wrapper::Windows::Devices::Sensors::SimpleOrientationSensor* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Sensors.SimpleOrientationSensor", L"ReadingTransform"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.ReadingTransform());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int SimpleOrientationSensor_put_ReadingTransform(py::wrapper::Windows::Devices::Sensors::SimpleOrientationSensor* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Sensors.SimpleOrientationSensor", L"ReadingTransform"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::Graphics::Display::DisplayOrientations>(arg);

            self->obj.ReadingTransform(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* SimpleOrientationSensor_get_DeviceId(py::wrapper::Windows::Devices::Sensors::SimpleOrientationSensor* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Sensors.SimpleOrientationSensor", L"DeviceId"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.DeviceId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SimpleOrientationSensor_add_OrientationChanged(py::wrapper::Windows::Devices::Sensors::SimpleOrientationSensor* self, PyObject* arg) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Devices.Sensors.SimpleOrientationSensor", L"OrientationChanged"))
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Devices::Sensors::SimpleOrientationSensor, winrt::Windows::Devices::Sensors::SimpleOrientationSensorOrientationChangedEventArgs>>(arg);

            return py::convert(self->obj.OrientationChanged(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SimpleOrientationSensor_remove_OrientationChanged(py::wrapper::Windows::Devices::Sensors::SimpleOrientationSensor* self, PyObject* arg) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Devices.Sensors.SimpleOrientationSensor", L"OrientationChanged"))
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.OrientationChanged(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_SimpleOrientationSensor(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Devices::Sensors::SimpleOrientationSensor>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_SimpleOrientationSensor(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Devices::Sensors::SimpleOrientationSensor>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_SimpleOrientationSensor[] = {
        { "get_current_orientation", reinterpret_cast<PyCFunction>(SimpleOrientationSensor_GetCurrentOrientation), METH_VARARGS, nullptr },
        { "add_orientation_changed", reinterpret_cast<PyCFunction>(SimpleOrientationSensor_add_OrientationChanged), METH_O, nullptr },
        { "remove_orientation_changed", reinterpret_cast<PyCFunction>(SimpleOrientationSensor_remove_OrientationChanged), METH_O, nullptr },
        { "_assign_array_", _assign_array_SimpleOrientationSensor, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_SimpleOrientationSensor), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_SimpleOrientationSensor[] = {
        { "reading_transform", reinterpret_cast<getter>(SimpleOrientationSensor_get_ReadingTransform), reinterpret_cast<setter>(SimpleOrientationSensor_put_ReadingTransform), nullptr, nullptr },
        { "device_id", reinterpret_cast<getter>(SimpleOrientationSensor_get_DeviceId), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_SimpleOrientationSensor[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_SimpleOrientationSensor) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_SimpleOrientationSensor) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_SimpleOrientationSensor) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_SimpleOrientationSensor) },
        { },
    };

    static PyType_Spec type_spec_SimpleOrientationSensor =
    {
        "winrt._winrt_windows_devices_sensors.SimpleOrientationSensor",
        sizeof(py::wrapper::Windows::Devices::Sensors::SimpleOrientationSensor),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_SimpleOrientationSensor
    };

    static PyGetSetDef getset_SimpleOrientationSensor_Static[] = {
        { }
    };

    static PyMethodDef methods_SimpleOrientationSensor_Static[] = {
        { "from_id_async", reinterpret_cast<PyCFunction>(SimpleOrientationSensor_FromIdAsync), METH_VARARGS, nullptr },
        { "get_default", reinterpret_cast<PyCFunction>(SimpleOrientationSensor_GetDefault), METH_VARARGS, nullptr },
        { "get_device_selector", reinterpret_cast<PyCFunction>(SimpleOrientationSensor_GetDeviceSelector), METH_VARARGS, nullptr },
        { }
    };

    static PyType_Slot type_slots_SimpleOrientationSensor_Static[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_SimpleOrientationSensor_Static) },
        { Py_tp_methods, reinterpret_cast<void*>(methods_SimpleOrientationSensor_Static) },
        { }
    };

    static PyType_Spec type_spec_SimpleOrientationSensor_Static =
    {
        "winrt._winrt_windows_devices_sensors.SimpleOrientationSensor_Static",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT,
        type_slots_SimpleOrientationSensor_Static
    };

    // ----- SimpleOrientationSensorOrientationChangedEventArgs class --------------------

    static PyObject* _new_SimpleOrientationSensorOrientationChangedEventArgs(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Devices::Sensors::SimpleOrientationSensorOrientationChangedEventArgs>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Devices::Sensors::SimpleOrientationSensorOrientationChangedEventArgs>::type_name);
        return nullptr;
    }

    static void _dealloc_SimpleOrientationSensorOrientationChangedEventArgs(py::wrapper::Windows::Devices::Sensors::SimpleOrientationSensorOrientationChangedEventArgs* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* SimpleOrientationSensorOrientationChangedEventArgs_get_Orientation(py::wrapper::Windows::Devices::Sensors::SimpleOrientationSensorOrientationChangedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Sensors.SimpleOrientationSensorOrientationChangedEventArgs", L"Orientation"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Orientation());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SimpleOrientationSensorOrientationChangedEventArgs_get_Timestamp(py::wrapper::Windows::Devices::Sensors::SimpleOrientationSensorOrientationChangedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Sensors.SimpleOrientationSensorOrientationChangedEventArgs", L"Timestamp"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Timestamp());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_SimpleOrientationSensorOrientationChangedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Devices::Sensors::SimpleOrientationSensorOrientationChangedEventArgs>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_SimpleOrientationSensorOrientationChangedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Devices::Sensors::SimpleOrientationSensorOrientationChangedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_SimpleOrientationSensorOrientationChangedEventArgs[] = {
        { "_assign_array_", _assign_array_SimpleOrientationSensorOrientationChangedEventArgs, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_SimpleOrientationSensorOrientationChangedEventArgs), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_SimpleOrientationSensorOrientationChangedEventArgs[] = {
        { "orientation", reinterpret_cast<getter>(SimpleOrientationSensorOrientationChangedEventArgs_get_Orientation), nullptr, nullptr, nullptr },
        { "timestamp", reinterpret_cast<getter>(SimpleOrientationSensorOrientationChangedEventArgs_get_Timestamp), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_SimpleOrientationSensorOrientationChangedEventArgs[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_SimpleOrientationSensorOrientationChangedEventArgs) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_SimpleOrientationSensorOrientationChangedEventArgs) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_SimpleOrientationSensorOrientationChangedEventArgs) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_SimpleOrientationSensorOrientationChangedEventArgs) },
        { },
    };

    static PyType_Spec type_spec_SimpleOrientationSensorOrientationChangedEventArgs =
    {
        "winrt._winrt_windows_devices_sensors.SimpleOrientationSensorOrientationChangedEventArgs",
        sizeof(py::wrapper::Windows::Devices::Sensors::SimpleOrientationSensorOrientationChangedEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_SimpleOrientationSensorOrientationChangedEventArgs
    };

    // ----- WakeOnApproachOptions class --------------------

    static PyObject* _new_WakeOnApproachOptions(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Devices::Sensors::WakeOnApproachOptions>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Devices::Sensors::WakeOnApproachOptions>::type_name);
        return nullptr;
    }

    static void _dealloc_WakeOnApproachOptions(py::wrapper::Windows::Devices::Sensors::WakeOnApproachOptions* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* WakeOnApproachOptions_get_DisableWhenBatterySaverOn(py::wrapper::Windows::Devices::Sensors::WakeOnApproachOptions* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Sensors.WakeOnApproachOptions", L"DisableWhenBatterySaverOn"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.DisableWhenBatterySaverOn());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int WakeOnApproachOptions_put_DisableWhenBatterySaverOn(py::wrapper::Windows::Devices::Sensors::WakeOnApproachOptions* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Sensors.WakeOnApproachOptions", L"DisableWhenBatterySaverOn"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<bool>(arg);

            self->obj.DisableWhenBatterySaverOn(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* WakeOnApproachOptions_get_AllowWhenExternalDisplayConnected(py::wrapper::Windows::Devices::Sensors::WakeOnApproachOptions* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Sensors.WakeOnApproachOptions", L"AllowWhenExternalDisplayConnected"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.AllowWhenExternalDisplayConnected());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int WakeOnApproachOptions_put_AllowWhenExternalDisplayConnected(py::wrapper::Windows::Devices::Sensors::WakeOnApproachOptions* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Sensors.WakeOnApproachOptions", L"AllowWhenExternalDisplayConnected"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<bool>(arg);

            self->obj.AllowWhenExternalDisplayConnected(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* _assign_array_WakeOnApproachOptions(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Devices::Sensors::WakeOnApproachOptions>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_WakeOnApproachOptions(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Devices::Sensors::WakeOnApproachOptions>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_WakeOnApproachOptions[] = {
        { "_assign_array_", _assign_array_WakeOnApproachOptions, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_WakeOnApproachOptions), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_WakeOnApproachOptions[] = {
        { "disable_when_battery_saver_on", reinterpret_cast<getter>(WakeOnApproachOptions_get_DisableWhenBatterySaverOn), reinterpret_cast<setter>(WakeOnApproachOptions_put_DisableWhenBatterySaverOn), nullptr, nullptr },
        { "allow_when_external_display_connected", reinterpret_cast<getter>(WakeOnApproachOptions_get_AllowWhenExternalDisplayConnected), reinterpret_cast<setter>(WakeOnApproachOptions_put_AllowWhenExternalDisplayConnected), nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_WakeOnApproachOptions[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_WakeOnApproachOptions) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_WakeOnApproachOptions) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_WakeOnApproachOptions) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_WakeOnApproachOptions) },
        { },
    };

    static PyType_Spec type_spec_WakeOnApproachOptions =
    {
        "winrt._winrt_windows_devices_sensors.WakeOnApproachOptions",
        sizeof(py::wrapper::Windows::Devices::Sensors::WakeOnApproachOptions),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_WakeOnApproachOptions
    };

    // ----- IHumanPresenceSensorExtension interface --------------------

    static PyObject* _new_IHumanPresenceSensorExtension(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Devices::Sensors::IHumanPresenceSensorExtension>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Devices::Sensors::IHumanPresenceSensorExtension>::type_name);
        return nullptr;
    }

    static void _dealloc_IHumanPresenceSensorExtension(py::wrapper::Windows::Devices::Sensors::IHumanPresenceSensorExtension* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* IHumanPresenceSensorExtension_Initialize(py::wrapper::Windows::Devices::Sensors::IHumanPresenceSensorExtension* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.Sensors.IHumanPresenceSensorExtension", L"Initialize", 1))
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                self->obj.Initialize(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* IHumanPresenceSensorExtension_ProcessReading(py::wrapper::Windows::Devices::Sensors::IHumanPresenceSensorExtension* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.Sensors.IHumanPresenceSensorExtension", L"ProcessReading", 1))
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Devices::Sensors::HumanPresenceSensorReading>(args, 0);

                return py::convert(self->obj.ProcessReading(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* IHumanPresenceSensorExtension_ProcessReadingTimeoutExpired(py::wrapper::Windows::Devices::Sensors::IHumanPresenceSensorExtension* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.Sensors.IHumanPresenceSensorExtension", L"ProcessReadingTimeoutExpired", 1))
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Devices::Sensors::HumanPresenceSensorReading>(args, 0);

                self->obj.ProcessReadingTimeoutExpired(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* IHumanPresenceSensorExtension_Reset(py::wrapper::Windows::Devices::Sensors::IHumanPresenceSensorExtension* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.Sensors.IHumanPresenceSensorExtension", L"Reset", 0))
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                self->obj.Reset();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* IHumanPresenceSensorExtension_Start(py::wrapper::Windows::Devices::Sensors::IHumanPresenceSensorExtension* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.Sensors.IHumanPresenceSensorExtension", L"Start", 0))
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                self->obj.Start();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* IHumanPresenceSensorExtension_Stop(py::wrapper::Windows::Devices::Sensors::IHumanPresenceSensorExtension* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.Sensors.IHumanPresenceSensorExtension", L"Stop", 0))
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                self->obj.Stop();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* IHumanPresenceSensorExtension_Uninitialize(py::wrapper::Windows::Devices::Sensors::IHumanPresenceSensorExtension* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.Sensors.IHumanPresenceSensorExtension", L"Uninitialize", 0))
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                self->obj.Uninitialize();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* _assign_array_IHumanPresenceSensorExtension(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Devices::Sensors::IHumanPresenceSensorExtension>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_IHumanPresenceSensorExtension(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Devices::Sensors::IHumanPresenceSensorExtension>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_IHumanPresenceSensorExtension[] = {
        { "initialize", reinterpret_cast<PyCFunction>(IHumanPresenceSensorExtension_Initialize), METH_VARARGS, nullptr },
        { "process_reading", reinterpret_cast<PyCFunction>(IHumanPresenceSensorExtension_ProcessReading), METH_VARARGS, nullptr },
        { "process_reading_timeout_expired", reinterpret_cast<PyCFunction>(IHumanPresenceSensorExtension_ProcessReadingTimeoutExpired), METH_VARARGS, nullptr },
        { "reset", reinterpret_cast<PyCFunction>(IHumanPresenceSensorExtension_Reset), METH_VARARGS, nullptr },
        { "start", reinterpret_cast<PyCFunction>(IHumanPresenceSensorExtension_Start), METH_VARARGS, nullptr },
        { "stop", reinterpret_cast<PyCFunction>(IHumanPresenceSensorExtension_Stop), METH_VARARGS, nullptr },
        { "uninitialize", reinterpret_cast<PyCFunction>(IHumanPresenceSensorExtension_Uninitialize), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_IHumanPresenceSensorExtension, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_IHumanPresenceSensorExtension), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_IHumanPresenceSensorExtension[] = {
        { }
    };

    static PyType_Slot _type_slots_IHumanPresenceSensorExtension[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_IHumanPresenceSensorExtension) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_IHumanPresenceSensorExtension) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_IHumanPresenceSensorExtension) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_IHumanPresenceSensorExtension) },
        { },
    };

    static PyType_Spec type_spec_IHumanPresenceSensorExtension =
    {
        "winrt._winrt_windows_devices_sensors.IHumanPresenceSensorExtension",
        sizeof(py::wrapper::Windows::Devices::Sensors::IHumanPresenceSensorExtension),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_IHumanPresenceSensorExtension
    };

    // ----- ISensorDataThreshold interface --------------------

    static PyObject* _new_ISensorDataThreshold(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Devices::Sensors::ISensorDataThreshold>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Devices::Sensors::ISensorDataThreshold>::type_name);
        return nullptr;
    }

    static void _dealloc_ISensorDataThreshold(py::wrapper::Windows::Devices::Sensors::ISensorDataThreshold* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* _assign_array_ISensorDataThreshold(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Devices::Sensors::ISensorDataThreshold>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_ISensorDataThreshold(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Devices::Sensors::ISensorDataThreshold>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_ISensorDataThreshold[] = {
        { "_assign_array_", _assign_array_ISensorDataThreshold, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_ISensorDataThreshold), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_ISensorDataThreshold[] = {
        { }
    };

    static PyType_Slot _type_slots_ISensorDataThreshold[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_ISensorDataThreshold) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_ISensorDataThreshold) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_ISensorDataThreshold) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_ISensorDataThreshold) },
        { },
    };

    static PyType_Spec type_spec_ISensorDataThreshold =
    {
        "winrt._winrt_windows_devices_sensors.ISensorDataThreshold",
        sizeof(py::wrapper::Windows::Devices::Sensors::ISensorDataThreshold),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_ISensorDataThreshold
    };

    // ----- Windows.Devices.Sensors Initialization --------------------
    PyDoc_STRVAR(module_doc, "Windows::Devices::Sensors");


    static PyModuleDef module_def
        = {PyModuleDef_HEAD_INIT,
           "_winrt_windows_devices_sensors",
           module_doc,
           0,
           nullptr,
           nullptr,
           nullptr,
           nullptr,
           nullptr};

} // py::cpp::Windows::Devices::Sensors

PyMODINIT_FUNC PyInit__winrt_windows_devices_sensors(void) noexcept
{
    using namespace py::cpp::Windows::Devices::Sensors;

    if (py::import_winrt_runtime() == -1)
    {
        return nullptr;
    }

    py::pyobj_handle module{PyModule_Create(&module_def)};

    if (!module)
    {
        return nullptr;
    }

    auto object_type = py::get_object_type();
    if (!object_type)
    {
        return nullptr;
    }

    py::pyobj_handle object_bases{PyTuple_Pack(1, object_type)};

    if (!object_bases)
    {
        return nullptr;
    }

    py::pyobj_handle type_Accelerometer_Static{PyType_FromSpec(&type_spec_Accelerometer_Static)};
    if (!type_Accelerometer_Static)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_Accelerometer, object_bases.get(), reinterpret_cast<PyTypeObject*>(type_Accelerometer_Static.get())) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_AccelerometerDataThreshold, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_AccelerometerReading, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_AccelerometerReadingChangedEventArgs, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_AccelerometerShakenEventArgs, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    py::pyobj_handle type_ActivitySensor_Static{PyType_FromSpec(&type_spec_ActivitySensor_Static)};
    if (!type_ActivitySensor_Static)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_ActivitySensor, object_bases.get(), reinterpret_cast<PyTypeObject*>(type_ActivitySensor_Static.get())) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_ActivitySensorReading, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_ActivitySensorReadingChangeReport, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_ActivitySensorReadingChangedEventArgs, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_ActivitySensorTriggerDetails, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_AdaptiveDimmingOptions, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    py::pyobj_handle type_Altimeter_Static{PyType_FromSpec(&type_spec_Altimeter_Static)};
    if (!type_Altimeter_Static)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_Altimeter, object_bases.get(), reinterpret_cast<PyTypeObject*>(type_Altimeter_Static.get())) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_AltimeterReading, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_AltimeterReadingChangedEventArgs, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    py::pyobj_handle type_Barometer_Static{PyType_FromSpec(&type_spec_Barometer_Static)};
    if (!type_Barometer_Static)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_Barometer, object_bases.get(), reinterpret_cast<PyTypeObject*>(type_Barometer_Static.get())) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_BarometerDataThreshold, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_BarometerReading, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_BarometerReadingChangedEventArgs, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    py::pyobj_handle type_Compass_Static{PyType_FromSpec(&type_spec_Compass_Static)};
    if (!type_Compass_Static)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_Compass, object_bases.get(), reinterpret_cast<PyTypeObject*>(type_Compass_Static.get())) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_CompassDataThreshold, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_CompassReading, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_CompassReadingChangedEventArgs, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    py::pyobj_handle type_Gyrometer_Static{PyType_FromSpec(&type_spec_Gyrometer_Static)};
    if (!type_Gyrometer_Static)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_Gyrometer, object_bases.get(), reinterpret_cast<PyTypeObject*>(type_Gyrometer_Static.get())) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_GyrometerDataThreshold, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_GyrometerReading, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_GyrometerReadingChangedEventArgs, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_HingeAngleReading, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    py::pyobj_handle type_HingeAngleSensor_Static{PyType_FromSpec(&type_spec_HingeAngleSensor_Static)};
    if (!type_HingeAngleSensor_Static)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_HingeAngleSensor, object_bases.get(), reinterpret_cast<PyTypeObject*>(type_HingeAngleSensor_Static.get())) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_HingeAngleSensorReadingChangedEventArgs, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_HumanPresenceFeatures, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    py::pyobj_handle type_HumanPresenceSensor_Static{PyType_FromSpec(&type_spec_HumanPresenceSensor_Static)};
    if (!type_HumanPresenceSensor_Static)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_HumanPresenceSensor, object_bases.get(), reinterpret_cast<PyTypeObject*>(type_HumanPresenceSensor_Static.get())) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_HumanPresenceSensorReading, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_HumanPresenceSensorReadingChangedEventArgs, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_HumanPresenceSensorReadingUpdate, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    py::pyobj_handle type_HumanPresenceSettings_Static{PyType_FromSpec(&type_spec_HumanPresenceSettings_Static)};
    if (!type_HumanPresenceSettings_Static)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_HumanPresenceSettings, object_bases.get(), reinterpret_cast<PyTypeObject*>(type_HumanPresenceSettings_Static.get())) == -1)
    {
        return nullptr;
    }

    py::pyobj_handle type_Inclinometer_Static{PyType_FromSpec(&type_spec_Inclinometer_Static)};
    if (!type_Inclinometer_Static)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_Inclinometer, object_bases.get(), reinterpret_cast<PyTypeObject*>(type_Inclinometer_Static.get())) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_InclinometerDataThreshold, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_InclinometerReading, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_InclinometerReadingChangedEventArgs, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    py::pyobj_handle type_LightSensor_Static{PyType_FromSpec(&type_spec_LightSensor_Static)};
    if (!type_LightSensor_Static)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_LightSensor, object_bases.get(), reinterpret_cast<PyTypeObject*>(type_LightSensor_Static.get())) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_LightSensorDataThreshold, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_LightSensorReading, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_LightSensorReadingChangedEventArgs, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_LockOnLeaveOptions, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    py::pyobj_handle type_Magnetometer_Static{PyType_FromSpec(&type_spec_Magnetometer_Static)};
    if (!type_Magnetometer_Static)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_Magnetometer, object_bases.get(), reinterpret_cast<PyTypeObject*>(type_Magnetometer_Static.get())) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_MagnetometerDataThreshold, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_MagnetometerReading, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_MagnetometerReadingChangedEventArgs, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    py::pyobj_handle type_OrientationSensor_Static{PyType_FromSpec(&type_spec_OrientationSensor_Static)};
    if (!type_OrientationSensor_Static)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_OrientationSensor, object_bases.get(), reinterpret_cast<PyTypeObject*>(type_OrientationSensor_Static.get())) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_OrientationSensorReading, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_OrientationSensorReadingChangedEventArgs, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    py::pyobj_handle type_Pedometer_Static{PyType_FromSpec(&type_spec_Pedometer_Static)};
    if (!type_Pedometer_Static)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_Pedometer, object_bases.get(), reinterpret_cast<PyTypeObject*>(type_Pedometer_Static.get())) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_PedometerDataThreshold, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_PedometerReading, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_PedometerReadingChangedEventArgs, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    py::pyobj_handle type_ProximitySensor_Static{PyType_FromSpec(&type_spec_ProximitySensor_Static)};
    if (!type_ProximitySensor_Static)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_ProximitySensor, object_bases.get(), reinterpret_cast<PyTypeObject*>(type_ProximitySensor_Static.get())) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_ProximitySensorDataThreshold, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_ProximitySensorDisplayOnOffController, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_ProximitySensorReading, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_ProximitySensorReadingChangedEventArgs, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_SensorDataThresholdTriggerDetails, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_SensorQuaternion, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_SensorRotationMatrix, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    py::pyobj_handle type_SimpleOrientationSensor_Static{PyType_FromSpec(&type_spec_SimpleOrientationSensor_Static)};
    if (!type_SimpleOrientationSensor_Static)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_SimpleOrientationSensor, object_bases.get(), reinterpret_cast<PyTypeObject*>(type_SimpleOrientationSensor_Static.get())) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_SimpleOrientationSensorOrientationChangedEventArgs, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_WakeOnApproachOptions, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_IHumanPresenceSensorExtension, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_ISensorDataThreshold, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }


    return module.detach();
}
