# WARNING: Please don't edit this file. It was generated by Python/WinRT v2.0.0-beta.2

import datetime
import sys
import types
import typing
import uuid as _uuid
from builtins import property as _property

import winrt._winrt
import winrt.system
import winrt.windows.foundation
import winrt.windows.foundation.collections
import winrt.windows.graphics.display

from winrt.windows.devices.sensors import AccelerometerReadingType, ActivitySensorReadingConfidence, ActivityType, HumanEngagement, HumanPresence, MagnetometerAccuracy, PedometerStepKind, SensorOptimizationGoal, SensorReadingType, SensorType, SimpleOrientation

Self = typing.TypeVar('Self')

@typing.final
class Accelerometer_Static(type):
    def from_id_async(cls, device_id: str, /) -> winrt.windows.foundation.IAsyncOperation[Accelerometer]: ...
    @typing.overload
    def get_default(cls) -> typing.Optional[Accelerometer]: ...
    @typing.overload
    def get_default(cls, reading_type: AccelerometerReadingType, /) -> typing.Optional[Accelerometer]: ...
    def get_device_selector(cls, reading_type: AccelerometerReadingType, /) -> str: ...

@typing.final
class Accelerometer(winrt.system.Object, metaclass=Accelerometer_Static):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> Accelerometer: ...
    def get_current_reading(self) -> typing.Optional[AccelerometerReading]: ...
    def add_reading_changed(self, handler: winrt.windows.foundation.TypedEventHandler[Accelerometer, AccelerometerReadingChangedEventArgs], /) -> winrt.windows.foundation.EventRegistrationToken: ...
    def remove_reading_changed(self, token: winrt.windows.foundation.EventRegistrationToken, /) -> None: ...
    def add_shaken(self, handler: winrt.windows.foundation.TypedEventHandler[Accelerometer, AccelerometerShakenEventArgs], /) -> winrt.windows.foundation.EventRegistrationToken: ...
    def remove_shaken(self, token: winrt.windows.foundation.EventRegistrationToken, /) -> None: ...
    @_property
    def report_interval(self) -> winrt.system.UInt32: ...
    @report_interval.setter
    def report_interval(self, value: winrt.system.UInt32) -> None: ...
    @_property
    def minimum_report_interval(self) -> winrt.system.UInt32: ...
    @_property
    def reading_transform(self) -> winrt.windows.graphics.display.DisplayOrientations: ...
    @reading_transform.setter
    def reading_transform(self, value: winrt.windows.graphics.display.DisplayOrientations) -> None: ...
    @_property
    def report_latency(self) -> winrt.system.UInt32: ...
    @report_latency.setter
    def report_latency(self, value: winrt.system.UInt32) -> None: ...
    @_property
    def max_batch_size(self) -> winrt.system.UInt32: ...
    @_property
    def reading_type(self) -> AccelerometerReadingType: ...
    @_property
    def report_threshold(self) -> typing.Optional[AccelerometerDataThreshold]: ...
    @_property
    def device_id(self) -> str: ...

@typing.final
class AccelerometerDataThreshold(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> AccelerometerDataThreshold: ...
    @_property
    def z_axis_in_g_force(self) -> winrt.system.Double: ...
    @z_axis_in_g_force.setter
    def z_axis_in_g_force(self, value: winrt.system.Double) -> None: ...
    @_property
    def y_axis_in_g_force(self) -> winrt.system.Double: ...
    @y_axis_in_g_force.setter
    def y_axis_in_g_force(self, value: winrt.system.Double) -> None: ...
    @_property
    def x_axis_in_g_force(self) -> winrt.system.Double: ...
    @x_axis_in_g_force.setter
    def x_axis_in_g_force(self, value: winrt.system.Double) -> None: ...

@typing.final
class AccelerometerReading(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> AccelerometerReading: ...
    @_property
    def acceleration_x(self) -> winrt.system.Double: ...
    @_property
    def acceleration_y(self) -> winrt.system.Double: ...
    @_property
    def acceleration_z(self) -> winrt.system.Double: ...
    @_property
    def timestamp(self) -> datetime.datetime: ...
    @_property
    def performance_count(self) -> typing.Optional[typing.Optional[datetime.timedelta]]: ...
    @_property
    def properties(self) -> typing.Optional[winrt.windows.foundation.collections.IMapView[str, winrt.system.Object]]: ...

@typing.final
class AccelerometerReadingChangedEventArgs(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> AccelerometerReadingChangedEventArgs: ...
    @_property
    def reading(self) -> typing.Optional[AccelerometerReading]: ...

@typing.final
class AccelerometerShakenEventArgs(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> AccelerometerShakenEventArgs: ...
    @_property
    def timestamp(self) -> datetime.datetime: ...

@typing.final
class ActivitySensor_Static(type):
    def from_id_async(cls, device_id: str, /) -> winrt.windows.foundation.IAsyncOperation[ActivitySensor]: ...
    def get_default_async(cls) -> winrt.windows.foundation.IAsyncOperation[ActivitySensor]: ...
    def get_device_selector(cls) -> str: ...
    @typing.overload
    def get_system_history_async(cls, from_time: datetime.datetime, /) -> winrt.windows.foundation.IAsyncOperation[winrt.windows.foundation.collections.IVectorView[ActivitySensorReading]]: ...
    @typing.overload
    def get_system_history_async(cls, from_time: datetime.datetime, duration: datetime.timedelta, /) -> winrt.windows.foundation.IAsyncOperation[winrt.windows.foundation.collections.IVectorView[ActivitySensorReading]]: ...

@typing.final
class ActivitySensor(winrt.system.Object, metaclass=ActivitySensor_Static):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> ActivitySensor: ...
    def get_current_reading_async(self) -> winrt.windows.foundation.IAsyncOperation[ActivitySensorReading]: ...
    def add_reading_changed(self, handler: winrt.windows.foundation.TypedEventHandler[ActivitySensor, ActivitySensorReadingChangedEventArgs], /) -> winrt.windows.foundation.EventRegistrationToken: ...
    def remove_reading_changed(self, token: winrt.windows.foundation.EventRegistrationToken, /) -> None: ...
    @_property
    def device_id(self) -> str: ...
    @_property
    def minimum_report_interval(self) -> winrt.system.UInt32: ...
    @_property
    def power_in_milliwatts(self) -> winrt.system.Double: ...
    @_property
    def subscribed_activities(self) -> typing.Optional[winrt.windows.foundation.collections.IVector[ActivityType]]: ...
    @_property
    def supported_activities(self) -> typing.Optional[winrt.windows.foundation.collections.IVectorView[ActivityType]]: ...

@typing.final
class ActivitySensorReading(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> ActivitySensorReading: ...
    @_property
    def activity(self) -> ActivityType: ...
    @_property
    def confidence(self) -> ActivitySensorReadingConfidence: ...
    @_property
    def timestamp(self) -> datetime.datetime: ...

@typing.final
class ActivitySensorReadingChangeReport(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> ActivitySensorReadingChangeReport: ...
    @_property
    def reading(self) -> typing.Optional[ActivitySensorReading]: ...

@typing.final
class ActivitySensorReadingChangedEventArgs(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> ActivitySensorReadingChangedEventArgs: ...
    @_property
    def reading(self) -> typing.Optional[ActivitySensorReading]: ...

@typing.final
class ActivitySensorTriggerDetails(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> ActivitySensorTriggerDetails: ...
    def read_reports(self) -> typing.Optional[winrt.windows.foundation.collections.IVectorView[ActivitySensorReadingChangeReport]]: ...

@typing.final
class AdaptiveDimmingOptions(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> AdaptiveDimmingOptions: ...
    @_property
    def allow_when_external_display_connected(self) -> bool: ...
    @allow_when_external_display_connected.setter
    def allow_when_external_display_connected(self, value: bool) -> None: ...

@typing.final
class Altimeter_Static(type):
    def get_default(cls) -> typing.Optional[Altimeter]: ...

@typing.final
class Altimeter(winrt.system.Object, metaclass=Altimeter_Static):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> Altimeter: ...
    def get_current_reading(self) -> typing.Optional[AltimeterReading]: ...
    def add_reading_changed(self, handler: winrt.windows.foundation.TypedEventHandler[Altimeter, AltimeterReadingChangedEventArgs], /) -> winrt.windows.foundation.EventRegistrationToken: ...
    def remove_reading_changed(self, token: winrt.windows.foundation.EventRegistrationToken, /) -> None: ...
    @_property
    def report_interval(self) -> winrt.system.UInt32: ...
    @report_interval.setter
    def report_interval(self, value: winrt.system.UInt32) -> None: ...
    @_property
    def device_id(self) -> str: ...
    @_property
    def minimum_report_interval(self) -> winrt.system.UInt32: ...
    @_property
    def report_latency(self) -> winrt.system.UInt32: ...
    @report_latency.setter
    def report_latency(self, value: winrt.system.UInt32) -> None: ...
    @_property
    def max_batch_size(self) -> winrt.system.UInt32: ...

@typing.final
class AltimeterReading(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> AltimeterReading: ...
    @_property
    def altitude_change_in_meters(self) -> winrt.system.Double: ...
    @_property
    def timestamp(self) -> datetime.datetime: ...
    @_property
    def performance_count(self) -> typing.Optional[typing.Optional[datetime.timedelta]]: ...
    @_property
    def properties(self) -> typing.Optional[winrt.windows.foundation.collections.IMapView[str, winrt.system.Object]]: ...

@typing.final
class AltimeterReadingChangedEventArgs(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> AltimeterReadingChangedEventArgs: ...
    @_property
    def reading(self) -> typing.Optional[AltimeterReading]: ...

@typing.final
class Barometer_Static(type):
    def from_id_async(cls, device_id: str, /) -> winrt.windows.foundation.IAsyncOperation[Barometer]: ...
    def get_default(cls) -> typing.Optional[Barometer]: ...
    def get_device_selector(cls) -> str: ...

@typing.final
class Barometer(winrt.system.Object, metaclass=Barometer_Static):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> Barometer: ...
    def get_current_reading(self) -> typing.Optional[BarometerReading]: ...
    def add_reading_changed(self, handler: winrt.windows.foundation.TypedEventHandler[Barometer, BarometerReadingChangedEventArgs], /) -> winrt.windows.foundation.EventRegistrationToken: ...
    def remove_reading_changed(self, token: winrt.windows.foundation.EventRegistrationToken, /) -> None: ...
    @_property
    def report_interval(self) -> winrt.system.UInt32: ...
    @report_interval.setter
    def report_interval(self, value: winrt.system.UInt32) -> None: ...
    @_property
    def device_id(self) -> str: ...
    @_property
    def minimum_report_interval(self) -> winrt.system.UInt32: ...
    @_property
    def report_latency(self) -> winrt.system.UInt32: ...
    @report_latency.setter
    def report_latency(self, value: winrt.system.UInt32) -> None: ...
    @_property
    def max_batch_size(self) -> winrt.system.UInt32: ...
    @_property
    def report_threshold(self) -> typing.Optional[BarometerDataThreshold]: ...

@typing.final
class BarometerDataThreshold(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> BarometerDataThreshold: ...
    @_property
    def hectopascals(self) -> winrt.system.Double: ...
    @hectopascals.setter
    def hectopascals(self, value: winrt.system.Double) -> None: ...

@typing.final
class BarometerReading(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> BarometerReading: ...
    @_property
    def station_pressure_in_hectopascals(self) -> winrt.system.Double: ...
    @_property
    def timestamp(self) -> datetime.datetime: ...
    @_property
    def performance_count(self) -> typing.Optional[typing.Optional[datetime.timedelta]]: ...
    @_property
    def properties(self) -> typing.Optional[winrt.windows.foundation.collections.IMapView[str, winrt.system.Object]]: ...

@typing.final
class BarometerReadingChangedEventArgs(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> BarometerReadingChangedEventArgs: ...
    @_property
    def reading(self) -> typing.Optional[BarometerReading]: ...

@typing.final
class Compass_Static(type):
    def from_id_async(cls, device_id: str, /) -> winrt.windows.foundation.IAsyncOperation[Compass]: ...
    def get_default(cls) -> typing.Optional[Compass]: ...
    def get_device_selector(cls) -> str: ...

@typing.final
class Compass(winrt.system.Object, metaclass=Compass_Static):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> Compass: ...
    def get_current_reading(self) -> typing.Optional[CompassReading]: ...
    def add_reading_changed(self, handler: winrt.windows.foundation.TypedEventHandler[Compass, CompassReadingChangedEventArgs], /) -> winrt.windows.foundation.EventRegistrationToken: ...
    def remove_reading_changed(self, token: winrt.windows.foundation.EventRegistrationToken, /) -> None: ...
    @_property
    def report_interval(self) -> winrt.system.UInt32: ...
    @report_interval.setter
    def report_interval(self, value: winrt.system.UInt32) -> None: ...
    @_property
    def minimum_report_interval(self) -> winrt.system.UInt32: ...
    @_property
    def reading_transform(self) -> winrt.windows.graphics.display.DisplayOrientations: ...
    @reading_transform.setter
    def reading_transform(self, value: winrt.windows.graphics.display.DisplayOrientations) -> None: ...
    @_property
    def report_latency(self) -> winrt.system.UInt32: ...
    @report_latency.setter
    def report_latency(self, value: winrt.system.UInt32) -> None: ...
    @_property
    def max_batch_size(self) -> winrt.system.UInt32: ...
    @_property
    def report_threshold(self) -> typing.Optional[CompassDataThreshold]: ...
    @_property
    def device_id(self) -> str: ...

@typing.final
class CompassDataThreshold(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> CompassDataThreshold: ...
    @_property
    def degrees(self) -> winrt.system.Double: ...
    @degrees.setter
    def degrees(self, value: winrt.system.Double) -> None: ...

@typing.final
class CompassReading(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> CompassReading: ...
    @_property
    def heading_magnetic_north(self) -> winrt.system.Double: ...
    @_property
    def heading_true_north(self) -> typing.Optional[typing.Optional[winrt.system.Double]]: ...
    @_property
    def timestamp(self) -> datetime.datetime: ...
    @_property
    def performance_count(self) -> typing.Optional[typing.Optional[datetime.timedelta]]: ...
    @_property
    def properties(self) -> typing.Optional[winrt.windows.foundation.collections.IMapView[str, winrt.system.Object]]: ...
    @_property
    def heading_accuracy(self) -> MagnetometerAccuracy: ...

@typing.final
class CompassReadingChangedEventArgs(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> CompassReadingChangedEventArgs: ...
    @_property
    def reading(self) -> typing.Optional[CompassReading]: ...

@typing.final
class Gyrometer_Static(type):
    def from_id_async(cls, device_id: str, /) -> winrt.windows.foundation.IAsyncOperation[Gyrometer]: ...
    def get_default(cls) -> typing.Optional[Gyrometer]: ...
    def get_device_selector(cls) -> str: ...

@typing.final
class Gyrometer(winrt.system.Object, metaclass=Gyrometer_Static):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> Gyrometer: ...
    def get_current_reading(self) -> typing.Optional[GyrometerReading]: ...
    def add_reading_changed(self, handler: winrt.windows.foundation.TypedEventHandler[Gyrometer, GyrometerReadingChangedEventArgs], /) -> winrt.windows.foundation.EventRegistrationToken: ...
    def remove_reading_changed(self, token: winrt.windows.foundation.EventRegistrationToken, /) -> None: ...
    @_property
    def report_interval(self) -> winrt.system.UInt32: ...
    @report_interval.setter
    def report_interval(self, value: winrt.system.UInt32) -> None: ...
    @_property
    def minimum_report_interval(self) -> winrt.system.UInt32: ...
    @_property
    def reading_transform(self) -> winrt.windows.graphics.display.DisplayOrientations: ...
    @reading_transform.setter
    def reading_transform(self, value: winrt.windows.graphics.display.DisplayOrientations) -> None: ...
    @_property
    def report_latency(self) -> winrt.system.UInt32: ...
    @report_latency.setter
    def report_latency(self, value: winrt.system.UInt32) -> None: ...
    @_property
    def max_batch_size(self) -> winrt.system.UInt32: ...
    @_property
    def report_threshold(self) -> typing.Optional[GyrometerDataThreshold]: ...
    @_property
    def device_id(self) -> str: ...

@typing.final
class GyrometerDataThreshold(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> GyrometerDataThreshold: ...
    @_property
    def z_axis_in_degrees_per_second(self) -> winrt.system.Double: ...
    @z_axis_in_degrees_per_second.setter
    def z_axis_in_degrees_per_second(self, value: winrt.system.Double) -> None: ...
    @_property
    def y_axis_in_degrees_per_second(self) -> winrt.system.Double: ...
    @y_axis_in_degrees_per_second.setter
    def y_axis_in_degrees_per_second(self, value: winrt.system.Double) -> None: ...
    @_property
    def x_axis_in_degrees_per_second(self) -> winrt.system.Double: ...
    @x_axis_in_degrees_per_second.setter
    def x_axis_in_degrees_per_second(self, value: winrt.system.Double) -> None: ...

@typing.final
class GyrometerReading(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> GyrometerReading: ...
    @_property
    def angular_velocity_x(self) -> winrt.system.Double: ...
    @_property
    def angular_velocity_y(self) -> winrt.system.Double: ...
    @_property
    def angular_velocity_z(self) -> winrt.system.Double: ...
    @_property
    def timestamp(self) -> datetime.datetime: ...
    @_property
    def performance_count(self) -> typing.Optional[typing.Optional[datetime.timedelta]]: ...
    @_property
    def properties(self) -> typing.Optional[winrt.windows.foundation.collections.IMapView[str, winrt.system.Object]]: ...

@typing.final
class GyrometerReadingChangedEventArgs(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> GyrometerReadingChangedEventArgs: ...
    @_property
    def reading(self) -> typing.Optional[GyrometerReading]: ...

@typing.final
class HingeAngleReading(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> HingeAngleReading: ...
    @_property
    def angle_in_degrees(self) -> winrt.system.Double: ...
    @_property
    def properties(self) -> typing.Optional[winrt.windows.foundation.collections.IMapView[str, winrt.system.Object]]: ...
    @_property
    def timestamp(self) -> datetime.datetime: ...

@typing.final
class HingeAngleSensor_Static(type):
    def from_id_async(cls, device_id: str, /) -> winrt.windows.foundation.IAsyncOperation[HingeAngleSensor]: ...
    def get_default_async(cls) -> winrt.windows.foundation.IAsyncOperation[HingeAngleSensor]: ...
    def get_device_selector(cls) -> str: ...
    def get_related_to_adjacent_panels_async(cls, first_panel_id: str, second_panel_id: str, /) -> winrt.windows.foundation.IAsyncOperation[HingeAngleSensor]: ...

@typing.final
class HingeAngleSensor(winrt.system.Object, metaclass=HingeAngleSensor_Static):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> HingeAngleSensor: ...
    def get_current_reading_async(self) -> winrt.windows.foundation.IAsyncOperation[HingeAngleReading]: ...
    def add_reading_changed(self, handler: winrt.windows.foundation.TypedEventHandler[HingeAngleSensor, HingeAngleSensorReadingChangedEventArgs], /) -> winrt.windows.foundation.EventRegistrationToken: ...
    def remove_reading_changed(self, token: winrt.windows.foundation.EventRegistrationToken, /) -> None: ...
    @_property
    def report_threshold_in_degrees(self) -> winrt.system.Double: ...
    @report_threshold_in_degrees.setter
    def report_threshold_in_degrees(self, value: winrt.system.Double) -> None: ...
    @_property
    def device_id(self) -> str: ...
    @_property
    def min_report_threshold_in_degrees(self) -> winrt.system.Double: ...

@typing.final
class HingeAngleSensorReadingChangedEventArgs(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> HingeAngleSensorReadingChangedEventArgs: ...
    @_property
    def reading(self) -> typing.Optional[HingeAngleReading]: ...

@typing.final
class HumanPresenceFeatures(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> HumanPresenceFeatures: ...
    @_property
    def is_attention_aware_dimming_supported(self) -> bool: ...
    @_property
    def is_lock_on_leave_supported(self) -> bool: ...
    @_property
    def is_wake_on_approach_supported(self) -> bool: ...
    @_property
    def sensor_id(self) -> str: ...
    @_property
    def supported_wake_or_lock_distances_in_millimeters(self) -> typing.Optional[winrt.windows.foundation.collections.IVectorView[winrt.system.UInt32]]: ...
    @_property
    def is_adaptive_dimming_supported(self) -> bool: ...

@typing.final
class HumanPresenceSensor_Static(type):
    def from_id(cls, sensor_id: str, /) -> typing.Optional[HumanPresenceSensor]: ...
    def from_id_async(cls, sensor_id: str, /) -> winrt.windows.foundation.IAsyncOperation[HumanPresenceSensor]: ...
    def get_default(cls) -> typing.Optional[HumanPresenceSensor]: ...
    def get_default_async(cls) -> winrt.windows.foundation.IAsyncOperation[HumanPresenceSensor]: ...
    def get_device_selector(cls) -> str: ...

@typing.final
class HumanPresenceSensor(winrt.system.Object, metaclass=HumanPresenceSensor_Static):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> HumanPresenceSensor: ...
    def get_current_reading(self) -> typing.Optional[HumanPresenceSensorReading]: ...
    def add_reading_changed(self, handler: winrt.windows.foundation.TypedEventHandler[HumanPresenceSensor, HumanPresenceSensorReadingChangedEventArgs], /) -> winrt.windows.foundation.EventRegistrationToken: ...
    def remove_reading_changed(self, token: winrt.windows.foundation.EventRegistrationToken, /) -> None: ...
    @_property
    def device_id(self) -> str: ...
    @_property
    def max_detectable_distance_in_millimeters(self) -> typing.Optional[typing.Optional[winrt.system.UInt32]]: ...
    @_property
    def min_detectable_distance_in_millimeters(self) -> typing.Optional[typing.Optional[winrt.system.UInt32]]: ...
    @_property
    def is_engagement_supported(self) -> bool: ...
    @_property
    def is_presence_supported(self) -> bool: ...

@typing.final
class HumanPresenceSensorReading(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> HumanPresenceSensorReading: ...
    @_property
    def distance_in_millimeters(self) -> typing.Optional[typing.Optional[winrt.system.UInt32]]: ...
    @_property
    def engagement(self) -> HumanEngagement: ...
    @_property
    def presence(self) -> HumanPresence: ...
    @_property
    def timestamp(self) -> datetime.datetime: ...
    @_property
    def properties(self) -> typing.Optional[winrt.windows.foundation.collections.IMapView[str, winrt.system.Object]]: ...

@typing.final
class HumanPresenceSensorReadingChangedEventArgs(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> HumanPresenceSensorReadingChangedEventArgs: ...
    @_property
    def reading(self) -> typing.Optional[HumanPresenceSensorReading]: ...

@typing.final
class HumanPresenceSensorReadingUpdate(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> HumanPresenceSensorReadingUpdate: ...
    def __new__(cls: typing.Type[HumanPresenceSensorReadingUpdate]) -> HumanPresenceSensorReadingUpdate:...
    @_property
    def timestamp(self) -> typing.Optional[typing.Optional[datetime.datetime]]: ...
    @timestamp.setter
    def timestamp(self, value: typing.Optional[typing.Optional[datetime.datetime]]) -> None: ...
    @_property
    def presence(self) -> typing.Optional[typing.Optional[HumanPresence]]: ...
    @presence.setter
    def presence(self, value: typing.Optional[typing.Optional[HumanPresence]]) -> None: ...
    @_property
    def engagement(self) -> typing.Optional[typing.Optional[HumanEngagement]]: ...
    @engagement.setter
    def engagement(self, value: typing.Optional[typing.Optional[HumanEngagement]]) -> None: ...
    @_property
    def distance_in_millimeters(self) -> typing.Optional[typing.Optional[winrt.system.UInt32]]: ...
    @distance_in_millimeters.setter
    def distance_in_millimeters(self, value: typing.Optional[typing.Optional[winrt.system.UInt32]]) -> None: ...

@typing.final
class HumanPresenceSettings_Static(type):
    def get_current_settings(cls) -> typing.Optional[HumanPresenceSettings]: ...
    def get_current_settings_async(cls) -> winrt.windows.foundation.IAsyncOperation[HumanPresenceSettings]: ...
    def get_supported_features_for_sensor_id(cls, sensor_id: str, /) -> typing.Optional[HumanPresenceFeatures]: ...
    def get_supported_features_for_sensor_id_async(cls, sensor_id: str, /) -> winrt.windows.foundation.IAsyncOperation[HumanPresenceFeatures]: ...
    def get_supported_lock_on_leave_timeouts(cls) -> typing.Optional[winrt.windows.foundation.collections.IVectorView[datetime.timedelta]]: ...
    def update_settings(cls, settings: typing.Optional[HumanPresenceSettings], /) -> None: ...
    def update_settings_async(cls, settings: typing.Optional[HumanPresenceSettings], /) -> winrt.windows.foundation.IAsyncAction: ...
    def add_settings_changed(cls, handler: winrt.windows.foundation.EventHandler[winrt.system.Object], /) -> winrt.windows.foundation.EventRegistrationToken: ...
    def remove_settings_changed(cls, token: winrt.windows.foundation.EventRegistrationToken, /) -> None: ...

@typing.final
class HumanPresenceSettings(winrt.system.Object, metaclass=HumanPresenceSettings_Static):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> HumanPresenceSettings: ...
    @_property
    def wake_on_approach_distance_in_millimeters(self) -> typing.Optional[typing.Optional[winrt.system.UInt32]]: ...
    @wake_on_approach_distance_in_millimeters.setter
    def wake_on_approach_distance_in_millimeters(self, value: typing.Optional[typing.Optional[winrt.system.UInt32]]) -> None: ...
    @_property
    def sensor_id(self) -> str: ...
    @sensor_id.setter
    def sensor_id(self, value: str) -> None: ...
    @_property
    def lock_on_leave_timeout(self) -> datetime.timedelta: ...
    @lock_on_leave_timeout.setter
    def lock_on_leave_timeout(self, value: datetime.timedelta) -> None: ...
    @_property
    def lock_on_leave_distance_in_millimeters(self) -> typing.Optional[typing.Optional[winrt.system.UInt32]]: ...
    @lock_on_leave_distance_in_millimeters.setter
    def lock_on_leave_distance_in_millimeters(self, value: typing.Optional[typing.Optional[winrt.system.UInt32]]) -> None: ...
    @_property
    def is_wake_on_approach_enabled(self) -> bool: ...
    @is_wake_on_approach_enabled.setter
    def is_wake_on_approach_enabled(self, value: bool) -> None: ...
    @_property
    def is_lock_on_leave_enabled(self) -> bool: ...
    @is_lock_on_leave_enabled.setter
    def is_lock_on_leave_enabled(self, value: bool) -> None: ...
    @_property
    def is_attention_aware_dimming_enabled(self) -> bool: ...
    @is_attention_aware_dimming_enabled.setter
    def is_attention_aware_dimming_enabled(self, value: bool) -> None: ...
    @_property
    def is_adaptive_dimming_enabled(self) -> bool: ...
    @is_adaptive_dimming_enabled.setter
    def is_adaptive_dimming_enabled(self, value: bool) -> None: ...
    @_property
    def dimming_options(self) -> typing.Optional[AdaptiveDimmingOptions]: ...
    @_property
    def lock_options(self) -> typing.Optional[LockOnLeaveOptions]: ...
    @_property
    def wake_options(self) -> typing.Optional[WakeOnApproachOptions]: ...

@typing.final
class Inclinometer_Static(type):
    def from_id_async(cls, device_id: str, /) -> winrt.windows.foundation.IAsyncOperation[Inclinometer]: ...
    @typing.overload
    def get_default(cls) -> typing.Optional[Inclinometer]: ...
    @typing.overload
    def get_default(cls, sensor_readingtype: SensorReadingType, /) -> typing.Optional[Inclinometer]: ...
    def get_default_for_relative_readings(cls) -> typing.Optional[Inclinometer]: ...
    def get_device_selector(cls, reading_type: SensorReadingType, /) -> str: ...

@typing.final
class Inclinometer(winrt.system.Object, metaclass=Inclinometer_Static):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> Inclinometer: ...
    def get_current_reading(self) -> typing.Optional[InclinometerReading]: ...
    def add_reading_changed(self, handler: winrt.windows.foundation.TypedEventHandler[Inclinometer, InclinometerReadingChangedEventArgs], /) -> winrt.windows.foundation.EventRegistrationToken: ...
    def remove_reading_changed(self, token: winrt.windows.foundation.EventRegistrationToken, /) -> None: ...
    @_property
    def report_interval(self) -> winrt.system.UInt32: ...
    @report_interval.setter
    def report_interval(self, value: winrt.system.UInt32) -> None: ...
    @_property
    def minimum_report_interval(self) -> winrt.system.UInt32: ...
    @_property
    def reading_transform(self) -> winrt.windows.graphics.display.DisplayOrientations: ...
    @reading_transform.setter
    def reading_transform(self, value: winrt.windows.graphics.display.DisplayOrientations) -> None: ...
    @_property
    def reading_type(self) -> SensorReadingType: ...
    @_property
    def report_latency(self) -> winrt.system.UInt32: ...
    @report_latency.setter
    def report_latency(self, value: winrt.system.UInt32) -> None: ...
    @_property
    def max_batch_size(self) -> winrt.system.UInt32: ...
    @_property
    def report_threshold(self) -> typing.Optional[InclinometerDataThreshold]: ...
    @_property
    def device_id(self) -> str: ...

@typing.final
class InclinometerDataThreshold(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> InclinometerDataThreshold: ...
    @_property
    def yaw_in_degrees(self) -> winrt.system.Single: ...
    @yaw_in_degrees.setter
    def yaw_in_degrees(self, value: winrt.system.Single) -> None: ...
    @_property
    def roll_in_degrees(self) -> winrt.system.Single: ...
    @roll_in_degrees.setter
    def roll_in_degrees(self, value: winrt.system.Single) -> None: ...
    @_property
    def pitch_in_degrees(self) -> winrt.system.Single: ...
    @pitch_in_degrees.setter
    def pitch_in_degrees(self, value: winrt.system.Single) -> None: ...

@typing.final
class InclinometerReading(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> InclinometerReading: ...
    @_property
    def pitch_degrees(self) -> winrt.system.Single: ...
    @_property
    def roll_degrees(self) -> winrt.system.Single: ...
    @_property
    def timestamp(self) -> datetime.datetime: ...
    @_property
    def yaw_degrees(self) -> winrt.system.Single: ...
    @_property
    def performance_count(self) -> typing.Optional[typing.Optional[datetime.timedelta]]: ...
    @_property
    def properties(self) -> typing.Optional[winrt.windows.foundation.collections.IMapView[str, winrt.system.Object]]: ...
    @_property
    def yaw_accuracy(self) -> MagnetometerAccuracy: ...

@typing.final
class InclinometerReadingChangedEventArgs(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> InclinometerReadingChangedEventArgs: ...
    @_property
    def reading(self) -> typing.Optional[InclinometerReading]: ...

@typing.final
class LightSensor_Static(type):
    def from_id_async(cls, device_id: str, /) -> winrt.windows.foundation.IAsyncOperation[LightSensor]: ...
    def get_default(cls) -> typing.Optional[LightSensor]: ...
    def get_device_selector(cls) -> str: ...

@typing.final
class LightSensor(winrt.system.Object, metaclass=LightSensor_Static):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> LightSensor: ...
    def get_current_reading(self) -> typing.Optional[LightSensorReading]: ...
    def add_reading_changed(self, handler: winrt.windows.foundation.TypedEventHandler[LightSensor, LightSensorReadingChangedEventArgs], /) -> winrt.windows.foundation.EventRegistrationToken: ...
    def remove_reading_changed(self, token: winrt.windows.foundation.EventRegistrationToken, /) -> None: ...
    @_property
    def report_interval(self) -> winrt.system.UInt32: ...
    @report_interval.setter
    def report_interval(self, value: winrt.system.UInt32) -> None: ...
    @_property
    def minimum_report_interval(self) -> winrt.system.UInt32: ...
    @_property
    def report_latency(self) -> winrt.system.UInt32: ...
    @report_latency.setter
    def report_latency(self, value: winrt.system.UInt32) -> None: ...
    @_property
    def max_batch_size(self) -> winrt.system.UInt32: ...
    @_property
    def report_threshold(self) -> typing.Optional[LightSensorDataThreshold]: ...
    @_property
    def device_id(self) -> str: ...

@typing.final
class LightSensorDataThreshold(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> LightSensorDataThreshold: ...
    @_property
    def lux_percentage(self) -> winrt.system.Single: ...
    @lux_percentage.setter
    def lux_percentage(self, value: winrt.system.Single) -> None: ...
    @_property
    def absolute_lux(self) -> winrt.system.Single: ...
    @absolute_lux.setter
    def absolute_lux(self, value: winrt.system.Single) -> None: ...

@typing.final
class LightSensorReading(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> LightSensorReading: ...
    @_property
    def illuminance_in_lux(self) -> winrt.system.Single: ...
    @_property
    def timestamp(self) -> datetime.datetime: ...
    @_property
    def performance_count(self) -> typing.Optional[typing.Optional[datetime.timedelta]]: ...
    @_property
    def properties(self) -> typing.Optional[winrt.windows.foundation.collections.IMapView[str, winrt.system.Object]]: ...

@typing.final
class LightSensorReadingChangedEventArgs(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> LightSensorReadingChangedEventArgs: ...
    @_property
    def reading(self) -> typing.Optional[LightSensorReading]: ...

@typing.final
class LockOnLeaveOptions(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> LockOnLeaveOptions: ...
    @_property
    def allow_when_external_display_connected(self) -> bool: ...
    @allow_when_external_display_connected.setter
    def allow_when_external_display_connected(self, value: bool) -> None: ...

@typing.final
class Magnetometer_Static(type):
    def from_id_async(cls, device_id: str, /) -> winrt.windows.foundation.IAsyncOperation[Magnetometer]: ...
    def get_default(cls) -> typing.Optional[Magnetometer]: ...
    def get_device_selector(cls) -> str: ...

@typing.final
class Magnetometer(winrt.system.Object, metaclass=Magnetometer_Static):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> Magnetometer: ...
    def get_current_reading(self) -> typing.Optional[MagnetometerReading]: ...
    def add_reading_changed(self, handler: winrt.windows.foundation.TypedEventHandler[Magnetometer, MagnetometerReadingChangedEventArgs], /) -> winrt.windows.foundation.EventRegistrationToken: ...
    def remove_reading_changed(self, token: winrt.windows.foundation.EventRegistrationToken, /) -> None: ...
    @_property
    def report_interval(self) -> winrt.system.UInt32: ...
    @report_interval.setter
    def report_interval(self, value: winrt.system.UInt32) -> None: ...
    @_property
    def minimum_report_interval(self) -> winrt.system.UInt32: ...
    @_property
    def reading_transform(self) -> winrt.windows.graphics.display.DisplayOrientations: ...
    @reading_transform.setter
    def reading_transform(self, value: winrt.windows.graphics.display.DisplayOrientations) -> None: ...
    @_property
    def report_latency(self) -> winrt.system.UInt32: ...
    @report_latency.setter
    def report_latency(self, value: winrt.system.UInt32) -> None: ...
    @_property
    def max_batch_size(self) -> winrt.system.UInt32: ...
    @_property
    def report_threshold(self) -> typing.Optional[MagnetometerDataThreshold]: ...
    @_property
    def device_id(self) -> str: ...

@typing.final
class MagnetometerDataThreshold(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> MagnetometerDataThreshold: ...
    @_property
    def z_axis_microteslas(self) -> winrt.system.Single: ...
    @z_axis_microteslas.setter
    def z_axis_microteslas(self, value: winrt.system.Single) -> None: ...
    @_property
    def y_axis_microteslas(self) -> winrt.system.Single: ...
    @y_axis_microteslas.setter
    def y_axis_microteslas(self, value: winrt.system.Single) -> None: ...
    @_property
    def x_axis_microteslas(self) -> winrt.system.Single: ...
    @x_axis_microteslas.setter
    def x_axis_microteslas(self, value: winrt.system.Single) -> None: ...

@typing.final
class MagnetometerReading(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> MagnetometerReading: ...
    @_property
    def directional_accuracy(self) -> MagnetometerAccuracy: ...
    @_property
    def magnetic_field_x(self) -> winrt.system.Single: ...
    @_property
    def magnetic_field_y(self) -> winrt.system.Single: ...
    @_property
    def magnetic_field_z(self) -> winrt.system.Single: ...
    @_property
    def timestamp(self) -> datetime.datetime: ...
    @_property
    def performance_count(self) -> typing.Optional[typing.Optional[datetime.timedelta]]: ...
    @_property
    def properties(self) -> typing.Optional[winrt.windows.foundation.collections.IMapView[str, winrt.system.Object]]: ...

@typing.final
class MagnetometerReadingChangedEventArgs(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> MagnetometerReadingChangedEventArgs: ...
    @_property
    def reading(self) -> typing.Optional[MagnetometerReading]: ...

@typing.final
class OrientationSensor_Static(type):
    def from_id_async(cls, device_id: str, /) -> winrt.windows.foundation.IAsyncOperation[OrientationSensor]: ...
    @typing.overload
    def get_default(cls) -> typing.Optional[OrientationSensor]: ...
    @typing.overload
    def get_default(cls, sensor_readingtype: SensorReadingType, /) -> typing.Optional[OrientationSensor]: ...
    @typing.overload
    def get_default(cls, sensor_reading_type: SensorReadingType, optimization_goal: SensorOptimizationGoal, /) -> typing.Optional[OrientationSensor]: ...
    def get_default_for_relative_readings(cls) -> typing.Optional[OrientationSensor]: ...
    @typing.overload
    def get_device_selector(cls, reading_type: SensorReadingType, /) -> str: ...
    @typing.overload
    def get_device_selector(cls, reading_type: SensorReadingType, optimization_goal: SensorOptimizationGoal, /) -> str: ...

@typing.final
class OrientationSensor(winrt.system.Object, metaclass=OrientationSensor_Static):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> OrientationSensor: ...
    def get_current_reading(self) -> typing.Optional[OrientationSensorReading]: ...
    def add_reading_changed(self, handler: winrt.windows.foundation.TypedEventHandler[OrientationSensor, OrientationSensorReadingChangedEventArgs], /) -> winrt.windows.foundation.EventRegistrationToken: ...
    def remove_reading_changed(self, token: winrt.windows.foundation.EventRegistrationToken, /) -> None: ...
    @_property
    def report_interval(self) -> winrt.system.UInt32: ...
    @report_interval.setter
    def report_interval(self, value: winrt.system.UInt32) -> None: ...
    @_property
    def minimum_report_interval(self) -> winrt.system.UInt32: ...
    @_property
    def reading_transform(self) -> winrt.windows.graphics.display.DisplayOrientations: ...
    @reading_transform.setter
    def reading_transform(self, value: winrt.windows.graphics.display.DisplayOrientations) -> None: ...
    @_property
    def reading_type(self) -> SensorReadingType: ...
    @_property
    def report_latency(self) -> winrt.system.UInt32: ...
    @report_latency.setter
    def report_latency(self, value: winrt.system.UInt32) -> None: ...
    @_property
    def max_batch_size(self) -> winrt.system.UInt32: ...
    @_property
    def device_id(self) -> str: ...

@typing.final
class OrientationSensorReading(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> OrientationSensorReading: ...
    @_property
    def quaternion(self) -> typing.Optional[SensorQuaternion]: ...
    @_property
    def rotation_matrix(self) -> typing.Optional[SensorRotationMatrix]: ...
    @_property
    def timestamp(self) -> datetime.datetime: ...
    @_property
    def performance_count(self) -> typing.Optional[typing.Optional[datetime.timedelta]]: ...
    @_property
    def properties(self) -> typing.Optional[winrt.windows.foundation.collections.IMapView[str, winrt.system.Object]]: ...
    @_property
    def yaw_accuracy(self) -> MagnetometerAccuracy: ...

@typing.final
class OrientationSensorReadingChangedEventArgs(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> OrientationSensorReadingChangedEventArgs: ...
    @_property
    def reading(self) -> typing.Optional[OrientationSensorReading]: ...

@typing.final
class Pedometer_Static(type):
    def from_id_async(cls, device_id: str, /) -> winrt.windows.foundation.IAsyncOperation[Pedometer]: ...
    def get_default_async(cls) -> winrt.windows.foundation.IAsyncOperation[Pedometer]: ...
    def get_device_selector(cls) -> str: ...
    def get_readings_from_trigger_details(cls, trigger_details: typing.Optional[SensorDataThresholdTriggerDetails], /) -> typing.Optional[winrt.windows.foundation.collections.IVectorView[PedometerReading]]: ...
    @typing.overload
    def get_system_history_async(cls, from_time: datetime.datetime, /) -> winrt.windows.foundation.IAsyncOperation[winrt.windows.foundation.collections.IVectorView[PedometerReading]]: ...
    @typing.overload
    def get_system_history_async(cls, from_time: datetime.datetime, duration: datetime.timedelta, /) -> winrt.windows.foundation.IAsyncOperation[winrt.windows.foundation.collections.IVectorView[PedometerReading]]: ...

@typing.final
class Pedometer(winrt.system.Object, metaclass=Pedometer_Static):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> Pedometer: ...
    def get_current_readings(self) -> typing.Optional[winrt.windows.foundation.collections.IMapView[PedometerStepKind, PedometerReading]]: ...
    def add_reading_changed(self, handler: winrt.windows.foundation.TypedEventHandler[Pedometer, PedometerReadingChangedEventArgs], /) -> winrt.windows.foundation.EventRegistrationToken: ...
    def remove_reading_changed(self, token: winrt.windows.foundation.EventRegistrationToken, /) -> None: ...
    @_property
    def report_interval(self) -> winrt.system.UInt32: ...
    @report_interval.setter
    def report_interval(self, value: winrt.system.UInt32) -> None: ...
    @_property
    def device_id(self) -> str: ...
    @_property
    def minimum_report_interval(self) -> winrt.system.UInt32: ...
    @_property
    def power_in_milliwatts(self) -> winrt.system.Double: ...

@typing.final
class PedometerDataThreshold(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> PedometerDataThreshold: ...
    def __new__(cls: typing.Type[PedometerDataThreshold], sensor: typing.Optional[Pedometer], step_goal: winrt.system.Int32) -> PedometerDataThreshold:...

@typing.final
class PedometerReading(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> PedometerReading: ...
    @_property
    def cumulative_steps(self) -> winrt.system.Int32: ...
    @_property
    def cumulative_steps_duration(self) -> datetime.timedelta: ...
    @_property
    def step_kind(self) -> PedometerStepKind: ...
    @_property
    def timestamp(self) -> datetime.datetime: ...

@typing.final
class PedometerReadingChangedEventArgs(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> PedometerReadingChangedEventArgs: ...
    @_property
    def reading(self) -> typing.Optional[PedometerReading]: ...

@typing.final
class ProximitySensor_Static(type):
    def from_id(cls, sensor_id: str, /) -> typing.Optional[ProximitySensor]: ...
    def get_device_selector(cls) -> str: ...
    def get_readings_from_trigger_details(cls, trigger_details: typing.Optional[SensorDataThresholdTriggerDetails], /) -> typing.Optional[winrt.windows.foundation.collections.IVectorView[ProximitySensorReading]]: ...

@typing.final
class ProximitySensor(winrt.system.Object, metaclass=ProximitySensor_Static):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> ProximitySensor: ...
    def create_display_on_off_controller(self) -> typing.Optional[ProximitySensorDisplayOnOffController]: ...
    def get_current_reading(self) -> typing.Optional[ProximitySensorReading]: ...
    def add_reading_changed(self, handler: winrt.windows.foundation.TypedEventHandler[ProximitySensor, ProximitySensorReadingChangedEventArgs], /) -> winrt.windows.foundation.EventRegistrationToken: ...
    def remove_reading_changed(self, token: winrt.windows.foundation.EventRegistrationToken, /) -> None: ...
    @_property
    def device_id(self) -> str: ...
    @_property
    def max_distance_in_millimeters(self) -> typing.Optional[typing.Optional[winrt.system.UInt32]]: ...
    @_property
    def min_distance_in_millimeters(self) -> typing.Optional[typing.Optional[winrt.system.UInt32]]: ...

@typing.final
class ProximitySensorDataThreshold(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> ProximitySensorDataThreshold: ...
    def __new__(cls: typing.Type[ProximitySensorDataThreshold], sensor: typing.Optional[ProximitySensor]) -> ProximitySensorDataThreshold:...

@typing.final
class ProximitySensorDisplayOnOffController(winrt.system.Object):
    def __enter__(self: Self) -> Self: ...
    def __exit__(self, *args) -> None: ...
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> ProximitySensorDisplayOnOffController: ...
    def close(self) -> None: ...

@typing.final
class ProximitySensorReading(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> ProximitySensorReading: ...
    @_property
    def distance_in_millimeters(self) -> typing.Optional[typing.Optional[winrt.system.UInt32]]: ...
    @_property
    def is_detected(self) -> bool: ...
    @_property
    def timestamp(self) -> datetime.datetime: ...

@typing.final
class ProximitySensorReadingChangedEventArgs(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> ProximitySensorReadingChangedEventArgs: ...
    @_property
    def reading(self) -> typing.Optional[ProximitySensorReading]: ...

@typing.final
class SensorDataThresholdTriggerDetails(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> SensorDataThresholdTriggerDetails: ...
    @_property
    def device_id(self) -> str: ...
    @_property
    def sensor_type(self) -> SensorType: ...

@typing.final
class SensorQuaternion(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> SensorQuaternion: ...
    @_property
    def w(self) -> winrt.system.Single: ...
    @_property
    def x(self) -> winrt.system.Single: ...
    @_property
    def y(self) -> winrt.system.Single: ...
    @_property
    def z(self) -> winrt.system.Single: ...

@typing.final
class SensorRotationMatrix(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> SensorRotationMatrix: ...
    @_property
    def m11(self) -> winrt.system.Single: ...
    @_property
    def m12(self) -> winrt.system.Single: ...
    @_property
    def m13(self) -> winrt.system.Single: ...
    @_property
    def m21(self) -> winrt.system.Single: ...
    @_property
    def m22(self) -> winrt.system.Single: ...
    @_property
    def m23(self) -> winrt.system.Single: ...
    @_property
    def m31(self) -> winrt.system.Single: ...
    @_property
    def m32(self) -> winrt.system.Single: ...
    @_property
    def m33(self) -> winrt.system.Single: ...

@typing.final
class SimpleOrientationSensor_Static(type):
    def from_id_async(cls, device_id: str, /) -> winrt.windows.foundation.IAsyncOperation[SimpleOrientationSensor]: ...
    def get_default(cls) -> typing.Optional[SimpleOrientationSensor]: ...
    def get_device_selector(cls) -> str: ...

@typing.final
class SimpleOrientationSensor(winrt.system.Object, metaclass=SimpleOrientationSensor_Static):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> SimpleOrientationSensor: ...
    def get_current_orientation(self) -> SimpleOrientation: ...
    def add_orientation_changed(self, handler: winrt.windows.foundation.TypedEventHandler[SimpleOrientationSensor, SimpleOrientationSensorOrientationChangedEventArgs], /) -> winrt.windows.foundation.EventRegistrationToken: ...
    def remove_orientation_changed(self, token: winrt.windows.foundation.EventRegistrationToken, /) -> None: ...
    @_property
    def reading_transform(self) -> winrt.windows.graphics.display.DisplayOrientations: ...
    @reading_transform.setter
    def reading_transform(self, value: winrt.windows.graphics.display.DisplayOrientations) -> None: ...
    @_property
    def device_id(self) -> str: ...

@typing.final
class SimpleOrientationSensorOrientationChangedEventArgs(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> SimpleOrientationSensorOrientationChangedEventArgs: ...
    @_property
    def orientation(self) -> SimpleOrientation: ...
    @_property
    def timestamp(self) -> datetime.datetime: ...

@typing.final
class WakeOnApproachOptions(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> WakeOnApproachOptions: ...
    @_property
    def disable_when_battery_saver_on(self) -> bool: ...
    @disable_when_battery_saver_on.setter
    def disable_when_battery_saver_on(self, value: bool) -> None: ...
    @_property
    def allow_when_external_display_connected(self) -> bool: ...
    @allow_when_external_display_connected.setter
    def allow_when_external_display_connected(self, value: bool) -> None: ...

@typing.final
class IHumanPresenceSensorExtension(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> IHumanPresenceSensorExtension: ...
    def initialize(self, device_interface: str, /) -> None: ...
    def process_reading(self, reading: typing.Optional[HumanPresenceSensorReading], /) -> typing.Optional[HumanPresenceSensorReadingUpdate]: ...
    def process_reading_timeout_expired(self, reading: typing.Optional[HumanPresenceSensorReading], /) -> None: ...
    def reset(self) -> None: ...
    def start(self) -> None: ...
    def stop(self) -> None: ...
    def uninitialize(self) -> None: ...

@typing.final
class ISensorDataThreshold(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> ISensorDataThreshold: ...

