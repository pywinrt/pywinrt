// WARNING: Please don't edit this file. It was generated by Python/WinRT v2.2.0

#include "py.Windows.UI.Input.Spatial.h"

namespace py::cpp::Windows::UI::Input::Spatial
{
    // ----- SpatialGestureRecognizer class --------------------

    static PyObject* _new_SpatialGestureRecognizer(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::UI::Input::Spatial::SpatialGestureSettings>(args, 0);

                winrt::Windows::UI::Input::Spatial::SpatialGestureRecognizer instance{param0};
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_SpatialGestureRecognizer(py::wrapper::Windows::UI::Input::Spatial::SpatialGestureRecognizer* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* SpatialGestureRecognizer_CancelPendingGestures(py::wrapper::Windows::UI::Input::Spatial::SpatialGestureRecognizer* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Input.Spatial.SpatialGestureRecognizer", L"CancelPendingGestures", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                self->obj.CancelPendingGestures();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* SpatialGestureRecognizer_CaptureInteraction(py::wrapper::Windows::UI::Input::Spatial::SpatialGestureRecognizer* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Input.Spatial.SpatialGestureRecognizer", L"CaptureInteraction", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::UI::Input::Spatial::SpatialInteraction>(args, 0);

                self->obj.CaptureInteraction(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* SpatialGestureRecognizer_TrySetGestureSettings(py::wrapper::Windows::UI::Input::Spatial::SpatialGestureRecognizer* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Input.Spatial.SpatialGestureRecognizer", L"TrySetGestureSettings", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::UI::Input::Spatial::SpatialGestureSettings>(args, 0);

                return py::convert(self->obj.TrySetGestureSettings(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* SpatialGestureRecognizer_get_GestureSettings(py::wrapper::Windows::UI::Input::Spatial::SpatialGestureRecognizer* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Input.Spatial.SpatialGestureRecognizer", L"GestureSettings");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.GestureSettings());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SpatialGestureRecognizer_add_HoldCanceled(py::wrapper::Windows::UI::Input::Spatial::SpatialGestureRecognizer* self, PyObject* arg) noexcept
    {
        try
        {
            static std::optional<bool> is_event_present{};

            if (!is_event_present.has_value())
            {
                is_event_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.UI.Input.Spatial.SpatialGestureRecognizer", L"HoldCanceled");
            }

            if (!is_event_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::UI::Input::Spatial::SpatialGestureRecognizer, winrt::Windows::UI::Input::Spatial::SpatialHoldCanceledEventArgs>>(arg);

            return py::convert(self->obj.HoldCanceled(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SpatialGestureRecognizer_remove_HoldCanceled(py::wrapper::Windows::UI::Input::Spatial::SpatialGestureRecognizer* self, PyObject* arg) noexcept
    {
        try
        {
            static std::optional<bool> is_event_present{};

            if (!is_event_present.has_value())
            {
                is_event_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.UI.Input.Spatial.SpatialGestureRecognizer", L"HoldCanceled");
            }

            if (!is_event_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.HoldCanceled(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SpatialGestureRecognizer_add_HoldCompleted(py::wrapper::Windows::UI::Input::Spatial::SpatialGestureRecognizer* self, PyObject* arg) noexcept
    {
        try
        {
            static std::optional<bool> is_event_present{};

            if (!is_event_present.has_value())
            {
                is_event_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.UI.Input.Spatial.SpatialGestureRecognizer", L"HoldCompleted");
            }

            if (!is_event_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::UI::Input::Spatial::SpatialGestureRecognizer, winrt::Windows::UI::Input::Spatial::SpatialHoldCompletedEventArgs>>(arg);

            return py::convert(self->obj.HoldCompleted(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SpatialGestureRecognizer_remove_HoldCompleted(py::wrapper::Windows::UI::Input::Spatial::SpatialGestureRecognizer* self, PyObject* arg) noexcept
    {
        try
        {
            static std::optional<bool> is_event_present{};

            if (!is_event_present.has_value())
            {
                is_event_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.UI.Input.Spatial.SpatialGestureRecognizer", L"HoldCompleted");
            }

            if (!is_event_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.HoldCompleted(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SpatialGestureRecognizer_add_HoldStarted(py::wrapper::Windows::UI::Input::Spatial::SpatialGestureRecognizer* self, PyObject* arg) noexcept
    {
        try
        {
            static std::optional<bool> is_event_present{};

            if (!is_event_present.has_value())
            {
                is_event_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.UI.Input.Spatial.SpatialGestureRecognizer", L"HoldStarted");
            }

            if (!is_event_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::UI::Input::Spatial::SpatialGestureRecognizer, winrt::Windows::UI::Input::Spatial::SpatialHoldStartedEventArgs>>(arg);

            return py::convert(self->obj.HoldStarted(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SpatialGestureRecognizer_remove_HoldStarted(py::wrapper::Windows::UI::Input::Spatial::SpatialGestureRecognizer* self, PyObject* arg) noexcept
    {
        try
        {
            static std::optional<bool> is_event_present{};

            if (!is_event_present.has_value())
            {
                is_event_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.UI.Input.Spatial.SpatialGestureRecognizer", L"HoldStarted");
            }

            if (!is_event_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.HoldStarted(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SpatialGestureRecognizer_add_ManipulationCanceled(py::wrapper::Windows::UI::Input::Spatial::SpatialGestureRecognizer* self, PyObject* arg) noexcept
    {
        try
        {
            static std::optional<bool> is_event_present{};

            if (!is_event_present.has_value())
            {
                is_event_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.UI.Input.Spatial.SpatialGestureRecognizer", L"ManipulationCanceled");
            }

            if (!is_event_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::UI::Input::Spatial::SpatialGestureRecognizer, winrt::Windows::UI::Input::Spatial::SpatialManipulationCanceledEventArgs>>(arg);

            return py::convert(self->obj.ManipulationCanceled(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SpatialGestureRecognizer_remove_ManipulationCanceled(py::wrapper::Windows::UI::Input::Spatial::SpatialGestureRecognizer* self, PyObject* arg) noexcept
    {
        try
        {
            static std::optional<bool> is_event_present{};

            if (!is_event_present.has_value())
            {
                is_event_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.UI.Input.Spatial.SpatialGestureRecognizer", L"ManipulationCanceled");
            }

            if (!is_event_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.ManipulationCanceled(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SpatialGestureRecognizer_add_ManipulationCompleted(py::wrapper::Windows::UI::Input::Spatial::SpatialGestureRecognizer* self, PyObject* arg) noexcept
    {
        try
        {
            static std::optional<bool> is_event_present{};

            if (!is_event_present.has_value())
            {
                is_event_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.UI.Input.Spatial.SpatialGestureRecognizer", L"ManipulationCompleted");
            }

            if (!is_event_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::UI::Input::Spatial::SpatialGestureRecognizer, winrt::Windows::UI::Input::Spatial::SpatialManipulationCompletedEventArgs>>(arg);

            return py::convert(self->obj.ManipulationCompleted(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SpatialGestureRecognizer_remove_ManipulationCompleted(py::wrapper::Windows::UI::Input::Spatial::SpatialGestureRecognizer* self, PyObject* arg) noexcept
    {
        try
        {
            static std::optional<bool> is_event_present{};

            if (!is_event_present.has_value())
            {
                is_event_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.UI.Input.Spatial.SpatialGestureRecognizer", L"ManipulationCompleted");
            }

            if (!is_event_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.ManipulationCompleted(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SpatialGestureRecognizer_add_ManipulationStarted(py::wrapper::Windows::UI::Input::Spatial::SpatialGestureRecognizer* self, PyObject* arg) noexcept
    {
        try
        {
            static std::optional<bool> is_event_present{};

            if (!is_event_present.has_value())
            {
                is_event_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.UI.Input.Spatial.SpatialGestureRecognizer", L"ManipulationStarted");
            }

            if (!is_event_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::UI::Input::Spatial::SpatialGestureRecognizer, winrt::Windows::UI::Input::Spatial::SpatialManipulationStartedEventArgs>>(arg);

            return py::convert(self->obj.ManipulationStarted(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SpatialGestureRecognizer_remove_ManipulationStarted(py::wrapper::Windows::UI::Input::Spatial::SpatialGestureRecognizer* self, PyObject* arg) noexcept
    {
        try
        {
            static std::optional<bool> is_event_present{};

            if (!is_event_present.has_value())
            {
                is_event_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.UI.Input.Spatial.SpatialGestureRecognizer", L"ManipulationStarted");
            }

            if (!is_event_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.ManipulationStarted(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SpatialGestureRecognizer_add_ManipulationUpdated(py::wrapper::Windows::UI::Input::Spatial::SpatialGestureRecognizer* self, PyObject* arg) noexcept
    {
        try
        {
            static std::optional<bool> is_event_present{};

            if (!is_event_present.has_value())
            {
                is_event_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.UI.Input.Spatial.SpatialGestureRecognizer", L"ManipulationUpdated");
            }

            if (!is_event_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::UI::Input::Spatial::SpatialGestureRecognizer, winrt::Windows::UI::Input::Spatial::SpatialManipulationUpdatedEventArgs>>(arg);

            return py::convert(self->obj.ManipulationUpdated(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SpatialGestureRecognizer_remove_ManipulationUpdated(py::wrapper::Windows::UI::Input::Spatial::SpatialGestureRecognizer* self, PyObject* arg) noexcept
    {
        try
        {
            static std::optional<bool> is_event_present{};

            if (!is_event_present.has_value())
            {
                is_event_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.UI.Input.Spatial.SpatialGestureRecognizer", L"ManipulationUpdated");
            }

            if (!is_event_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.ManipulationUpdated(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SpatialGestureRecognizer_add_NavigationCanceled(py::wrapper::Windows::UI::Input::Spatial::SpatialGestureRecognizer* self, PyObject* arg) noexcept
    {
        try
        {
            static std::optional<bool> is_event_present{};

            if (!is_event_present.has_value())
            {
                is_event_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.UI.Input.Spatial.SpatialGestureRecognizer", L"NavigationCanceled");
            }

            if (!is_event_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::UI::Input::Spatial::SpatialGestureRecognizer, winrt::Windows::UI::Input::Spatial::SpatialNavigationCanceledEventArgs>>(arg);

            return py::convert(self->obj.NavigationCanceled(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SpatialGestureRecognizer_remove_NavigationCanceled(py::wrapper::Windows::UI::Input::Spatial::SpatialGestureRecognizer* self, PyObject* arg) noexcept
    {
        try
        {
            static std::optional<bool> is_event_present{};

            if (!is_event_present.has_value())
            {
                is_event_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.UI.Input.Spatial.SpatialGestureRecognizer", L"NavigationCanceled");
            }

            if (!is_event_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.NavigationCanceled(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SpatialGestureRecognizer_add_NavigationCompleted(py::wrapper::Windows::UI::Input::Spatial::SpatialGestureRecognizer* self, PyObject* arg) noexcept
    {
        try
        {
            static std::optional<bool> is_event_present{};

            if (!is_event_present.has_value())
            {
                is_event_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.UI.Input.Spatial.SpatialGestureRecognizer", L"NavigationCompleted");
            }

            if (!is_event_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::UI::Input::Spatial::SpatialGestureRecognizer, winrt::Windows::UI::Input::Spatial::SpatialNavigationCompletedEventArgs>>(arg);

            return py::convert(self->obj.NavigationCompleted(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SpatialGestureRecognizer_remove_NavigationCompleted(py::wrapper::Windows::UI::Input::Spatial::SpatialGestureRecognizer* self, PyObject* arg) noexcept
    {
        try
        {
            static std::optional<bool> is_event_present{};

            if (!is_event_present.has_value())
            {
                is_event_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.UI.Input.Spatial.SpatialGestureRecognizer", L"NavigationCompleted");
            }

            if (!is_event_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.NavigationCompleted(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SpatialGestureRecognizer_add_NavigationStarted(py::wrapper::Windows::UI::Input::Spatial::SpatialGestureRecognizer* self, PyObject* arg) noexcept
    {
        try
        {
            static std::optional<bool> is_event_present{};

            if (!is_event_present.has_value())
            {
                is_event_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.UI.Input.Spatial.SpatialGestureRecognizer", L"NavigationStarted");
            }

            if (!is_event_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::UI::Input::Spatial::SpatialGestureRecognizer, winrt::Windows::UI::Input::Spatial::SpatialNavigationStartedEventArgs>>(arg);

            return py::convert(self->obj.NavigationStarted(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SpatialGestureRecognizer_remove_NavigationStarted(py::wrapper::Windows::UI::Input::Spatial::SpatialGestureRecognizer* self, PyObject* arg) noexcept
    {
        try
        {
            static std::optional<bool> is_event_present{};

            if (!is_event_present.has_value())
            {
                is_event_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.UI.Input.Spatial.SpatialGestureRecognizer", L"NavigationStarted");
            }

            if (!is_event_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.NavigationStarted(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SpatialGestureRecognizer_add_NavigationUpdated(py::wrapper::Windows::UI::Input::Spatial::SpatialGestureRecognizer* self, PyObject* arg) noexcept
    {
        try
        {
            static std::optional<bool> is_event_present{};

            if (!is_event_present.has_value())
            {
                is_event_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.UI.Input.Spatial.SpatialGestureRecognizer", L"NavigationUpdated");
            }

            if (!is_event_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::UI::Input::Spatial::SpatialGestureRecognizer, winrt::Windows::UI::Input::Spatial::SpatialNavigationUpdatedEventArgs>>(arg);

            return py::convert(self->obj.NavigationUpdated(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SpatialGestureRecognizer_remove_NavigationUpdated(py::wrapper::Windows::UI::Input::Spatial::SpatialGestureRecognizer* self, PyObject* arg) noexcept
    {
        try
        {
            static std::optional<bool> is_event_present{};

            if (!is_event_present.has_value())
            {
                is_event_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.UI.Input.Spatial.SpatialGestureRecognizer", L"NavigationUpdated");
            }

            if (!is_event_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.NavigationUpdated(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SpatialGestureRecognizer_add_RecognitionEnded(py::wrapper::Windows::UI::Input::Spatial::SpatialGestureRecognizer* self, PyObject* arg) noexcept
    {
        try
        {
            static std::optional<bool> is_event_present{};

            if (!is_event_present.has_value())
            {
                is_event_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.UI.Input.Spatial.SpatialGestureRecognizer", L"RecognitionEnded");
            }

            if (!is_event_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::UI::Input::Spatial::SpatialGestureRecognizer, winrt::Windows::UI::Input::Spatial::SpatialRecognitionEndedEventArgs>>(arg);

            return py::convert(self->obj.RecognitionEnded(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SpatialGestureRecognizer_remove_RecognitionEnded(py::wrapper::Windows::UI::Input::Spatial::SpatialGestureRecognizer* self, PyObject* arg) noexcept
    {
        try
        {
            static std::optional<bool> is_event_present{};

            if (!is_event_present.has_value())
            {
                is_event_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.UI.Input.Spatial.SpatialGestureRecognizer", L"RecognitionEnded");
            }

            if (!is_event_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.RecognitionEnded(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SpatialGestureRecognizer_add_RecognitionStarted(py::wrapper::Windows::UI::Input::Spatial::SpatialGestureRecognizer* self, PyObject* arg) noexcept
    {
        try
        {
            static std::optional<bool> is_event_present{};

            if (!is_event_present.has_value())
            {
                is_event_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.UI.Input.Spatial.SpatialGestureRecognizer", L"RecognitionStarted");
            }

            if (!is_event_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::UI::Input::Spatial::SpatialGestureRecognizer, winrt::Windows::UI::Input::Spatial::SpatialRecognitionStartedEventArgs>>(arg);

            return py::convert(self->obj.RecognitionStarted(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SpatialGestureRecognizer_remove_RecognitionStarted(py::wrapper::Windows::UI::Input::Spatial::SpatialGestureRecognizer* self, PyObject* arg) noexcept
    {
        try
        {
            static std::optional<bool> is_event_present{};

            if (!is_event_present.has_value())
            {
                is_event_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.UI.Input.Spatial.SpatialGestureRecognizer", L"RecognitionStarted");
            }

            if (!is_event_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.RecognitionStarted(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SpatialGestureRecognizer_add_Tapped(py::wrapper::Windows::UI::Input::Spatial::SpatialGestureRecognizer* self, PyObject* arg) noexcept
    {
        try
        {
            static std::optional<bool> is_event_present{};

            if (!is_event_present.has_value())
            {
                is_event_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.UI.Input.Spatial.SpatialGestureRecognizer", L"Tapped");
            }

            if (!is_event_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::UI::Input::Spatial::SpatialGestureRecognizer, winrt::Windows::UI::Input::Spatial::SpatialTappedEventArgs>>(arg);

            return py::convert(self->obj.Tapped(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SpatialGestureRecognizer_remove_Tapped(py::wrapper::Windows::UI::Input::Spatial::SpatialGestureRecognizer* self, PyObject* arg) noexcept
    {
        try
        {
            static std::optional<bool> is_event_present{};

            if (!is_event_present.has_value())
            {
                is_event_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.UI.Input.Spatial.SpatialGestureRecognizer", L"Tapped");
            }

            if (!is_event_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.Tapped(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_SpatialGestureRecognizer(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::Input::Spatial::SpatialGestureRecognizer>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_SpatialGestureRecognizer(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Input::Spatial::SpatialGestureRecognizer>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_SpatialGestureRecognizer[] = {
        { "cancel_pending_gestures", reinterpret_cast<PyCFunction>(SpatialGestureRecognizer_CancelPendingGestures), METH_VARARGS, nullptr },
        { "capture_interaction", reinterpret_cast<PyCFunction>(SpatialGestureRecognizer_CaptureInteraction), METH_VARARGS, nullptr },
        { "try_set_gesture_settings", reinterpret_cast<PyCFunction>(SpatialGestureRecognizer_TrySetGestureSettings), METH_VARARGS, nullptr },
        { "add_hold_canceled", reinterpret_cast<PyCFunction>(SpatialGestureRecognizer_add_HoldCanceled), METH_O, nullptr },
        { "remove_hold_canceled", reinterpret_cast<PyCFunction>(SpatialGestureRecognizer_remove_HoldCanceled), METH_O, nullptr },
        { "add_hold_completed", reinterpret_cast<PyCFunction>(SpatialGestureRecognizer_add_HoldCompleted), METH_O, nullptr },
        { "remove_hold_completed", reinterpret_cast<PyCFunction>(SpatialGestureRecognizer_remove_HoldCompleted), METH_O, nullptr },
        { "add_hold_started", reinterpret_cast<PyCFunction>(SpatialGestureRecognizer_add_HoldStarted), METH_O, nullptr },
        { "remove_hold_started", reinterpret_cast<PyCFunction>(SpatialGestureRecognizer_remove_HoldStarted), METH_O, nullptr },
        { "add_manipulation_canceled", reinterpret_cast<PyCFunction>(SpatialGestureRecognizer_add_ManipulationCanceled), METH_O, nullptr },
        { "remove_manipulation_canceled", reinterpret_cast<PyCFunction>(SpatialGestureRecognizer_remove_ManipulationCanceled), METH_O, nullptr },
        { "add_manipulation_completed", reinterpret_cast<PyCFunction>(SpatialGestureRecognizer_add_ManipulationCompleted), METH_O, nullptr },
        { "remove_manipulation_completed", reinterpret_cast<PyCFunction>(SpatialGestureRecognizer_remove_ManipulationCompleted), METH_O, nullptr },
        { "add_manipulation_started", reinterpret_cast<PyCFunction>(SpatialGestureRecognizer_add_ManipulationStarted), METH_O, nullptr },
        { "remove_manipulation_started", reinterpret_cast<PyCFunction>(SpatialGestureRecognizer_remove_ManipulationStarted), METH_O, nullptr },
        { "add_manipulation_updated", reinterpret_cast<PyCFunction>(SpatialGestureRecognizer_add_ManipulationUpdated), METH_O, nullptr },
        { "remove_manipulation_updated", reinterpret_cast<PyCFunction>(SpatialGestureRecognizer_remove_ManipulationUpdated), METH_O, nullptr },
        { "add_navigation_canceled", reinterpret_cast<PyCFunction>(SpatialGestureRecognizer_add_NavigationCanceled), METH_O, nullptr },
        { "remove_navigation_canceled", reinterpret_cast<PyCFunction>(SpatialGestureRecognizer_remove_NavigationCanceled), METH_O, nullptr },
        { "add_navigation_completed", reinterpret_cast<PyCFunction>(SpatialGestureRecognizer_add_NavigationCompleted), METH_O, nullptr },
        { "remove_navigation_completed", reinterpret_cast<PyCFunction>(SpatialGestureRecognizer_remove_NavigationCompleted), METH_O, nullptr },
        { "add_navigation_started", reinterpret_cast<PyCFunction>(SpatialGestureRecognizer_add_NavigationStarted), METH_O, nullptr },
        { "remove_navigation_started", reinterpret_cast<PyCFunction>(SpatialGestureRecognizer_remove_NavigationStarted), METH_O, nullptr },
        { "add_navigation_updated", reinterpret_cast<PyCFunction>(SpatialGestureRecognizer_add_NavigationUpdated), METH_O, nullptr },
        { "remove_navigation_updated", reinterpret_cast<PyCFunction>(SpatialGestureRecognizer_remove_NavigationUpdated), METH_O, nullptr },
        { "add_recognition_ended", reinterpret_cast<PyCFunction>(SpatialGestureRecognizer_add_RecognitionEnded), METH_O, nullptr },
        { "remove_recognition_ended", reinterpret_cast<PyCFunction>(SpatialGestureRecognizer_remove_RecognitionEnded), METH_O, nullptr },
        { "add_recognition_started", reinterpret_cast<PyCFunction>(SpatialGestureRecognizer_add_RecognitionStarted), METH_O, nullptr },
        { "remove_recognition_started", reinterpret_cast<PyCFunction>(SpatialGestureRecognizer_remove_RecognitionStarted), METH_O, nullptr },
        { "add_tapped", reinterpret_cast<PyCFunction>(SpatialGestureRecognizer_add_Tapped), METH_O, nullptr },
        { "remove_tapped", reinterpret_cast<PyCFunction>(SpatialGestureRecognizer_remove_Tapped), METH_O, nullptr },
        { "_assign_array_", _assign_array_SpatialGestureRecognizer, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_SpatialGestureRecognizer), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_SpatialGestureRecognizer[] = {
        { "gesture_settings", reinterpret_cast<getter>(SpatialGestureRecognizer_get_GestureSettings), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_SpatialGestureRecognizer[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_SpatialGestureRecognizer) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_SpatialGestureRecognizer) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_SpatialGestureRecognizer) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_SpatialGestureRecognizer) },
        { }
    };

    static PyType_Spec type_spec_SpatialGestureRecognizer = {
        "winrt._winrt_windows_ui_input_spatial.SpatialGestureRecognizer",
        sizeof(py::wrapper::Windows::UI::Input::Spatial::SpatialGestureRecognizer),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_SpatialGestureRecognizer};

    // ----- SpatialHoldCanceledEventArgs class --------------------

    static PyObject* _new_SpatialHoldCanceledEventArgs(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::UI::Input::Spatial::SpatialHoldCanceledEventArgs>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::UI::Input::Spatial::SpatialHoldCanceledEventArgs>::type_name);
        return nullptr;
    }

    static void _dealloc_SpatialHoldCanceledEventArgs(py::wrapper::Windows::UI::Input::Spatial::SpatialHoldCanceledEventArgs* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* SpatialHoldCanceledEventArgs_get_InteractionSourceKind(py::wrapper::Windows::UI::Input::Spatial::SpatialHoldCanceledEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Input.Spatial.SpatialHoldCanceledEventArgs", L"InteractionSourceKind");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.InteractionSourceKind());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_SpatialHoldCanceledEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::Input::Spatial::SpatialHoldCanceledEventArgs>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_SpatialHoldCanceledEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Input::Spatial::SpatialHoldCanceledEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_SpatialHoldCanceledEventArgs[] = {
        { "_assign_array_", _assign_array_SpatialHoldCanceledEventArgs, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_SpatialHoldCanceledEventArgs), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_SpatialHoldCanceledEventArgs[] = {
        { "interaction_source_kind", reinterpret_cast<getter>(SpatialHoldCanceledEventArgs_get_InteractionSourceKind), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_SpatialHoldCanceledEventArgs[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_SpatialHoldCanceledEventArgs) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_SpatialHoldCanceledEventArgs) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_SpatialHoldCanceledEventArgs) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_SpatialHoldCanceledEventArgs) },
        { }
    };

    static PyType_Spec type_spec_SpatialHoldCanceledEventArgs = {
        "winrt._winrt_windows_ui_input_spatial.SpatialHoldCanceledEventArgs",
        sizeof(py::wrapper::Windows::UI::Input::Spatial::SpatialHoldCanceledEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_SpatialHoldCanceledEventArgs};

    // ----- SpatialHoldCompletedEventArgs class --------------------

    static PyObject* _new_SpatialHoldCompletedEventArgs(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::UI::Input::Spatial::SpatialHoldCompletedEventArgs>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::UI::Input::Spatial::SpatialHoldCompletedEventArgs>::type_name);
        return nullptr;
    }

    static void _dealloc_SpatialHoldCompletedEventArgs(py::wrapper::Windows::UI::Input::Spatial::SpatialHoldCompletedEventArgs* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* SpatialHoldCompletedEventArgs_get_InteractionSourceKind(py::wrapper::Windows::UI::Input::Spatial::SpatialHoldCompletedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Input.Spatial.SpatialHoldCompletedEventArgs", L"InteractionSourceKind");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.InteractionSourceKind());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_SpatialHoldCompletedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::Input::Spatial::SpatialHoldCompletedEventArgs>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_SpatialHoldCompletedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Input::Spatial::SpatialHoldCompletedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_SpatialHoldCompletedEventArgs[] = {
        { "_assign_array_", _assign_array_SpatialHoldCompletedEventArgs, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_SpatialHoldCompletedEventArgs), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_SpatialHoldCompletedEventArgs[] = {
        { "interaction_source_kind", reinterpret_cast<getter>(SpatialHoldCompletedEventArgs_get_InteractionSourceKind), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_SpatialHoldCompletedEventArgs[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_SpatialHoldCompletedEventArgs) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_SpatialHoldCompletedEventArgs) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_SpatialHoldCompletedEventArgs) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_SpatialHoldCompletedEventArgs) },
        { }
    };

    static PyType_Spec type_spec_SpatialHoldCompletedEventArgs = {
        "winrt._winrt_windows_ui_input_spatial.SpatialHoldCompletedEventArgs",
        sizeof(py::wrapper::Windows::UI::Input::Spatial::SpatialHoldCompletedEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_SpatialHoldCompletedEventArgs};

    // ----- SpatialHoldStartedEventArgs class --------------------

    static PyObject* _new_SpatialHoldStartedEventArgs(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::UI::Input::Spatial::SpatialHoldStartedEventArgs>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::UI::Input::Spatial::SpatialHoldStartedEventArgs>::type_name);
        return nullptr;
    }

    static void _dealloc_SpatialHoldStartedEventArgs(py::wrapper::Windows::UI::Input::Spatial::SpatialHoldStartedEventArgs* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* SpatialHoldStartedEventArgs_TryGetPointerPose(py::wrapper::Windows::UI::Input::Spatial::SpatialHoldStartedEventArgs* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Input.Spatial.SpatialHoldStartedEventArgs", L"TryGetPointerPose", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Perception::Spatial::SpatialCoordinateSystem>(args, 0);

                return py::convert(self->obj.TryGetPointerPose(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* SpatialHoldStartedEventArgs_get_InteractionSourceKind(py::wrapper::Windows::UI::Input::Spatial::SpatialHoldStartedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Input.Spatial.SpatialHoldStartedEventArgs", L"InteractionSourceKind");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.InteractionSourceKind());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_SpatialHoldStartedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::Input::Spatial::SpatialHoldStartedEventArgs>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_SpatialHoldStartedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Input::Spatial::SpatialHoldStartedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_SpatialHoldStartedEventArgs[] = {
        { "try_get_pointer_pose", reinterpret_cast<PyCFunction>(SpatialHoldStartedEventArgs_TryGetPointerPose), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_SpatialHoldStartedEventArgs, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_SpatialHoldStartedEventArgs), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_SpatialHoldStartedEventArgs[] = {
        { "interaction_source_kind", reinterpret_cast<getter>(SpatialHoldStartedEventArgs_get_InteractionSourceKind), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_SpatialHoldStartedEventArgs[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_SpatialHoldStartedEventArgs) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_SpatialHoldStartedEventArgs) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_SpatialHoldStartedEventArgs) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_SpatialHoldStartedEventArgs) },
        { }
    };

    static PyType_Spec type_spec_SpatialHoldStartedEventArgs = {
        "winrt._winrt_windows_ui_input_spatial.SpatialHoldStartedEventArgs",
        sizeof(py::wrapper::Windows::UI::Input::Spatial::SpatialHoldStartedEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_SpatialHoldStartedEventArgs};

    // ----- SpatialInteraction class --------------------

    static PyObject* _new_SpatialInteraction(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::UI::Input::Spatial::SpatialInteraction>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::UI::Input::Spatial::SpatialInteraction>::type_name);
        return nullptr;
    }

    static void _dealloc_SpatialInteraction(py::wrapper::Windows::UI::Input::Spatial::SpatialInteraction* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* SpatialInteraction_get_SourceState(py::wrapper::Windows::UI::Input::Spatial::SpatialInteraction* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Input.Spatial.SpatialInteraction", L"SourceState");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.SourceState());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_SpatialInteraction(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::Input::Spatial::SpatialInteraction>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_SpatialInteraction(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Input::Spatial::SpatialInteraction>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_SpatialInteraction[] = {
        { "_assign_array_", _assign_array_SpatialInteraction, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_SpatialInteraction), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_SpatialInteraction[] = {
        { "source_state", reinterpret_cast<getter>(SpatialInteraction_get_SourceState), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_SpatialInteraction[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_SpatialInteraction) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_SpatialInteraction) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_SpatialInteraction) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_SpatialInteraction) },
        { }
    };

    static PyType_Spec type_spec_SpatialInteraction = {
        "winrt._winrt_windows_ui_input_spatial.SpatialInteraction",
        sizeof(py::wrapper::Windows::UI::Input::Spatial::SpatialInteraction),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_SpatialInteraction};

    // ----- SpatialInteractionController class --------------------

    static PyObject* _new_SpatialInteractionController(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::UI::Input::Spatial::SpatialInteractionController>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::UI::Input::Spatial::SpatialInteractionController>::type_name);
        return nullptr;
    }

    static void _dealloc_SpatialInteractionController(py::wrapper::Windows::UI::Input::Spatial::SpatialInteractionController* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* SpatialInteractionController_TryGetBatteryReport(py::wrapper::Windows::UI::Input::Spatial::SpatialInteractionController* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Input.Spatial.SpatialInteractionController", L"TryGetBatteryReport", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert(self->obj.TryGetBatteryReport());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* SpatialInteractionController_TryGetRenderableModelAsync(py::wrapper::Windows::UI::Input::Spatial::SpatialInteractionController* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Input.Spatial.SpatialInteractionController", L"TryGetRenderableModelAsync", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert(self->obj.TryGetRenderableModelAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* SpatialInteractionController_get_HasThumbstick(py::wrapper::Windows::UI::Input::Spatial::SpatialInteractionController* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Input.Spatial.SpatialInteractionController", L"HasThumbstick");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.HasThumbstick());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SpatialInteractionController_get_HasTouchpad(py::wrapper::Windows::UI::Input::Spatial::SpatialInteractionController* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Input.Spatial.SpatialInteractionController", L"HasTouchpad");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.HasTouchpad());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SpatialInteractionController_get_ProductId(py::wrapper::Windows::UI::Input::Spatial::SpatialInteractionController* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Input.Spatial.SpatialInteractionController", L"ProductId");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.ProductId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SpatialInteractionController_get_SimpleHapticsController(py::wrapper::Windows::UI::Input::Spatial::SpatialInteractionController* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Input.Spatial.SpatialInteractionController", L"SimpleHapticsController");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.SimpleHapticsController());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SpatialInteractionController_get_VendorId(py::wrapper::Windows::UI::Input::Spatial::SpatialInteractionController* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Input.Spatial.SpatialInteractionController", L"VendorId");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.VendorId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SpatialInteractionController_get_Version(py::wrapper::Windows::UI::Input::Spatial::SpatialInteractionController* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Input.Spatial.SpatialInteractionController", L"Version");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Version());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_SpatialInteractionController(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::Input::Spatial::SpatialInteractionController>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_SpatialInteractionController(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Input::Spatial::SpatialInteractionController>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_SpatialInteractionController[] = {
        { "try_get_battery_report", reinterpret_cast<PyCFunction>(SpatialInteractionController_TryGetBatteryReport), METH_VARARGS, nullptr },
        { "try_get_renderable_model_async", reinterpret_cast<PyCFunction>(SpatialInteractionController_TryGetRenderableModelAsync), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_SpatialInteractionController, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_SpatialInteractionController), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_SpatialInteractionController[] = {
        { "has_thumbstick", reinterpret_cast<getter>(SpatialInteractionController_get_HasThumbstick), nullptr, nullptr, nullptr },
        { "has_touchpad", reinterpret_cast<getter>(SpatialInteractionController_get_HasTouchpad), nullptr, nullptr, nullptr },
        { "product_id", reinterpret_cast<getter>(SpatialInteractionController_get_ProductId), nullptr, nullptr, nullptr },
        { "simple_haptics_controller", reinterpret_cast<getter>(SpatialInteractionController_get_SimpleHapticsController), nullptr, nullptr, nullptr },
        { "vendor_id", reinterpret_cast<getter>(SpatialInteractionController_get_VendorId), nullptr, nullptr, nullptr },
        { "version", reinterpret_cast<getter>(SpatialInteractionController_get_Version), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_SpatialInteractionController[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_SpatialInteractionController) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_SpatialInteractionController) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_SpatialInteractionController) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_SpatialInteractionController) },
        { }
    };

    static PyType_Spec type_spec_SpatialInteractionController = {
        "winrt._winrt_windows_ui_input_spatial.SpatialInteractionController",
        sizeof(py::wrapper::Windows::UI::Input::Spatial::SpatialInteractionController),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_SpatialInteractionController};

    // ----- SpatialInteractionControllerProperties class --------------------

    static PyObject* _new_SpatialInteractionControllerProperties(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::UI::Input::Spatial::SpatialInteractionControllerProperties>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::UI::Input::Spatial::SpatialInteractionControllerProperties>::type_name);
        return nullptr;
    }

    static void _dealloc_SpatialInteractionControllerProperties(py::wrapper::Windows::UI::Input::Spatial::SpatialInteractionControllerProperties* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* SpatialInteractionControllerProperties_get_IsThumbstickPressed(py::wrapper::Windows::UI::Input::Spatial::SpatialInteractionControllerProperties* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Input.Spatial.SpatialInteractionControllerProperties", L"IsThumbstickPressed");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.IsThumbstickPressed());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SpatialInteractionControllerProperties_get_IsTouchpadPressed(py::wrapper::Windows::UI::Input::Spatial::SpatialInteractionControllerProperties* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Input.Spatial.SpatialInteractionControllerProperties", L"IsTouchpadPressed");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.IsTouchpadPressed());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SpatialInteractionControllerProperties_get_IsTouchpadTouched(py::wrapper::Windows::UI::Input::Spatial::SpatialInteractionControllerProperties* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Input.Spatial.SpatialInteractionControllerProperties", L"IsTouchpadTouched");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.IsTouchpadTouched());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SpatialInteractionControllerProperties_get_ThumbstickX(py::wrapper::Windows::UI::Input::Spatial::SpatialInteractionControllerProperties* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Input.Spatial.SpatialInteractionControllerProperties", L"ThumbstickX");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.ThumbstickX());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SpatialInteractionControllerProperties_get_ThumbstickY(py::wrapper::Windows::UI::Input::Spatial::SpatialInteractionControllerProperties* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Input.Spatial.SpatialInteractionControllerProperties", L"ThumbstickY");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.ThumbstickY());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SpatialInteractionControllerProperties_get_TouchpadX(py::wrapper::Windows::UI::Input::Spatial::SpatialInteractionControllerProperties* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Input.Spatial.SpatialInteractionControllerProperties", L"TouchpadX");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.TouchpadX());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SpatialInteractionControllerProperties_get_TouchpadY(py::wrapper::Windows::UI::Input::Spatial::SpatialInteractionControllerProperties* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Input.Spatial.SpatialInteractionControllerProperties", L"TouchpadY");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.TouchpadY());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_SpatialInteractionControllerProperties(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::Input::Spatial::SpatialInteractionControllerProperties>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_SpatialInteractionControllerProperties(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Input::Spatial::SpatialInteractionControllerProperties>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_SpatialInteractionControllerProperties[] = {
        { "_assign_array_", _assign_array_SpatialInteractionControllerProperties, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_SpatialInteractionControllerProperties), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_SpatialInteractionControllerProperties[] = {
        { "is_thumbstick_pressed", reinterpret_cast<getter>(SpatialInteractionControllerProperties_get_IsThumbstickPressed), nullptr, nullptr, nullptr },
        { "is_touchpad_pressed", reinterpret_cast<getter>(SpatialInteractionControllerProperties_get_IsTouchpadPressed), nullptr, nullptr, nullptr },
        { "is_touchpad_touched", reinterpret_cast<getter>(SpatialInteractionControllerProperties_get_IsTouchpadTouched), nullptr, nullptr, nullptr },
        { "thumbstick_x", reinterpret_cast<getter>(SpatialInteractionControllerProperties_get_ThumbstickX), nullptr, nullptr, nullptr },
        { "thumbstick_y", reinterpret_cast<getter>(SpatialInteractionControllerProperties_get_ThumbstickY), nullptr, nullptr, nullptr },
        { "touchpad_x", reinterpret_cast<getter>(SpatialInteractionControllerProperties_get_TouchpadX), nullptr, nullptr, nullptr },
        { "touchpad_y", reinterpret_cast<getter>(SpatialInteractionControllerProperties_get_TouchpadY), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_SpatialInteractionControllerProperties[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_SpatialInteractionControllerProperties) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_SpatialInteractionControllerProperties) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_SpatialInteractionControllerProperties) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_SpatialInteractionControllerProperties) },
        { }
    };

    static PyType_Spec type_spec_SpatialInteractionControllerProperties = {
        "winrt._winrt_windows_ui_input_spatial.SpatialInteractionControllerProperties",
        sizeof(py::wrapper::Windows::UI::Input::Spatial::SpatialInteractionControllerProperties),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_SpatialInteractionControllerProperties};

    // ----- SpatialInteractionDetectedEventArgs class --------------------

    static PyObject* _new_SpatialInteractionDetectedEventArgs(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::UI::Input::Spatial::SpatialInteractionDetectedEventArgs>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::UI::Input::Spatial::SpatialInteractionDetectedEventArgs>::type_name);
        return nullptr;
    }

    static void _dealloc_SpatialInteractionDetectedEventArgs(py::wrapper::Windows::UI::Input::Spatial::SpatialInteractionDetectedEventArgs* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* SpatialInteractionDetectedEventArgs_TryGetPointerPose(py::wrapper::Windows::UI::Input::Spatial::SpatialInteractionDetectedEventArgs* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Input.Spatial.SpatialInteractionDetectedEventArgs", L"TryGetPointerPose", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Perception::Spatial::SpatialCoordinateSystem>(args, 0);

                return py::convert(self->obj.TryGetPointerPose(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* SpatialInteractionDetectedEventArgs_get_Interaction(py::wrapper::Windows::UI::Input::Spatial::SpatialInteractionDetectedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Input.Spatial.SpatialInteractionDetectedEventArgs", L"Interaction");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Interaction());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SpatialInteractionDetectedEventArgs_get_InteractionSourceKind(py::wrapper::Windows::UI::Input::Spatial::SpatialInteractionDetectedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Input.Spatial.SpatialInteractionDetectedEventArgs", L"InteractionSourceKind");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.InteractionSourceKind());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SpatialInteractionDetectedEventArgs_get_InteractionSource(py::wrapper::Windows::UI::Input::Spatial::SpatialInteractionDetectedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Input.Spatial.SpatialInteractionDetectedEventArgs", L"InteractionSource");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.InteractionSource());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_SpatialInteractionDetectedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::Input::Spatial::SpatialInteractionDetectedEventArgs>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_SpatialInteractionDetectedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Input::Spatial::SpatialInteractionDetectedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_SpatialInteractionDetectedEventArgs[] = {
        { "try_get_pointer_pose", reinterpret_cast<PyCFunction>(SpatialInteractionDetectedEventArgs_TryGetPointerPose), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_SpatialInteractionDetectedEventArgs, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_SpatialInteractionDetectedEventArgs), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_SpatialInteractionDetectedEventArgs[] = {
        { "interaction", reinterpret_cast<getter>(SpatialInteractionDetectedEventArgs_get_Interaction), nullptr, nullptr, nullptr },
        { "interaction_source_kind", reinterpret_cast<getter>(SpatialInteractionDetectedEventArgs_get_InteractionSourceKind), nullptr, nullptr, nullptr },
        { "interaction_source", reinterpret_cast<getter>(SpatialInteractionDetectedEventArgs_get_InteractionSource), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_SpatialInteractionDetectedEventArgs[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_SpatialInteractionDetectedEventArgs) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_SpatialInteractionDetectedEventArgs) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_SpatialInteractionDetectedEventArgs) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_SpatialInteractionDetectedEventArgs) },
        { }
    };

    static PyType_Spec type_spec_SpatialInteractionDetectedEventArgs = {
        "winrt._winrt_windows_ui_input_spatial.SpatialInteractionDetectedEventArgs",
        sizeof(py::wrapper::Windows::UI::Input::Spatial::SpatialInteractionDetectedEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_SpatialInteractionDetectedEventArgs};

    // ----- SpatialInteractionManager class --------------------

    static PyObject* _new_SpatialInteractionManager(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::UI::Input::Spatial::SpatialInteractionManager>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::UI::Input::Spatial::SpatialInteractionManager>::type_name);
        return nullptr;
    }

    static void _dealloc_SpatialInteractionManager(py::wrapper::Windows::UI::Input::Spatial::SpatialInteractionManager* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* SpatialInteractionManager_GetDetectedSourcesAtTimestamp(py::wrapper::Windows::UI::Input::Spatial::SpatialInteractionManager* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Input.Spatial.SpatialInteractionManager", L"GetDetectedSourcesAtTimestamp", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Perception::PerceptionTimestamp>(args, 0);

                return py::convert(self->obj.GetDetectedSourcesAtTimestamp(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* SpatialInteractionManager_GetForCurrentView(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Input.Spatial.SpatialInteractionManager", L"GetForCurrentView", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert(winrt::Windows::UI::Input::Spatial::SpatialInteractionManager::GetForCurrentView());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* SpatialInteractionManager_IsSourceKindSupported(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Input.Spatial.SpatialInteractionManager", L"IsSourceKindSupported", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::UI::Input::Spatial::SpatialInteractionSourceKind>(args, 0);

                return py::convert(winrt::Windows::UI::Input::Spatial::SpatialInteractionManager::IsSourceKindSupported(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* SpatialInteractionManager_add_InteractionDetected(py::wrapper::Windows::UI::Input::Spatial::SpatialInteractionManager* self, PyObject* arg) noexcept
    {
        try
        {
            static std::optional<bool> is_event_present{};

            if (!is_event_present.has_value())
            {
                is_event_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.UI.Input.Spatial.SpatialInteractionManager", L"InteractionDetected");
            }

            if (!is_event_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::UI::Input::Spatial::SpatialInteractionManager, winrt::Windows::UI::Input::Spatial::SpatialInteractionDetectedEventArgs>>(arg);

            return py::convert(self->obj.InteractionDetected(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SpatialInteractionManager_remove_InteractionDetected(py::wrapper::Windows::UI::Input::Spatial::SpatialInteractionManager* self, PyObject* arg) noexcept
    {
        try
        {
            static std::optional<bool> is_event_present{};

            if (!is_event_present.has_value())
            {
                is_event_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.UI.Input.Spatial.SpatialInteractionManager", L"InteractionDetected");
            }

            if (!is_event_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.InteractionDetected(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SpatialInteractionManager_add_SourceDetected(py::wrapper::Windows::UI::Input::Spatial::SpatialInteractionManager* self, PyObject* arg) noexcept
    {
        try
        {
            static std::optional<bool> is_event_present{};

            if (!is_event_present.has_value())
            {
                is_event_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.UI.Input.Spatial.SpatialInteractionManager", L"SourceDetected");
            }

            if (!is_event_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::UI::Input::Spatial::SpatialInteractionManager, winrt::Windows::UI::Input::Spatial::SpatialInteractionSourceEventArgs>>(arg);

            return py::convert(self->obj.SourceDetected(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SpatialInteractionManager_remove_SourceDetected(py::wrapper::Windows::UI::Input::Spatial::SpatialInteractionManager* self, PyObject* arg) noexcept
    {
        try
        {
            static std::optional<bool> is_event_present{};

            if (!is_event_present.has_value())
            {
                is_event_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.UI.Input.Spatial.SpatialInteractionManager", L"SourceDetected");
            }

            if (!is_event_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.SourceDetected(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SpatialInteractionManager_add_SourceLost(py::wrapper::Windows::UI::Input::Spatial::SpatialInteractionManager* self, PyObject* arg) noexcept
    {
        try
        {
            static std::optional<bool> is_event_present{};

            if (!is_event_present.has_value())
            {
                is_event_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.UI.Input.Spatial.SpatialInteractionManager", L"SourceLost");
            }

            if (!is_event_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::UI::Input::Spatial::SpatialInteractionManager, winrt::Windows::UI::Input::Spatial::SpatialInteractionSourceEventArgs>>(arg);

            return py::convert(self->obj.SourceLost(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SpatialInteractionManager_remove_SourceLost(py::wrapper::Windows::UI::Input::Spatial::SpatialInteractionManager* self, PyObject* arg) noexcept
    {
        try
        {
            static std::optional<bool> is_event_present{};

            if (!is_event_present.has_value())
            {
                is_event_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.UI.Input.Spatial.SpatialInteractionManager", L"SourceLost");
            }

            if (!is_event_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.SourceLost(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SpatialInteractionManager_add_SourcePressed(py::wrapper::Windows::UI::Input::Spatial::SpatialInteractionManager* self, PyObject* arg) noexcept
    {
        try
        {
            static std::optional<bool> is_event_present{};

            if (!is_event_present.has_value())
            {
                is_event_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.UI.Input.Spatial.SpatialInteractionManager", L"SourcePressed");
            }

            if (!is_event_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::UI::Input::Spatial::SpatialInteractionManager, winrt::Windows::UI::Input::Spatial::SpatialInteractionSourceEventArgs>>(arg);

            return py::convert(self->obj.SourcePressed(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SpatialInteractionManager_remove_SourcePressed(py::wrapper::Windows::UI::Input::Spatial::SpatialInteractionManager* self, PyObject* arg) noexcept
    {
        try
        {
            static std::optional<bool> is_event_present{};

            if (!is_event_present.has_value())
            {
                is_event_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.UI.Input.Spatial.SpatialInteractionManager", L"SourcePressed");
            }

            if (!is_event_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.SourcePressed(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SpatialInteractionManager_add_SourceReleased(py::wrapper::Windows::UI::Input::Spatial::SpatialInteractionManager* self, PyObject* arg) noexcept
    {
        try
        {
            static std::optional<bool> is_event_present{};

            if (!is_event_present.has_value())
            {
                is_event_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.UI.Input.Spatial.SpatialInteractionManager", L"SourceReleased");
            }

            if (!is_event_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::UI::Input::Spatial::SpatialInteractionManager, winrt::Windows::UI::Input::Spatial::SpatialInteractionSourceEventArgs>>(arg);

            return py::convert(self->obj.SourceReleased(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SpatialInteractionManager_remove_SourceReleased(py::wrapper::Windows::UI::Input::Spatial::SpatialInteractionManager* self, PyObject* arg) noexcept
    {
        try
        {
            static std::optional<bool> is_event_present{};

            if (!is_event_present.has_value())
            {
                is_event_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.UI.Input.Spatial.SpatialInteractionManager", L"SourceReleased");
            }

            if (!is_event_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.SourceReleased(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SpatialInteractionManager_add_SourceUpdated(py::wrapper::Windows::UI::Input::Spatial::SpatialInteractionManager* self, PyObject* arg) noexcept
    {
        try
        {
            static std::optional<bool> is_event_present{};

            if (!is_event_present.has_value())
            {
                is_event_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.UI.Input.Spatial.SpatialInteractionManager", L"SourceUpdated");
            }

            if (!is_event_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::UI::Input::Spatial::SpatialInteractionManager, winrt::Windows::UI::Input::Spatial::SpatialInteractionSourceEventArgs>>(arg);

            return py::convert(self->obj.SourceUpdated(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SpatialInteractionManager_remove_SourceUpdated(py::wrapper::Windows::UI::Input::Spatial::SpatialInteractionManager* self, PyObject* arg) noexcept
    {
        try
        {
            static std::optional<bool> is_event_present{};

            if (!is_event_present.has_value())
            {
                is_event_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.UI.Input.Spatial.SpatialInteractionManager", L"SourceUpdated");
            }

            if (!is_event_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.SourceUpdated(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_SpatialInteractionManager(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::Input::Spatial::SpatialInteractionManager>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_SpatialInteractionManager(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Input::Spatial::SpatialInteractionManager>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_SpatialInteractionManager[] = {
        { "get_detected_sources_at_timestamp", reinterpret_cast<PyCFunction>(SpatialInteractionManager_GetDetectedSourcesAtTimestamp), METH_VARARGS, nullptr },
        { "add_interaction_detected", reinterpret_cast<PyCFunction>(SpatialInteractionManager_add_InteractionDetected), METH_O, nullptr },
        { "remove_interaction_detected", reinterpret_cast<PyCFunction>(SpatialInteractionManager_remove_InteractionDetected), METH_O, nullptr },
        { "add_source_detected", reinterpret_cast<PyCFunction>(SpatialInteractionManager_add_SourceDetected), METH_O, nullptr },
        { "remove_source_detected", reinterpret_cast<PyCFunction>(SpatialInteractionManager_remove_SourceDetected), METH_O, nullptr },
        { "add_source_lost", reinterpret_cast<PyCFunction>(SpatialInteractionManager_add_SourceLost), METH_O, nullptr },
        { "remove_source_lost", reinterpret_cast<PyCFunction>(SpatialInteractionManager_remove_SourceLost), METH_O, nullptr },
        { "add_source_pressed", reinterpret_cast<PyCFunction>(SpatialInteractionManager_add_SourcePressed), METH_O, nullptr },
        { "remove_source_pressed", reinterpret_cast<PyCFunction>(SpatialInteractionManager_remove_SourcePressed), METH_O, nullptr },
        { "add_source_released", reinterpret_cast<PyCFunction>(SpatialInteractionManager_add_SourceReleased), METH_O, nullptr },
        { "remove_source_released", reinterpret_cast<PyCFunction>(SpatialInteractionManager_remove_SourceReleased), METH_O, nullptr },
        { "add_source_updated", reinterpret_cast<PyCFunction>(SpatialInteractionManager_add_SourceUpdated), METH_O, nullptr },
        { "remove_source_updated", reinterpret_cast<PyCFunction>(SpatialInteractionManager_remove_SourceUpdated), METH_O, nullptr },
        { "_assign_array_", _assign_array_SpatialInteractionManager, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_SpatialInteractionManager), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_SpatialInteractionManager[] = {
        { }
    };

    static PyType_Slot _type_slots_SpatialInteractionManager[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_SpatialInteractionManager) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_SpatialInteractionManager) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_SpatialInteractionManager) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_SpatialInteractionManager) },
        { }
    };

    static PyType_Spec type_spec_SpatialInteractionManager = {
        "winrt._winrt_windows_ui_input_spatial.SpatialInteractionManager",
        sizeof(py::wrapper::Windows::UI::Input::Spatial::SpatialInteractionManager),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_SpatialInteractionManager};

    static PyGetSetDef getset_SpatialInteractionManager_Static[] = {
        { }
    };

    static PyMethodDef methods_SpatialInteractionManager_Static[] = {
        { "get_for_current_view", reinterpret_cast<PyCFunction>(SpatialInteractionManager_GetForCurrentView), METH_VARARGS, nullptr },
        { "is_source_kind_supported", reinterpret_cast<PyCFunction>(SpatialInteractionManager_IsSourceKindSupported), METH_VARARGS, nullptr },
        { }
    };

    static PyType_Slot type_slots_SpatialInteractionManager_Static[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_SpatialInteractionManager_Static) },
        { Py_tp_methods, reinterpret_cast<void*>(methods_SpatialInteractionManager_Static) },
        { }
    };

    static PyType_Spec type_spec_SpatialInteractionManager_Static =
    {
        "winrt._winrt_windows_ui_input_spatial.SpatialInteractionManager_Static",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT,
        type_slots_SpatialInteractionManager_Static
    };

    // ----- SpatialInteractionSource class --------------------

    static PyObject* _new_SpatialInteractionSource(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::UI::Input::Spatial::SpatialInteractionSource>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::UI::Input::Spatial::SpatialInteractionSource>::type_name);
        return nullptr;
    }

    static void _dealloc_SpatialInteractionSource(py::wrapper::Windows::UI::Input::Spatial::SpatialInteractionSource* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* SpatialInteractionSource_TryCreateHandMeshObserver(py::wrapper::Windows::UI::Input::Spatial::SpatialInteractionSource* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Input.Spatial.SpatialInteractionSource", L"TryCreateHandMeshObserver", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert(self->obj.TryCreateHandMeshObserver());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* SpatialInteractionSource_TryCreateHandMeshObserverAsync(py::wrapper::Windows::UI::Input::Spatial::SpatialInteractionSource* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Input.Spatial.SpatialInteractionSource", L"TryCreateHandMeshObserverAsync", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert(self->obj.TryCreateHandMeshObserverAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* SpatialInteractionSource_TryGetStateAtTimestamp(py::wrapper::Windows::UI::Input::Spatial::SpatialInteractionSource* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Input.Spatial.SpatialInteractionSource", L"TryGetStateAtTimestamp", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Perception::PerceptionTimestamp>(args, 0);

                return py::convert(self->obj.TryGetStateAtTimestamp(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* SpatialInteractionSource_get_Id(py::wrapper::Windows::UI::Input::Spatial::SpatialInteractionSource* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Input.Spatial.SpatialInteractionSource", L"Id");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Id());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SpatialInteractionSource_get_Kind(py::wrapper::Windows::UI::Input::Spatial::SpatialInteractionSource* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Input.Spatial.SpatialInteractionSource", L"Kind");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Kind());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SpatialInteractionSource_get_Controller(py::wrapper::Windows::UI::Input::Spatial::SpatialInteractionSource* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Input.Spatial.SpatialInteractionSource", L"Controller");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Controller());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SpatialInteractionSource_get_IsGraspSupported(py::wrapper::Windows::UI::Input::Spatial::SpatialInteractionSource* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Input.Spatial.SpatialInteractionSource", L"IsGraspSupported");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.IsGraspSupported());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SpatialInteractionSource_get_IsMenuSupported(py::wrapper::Windows::UI::Input::Spatial::SpatialInteractionSource* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Input.Spatial.SpatialInteractionSource", L"IsMenuSupported");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.IsMenuSupported());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SpatialInteractionSource_get_IsPointingSupported(py::wrapper::Windows::UI::Input::Spatial::SpatialInteractionSource* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Input.Spatial.SpatialInteractionSource", L"IsPointingSupported");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.IsPointingSupported());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SpatialInteractionSource_get_Handedness(py::wrapper::Windows::UI::Input::Spatial::SpatialInteractionSource* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Input.Spatial.SpatialInteractionSource", L"Handedness");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Handedness());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_SpatialInteractionSource(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::Input::Spatial::SpatialInteractionSource>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_SpatialInteractionSource(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Input::Spatial::SpatialInteractionSource>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_SpatialInteractionSource[] = {
        { "try_create_hand_mesh_observer", reinterpret_cast<PyCFunction>(SpatialInteractionSource_TryCreateHandMeshObserver), METH_VARARGS, nullptr },
        { "try_create_hand_mesh_observer_async", reinterpret_cast<PyCFunction>(SpatialInteractionSource_TryCreateHandMeshObserverAsync), METH_VARARGS, nullptr },
        { "try_get_state_at_timestamp", reinterpret_cast<PyCFunction>(SpatialInteractionSource_TryGetStateAtTimestamp), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_SpatialInteractionSource, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_SpatialInteractionSource), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_SpatialInteractionSource[] = {
        { "id", reinterpret_cast<getter>(SpatialInteractionSource_get_Id), nullptr, nullptr, nullptr },
        { "kind", reinterpret_cast<getter>(SpatialInteractionSource_get_Kind), nullptr, nullptr, nullptr },
        { "controller", reinterpret_cast<getter>(SpatialInteractionSource_get_Controller), nullptr, nullptr, nullptr },
        { "is_grasp_supported", reinterpret_cast<getter>(SpatialInteractionSource_get_IsGraspSupported), nullptr, nullptr, nullptr },
        { "is_menu_supported", reinterpret_cast<getter>(SpatialInteractionSource_get_IsMenuSupported), nullptr, nullptr, nullptr },
        { "is_pointing_supported", reinterpret_cast<getter>(SpatialInteractionSource_get_IsPointingSupported), nullptr, nullptr, nullptr },
        { "handedness", reinterpret_cast<getter>(SpatialInteractionSource_get_Handedness), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_SpatialInteractionSource[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_SpatialInteractionSource) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_SpatialInteractionSource) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_SpatialInteractionSource) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_SpatialInteractionSource) },
        { }
    };

    static PyType_Spec type_spec_SpatialInteractionSource = {
        "winrt._winrt_windows_ui_input_spatial.SpatialInteractionSource",
        sizeof(py::wrapper::Windows::UI::Input::Spatial::SpatialInteractionSource),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_SpatialInteractionSource};

    // ----- SpatialInteractionSourceEventArgs class --------------------

    static PyObject* _new_SpatialInteractionSourceEventArgs(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::UI::Input::Spatial::SpatialInteractionSourceEventArgs>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::UI::Input::Spatial::SpatialInteractionSourceEventArgs>::type_name);
        return nullptr;
    }

    static void _dealloc_SpatialInteractionSourceEventArgs(py::wrapper::Windows::UI::Input::Spatial::SpatialInteractionSourceEventArgs* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* SpatialInteractionSourceEventArgs_get_State(py::wrapper::Windows::UI::Input::Spatial::SpatialInteractionSourceEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Input.Spatial.SpatialInteractionSourceEventArgs", L"State");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.State());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SpatialInteractionSourceEventArgs_get_PressKind(py::wrapper::Windows::UI::Input::Spatial::SpatialInteractionSourceEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Input.Spatial.SpatialInteractionSourceEventArgs", L"PressKind");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.PressKind());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_SpatialInteractionSourceEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::Input::Spatial::SpatialInteractionSourceEventArgs>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_SpatialInteractionSourceEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Input::Spatial::SpatialInteractionSourceEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_SpatialInteractionSourceEventArgs[] = {
        { "_assign_array_", _assign_array_SpatialInteractionSourceEventArgs, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_SpatialInteractionSourceEventArgs), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_SpatialInteractionSourceEventArgs[] = {
        { "state", reinterpret_cast<getter>(SpatialInteractionSourceEventArgs_get_State), nullptr, nullptr, nullptr },
        { "press_kind", reinterpret_cast<getter>(SpatialInteractionSourceEventArgs_get_PressKind), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_SpatialInteractionSourceEventArgs[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_SpatialInteractionSourceEventArgs) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_SpatialInteractionSourceEventArgs) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_SpatialInteractionSourceEventArgs) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_SpatialInteractionSourceEventArgs) },
        { }
    };

    static PyType_Spec type_spec_SpatialInteractionSourceEventArgs = {
        "winrt._winrt_windows_ui_input_spatial.SpatialInteractionSourceEventArgs",
        sizeof(py::wrapper::Windows::UI::Input::Spatial::SpatialInteractionSourceEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_SpatialInteractionSourceEventArgs};

    // ----- SpatialInteractionSourceLocation class --------------------

    static PyObject* _new_SpatialInteractionSourceLocation(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::UI::Input::Spatial::SpatialInteractionSourceLocation>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::UI::Input::Spatial::SpatialInteractionSourceLocation>::type_name);
        return nullptr;
    }

    static void _dealloc_SpatialInteractionSourceLocation(py::wrapper::Windows::UI::Input::Spatial::SpatialInteractionSourceLocation* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* SpatialInteractionSourceLocation_get_Position(py::wrapper::Windows::UI::Input::Spatial::SpatialInteractionSourceLocation* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Input.Spatial.SpatialInteractionSourceLocation", L"Position");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Position());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SpatialInteractionSourceLocation_get_Velocity(py::wrapper::Windows::UI::Input::Spatial::SpatialInteractionSourceLocation* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Input.Spatial.SpatialInteractionSourceLocation", L"Velocity");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Velocity());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SpatialInteractionSourceLocation_get_Orientation(py::wrapper::Windows::UI::Input::Spatial::SpatialInteractionSourceLocation* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Input.Spatial.SpatialInteractionSourceLocation", L"Orientation");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Orientation());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SpatialInteractionSourceLocation_get_AngularVelocity(py::wrapper::Windows::UI::Input::Spatial::SpatialInteractionSourceLocation* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Input.Spatial.SpatialInteractionSourceLocation", L"AngularVelocity");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.AngularVelocity());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SpatialInteractionSourceLocation_get_PositionAccuracy(py::wrapper::Windows::UI::Input::Spatial::SpatialInteractionSourceLocation* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Input.Spatial.SpatialInteractionSourceLocation", L"PositionAccuracy");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.PositionAccuracy());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SpatialInteractionSourceLocation_get_SourcePointerPose(py::wrapper::Windows::UI::Input::Spatial::SpatialInteractionSourceLocation* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Input.Spatial.SpatialInteractionSourceLocation", L"SourcePointerPose");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.SourcePointerPose());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_SpatialInteractionSourceLocation(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::Input::Spatial::SpatialInteractionSourceLocation>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_SpatialInteractionSourceLocation(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Input::Spatial::SpatialInteractionSourceLocation>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_SpatialInteractionSourceLocation[] = {
        { "_assign_array_", _assign_array_SpatialInteractionSourceLocation, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_SpatialInteractionSourceLocation), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_SpatialInteractionSourceLocation[] = {
        { "position", reinterpret_cast<getter>(SpatialInteractionSourceLocation_get_Position), nullptr, nullptr, nullptr },
        { "velocity", reinterpret_cast<getter>(SpatialInteractionSourceLocation_get_Velocity), nullptr, nullptr, nullptr },
        { "orientation", reinterpret_cast<getter>(SpatialInteractionSourceLocation_get_Orientation), nullptr, nullptr, nullptr },
        { "angular_velocity", reinterpret_cast<getter>(SpatialInteractionSourceLocation_get_AngularVelocity), nullptr, nullptr, nullptr },
        { "position_accuracy", reinterpret_cast<getter>(SpatialInteractionSourceLocation_get_PositionAccuracy), nullptr, nullptr, nullptr },
        { "source_pointer_pose", reinterpret_cast<getter>(SpatialInteractionSourceLocation_get_SourcePointerPose), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_SpatialInteractionSourceLocation[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_SpatialInteractionSourceLocation) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_SpatialInteractionSourceLocation) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_SpatialInteractionSourceLocation) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_SpatialInteractionSourceLocation) },
        { }
    };

    static PyType_Spec type_spec_SpatialInteractionSourceLocation = {
        "winrt._winrt_windows_ui_input_spatial.SpatialInteractionSourceLocation",
        sizeof(py::wrapper::Windows::UI::Input::Spatial::SpatialInteractionSourceLocation),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_SpatialInteractionSourceLocation};

    // ----- SpatialInteractionSourceProperties class --------------------

    static PyObject* _new_SpatialInteractionSourceProperties(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::UI::Input::Spatial::SpatialInteractionSourceProperties>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::UI::Input::Spatial::SpatialInteractionSourceProperties>::type_name);
        return nullptr;
    }

    static void _dealloc_SpatialInteractionSourceProperties(py::wrapper::Windows::UI::Input::Spatial::SpatialInteractionSourceProperties* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* SpatialInteractionSourceProperties_TryGetLocation(py::wrapper::Windows::UI::Input::Spatial::SpatialInteractionSourceProperties* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Input.Spatial.SpatialInteractionSourceProperties", L"TryGetLocation", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Perception::Spatial::SpatialCoordinateSystem>(args, 0);

                return py::convert(self->obj.TryGetLocation(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* SpatialInteractionSourceProperties_TryGetSourceLossMitigationDirection(py::wrapper::Windows::UI::Input::Spatial::SpatialInteractionSourceProperties* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Input.Spatial.SpatialInteractionSourceProperties", L"TryGetSourceLossMitigationDirection", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Perception::Spatial::SpatialCoordinateSystem>(args, 0);

                return py::convert(self->obj.TryGetSourceLossMitigationDirection(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* SpatialInteractionSourceProperties_get_SourceLossRisk(py::wrapper::Windows::UI::Input::Spatial::SpatialInteractionSourceProperties* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Input.Spatial.SpatialInteractionSourceProperties", L"SourceLossRisk");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.SourceLossRisk());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_SpatialInteractionSourceProperties(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::Input::Spatial::SpatialInteractionSourceProperties>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_SpatialInteractionSourceProperties(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Input::Spatial::SpatialInteractionSourceProperties>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_SpatialInteractionSourceProperties[] = {
        { "try_get_location", reinterpret_cast<PyCFunction>(SpatialInteractionSourceProperties_TryGetLocation), METH_VARARGS, nullptr },
        { "try_get_source_loss_mitigation_direction", reinterpret_cast<PyCFunction>(SpatialInteractionSourceProperties_TryGetSourceLossMitigationDirection), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_SpatialInteractionSourceProperties, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_SpatialInteractionSourceProperties), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_SpatialInteractionSourceProperties[] = {
        { "source_loss_risk", reinterpret_cast<getter>(SpatialInteractionSourceProperties_get_SourceLossRisk), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_SpatialInteractionSourceProperties[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_SpatialInteractionSourceProperties) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_SpatialInteractionSourceProperties) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_SpatialInteractionSourceProperties) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_SpatialInteractionSourceProperties) },
        { }
    };

    static PyType_Spec type_spec_SpatialInteractionSourceProperties = {
        "winrt._winrt_windows_ui_input_spatial.SpatialInteractionSourceProperties",
        sizeof(py::wrapper::Windows::UI::Input::Spatial::SpatialInteractionSourceProperties),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_SpatialInteractionSourceProperties};

    // ----- SpatialInteractionSourceState class --------------------

    static PyObject* _new_SpatialInteractionSourceState(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::UI::Input::Spatial::SpatialInteractionSourceState>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::UI::Input::Spatial::SpatialInteractionSourceState>::type_name);
        return nullptr;
    }

    static void _dealloc_SpatialInteractionSourceState(py::wrapper::Windows::UI::Input::Spatial::SpatialInteractionSourceState* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* SpatialInteractionSourceState_TryGetHandPose(py::wrapper::Windows::UI::Input::Spatial::SpatialInteractionSourceState* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Input.Spatial.SpatialInteractionSourceState", L"TryGetHandPose", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert(self->obj.TryGetHandPose());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* SpatialInteractionSourceState_TryGetPointerPose(py::wrapper::Windows::UI::Input::Spatial::SpatialInteractionSourceState* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Input.Spatial.SpatialInteractionSourceState", L"TryGetPointerPose", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Perception::Spatial::SpatialCoordinateSystem>(args, 0);

                return py::convert(self->obj.TryGetPointerPose(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* SpatialInteractionSourceState_get_IsPressed(py::wrapper::Windows::UI::Input::Spatial::SpatialInteractionSourceState* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Input.Spatial.SpatialInteractionSourceState", L"IsPressed");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.IsPressed());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SpatialInteractionSourceState_get_Properties(py::wrapper::Windows::UI::Input::Spatial::SpatialInteractionSourceState* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Input.Spatial.SpatialInteractionSourceState", L"Properties");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Properties());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SpatialInteractionSourceState_get_Source(py::wrapper::Windows::UI::Input::Spatial::SpatialInteractionSourceState* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Input.Spatial.SpatialInteractionSourceState", L"Source");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Source());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SpatialInteractionSourceState_get_Timestamp(py::wrapper::Windows::UI::Input::Spatial::SpatialInteractionSourceState* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Input.Spatial.SpatialInteractionSourceState", L"Timestamp");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Timestamp());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SpatialInteractionSourceState_get_ControllerProperties(py::wrapper::Windows::UI::Input::Spatial::SpatialInteractionSourceState* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Input.Spatial.SpatialInteractionSourceState", L"ControllerProperties");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.ControllerProperties());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SpatialInteractionSourceState_get_IsGrasped(py::wrapper::Windows::UI::Input::Spatial::SpatialInteractionSourceState* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Input.Spatial.SpatialInteractionSourceState", L"IsGrasped");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.IsGrasped());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SpatialInteractionSourceState_get_IsMenuPressed(py::wrapper::Windows::UI::Input::Spatial::SpatialInteractionSourceState* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Input.Spatial.SpatialInteractionSourceState", L"IsMenuPressed");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.IsMenuPressed());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SpatialInteractionSourceState_get_IsSelectPressed(py::wrapper::Windows::UI::Input::Spatial::SpatialInteractionSourceState* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Input.Spatial.SpatialInteractionSourceState", L"IsSelectPressed");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.IsSelectPressed());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SpatialInteractionSourceState_get_SelectPressedValue(py::wrapper::Windows::UI::Input::Spatial::SpatialInteractionSourceState* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Input.Spatial.SpatialInteractionSourceState", L"SelectPressedValue");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.SelectPressedValue());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_SpatialInteractionSourceState(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::Input::Spatial::SpatialInteractionSourceState>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_SpatialInteractionSourceState(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Input::Spatial::SpatialInteractionSourceState>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_SpatialInteractionSourceState[] = {
        { "try_get_hand_pose", reinterpret_cast<PyCFunction>(SpatialInteractionSourceState_TryGetHandPose), METH_VARARGS, nullptr },
        { "try_get_pointer_pose", reinterpret_cast<PyCFunction>(SpatialInteractionSourceState_TryGetPointerPose), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_SpatialInteractionSourceState, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_SpatialInteractionSourceState), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_SpatialInteractionSourceState[] = {
        { "is_pressed", reinterpret_cast<getter>(SpatialInteractionSourceState_get_IsPressed), nullptr, nullptr, nullptr },
        { "properties", reinterpret_cast<getter>(SpatialInteractionSourceState_get_Properties), nullptr, nullptr, nullptr },
        { "source", reinterpret_cast<getter>(SpatialInteractionSourceState_get_Source), nullptr, nullptr, nullptr },
        { "timestamp", reinterpret_cast<getter>(SpatialInteractionSourceState_get_Timestamp), nullptr, nullptr, nullptr },
        { "controller_properties", reinterpret_cast<getter>(SpatialInteractionSourceState_get_ControllerProperties), nullptr, nullptr, nullptr },
        { "is_grasped", reinterpret_cast<getter>(SpatialInteractionSourceState_get_IsGrasped), nullptr, nullptr, nullptr },
        { "is_menu_pressed", reinterpret_cast<getter>(SpatialInteractionSourceState_get_IsMenuPressed), nullptr, nullptr, nullptr },
        { "is_select_pressed", reinterpret_cast<getter>(SpatialInteractionSourceState_get_IsSelectPressed), nullptr, nullptr, nullptr },
        { "select_pressed_value", reinterpret_cast<getter>(SpatialInteractionSourceState_get_SelectPressedValue), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_SpatialInteractionSourceState[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_SpatialInteractionSourceState) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_SpatialInteractionSourceState) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_SpatialInteractionSourceState) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_SpatialInteractionSourceState) },
        { }
    };

    static PyType_Spec type_spec_SpatialInteractionSourceState = {
        "winrt._winrt_windows_ui_input_spatial.SpatialInteractionSourceState",
        sizeof(py::wrapper::Windows::UI::Input::Spatial::SpatialInteractionSourceState),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_SpatialInteractionSourceState};

    // ----- SpatialManipulationCanceledEventArgs class --------------------

    static PyObject* _new_SpatialManipulationCanceledEventArgs(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::UI::Input::Spatial::SpatialManipulationCanceledEventArgs>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::UI::Input::Spatial::SpatialManipulationCanceledEventArgs>::type_name);
        return nullptr;
    }

    static void _dealloc_SpatialManipulationCanceledEventArgs(py::wrapper::Windows::UI::Input::Spatial::SpatialManipulationCanceledEventArgs* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* SpatialManipulationCanceledEventArgs_get_InteractionSourceKind(py::wrapper::Windows::UI::Input::Spatial::SpatialManipulationCanceledEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Input.Spatial.SpatialManipulationCanceledEventArgs", L"InteractionSourceKind");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.InteractionSourceKind());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_SpatialManipulationCanceledEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::Input::Spatial::SpatialManipulationCanceledEventArgs>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_SpatialManipulationCanceledEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Input::Spatial::SpatialManipulationCanceledEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_SpatialManipulationCanceledEventArgs[] = {
        { "_assign_array_", _assign_array_SpatialManipulationCanceledEventArgs, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_SpatialManipulationCanceledEventArgs), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_SpatialManipulationCanceledEventArgs[] = {
        { "interaction_source_kind", reinterpret_cast<getter>(SpatialManipulationCanceledEventArgs_get_InteractionSourceKind), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_SpatialManipulationCanceledEventArgs[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_SpatialManipulationCanceledEventArgs) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_SpatialManipulationCanceledEventArgs) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_SpatialManipulationCanceledEventArgs) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_SpatialManipulationCanceledEventArgs) },
        { }
    };

    static PyType_Spec type_spec_SpatialManipulationCanceledEventArgs = {
        "winrt._winrt_windows_ui_input_spatial.SpatialManipulationCanceledEventArgs",
        sizeof(py::wrapper::Windows::UI::Input::Spatial::SpatialManipulationCanceledEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_SpatialManipulationCanceledEventArgs};

    // ----- SpatialManipulationCompletedEventArgs class --------------------

    static PyObject* _new_SpatialManipulationCompletedEventArgs(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::UI::Input::Spatial::SpatialManipulationCompletedEventArgs>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::UI::Input::Spatial::SpatialManipulationCompletedEventArgs>::type_name);
        return nullptr;
    }

    static void _dealloc_SpatialManipulationCompletedEventArgs(py::wrapper::Windows::UI::Input::Spatial::SpatialManipulationCompletedEventArgs* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* SpatialManipulationCompletedEventArgs_TryGetCumulativeDelta(py::wrapper::Windows::UI::Input::Spatial::SpatialManipulationCompletedEventArgs* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Input.Spatial.SpatialManipulationCompletedEventArgs", L"TryGetCumulativeDelta", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Perception::Spatial::SpatialCoordinateSystem>(args, 0);

                return py::convert(self->obj.TryGetCumulativeDelta(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* SpatialManipulationCompletedEventArgs_get_InteractionSourceKind(py::wrapper::Windows::UI::Input::Spatial::SpatialManipulationCompletedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Input.Spatial.SpatialManipulationCompletedEventArgs", L"InteractionSourceKind");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.InteractionSourceKind());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_SpatialManipulationCompletedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::Input::Spatial::SpatialManipulationCompletedEventArgs>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_SpatialManipulationCompletedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Input::Spatial::SpatialManipulationCompletedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_SpatialManipulationCompletedEventArgs[] = {
        { "try_get_cumulative_delta", reinterpret_cast<PyCFunction>(SpatialManipulationCompletedEventArgs_TryGetCumulativeDelta), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_SpatialManipulationCompletedEventArgs, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_SpatialManipulationCompletedEventArgs), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_SpatialManipulationCompletedEventArgs[] = {
        { "interaction_source_kind", reinterpret_cast<getter>(SpatialManipulationCompletedEventArgs_get_InteractionSourceKind), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_SpatialManipulationCompletedEventArgs[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_SpatialManipulationCompletedEventArgs) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_SpatialManipulationCompletedEventArgs) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_SpatialManipulationCompletedEventArgs) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_SpatialManipulationCompletedEventArgs) },
        { }
    };

    static PyType_Spec type_spec_SpatialManipulationCompletedEventArgs = {
        "winrt._winrt_windows_ui_input_spatial.SpatialManipulationCompletedEventArgs",
        sizeof(py::wrapper::Windows::UI::Input::Spatial::SpatialManipulationCompletedEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_SpatialManipulationCompletedEventArgs};

    // ----- SpatialManipulationDelta class --------------------

    static PyObject* _new_SpatialManipulationDelta(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::UI::Input::Spatial::SpatialManipulationDelta>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::UI::Input::Spatial::SpatialManipulationDelta>::type_name);
        return nullptr;
    }

    static void _dealloc_SpatialManipulationDelta(py::wrapper::Windows::UI::Input::Spatial::SpatialManipulationDelta* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* SpatialManipulationDelta_get_Translation(py::wrapper::Windows::UI::Input::Spatial::SpatialManipulationDelta* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Input.Spatial.SpatialManipulationDelta", L"Translation");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Translation());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_SpatialManipulationDelta(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::Input::Spatial::SpatialManipulationDelta>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_SpatialManipulationDelta(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Input::Spatial::SpatialManipulationDelta>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_SpatialManipulationDelta[] = {
        { "_assign_array_", _assign_array_SpatialManipulationDelta, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_SpatialManipulationDelta), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_SpatialManipulationDelta[] = {
        { "translation", reinterpret_cast<getter>(SpatialManipulationDelta_get_Translation), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_SpatialManipulationDelta[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_SpatialManipulationDelta) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_SpatialManipulationDelta) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_SpatialManipulationDelta) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_SpatialManipulationDelta) },
        { }
    };

    static PyType_Spec type_spec_SpatialManipulationDelta = {
        "winrt._winrt_windows_ui_input_spatial.SpatialManipulationDelta",
        sizeof(py::wrapper::Windows::UI::Input::Spatial::SpatialManipulationDelta),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_SpatialManipulationDelta};

    // ----- SpatialManipulationStartedEventArgs class --------------------

    static PyObject* _new_SpatialManipulationStartedEventArgs(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::UI::Input::Spatial::SpatialManipulationStartedEventArgs>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::UI::Input::Spatial::SpatialManipulationStartedEventArgs>::type_name);
        return nullptr;
    }

    static void _dealloc_SpatialManipulationStartedEventArgs(py::wrapper::Windows::UI::Input::Spatial::SpatialManipulationStartedEventArgs* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* SpatialManipulationStartedEventArgs_TryGetPointerPose(py::wrapper::Windows::UI::Input::Spatial::SpatialManipulationStartedEventArgs* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Input.Spatial.SpatialManipulationStartedEventArgs", L"TryGetPointerPose", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Perception::Spatial::SpatialCoordinateSystem>(args, 0);

                return py::convert(self->obj.TryGetPointerPose(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* SpatialManipulationStartedEventArgs_get_InteractionSourceKind(py::wrapper::Windows::UI::Input::Spatial::SpatialManipulationStartedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Input.Spatial.SpatialManipulationStartedEventArgs", L"InteractionSourceKind");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.InteractionSourceKind());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_SpatialManipulationStartedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::Input::Spatial::SpatialManipulationStartedEventArgs>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_SpatialManipulationStartedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Input::Spatial::SpatialManipulationStartedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_SpatialManipulationStartedEventArgs[] = {
        { "try_get_pointer_pose", reinterpret_cast<PyCFunction>(SpatialManipulationStartedEventArgs_TryGetPointerPose), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_SpatialManipulationStartedEventArgs, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_SpatialManipulationStartedEventArgs), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_SpatialManipulationStartedEventArgs[] = {
        { "interaction_source_kind", reinterpret_cast<getter>(SpatialManipulationStartedEventArgs_get_InteractionSourceKind), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_SpatialManipulationStartedEventArgs[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_SpatialManipulationStartedEventArgs) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_SpatialManipulationStartedEventArgs) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_SpatialManipulationStartedEventArgs) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_SpatialManipulationStartedEventArgs) },
        { }
    };

    static PyType_Spec type_spec_SpatialManipulationStartedEventArgs = {
        "winrt._winrt_windows_ui_input_spatial.SpatialManipulationStartedEventArgs",
        sizeof(py::wrapper::Windows::UI::Input::Spatial::SpatialManipulationStartedEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_SpatialManipulationStartedEventArgs};

    // ----- SpatialManipulationUpdatedEventArgs class --------------------

    static PyObject* _new_SpatialManipulationUpdatedEventArgs(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::UI::Input::Spatial::SpatialManipulationUpdatedEventArgs>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::UI::Input::Spatial::SpatialManipulationUpdatedEventArgs>::type_name);
        return nullptr;
    }

    static void _dealloc_SpatialManipulationUpdatedEventArgs(py::wrapper::Windows::UI::Input::Spatial::SpatialManipulationUpdatedEventArgs* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* SpatialManipulationUpdatedEventArgs_TryGetCumulativeDelta(py::wrapper::Windows::UI::Input::Spatial::SpatialManipulationUpdatedEventArgs* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Input.Spatial.SpatialManipulationUpdatedEventArgs", L"TryGetCumulativeDelta", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Perception::Spatial::SpatialCoordinateSystem>(args, 0);

                return py::convert(self->obj.TryGetCumulativeDelta(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* SpatialManipulationUpdatedEventArgs_get_InteractionSourceKind(py::wrapper::Windows::UI::Input::Spatial::SpatialManipulationUpdatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Input.Spatial.SpatialManipulationUpdatedEventArgs", L"InteractionSourceKind");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.InteractionSourceKind());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_SpatialManipulationUpdatedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::Input::Spatial::SpatialManipulationUpdatedEventArgs>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_SpatialManipulationUpdatedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Input::Spatial::SpatialManipulationUpdatedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_SpatialManipulationUpdatedEventArgs[] = {
        { "try_get_cumulative_delta", reinterpret_cast<PyCFunction>(SpatialManipulationUpdatedEventArgs_TryGetCumulativeDelta), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_SpatialManipulationUpdatedEventArgs, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_SpatialManipulationUpdatedEventArgs), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_SpatialManipulationUpdatedEventArgs[] = {
        { "interaction_source_kind", reinterpret_cast<getter>(SpatialManipulationUpdatedEventArgs_get_InteractionSourceKind), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_SpatialManipulationUpdatedEventArgs[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_SpatialManipulationUpdatedEventArgs) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_SpatialManipulationUpdatedEventArgs) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_SpatialManipulationUpdatedEventArgs) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_SpatialManipulationUpdatedEventArgs) },
        { }
    };

    static PyType_Spec type_spec_SpatialManipulationUpdatedEventArgs = {
        "winrt._winrt_windows_ui_input_spatial.SpatialManipulationUpdatedEventArgs",
        sizeof(py::wrapper::Windows::UI::Input::Spatial::SpatialManipulationUpdatedEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_SpatialManipulationUpdatedEventArgs};

    // ----- SpatialNavigationCanceledEventArgs class --------------------

    static PyObject* _new_SpatialNavigationCanceledEventArgs(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::UI::Input::Spatial::SpatialNavigationCanceledEventArgs>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::UI::Input::Spatial::SpatialNavigationCanceledEventArgs>::type_name);
        return nullptr;
    }

    static void _dealloc_SpatialNavigationCanceledEventArgs(py::wrapper::Windows::UI::Input::Spatial::SpatialNavigationCanceledEventArgs* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* SpatialNavigationCanceledEventArgs_get_InteractionSourceKind(py::wrapper::Windows::UI::Input::Spatial::SpatialNavigationCanceledEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Input.Spatial.SpatialNavigationCanceledEventArgs", L"InteractionSourceKind");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.InteractionSourceKind());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_SpatialNavigationCanceledEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::Input::Spatial::SpatialNavigationCanceledEventArgs>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_SpatialNavigationCanceledEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Input::Spatial::SpatialNavigationCanceledEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_SpatialNavigationCanceledEventArgs[] = {
        { "_assign_array_", _assign_array_SpatialNavigationCanceledEventArgs, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_SpatialNavigationCanceledEventArgs), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_SpatialNavigationCanceledEventArgs[] = {
        { "interaction_source_kind", reinterpret_cast<getter>(SpatialNavigationCanceledEventArgs_get_InteractionSourceKind), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_SpatialNavigationCanceledEventArgs[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_SpatialNavigationCanceledEventArgs) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_SpatialNavigationCanceledEventArgs) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_SpatialNavigationCanceledEventArgs) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_SpatialNavigationCanceledEventArgs) },
        { }
    };

    static PyType_Spec type_spec_SpatialNavigationCanceledEventArgs = {
        "winrt._winrt_windows_ui_input_spatial.SpatialNavigationCanceledEventArgs",
        sizeof(py::wrapper::Windows::UI::Input::Spatial::SpatialNavigationCanceledEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_SpatialNavigationCanceledEventArgs};

    // ----- SpatialNavigationCompletedEventArgs class --------------------

    static PyObject* _new_SpatialNavigationCompletedEventArgs(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::UI::Input::Spatial::SpatialNavigationCompletedEventArgs>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::UI::Input::Spatial::SpatialNavigationCompletedEventArgs>::type_name);
        return nullptr;
    }

    static void _dealloc_SpatialNavigationCompletedEventArgs(py::wrapper::Windows::UI::Input::Spatial::SpatialNavigationCompletedEventArgs* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* SpatialNavigationCompletedEventArgs_get_InteractionSourceKind(py::wrapper::Windows::UI::Input::Spatial::SpatialNavigationCompletedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Input.Spatial.SpatialNavigationCompletedEventArgs", L"InteractionSourceKind");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.InteractionSourceKind());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SpatialNavigationCompletedEventArgs_get_NormalizedOffset(py::wrapper::Windows::UI::Input::Spatial::SpatialNavigationCompletedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Input.Spatial.SpatialNavigationCompletedEventArgs", L"NormalizedOffset");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.NormalizedOffset());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_SpatialNavigationCompletedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::Input::Spatial::SpatialNavigationCompletedEventArgs>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_SpatialNavigationCompletedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Input::Spatial::SpatialNavigationCompletedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_SpatialNavigationCompletedEventArgs[] = {
        { "_assign_array_", _assign_array_SpatialNavigationCompletedEventArgs, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_SpatialNavigationCompletedEventArgs), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_SpatialNavigationCompletedEventArgs[] = {
        { "interaction_source_kind", reinterpret_cast<getter>(SpatialNavigationCompletedEventArgs_get_InteractionSourceKind), nullptr, nullptr, nullptr },
        { "normalized_offset", reinterpret_cast<getter>(SpatialNavigationCompletedEventArgs_get_NormalizedOffset), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_SpatialNavigationCompletedEventArgs[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_SpatialNavigationCompletedEventArgs) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_SpatialNavigationCompletedEventArgs) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_SpatialNavigationCompletedEventArgs) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_SpatialNavigationCompletedEventArgs) },
        { }
    };

    static PyType_Spec type_spec_SpatialNavigationCompletedEventArgs = {
        "winrt._winrt_windows_ui_input_spatial.SpatialNavigationCompletedEventArgs",
        sizeof(py::wrapper::Windows::UI::Input::Spatial::SpatialNavigationCompletedEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_SpatialNavigationCompletedEventArgs};

    // ----- SpatialNavigationStartedEventArgs class --------------------

    static PyObject* _new_SpatialNavigationStartedEventArgs(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::UI::Input::Spatial::SpatialNavigationStartedEventArgs>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::UI::Input::Spatial::SpatialNavigationStartedEventArgs>::type_name);
        return nullptr;
    }

    static void _dealloc_SpatialNavigationStartedEventArgs(py::wrapper::Windows::UI::Input::Spatial::SpatialNavigationStartedEventArgs* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* SpatialNavigationStartedEventArgs_TryGetPointerPose(py::wrapper::Windows::UI::Input::Spatial::SpatialNavigationStartedEventArgs* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Input.Spatial.SpatialNavigationStartedEventArgs", L"TryGetPointerPose", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Perception::Spatial::SpatialCoordinateSystem>(args, 0);

                return py::convert(self->obj.TryGetPointerPose(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* SpatialNavigationStartedEventArgs_get_InteractionSourceKind(py::wrapper::Windows::UI::Input::Spatial::SpatialNavigationStartedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Input.Spatial.SpatialNavigationStartedEventArgs", L"InteractionSourceKind");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.InteractionSourceKind());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SpatialNavigationStartedEventArgs_get_IsNavigatingX(py::wrapper::Windows::UI::Input::Spatial::SpatialNavigationStartedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Input.Spatial.SpatialNavigationStartedEventArgs", L"IsNavigatingX");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.IsNavigatingX());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SpatialNavigationStartedEventArgs_get_IsNavigatingY(py::wrapper::Windows::UI::Input::Spatial::SpatialNavigationStartedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Input.Spatial.SpatialNavigationStartedEventArgs", L"IsNavigatingY");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.IsNavigatingY());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SpatialNavigationStartedEventArgs_get_IsNavigatingZ(py::wrapper::Windows::UI::Input::Spatial::SpatialNavigationStartedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Input.Spatial.SpatialNavigationStartedEventArgs", L"IsNavigatingZ");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.IsNavigatingZ());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_SpatialNavigationStartedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::Input::Spatial::SpatialNavigationStartedEventArgs>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_SpatialNavigationStartedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Input::Spatial::SpatialNavigationStartedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_SpatialNavigationStartedEventArgs[] = {
        { "try_get_pointer_pose", reinterpret_cast<PyCFunction>(SpatialNavigationStartedEventArgs_TryGetPointerPose), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_SpatialNavigationStartedEventArgs, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_SpatialNavigationStartedEventArgs), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_SpatialNavigationStartedEventArgs[] = {
        { "interaction_source_kind", reinterpret_cast<getter>(SpatialNavigationStartedEventArgs_get_InteractionSourceKind), nullptr, nullptr, nullptr },
        { "is_navigating_x", reinterpret_cast<getter>(SpatialNavigationStartedEventArgs_get_IsNavigatingX), nullptr, nullptr, nullptr },
        { "is_navigating_y", reinterpret_cast<getter>(SpatialNavigationStartedEventArgs_get_IsNavigatingY), nullptr, nullptr, nullptr },
        { "is_navigating_z", reinterpret_cast<getter>(SpatialNavigationStartedEventArgs_get_IsNavigatingZ), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_SpatialNavigationStartedEventArgs[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_SpatialNavigationStartedEventArgs) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_SpatialNavigationStartedEventArgs) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_SpatialNavigationStartedEventArgs) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_SpatialNavigationStartedEventArgs) },
        { }
    };

    static PyType_Spec type_spec_SpatialNavigationStartedEventArgs = {
        "winrt._winrt_windows_ui_input_spatial.SpatialNavigationStartedEventArgs",
        sizeof(py::wrapper::Windows::UI::Input::Spatial::SpatialNavigationStartedEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_SpatialNavigationStartedEventArgs};

    // ----- SpatialNavigationUpdatedEventArgs class --------------------

    static PyObject* _new_SpatialNavigationUpdatedEventArgs(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::UI::Input::Spatial::SpatialNavigationUpdatedEventArgs>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::UI::Input::Spatial::SpatialNavigationUpdatedEventArgs>::type_name);
        return nullptr;
    }

    static void _dealloc_SpatialNavigationUpdatedEventArgs(py::wrapper::Windows::UI::Input::Spatial::SpatialNavigationUpdatedEventArgs* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* SpatialNavigationUpdatedEventArgs_get_InteractionSourceKind(py::wrapper::Windows::UI::Input::Spatial::SpatialNavigationUpdatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Input.Spatial.SpatialNavigationUpdatedEventArgs", L"InteractionSourceKind");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.InteractionSourceKind());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SpatialNavigationUpdatedEventArgs_get_NormalizedOffset(py::wrapper::Windows::UI::Input::Spatial::SpatialNavigationUpdatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Input.Spatial.SpatialNavigationUpdatedEventArgs", L"NormalizedOffset");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.NormalizedOffset());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_SpatialNavigationUpdatedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::Input::Spatial::SpatialNavigationUpdatedEventArgs>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_SpatialNavigationUpdatedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Input::Spatial::SpatialNavigationUpdatedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_SpatialNavigationUpdatedEventArgs[] = {
        { "_assign_array_", _assign_array_SpatialNavigationUpdatedEventArgs, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_SpatialNavigationUpdatedEventArgs), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_SpatialNavigationUpdatedEventArgs[] = {
        { "interaction_source_kind", reinterpret_cast<getter>(SpatialNavigationUpdatedEventArgs_get_InteractionSourceKind), nullptr, nullptr, nullptr },
        { "normalized_offset", reinterpret_cast<getter>(SpatialNavigationUpdatedEventArgs_get_NormalizedOffset), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_SpatialNavigationUpdatedEventArgs[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_SpatialNavigationUpdatedEventArgs) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_SpatialNavigationUpdatedEventArgs) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_SpatialNavigationUpdatedEventArgs) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_SpatialNavigationUpdatedEventArgs) },
        { }
    };

    static PyType_Spec type_spec_SpatialNavigationUpdatedEventArgs = {
        "winrt._winrt_windows_ui_input_spatial.SpatialNavigationUpdatedEventArgs",
        sizeof(py::wrapper::Windows::UI::Input::Spatial::SpatialNavigationUpdatedEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_SpatialNavigationUpdatedEventArgs};

    // ----- SpatialPointerInteractionSourcePose class --------------------

    static PyObject* _new_SpatialPointerInteractionSourcePose(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::UI::Input::Spatial::SpatialPointerInteractionSourcePose>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::UI::Input::Spatial::SpatialPointerInteractionSourcePose>::type_name);
        return nullptr;
    }

    static void _dealloc_SpatialPointerInteractionSourcePose(py::wrapper::Windows::UI::Input::Spatial::SpatialPointerInteractionSourcePose* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* SpatialPointerInteractionSourcePose_get_ForwardDirection(py::wrapper::Windows::UI::Input::Spatial::SpatialPointerInteractionSourcePose* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Input.Spatial.SpatialPointerInteractionSourcePose", L"ForwardDirection");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.ForwardDirection());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SpatialPointerInteractionSourcePose_get_Position(py::wrapper::Windows::UI::Input::Spatial::SpatialPointerInteractionSourcePose* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Input.Spatial.SpatialPointerInteractionSourcePose", L"Position");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Position());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SpatialPointerInteractionSourcePose_get_UpDirection(py::wrapper::Windows::UI::Input::Spatial::SpatialPointerInteractionSourcePose* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Input.Spatial.SpatialPointerInteractionSourcePose", L"UpDirection");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.UpDirection());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SpatialPointerInteractionSourcePose_get_Orientation(py::wrapper::Windows::UI::Input::Spatial::SpatialPointerInteractionSourcePose* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Input.Spatial.SpatialPointerInteractionSourcePose", L"Orientation");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Orientation());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SpatialPointerInteractionSourcePose_get_PositionAccuracy(py::wrapper::Windows::UI::Input::Spatial::SpatialPointerInteractionSourcePose* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Input.Spatial.SpatialPointerInteractionSourcePose", L"PositionAccuracy");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.PositionAccuracy());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_SpatialPointerInteractionSourcePose(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::Input::Spatial::SpatialPointerInteractionSourcePose>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_SpatialPointerInteractionSourcePose(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Input::Spatial::SpatialPointerInteractionSourcePose>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_SpatialPointerInteractionSourcePose[] = {
        { "_assign_array_", _assign_array_SpatialPointerInteractionSourcePose, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_SpatialPointerInteractionSourcePose), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_SpatialPointerInteractionSourcePose[] = {
        { "forward_direction", reinterpret_cast<getter>(SpatialPointerInteractionSourcePose_get_ForwardDirection), nullptr, nullptr, nullptr },
        { "position", reinterpret_cast<getter>(SpatialPointerInteractionSourcePose_get_Position), nullptr, nullptr, nullptr },
        { "up_direction", reinterpret_cast<getter>(SpatialPointerInteractionSourcePose_get_UpDirection), nullptr, nullptr, nullptr },
        { "orientation", reinterpret_cast<getter>(SpatialPointerInteractionSourcePose_get_Orientation), nullptr, nullptr, nullptr },
        { "position_accuracy", reinterpret_cast<getter>(SpatialPointerInteractionSourcePose_get_PositionAccuracy), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_SpatialPointerInteractionSourcePose[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_SpatialPointerInteractionSourcePose) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_SpatialPointerInteractionSourcePose) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_SpatialPointerInteractionSourcePose) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_SpatialPointerInteractionSourcePose) },
        { }
    };

    static PyType_Spec type_spec_SpatialPointerInteractionSourcePose = {
        "winrt._winrt_windows_ui_input_spatial.SpatialPointerInteractionSourcePose",
        sizeof(py::wrapper::Windows::UI::Input::Spatial::SpatialPointerInteractionSourcePose),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_SpatialPointerInteractionSourcePose};

    // ----- SpatialPointerPose class --------------------

    static PyObject* _new_SpatialPointerPose(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::UI::Input::Spatial::SpatialPointerPose>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::UI::Input::Spatial::SpatialPointerPose>::type_name);
        return nullptr;
    }

    static void _dealloc_SpatialPointerPose(py::wrapper::Windows::UI::Input::Spatial::SpatialPointerPose* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* SpatialPointerPose_TryGetAtTimestamp(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Input.Spatial.SpatialPointerPose", L"TryGetAtTimestamp", 2);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(2);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Perception::Spatial::SpatialCoordinateSystem>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Perception::PerceptionTimestamp>(args, 1);

                return py::convert(winrt::Windows::UI::Input::Spatial::SpatialPointerPose::TryGetAtTimestamp(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* SpatialPointerPose_TryGetInteractionSourcePose(py::wrapper::Windows::UI::Input::Spatial::SpatialPointerPose* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Input.Spatial.SpatialPointerPose", L"TryGetInteractionSourcePose", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::UI::Input::Spatial::SpatialInteractionSource>(args, 0);

                return py::convert(self->obj.TryGetInteractionSourcePose(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* SpatialPointerPose_get_Head(py::wrapper::Windows::UI::Input::Spatial::SpatialPointerPose* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Input.Spatial.SpatialPointerPose", L"Head");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Head());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SpatialPointerPose_get_Timestamp(py::wrapper::Windows::UI::Input::Spatial::SpatialPointerPose* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Input.Spatial.SpatialPointerPose", L"Timestamp");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Timestamp());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SpatialPointerPose_get_Eyes(py::wrapper::Windows::UI::Input::Spatial::SpatialPointerPose* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Input.Spatial.SpatialPointerPose", L"Eyes");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Eyes());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SpatialPointerPose_get_IsHeadCapturedBySystem(py::wrapper::Windows::UI::Input::Spatial::SpatialPointerPose* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Input.Spatial.SpatialPointerPose", L"IsHeadCapturedBySystem");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.IsHeadCapturedBySystem());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_SpatialPointerPose(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::Input::Spatial::SpatialPointerPose>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_SpatialPointerPose(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Input::Spatial::SpatialPointerPose>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_SpatialPointerPose[] = {
        { "try_get_interaction_source_pose", reinterpret_cast<PyCFunction>(SpatialPointerPose_TryGetInteractionSourcePose), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_SpatialPointerPose, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_SpatialPointerPose), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_SpatialPointerPose[] = {
        { "head", reinterpret_cast<getter>(SpatialPointerPose_get_Head), nullptr, nullptr, nullptr },
        { "timestamp", reinterpret_cast<getter>(SpatialPointerPose_get_Timestamp), nullptr, nullptr, nullptr },
        { "eyes", reinterpret_cast<getter>(SpatialPointerPose_get_Eyes), nullptr, nullptr, nullptr },
        { "is_head_captured_by_system", reinterpret_cast<getter>(SpatialPointerPose_get_IsHeadCapturedBySystem), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_SpatialPointerPose[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_SpatialPointerPose) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_SpatialPointerPose) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_SpatialPointerPose) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_SpatialPointerPose) },
        { }
    };

    static PyType_Spec type_spec_SpatialPointerPose = {
        "winrt._winrt_windows_ui_input_spatial.SpatialPointerPose",
        sizeof(py::wrapper::Windows::UI::Input::Spatial::SpatialPointerPose),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_SpatialPointerPose};

    static PyGetSetDef getset_SpatialPointerPose_Static[] = {
        { }
    };

    static PyMethodDef methods_SpatialPointerPose_Static[] = {
        { "try_get_at_timestamp", reinterpret_cast<PyCFunction>(SpatialPointerPose_TryGetAtTimestamp), METH_VARARGS, nullptr },
        { }
    };

    static PyType_Slot type_slots_SpatialPointerPose_Static[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_SpatialPointerPose_Static) },
        { Py_tp_methods, reinterpret_cast<void*>(methods_SpatialPointerPose_Static) },
        { }
    };

    static PyType_Spec type_spec_SpatialPointerPose_Static =
    {
        "winrt._winrt_windows_ui_input_spatial.SpatialPointerPose_Static",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT,
        type_slots_SpatialPointerPose_Static
    };

    // ----- SpatialRecognitionEndedEventArgs class --------------------

    static PyObject* _new_SpatialRecognitionEndedEventArgs(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::UI::Input::Spatial::SpatialRecognitionEndedEventArgs>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::UI::Input::Spatial::SpatialRecognitionEndedEventArgs>::type_name);
        return nullptr;
    }

    static void _dealloc_SpatialRecognitionEndedEventArgs(py::wrapper::Windows::UI::Input::Spatial::SpatialRecognitionEndedEventArgs* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* SpatialRecognitionEndedEventArgs_get_InteractionSourceKind(py::wrapper::Windows::UI::Input::Spatial::SpatialRecognitionEndedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Input.Spatial.SpatialRecognitionEndedEventArgs", L"InteractionSourceKind");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.InteractionSourceKind());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_SpatialRecognitionEndedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::Input::Spatial::SpatialRecognitionEndedEventArgs>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_SpatialRecognitionEndedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Input::Spatial::SpatialRecognitionEndedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_SpatialRecognitionEndedEventArgs[] = {
        { "_assign_array_", _assign_array_SpatialRecognitionEndedEventArgs, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_SpatialRecognitionEndedEventArgs), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_SpatialRecognitionEndedEventArgs[] = {
        { "interaction_source_kind", reinterpret_cast<getter>(SpatialRecognitionEndedEventArgs_get_InteractionSourceKind), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_SpatialRecognitionEndedEventArgs[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_SpatialRecognitionEndedEventArgs) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_SpatialRecognitionEndedEventArgs) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_SpatialRecognitionEndedEventArgs) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_SpatialRecognitionEndedEventArgs) },
        { }
    };

    static PyType_Spec type_spec_SpatialRecognitionEndedEventArgs = {
        "winrt._winrt_windows_ui_input_spatial.SpatialRecognitionEndedEventArgs",
        sizeof(py::wrapper::Windows::UI::Input::Spatial::SpatialRecognitionEndedEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_SpatialRecognitionEndedEventArgs};

    // ----- SpatialRecognitionStartedEventArgs class --------------------

    static PyObject* _new_SpatialRecognitionStartedEventArgs(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::UI::Input::Spatial::SpatialRecognitionStartedEventArgs>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::UI::Input::Spatial::SpatialRecognitionStartedEventArgs>::type_name);
        return nullptr;
    }

    static void _dealloc_SpatialRecognitionStartedEventArgs(py::wrapper::Windows::UI::Input::Spatial::SpatialRecognitionStartedEventArgs* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* SpatialRecognitionStartedEventArgs_IsGesturePossible(py::wrapper::Windows::UI::Input::Spatial::SpatialRecognitionStartedEventArgs* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Input.Spatial.SpatialRecognitionStartedEventArgs", L"IsGesturePossible", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::UI::Input::Spatial::SpatialGestureSettings>(args, 0);

                return py::convert(self->obj.IsGesturePossible(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* SpatialRecognitionStartedEventArgs_TryGetPointerPose(py::wrapper::Windows::UI::Input::Spatial::SpatialRecognitionStartedEventArgs* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Input.Spatial.SpatialRecognitionStartedEventArgs", L"TryGetPointerPose", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Perception::Spatial::SpatialCoordinateSystem>(args, 0);

                return py::convert(self->obj.TryGetPointerPose(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* SpatialRecognitionStartedEventArgs_get_InteractionSourceKind(py::wrapper::Windows::UI::Input::Spatial::SpatialRecognitionStartedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Input.Spatial.SpatialRecognitionStartedEventArgs", L"InteractionSourceKind");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.InteractionSourceKind());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_SpatialRecognitionStartedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::Input::Spatial::SpatialRecognitionStartedEventArgs>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_SpatialRecognitionStartedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Input::Spatial::SpatialRecognitionStartedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_SpatialRecognitionStartedEventArgs[] = {
        { "is_gesture_possible", reinterpret_cast<PyCFunction>(SpatialRecognitionStartedEventArgs_IsGesturePossible), METH_VARARGS, nullptr },
        { "try_get_pointer_pose", reinterpret_cast<PyCFunction>(SpatialRecognitionStartedEventArgs_TryGetPointerPose), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_SpatialRecognitionStartedEventArgs, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_SpatialRecognitionStartedEventArgs), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_SpatialRecognitionStartedEventArgs[] = {
        { "interaction_source_kind", reinterpret_cast<getter>(SpatialRecognitionStartedEventArgs_get_InteractionSourceKind), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_SpatialRecognitionStartedEventArgs[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_SpatialRecognitionStartedEventArgs) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_SpatialRecognitionStartedEventArgs) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_SpatialRecognitionStartedEventArgs) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_SpatialRecognitionStartedEventArgs) },
        { }
    };

    static PyType_Spec type_spec_SpatialRecognitionStartedEventArgs = {
        "winrt._winrt_windows_ui_input_spatial.SpatialRecognitionStartedEventArgs",
        sizeof(py::wrapper::Windows::UI::Input::Spatial::SpatialRecognitionStartedEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_SpatialRecognitionStartedEventArgs};

    // ----- SpatialTappedEventArgs class --------------------

    static PyObject* _new_SpatialTappedEventArgs(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::UI::Input::Spatial::SpatialTappedEventArgs>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::UI::Input::Spatial::SpatialTappedEventArgs>::type_name);
        return nullptr;
    }

    static void _dealloc_SpatialTappedEventArgs(py::wrapper::Windows::UI::Input::Spatial::SpatialTappedEventArgs* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* SpatialTappedEventArgs_TryGetPointerPose(py::wrapper::Windows::UI::Input::Spatial::SpatialTappedEventArgs* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Input.Spatial.SpatialTappedEventArgs", L"TryGetPointerPose", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Perception::Spatial::SpatialCoordinateSystem>(args, 0);

                return py::convert(self->obj.TryGetPointerPose(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* SpatialTappedEventArgs_get_InteractionSourceKind(py::wrapper::Windows::UI::Input::Spatial::SpatialTappedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Input.Spatial.SpatialTappedEventArgs", L"InteractionSourceKind");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.InteractionSourceKind());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SpatialTappedEventArgs_get_TapCount(py::wrapper::Windows::UI::Input::Spatial::SpatialTappedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Input.Spatial.SpatialTappedEventArgs", L"TapCount");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.TapCount());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_SpatialTappedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::Input::Spatial::SpatialTappedEventArgs>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_SpatialTappedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Input::Spatial::SpatialTappedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_SpatialTappedEventArgs[] = {
        { "try_get_pointer_pose", reinterpret_cast<PyCFunction>(SpatialTappedEventArgs_TryGetPointerPose), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_SpatialTappedEventArgs, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_SpatialTappedEventArgs), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_SpatialTappedEventArgs[] = {
        { "interaction_source_kind", reinterpret_cast<getter>(SpatialTappedEventArgs_get_InteractionSourceKind), nullptr, nullptr, nullptr },
        { "tap_count", reinterpret_cast<getter>(SpatialTappedEventArgs_get_TapCount), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_SpatialTappedEventArgs[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_SpatialTappedEventArgs) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_SpatialTappedEventArgs) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_SpatialTappedEventArgs) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_SpatialTappedEventArgs) },
        { }
    };

    static PyType_Spec type_spec_SpatialTappedEventArgs = {
        "winrt._winrt_windows_ui_input_spatial.SpatialTappedEventArgs",
        sizeof(py::wrapper::Windows::UI::Input::Spatial::SpatialTappedEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_SpatialTappedEventArgs};

    // ----- Windows.UI.Input.Spatial Initialization --------------------

    PyDoc_STRVAR(module_doc, "Windows.UI.Input.Spatial");

    static PyModuleDef module_def = {
        PyModuleDef_HEAD_INIT,
        "_winrt_windows_ui_input_spatial",
        module_doc,
        0,
        nullptr,
        nullptr,
        nullptr,
        nullptr,
        nullptr};
} // py::cpp::Windows::UI::Input::Spatial

PyMODINIT_FUNC PyInit__winrt_windows_ui_input_spatial(void) noexcept
{
    using namespace py::cpp::Windows::UI::Input::Spatial;

    if (py::import_winrt_runtime() == -1)
    {
        return nullptr;
    }

    py::pyobj_handle module{PyModule_Create(&module_def)};

    if (!module)
    {
        return nullptr;
    }

    auto object_type = py::get_object_type();
    if (!object_type)
    {
        return nullptr;
    }

    py::pyobj_handle object_bases{PyTuple_Pack(1, object_type)};

    if (!object_bases)
    {
        return nullptr;
    }

    py::pytype_handle SpatialGestureRecognizer_type{py::register_python_type(module.get(), &type_spec_SpatialGestureRecognizer, object_bases.get(), nullptr)};
    if (!SpatialGestureRecognizer_type)
    {
        return nullptr;
    }

    py::pytype_handle SpatialHoldCanceledEventArgs_type{py::register_python_type(module.get(), &type_spec_SpatialHoldCanceledEventArgs, object_bases.get(), nullptr)};
    if (!SpatialHoldCanceledEventArgs_type)
    {
        return nullptr;
    }

    py::pytype_handle SpatialHoldCompletedEventArgs_type{py::register_python_type(module.get(), &type_spec_SpatialHoldCompletedEventArgs, object_bases.get(), nullptr)};
    if (!SpatialHoldCompletedEventArgs_type)
    {
        return nullptr;
    }

    py::pytype_handle SpatialHoldStartedEventArgs_type{py::register_python_type(module.get(), &type_spec_SpatialHoldStartedEventArgs, object_bases.get(), nullptr)};
    if (!SpatialHoldStartedEventArgs_type)
    {
        return nullptr;
    }

    py::pytype_handle SpatialInteraction_type{py::register_python_type(module.get(), &type_spec_SpatialInteraction, object_bases.get(), nullptr)};
    if (!SpatialInteraction_type)
    {
        return nullptr;
    }

    py::pytype_handle SpatialInteractionController_type{py::register_python_type(module.get(), &type_spec_SpatialInteractionController, object_bases.get(), nullptr)};
    if (!SpatialInteractionController_type)
    {
        return nullptr;
    }

    py::pytype_handle SpatialInteractionControllerProperties_type{py::register_python_type(module.get(), &type_spec_SpatialInteractionControllerProperties, object_bases.get(), nullptr)};
    if (!SpatialInteractionControllerProperties_type)
    {
        return nullptr;
    }

    py::pytype_handle SpatialInteractionDetectedEventArgs_type{py::register_python_type(module.get(), &type_spec_SpatialInteractionDetectedEventArgs, object_bases.get(), nullptr)};
    if (!SpatialInteractionDetectedEventArgs_type)
    {
        return nullptr;
    }

    py::pyobj_handle type_SpatialInteractionManager_Static{PyType_FromSpec(&type_spec_SpatialInteractionManager_Static)};
    if (!type_SpatialInteractionManager_Static)
    {
        return nullptr;
    }

    py::pytype_handle SpatialInteractionManager_type{py::register_python_type(module.get(), &type_spec_SpatialInteractionManager, object_bases.get(), reinterpret_cast<PyTypeObject*>(type_SpatialInteractionManager_Static.get()))};
    if (!SpatialInteractionManager_type)
    {
        return nullptr;
    }

    py::pytype_handle SpatialInteractionSource_type{py::register_python_type(module.get(), &type_spec_SpatialInteractionSource, object_bases.get(), nullptr)};
    if (!SpatialInteractionSource_type)
    {
        return nullptr;
    }

    py::pytype_handle SpatialInteractionSourceEventArgs_type{py::register_python_type(module.get(), &type_spec_SpatialInteractionSourceEventArgs, object_bases.get(), nullptr)};
    if (!SpatialInteractionSourceEventArgs_type)
    {
        return nullptr;
    }

    py::pytype_handle SpatialInteractionSourceLocation_type{py::register_python_type(module.get(), &type_spec_SpatialInteractionSourceLocation, object_bases.get(), nullptr)};
    if (!SpatialInteractionSourceLocation_type)
    {
        return nullptr;
    }

    py::pytype_handle SpatialInteractionSourceProperties_type{py::register_python_type(module.get(), &type_spec_SpatialInteractionSourceProperties, object_bases.get(), nullptr)};
    if (!SpatialInteractionSourceProperties_type)
    {
        return nullptr;
    }

    py::pytype_handle SpatialInteractionSourceState_type{py::register_python_type(module.get(), &type_spec_SpatialInteractionSourceState, object_bases.get(), nullptr)};
    if (!SpatialInteractionSourceState_type)
    {
        return nullptr;
    }

    py::pytype_handle SpatialManipulationCanceledEventArgs_type{py::register_python_type(module.get(), &type_spec_SpatialManipulationCanceledEventArgs, object_bases.get(), nullptr)};
    if (!SpatialManipulationCanceledEventArgs_type)
    {
        return nullptr;
    }

    py::pytype_handle SpatialManipulationCompletedEventArgs_type{py::register_python_type(module.get(), &type_spec_SpatialManipulationCompletedEventArgs, object_bases.get(), nullptr)};
    if (!SpatialManipulationCompletedEventArgs_type)
    {
        return nullptr;
    }

    py::pytype_handle SpatialManipulationDelta_type{py::register_python_type(module.get(), &type_spec_SpatialManipulationDelta, object_bases.get(), nullptr)};
    if (!SpatialManipulationDelta_type)
    {
        return nullptr;
    }

    py::pytype_handle SpatialManipulationStartedEventArgs_type{py::register_python_type(module.get(), &type_spec_SpatialManipulationStartedEventArgs, object_bases.get(), nullptr)};
    if (!SpatialManipulationStartedEventArgs_type)
    {
        return nullptr;
    }

    py::pytype_handle SpatialManipulationUpdatedEventArgs_type{py::register_python_type(module.get(), &type_spec_SpatialManipulationUpdatedEventArgs, object_bases.get(), nullptr)};
    if (!SpatialManipulationUpdatedEventArgs_type)
    {
        return nullptr;
    }

    py::pytype_handle SpatialNavigationCanceledEventArgs_type{py::register_python_type(module.get(), &type_spec_SpatialNavigationCanceledEventArgs, object_bases.get(), nullptr)};
    if (!SpatialNavigationCanceledEventArgs_type)
    {
        return nullptr;
    }

    py::pytype_handle SpatialNavigationCompletedEventArgs_type{py::register_python_type(module.get(), &type_spec_SpatialNavigationCompletedEventArgs, object_bases.get(), nullptr)};
    if (!SpatialNavigationCompletedEventArgs_type)
    {
        return nullptr;
    }

    py::pytype_handle SpatialNavigationStartedEventArgs_type{py::register_python_type(module.get(), &type_spec_SpatialNavigationStartedEventArgs, object_bases.get(), nullptr)};
    if (!SpatialNavigationStartedEventArgs_type)
    {
        return nullptr;
    }

    py::pytype_handle SpatialNavigationUpdatedEventArgs_type{py::register_python_type(module.get(), &type_spec_SpatialNavigationUpdatedEventArgs, object_bases.get(), nullptr)};
    if (!SpatialNavigationUpdatedEventArgs_type)
    {
        return nullptr;
    }

    py::pytype_handle SpatialPointerInteractionSourcePose_type{py::register_python_type(module.get(), &type_spec_SpatialPointerInteractionSourcePose, object_bases.get(), nullptr)};
    if (!SpatialPointerInteractionSourcePose_type)
    {
        return nullptr;
    }

    py::pyobj_handle type_SpatialPointerPose_Static{PyType_FromSpec(&type_spec_SpatialPointerPose_Static)};
    if (!type_SpatialPointerPose_Static)
    {
        return nullptr;
    }

    py::pytype_handle SpatialPointerPose_type{py::register_python_type(module.get(), &type_spec_SpatialPointerPose, object_bases.get(), reinterpret_cast<PyTypeObject*>(type_SpatialPointerPose_Static.get()))};
    if (!SpatialPointerPose_type)
    {
        return nullptr;
    }

    py::pytype_handle SpatialRecognitionEndedEventArgs_type{py::register_python_type(module.get(), &type_spec_SpatialRecognitionEndedEventArgs, object_bases.get(), nullptr)};
    if (!SpatialRecognitionEndedEventArgs_type)
    {
        return nullptr;
    }

    py::pytype_handle SpatialRecognitionStartedEventArgs_type{py::register_python_type(module.get(), &type_spec_SpatialRecognitionStartedEventArgs, object_bases.get(), nullptr)};
    if (!SpatialRecognitionStartedEventArgs_type)
    {
        return nullptr;
    }

    py::pytype_handle SpatialTappedEventArgs_type{py::register_python_type(module.get(), &type_spec_SpatialTappedEventArgs, object_bases.get(), nullptr)};
    if (!SpatialTappedEventArgs_type)
    {
        return nullptr;
    }


    return module.detach();
}
