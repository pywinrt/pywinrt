// WARNING: Please don't edit this file. It was generated by Python/WinRT v0.0.0

#include "pybase.h"
#include "py.Windows.UI.Input.Spatial.h"


namespace py::cpp::Windows::UI::Input::Spatial
{
    struct module_state
    {
        PyObject* type_SpatialGestureSettings;
        PyObject* type_SpatialInteractionPressKind;
        PyObject* type_SpatialInteractionSourceHandedness;
        PyObject* type_SpatialInteractionSourceKind;
        PyObject* type_SpatialInteractionSourcePositionAccuracy;
        PyTypeObject* type_SpatialGestureRecognizer;
        PyTypeObject* type_SpatialHoldCanceledEventArgs;
        PyTypeObject* type_SpatialHoldCompletedEventArgs;
        PyTypeObject* type_SpatialHoldStartedEventArgs;
        PyTypeObject* type_SpatialInteraction;
        PyTypeObject* type_SpatialInteractionController;
        PyTypeObject* type_SpatialInteractionControllerProperties;
        PyTypeObject* type_SpatialInteractionDetectedEventArgs;
        PyTypeObject* type_SpatialInteractionManager;
        PyTypeObject* type_SpatialInteractionSource;
        PyTypeObject* type_SpatialInteractionSourceEventArgs;
        PyTypeObject* type_SpatialInteractionSourceLocation;
        PyTypeObject* type_SpatialInteractionSourceProperties;
        PyTypeObject* type_SpatialInteractionSourceState;
        PyTypeObject* type_SpatialManipulationCanceledEventArgs;
        PyTypeObject* type_SpatialManipulationCompletedEventArgs;
        PyTypeObject* type_SpatialManipulationDelta;
        PyTypeObject* type_SpatialManipulationStartedEventArgs;
        PyTypeObject* type_SpatialManipulationUpdatedEventArgs;
        PyTypeObject* type_SpatialNavigationCanceledEventArgs;
        PyTypeObject* type_SpatialNavigationCompletedEventArgs;
        PyTypeObject* type_SpatialNavigationStartedEventArgs;
        PyTypeObject* type_SpatialNavigationUpdatedEventArgs;
        PyTypeObject* type_SpatialPointerInteractionSourcePose;
        PyTypeObject* type_SpatialPointerPose;
        PyTypeObject* type_SpatialRecognitionEndedEventArgs;
        PyTypeObject* type_SpatialRecognitionStartedEventArgs;
        PyTypeObject* type_SpatialTappedEventArgs;
    };

    static PyObject* register_SpatialGestureSettings(PyObject* module, PyObject* type) noexcept
    {
        auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
        WINRT_ASSERT(state);

        if (state->type_SpatialGestureSettings)
        {
            PyErr_SetString(PyExc_RuntimeError, "type has already been registered");
            return nullptr;
        }

        if (!PyType_Check(type))
        {
            PyErr_SetString(PyExc_TypeError, "argument is not a type");
            return nullptr;
        }

        state->type_SpatialGestureSettings = type;
        Py_INCREF(state->type_SpatialGestureSettings);


        Py_RETURN_NONE;
    }

    static PyObject* register_SpatialInteractionPressKind(PyObject* module, PyObject* type) noexcept
    {
        auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
        WINRT_ASSERT(state);

        if (state->type_SpatialInteractionPressKind)
        {
            PyErr_SetString(PyExc_RuntimeError, "type has already been registered");
            return nullptr;
        }

        if (!PyType_Check(type))
        {
            PyErr_SetString(PyExc_TypeError, "argument is not a type");
            return nullptr;
        }

        state->type_SpatialInteractionPressKind = type;
        Py_INCREF(state->type_SpatialInteractionPressKind);


        Py_RETURN_NONE;
    }

    static PyObject* register_SpatialInteractionSourceHandedness(PyObject* module, PyObject* type) noexcept
    {
        auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
        WINRT_ASSERT(state);

        if (state->type_SpatialInteractionSourceHandedness)
        {
            PyErr_SetString(PyExc_RuntimeError, "type has already been registered");
            return nullptr;
        }

        if (!PyType_Check(type))
        {
            PyErr_SetString(PyExc_TypeError, "argument is not a type");
            return nullptr;
        }

        state->type_SpatialInteractionSourceHandedness = type;
        Py_INCREF(state->type_SpatialInteractionSourceHandedness);


        Py_RETURN_NONE;
    }

    static PyObject* register_SpatialInteractionSourceKind(PyObject* module, PyObject* type) noexcept
    {
        auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
        WINRT_ASSERT(state);

        if (state->type_SpatialInteractionSourceKind)
        {
            PyErr_SetString(PyExc_RuntimeError, "type has already been registered");
            return nullptr;
        }

        if (!PyType_Check(type))
        {
            PyErr_SetString(PyExc_TypeError, "argument is not a type");
            return nullptr;
        }

        state->type_SpatialInteractionSourceKind = type;
        Py_INCREF(state->type_SpatialInteractionSourceKind);


        Py_RETURN_NONE;
    }

    static PyObject* register_SpatialInteractionSourcePositionAccuracy(PyObject* module, PyObject* type) noexcept
    {
        auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
        WINRT_ASSERT(state);

        if (state->type_SpatialInteractionSourcePositionAccuracy)
        {
            PyErr_SetString(PyExc_RuntimeError, "type has already been registered");
            return nullptr;
        }

        if (!PyType_Check(type))
        {
            PyErr_SetString(PyExc_TypeError, "argument is not a type");
            return nullptr;
        }

        state->type_SpatialInteractionSourcePositionAccuracy = type;
        Py_INCREF(state->type_SpatialInteractionSourcePositionAccuracy);


        Py_RETURN_NONE;
    }

    // ----- SpatialGestureRecognizer class --------------------
    static constexpr const char* const type_name_SpatialGestureRecognizer = "SpatialGestureRecognizer";

    static PyObject* _new_SpatialGestureRecognizer(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::UI::Input::Spatial::SpatialGestureSettings>(args, 0);

                winrt::Windows::UI::Input::Spatial::SpatialGestureRecognizer instance{ param0 };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_SpatialGestureRecognizer(py::wrapper::Windows::UI::Input::Spatial::SpatialGestureRecognizer* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* SpatialGestureRecognizer_CancelPendingGestures(py::wrapper::Windows::UI::Input::Spatial::SpatialGestureRecognizer* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Input.Spatial.SpatialGestureRecognizer", L"CancelPendingGestures", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                self->obj.CancelPendingGestures();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* SpatialGestureRecognizer_CaptureInteraction(py::wrapper::Windows::UI::Input::Spatial::SpatialGestureRecognizer* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Input.Spatial.SpatialGestureRecognizer", L"CaptureInteraction", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::UI::Input::Spatial::SpatialInteraction>(args, 0);

                self->obj.CaptureInteraction(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* SpatialGestureRecognizer_TrySetGestureSettings(py::wrapper::Windows::UI::Input::Spatial::SpatialGestureRecognizer* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Input.Spatial.SpatialGestureRecognizer", L"TrySetGestureSettings", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::UI::Input::Spatial::SpatialGestureSettings>(args, 0);

                return py::convert(self->obj.TrySetGestureSettings(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* SpatialGestureRecognizer_get_GestureSettings(py::wrapper::Windows::UI::Input::Spatial::SpatialGestureRecognizer* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Input.Spatial.SpatialGestureRecognizer", L"GestureSettings"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.GestureSettings());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SpatialGestureRecognizer_add_HoldCanceled(py::wrapper::Windows::UI::Input::Spatial::SpatialGestureRecognizer* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.UI.Input.Spatial.SpatialGestureRecognizer", L"HoldCanceled"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::UI::Input::Spatial::SpatialGestureRecognizer, winrt::Windows::UI::Input::Spatial::SpatialHoldCanceledEventArgs>>(arg);

            return py::convert(self->obj.HoldCanceled(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SpatialGestureRecognizer_remove_HoldCanceled(py::wrapper::Windows::UI::Input::Spatial::SpatialGestureRecognizer* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.UI.Input.Spatial.SpatialGestureRecognizer", L"HoldCanceled"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.HoldCanceled(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SpatialGestureRecognizer_add_HoldCompleted(py::wrapper::Windows::UI::Input::Spatial::SpatialGestureRecognizer* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.UI.Input.Spatial.SpatialGestureRecognizer", L"HoldCompleted"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::UI::Input::Spatial::SpatialGestureRecognizer, winrt::Windows::UI::Input::Spatial::SpatialHoldCompletedEventArgs>>(arg);

            return py::convert(self->obj.HoldCompleted(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SpatialGestureRecognizer_remove_HoldCompleted(py::wrapper::Windows::UI::Input::Spatial::SpatialGestureRecognizer* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.UI.Input.Spatial.SpatialGestureRecognizer", L"HoldCompleted"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.HoldCompleted(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SpatialGestureRecognizer_add_HoldStarted(py::wrapper::Windows::UI::Input::Spatial::SpatialGestureRecognizer* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.UI.Input.Spatial.SpatialGestureRecognizer", L"HoldStarted"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::UI::Input::Spatial::SpatialGestureRecognizer, winrt::Windows::UI::Input::Spatial::SpatialHoldStartedEventArgs>>(arg);

            return py::convert(self->obj.HoldStarted(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SpatialGestureRecognizer_remove_HoldStarted(py::wrapper::Windows::UI::Input::Spatial::SpatialGestureRecognizer* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.UI.Input.Spatial.SpatialGestureRecognizer", L"HoldStarted"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.HoldStarted(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SpatialGestureRecognizer_add_ManipulationCanceled(py::wrapper::Windows::UI::Input::Spatial::SpatialGestureRecognizer* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.UI.Input.Spatial.SpatialGestureRecognizer", L"ManipulationCanceled"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::UI::Input::Spatial::SpatialGestureRecognizer, winrt::Windows::UI::Input::Spatial::SpatialManipulationCanceledEventArgs>>(arg);

            return py::convert(self->obj.ManipulationCanceled(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SpatialGestureRecognizer_remove_ManipulationCanceled(py::wrapper::Windows::UI::Input::Spatial::SpatialGestureRecognizer* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.UI.Input.Spatial.SpatialGestureRecognizer", L"ManipulationCanceled"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.ManipulationCanceled(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SpatialGestureRecognizer_add_ManipulationCompleted(py::wrapper::Windows::UI::Input::Spatial::SpatialGestureRecognizer* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.UI.Input.Spatial.SpatialGestureRecognizer", L"ManipulationCompleted"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::UI::Input::Spatial::SpatialGestureRecognizer, winrt::Windows::UI::Input::Spatial::SpatialManipulationCompletedEventArgs>>(arg);

            return py::convert(self->obj.ManipulationCompleted(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SpatialGestureRecognizer_remove_ManipulationCompleted(py::wrapper::Windows::UI::Input::Spatial::SpatialGestureRecognizer* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.UI.Input.Spatial.SpatialGestureRecognizer", L"ManipulationCompleted"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.ManipulationCompleted(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SpatialGestureRecognizer_add_ManipulationStarted(py::wrapper::Windows::UI::Input::Spatial::SpatialGestureRecognizer* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.UI.Input.Spatial.SpatialGestureRecognizer", L"ManipulationStarted"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::UI::Input::Spatial::SpatialGestureRecognizer, winrt::Windows::UI::Input::Spatial::SpatialManipulationStartedEventArgs>>(arg);

            return py::convert(self->obj.ManipulationStarted(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SpatialGestureRecognizer_remove_ManipulationStarted(py::wrapper::Windows::UI::Input::Spatial::SpatialGestureRecognizer* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.UI.Input.Spatial.SpatialGestureRecognizer", L"ManipulationStarted"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.ManipulationStarted(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SpatialGestureRecognizer_add_ManipulationUpdated(py::wrapper::Windows::UI::Input::Spatial::SpatialGestureRecognizer* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.UI.Input.Spatial.SpatialGestureRecognizer", L"ManipulationUpdated"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::UI::Input::Spatial::SpatialGestureRecognizer, winrt::Windows::UI::Input::Spatial::SpatialManipulationUpdatedEventArgs>>(arg);

            return py::convert(self->obj.ManipulationUpdated(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SpatialGestureRecognizer_remove_ManipulationUpdated(py::wrapper::Windows::UI::Input::Spatial::SpatialGestureRecognizer* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.UI.Input.Spatial.SpatialGestureRecognizer", L"ManipulationUpdated"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.ManipulationUpdated(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SpatialGestureRecognizer_add_NavigationCanceled(py::wrapper::Windows::UI::Input::Spatial::SpatialGestureRecognizer* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.UI.Input.Spatial.SpatialGestureRecognizer", L"NavigationCanceled"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::UI::Input::Spatial::SpatialGestureRecognizer, winrt::Windows::UI::Input::Spatial::SpatialNavigationCanceledEventArgs>>(arg);

            return py::convert(self->obj.NavigationCanceled(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SpatialGestureRecognizer_remove_NavigationCanceled(py::wrapper::Windows::UI::Input::Spatial::SpatialGestureRecognizer* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.UI.Input.Spatial.SpatialGestureRecognizer", L"NavigationCanceled"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.NavigationCanceled(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SpatialGestureRecognizer_add_NavigationCompleted(py::wrapper::Windows::UI::Input::Spatial::SpatialGestureRecognizer* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.UI.Input.Spatial.SpatialGestureRecognizer", L"NavigationCompleted"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::UI::Input::Spatial::SpatialGestureRecognizer, winrt::Windows::UI::Input::Spatial::SpatialNavigationCompletedEventArgs>>(arg);

            return py::convert(self->obj.NavigationCompleted(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SpatialGestureRecognizer_remove_NavigationCompleted(py::wrapper::Windows::UI::Input::Spatial::SpatialGestureRecognizer* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.UI.Input.Spatial.SpatialGestureRecognizer", L"NavigationCompleted"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.NavigationCompleted(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SpatialGestureRecognizer_add_NavigationStarted(py::wrapper::Windows::UI::Input::Spatial::SpatialGestureRecognizer* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.UI.Input.Spatial.SpatialGestureRecognizer", L"NavigationStarted"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::UI::Input::Spatial::SpatialGestureRecognizer, winrt::Windows::UI::Input::Spatial::SpatialNavigationStartedEventArgs>>(arg);

            return py::convert(self->obj.NavigationStarted(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SpatialGestureRecognizer_remove_NavigationStarted(py::wrapper::Windows::UI::Input::Spatial::SpatialGestureRecognizer* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.UI.Input.Spatial.SpatialGestureRecognizer", L"NavigationStarted"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.NavigationStarted(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SpatialGestureRecognizer_add_NavigationUpdated(py::wrapper::Windows::UI::Input::Spatial::SpatialGestureRecognizer* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.UI.Input.Spatial.SpatialGestureRecognizer", L"NavigationUpdated"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::UI::Input::Spatial::SpatialGestureRecognizer, winrt::Windows::UI::Input::Spatial::SpatialNavigationUpdatedEventArgs>>(arg);

            return py::convert(self->obj.NavigationUpdated(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SpatialGestureRecognizer_remove_NavigationUpdated(py::wrapper::Windows::UI::Input::Spatial::SpatialGestureRecognizer* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.UI.Input.Spatial.SpatialGestureRecognizer", L"NavigationUpdated"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.NavigationUpdated(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SpatialGestureRecognizer_add_RecognitionEnded(py::wrapper::Windows::UI::Input::Spatial::SpatialGestureRecognizer* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.UI.Input.Spatial.SpatialGestureRecognizer", L"RecognitionEnded"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::UI::Input::Spatial::SpatialGestureRecognizer, winrt::Windows::UI::Input::Spatial::SpatialRecognitionEndedEventArgs>>(arg);

            return py::convert(self->obj.RecognitionEnded(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SpatialGestureRecognizer_remove_RecognitionEnded(py::wrapper::Windows::UI::Input::Spatial::SpatialGestureRecognizer* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.UI.Input.Spatial.SpatialGestureRecognizer", L"RecognitionEnded"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.RecognitionEnded(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SpatialGestureRecognizer_add_RecognitionStarted(py::wrapper::Windows::UI::Input::Spatial::SpatialGestureRecognizer* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.UI.Input.Spatial.SpatialGestureRecognizer", L"RecognitionStarted"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::UI::Input::Spatial::SpatialGestureRecognizer, winrt::Windows::UI::Input::Spatial::SpatialRecognitionStartedEventArgs>>(arg);

            return py::convert(self->obj.RecognitionStarted(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SpatialGestureRecognizer_remove_RecognitionStarted(py::wrapper::Windows::UI::Input::Spatial::SpatialGestureRecognizer* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.UI.Input.Spatial.SpatialGestureRecognizer", L"RecognitionStarted"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.RecognitionStarted(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SpatialGestureRecognizer_add_Tapped(py::wrapper::Windows::UI::Input::Spatial::SpatialGestureRecognizer* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.UI.Input.Spatial.SpatialGestureRecognizer", L"Tapped"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::UI::Input::Spatial::SpatialGestureRecognizer, winrt::Windows::UI::Input::Spatial::SpatialTappedEventArgs>>(arg);

            return py::convert(self->obj.Tapped(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SpatialGestureRecognizer_remove_Tapped(py::wrapper::Windows::UI::Input::Spatial::SpatialGestureRecognizer* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.UI.Input.Spatial.SpatialGestureRecognizer", L"Tapped"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.Tapped(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_SpatialGestureRecognizer(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::Input::Spatial::SpatialGestureRecognizer>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_SpatialGestureRecognizer(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Input::Spatial::SpatialGestureRecognizer>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_SpatialGestureRecognizer[] = {
        { "cancel_pending_gestures", reinterpret_cast<PyCFunction>(SpatialGestureRecognizer_CancelPendingGestures), METH_VARARGS, nullptr },
        { "capture_interaction", reinterpret_cast<PyCFunction>(SpatialGestureRecognizer_CaptureInteraction), METH_VARARGS, nullptr },
        { "try_set_gesture_settings", reinterpret_cast<PyCFunction>(SpatialGestureRecognizer_TrySetGestureSettings), METH_VARARGS, nullptr },
        { "add_hold_canceled", reinterpret_cast<PyCFunction>(SpatialGestureRecognizer_add_HoldCanceled), METH_O, nullptr },
        { "remove_hold_canceled", reinterpret_cast<PyCFunction>(SpatialGestureRecognizer_remove_HoldCanceled), METH_O, nullptr },
        { "add_hold_completed", reinterpret_cast<PyCFunction>(SpatialGestureRecognizer_add_HoldCompleted), METH_O, nullptr },
        { "remove_hold_completed", reinterpret_cast<PyCFunction>(SpatialGestureRecognizer_remove_HoldCompleted), METH_O, nullptr },
        { "add_hold_started", reinterpret_cast<PyCFunction>(SpatialGestureRecognizer_add_HoldStarted), METH_O, nullptr },
        { "remove_hold_started", reinterpret_cast<PyCFunction>(SpatialGestureRecognizer_remove_HoldStarted), METH_O, nullptr },
        { "add_manipulation_canceled", reinterpret_cast<PyCFunction>(SpatialGestureRecognizer_add_ManipulationCanceled), METH_O, nullptr },
        { "remove_manipulation_canceled", reinterpret_cast<PyCFunction>(SpatialGestureRecognizer_remove_ManipulationCanceled), METH_O, nullptr },
        { "add_manipulation_completed", reinterpret_cast<PyCFunction>(SpatialGestureRecognizer_add_ManipulationCompleted), METH_O, nullptr },
        { "remove_manipulation_completed", reinterpret_cast<PyCFunction>(SpatialGestureRecognizer_remove_ManipulationCompleted), METH_O, nullptr },
        { "add_manipulation_started", reinterpret_cast<PyCFunction>(SpatialGestureRecognizer_add_ManipulationStarted), METH_O, nullptr },
        { "remove_manipulation_started", reinterpret_cast<PyCFunction>(SpatialGestureRecognizer_remove_ManipulationStarted), METH_O, nullptr },
        { "add_manipulation_updated", reinterpret_cast<PyCFunction>(SpatialGestureRecognizer_add_ManipulationUpdated), METH_O, nullptr },
        { "remove_manipulation_updated", reinterpret_cast<PyCFunction>(SpatialGestureRecognizer_remove_ManipulationUpdated), METH_O, nullptr },
        { "add_navigation_canceled", reinterpret_cast<PyCFunction>(SpatialGestureRecognizer_add_NavigationCanceled), METH_O, nullptr },
        { "remove_navigation_canceled", reinterpret_cast<PyCFunction>(SpatialGestureRecognizer_remove_NavigationCanceled), METH_O, nullptr },
        { "add_navigation_completed", reinterpret_cast<PyCFunction>(SpatialGestureRecognizer_add_NavigationCompleted), METH_O, nullptr },
        { "remove_navigation_completed", reinterpret_cast<PyCFunction>(SpatialGestureRecognizer_remove_NavigationCompleted), METH_O, nullptr },
        { "add_navigation_started", reinterpret_cast<PyCFunction>(SpatialGestureRecognizer_add_NavigationStarted), METH_O, nullptr },
        { "remove_navigation_started", reinterpret_cast<PyCFunction>(SpatialGestureRecognizer_remove_NavigationStarted), METH_O, nullptr },
        { "add_navigation_updated", reinterpret_cast<PyCFunction>(SpatialGestureRecognizer_add_NavigationUpdated), METH_O, nullptr },
        { "remove_navigation_updated", reinterpret_cast<PyCFunction>(SpatialGestureRecognizer_remove_NavigationUpdated), METH_O, nullptr },
        { "add_recognition_ended", reinterpret_cast<PyCFunction>(SpatialGestureRecognizer_add_RecognitionEnded), METH_O, nullptr },
        { "remove_recognition_ended", reinterpret_cast<PyCFunction>(SpatialGestureRecognizer_remove_RecognitionEnded), METH_O, nullptr },
        { "add_recognition_started", reinterpret_cast<PyCFunction>(SpatialGestureRecognizer_add_RecognitionStarted), METH_O, nullptr },
        { "remove_recognition_started", reinterpret_cast<PyCFunction>(SpatialGestureRecognizer_remove_RecognitionStarted), METH_O, nullptr },
        { "add_tapped", reinterpret_cast<PyCFunction>(SpatialGestureRecognizer_add_Tapped), METH_O, nullptr },
        { "remove_tapped", reinterpret_cast<PyCFunction>(SpatialGestureRecognizer_remove_Tapped), METH_O, nullptr },
        { "_assign_array_", _assign_array_SpatialGestureRecognizer, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_SpatialGestureRecognizer), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_SpatialGestureRecognizer[] = {
        { "gesture_settings", reinterpret_cast<getter>(SpatialGestureRecognizer_get_GestureSettings), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_SpatialGestureRecognizer[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_SpatialGestureRecognizer) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_SpatialGestureRecognizer) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_SpatialGestureRecognizer) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_SpatialGestureRecognizer) },
        { },
    };

    static PyType_Spec type_spec_SpatialGestureRecognizer =
    {
        "_winrt_Windows_UI_Input_Spatial.SpatialGestureRecognizer",
        sizeof(py::wrapper::Windows::UI::Input::Spatial::SpatialGestureRecognizer),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_SpatialGestureRecognizer
    };

    // ----- SpatialHoldCanceledEventArgs class --------------------
    static constexpr const char* const type_name_SpatialHoldCanceledEventArgs = "SpatialHoldCanceledEventArgs";

    static PyObject* _new_SpatialHoldCanceledEventArgs(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_SpatialHoldCanceledEventArgs);
        return nullptr;
    }

    static void _dealloc_SpatialHoldCanceledEventArgs(py::wrapper::Windows::UI::Input::Spatial::SpatialHoldCanceledEventArgs* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* SpatialHoldCanceledEventArgs_get_InteractionSourceKind(py::wrapper::Windows::UI::Input::Spatial::SpatialHoldCanceledEventArgs* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Input.Spatial.SpatialHoldCanceledEventArgs", L"InteractionSourceKind"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.InteractionSourceKind());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_SpatialHoldCanceledEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::Input::Spatial::SpatialHoldCanceledEventArgs>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_SpatialHoldCanceledEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Input::Spatial::SpatialHoldCanceledEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_SpatialHoldCanceledEventArgs[] = {
        { "_assign_array_", _assign_array_SpatialHoldCanceledEventArgs, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_SpatialHoldCanceledEventArgs), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_SpatialHoldCanceledEventArgs[] = {
        { "interaction_source_kind", reinterpret_cast<getter>(SpatialHoldCanceledEventArgs_get_InteractionSourceKind), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_SpatialHoldCanceledEventArgs[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_SpatialHoldCanceledEventArgs) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_SpatialHoldCanceledEventArgs) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_SpatialHoldCanceledEventArgs) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_SpatialHoldCanceledEventArgs) },
        { },
    };

    static PyType_Spec type_spec_SpatialHoldCanceledEventArgs =
    {
        "_winrt_Windows_UI_Input_Spatial.SpatialHoldCanceledEventArgs",
        sizeof(py::wrapper::Windows::UI::Input::Spatial::SpatialHoldCanceledEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_SpatialHoldCanceledEventArgs
    };

    // ----- SpatialHoldCompletedEventArgs class --------------------
    static constexpr const char* const type_name_SpatialHoldCompletedEventArgs = "SpatialHoldCompletedEventArgs";

    static PyObject* _new_SpatialHoldCompletedEventArgs(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_SpatialHoldCompletedEventArgs);
        return nullptr;
    }

    static void _dealloc_SpatialHoldCompletedEventArgs(py::wrapper::Windows::UI::Input::Spatial::SpatialHoldCompletedEventArgs* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* SpatialHoldCompletedEventArgs_get_InteractionSourceKind(py::wrapper::Windows::UI::Input::Spatial::SpatialHoldCompletedEventArgs* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Input.Spatial.SpatialHoldCompletedEventArgs", L"InteractionSourceKind"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.InteractionSourceKind());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_SpatialHoldCompletedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::Input::Spatial::SpatialHoldCompletedEventArgs>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_SpatialHoldCompletedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Input::Spatial::SpatialHoldCompletedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_SpatialHoldCompletedEventArgs[] = {
        { "_assign_array_", _assign_array_SpatialHoldCompletedEventArgs, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_SpatialHoldCompletedEventArgs), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_SpatialHoldCompletedEventArgs[] = {
        { "interaction_source_kind", reinterpret_cast<getter>(SpatialHoldCompletedEventArgs_get_InteractionSourceKind), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_SpatialHoldCompletedEventArgs[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_SpatialHoldCompletedEventArgs) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_SpatialHoldCompletedEventArgs) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_SpatialHoldCompletedEventArgs) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_SpatialHoldCompletedEventArgs) },
        { },
    };

    static PyType_Spec type_spec_SpatialHoldCompletedEventArgs =
    {
        "_winrt_Windows_UI_Input_Spatial.SpatialHoldCompletedEventArgs",
        sizeof(py::wrapper::Windows::UI::Input::Spatial::SpatialHoldCompletedEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_SpatialHoldCompletedEventArgs
    };

    // ----- SpatialHoldStartedEventArgs class --------------------
    static constexpr const char* const type_name_SpatialHoldStartedEventArgs = "SpatialHoldStartedEventArgs";

    static PyObject* _new_SpatialHoldStartedEventArgs(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_SpatialHoldStartedEventArgs);
        return nullptr;
    }

    static void _dealloc_SpatialHoldStartedEventArgs(py::wrapper::Windows::UI::Input::Spatial::SpatialHoldStartedEventArgs* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* SpatialHoldStartedEventArgs_TryGetPointerPose(py::wrapper::Windows::UI::Input::Spatial::SpatialHoldStartedEventArgs* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Input.Spatial.SpatialHoldStartedEventArgs", L"TryGetPointerPose", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::Perception::Spatial::SpatialCoordinateSystem>(args, 0);

                return py::convert(self->obj.TryGetPointerPose(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* SpatialHoldStartedEventArgs_get_InteractionSourceKind(py::wrapper::Windows::UI::Input::Spatial::SpatialHoldStartedEventArgs* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Input.Spatial.SpatialHoldStartedEventArgs", L"InteractionSourceKind"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.InteractionSourceKind());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_SpatialHoldStartedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::Input::Spatial::SpatialHoldStartedEventArgs>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_SpatialHoldStartedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Input::Spatial::SpatialHoldStartedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_SpatialHoldStartedEventArgs[] = {
        { "try_get_pointer_pose", reinterpret_cast<PyCFunction>(SpatialHoldStartedEventArgs_TryGetPointerPose), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_SpatialHoldStartedEventArgs, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_SpatialHoldStartedEventArgs), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_SpatialHoldStartedEventArgs[] = {
        { "interaction_source_kind", reinterpret_cast<getter>(SpatialHoldStartedEventArgs_get_InteractionSourceKind), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_SpatialHoldStartedEventArgs[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_SpatialHoldStartedEventArgs) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_SpatialHoldStartedEventArgs) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_SpatialHoldStartedEventArgs) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_SpatialHoldStartedEventArgs) },
        { },
    };

    static PyType_Spec type_spec_SpatialHoldStartedEventArgs =
    {
        "_winrt_Windows_UI_Input_Spatial.SpatialHoldStartedEventArgs",
        sizeof(py::wrapper::Windows::UI::Input::Spatial::SpatialHoldStartedEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_SpatialHoldStartedEventArgs
    };

    // ----- SpatialInteraction class --------------------
    static constexpr const char* const type_name_SpatialInteraction = "SpatialInteraction";

    static PyObject* _new_SpatialInteraction(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_SpatialInteraction);
        return nullptr;
    }

    static void _dealloc_SpatialInteraction(py::wrapper::Windows::UI::Input::Spatial::SpatialInteraction* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* SpatialInteraction_get_SourceState(py::wrapper::Windows::UI::Input::Spatial::SpatialInteraction* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Input.Spatial.SpatialInteraction", L"SourceState"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.SourceState());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_SpatialInteraction(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::Input::Spatial::SpatialInteraction>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_SpatialInteraction(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Input::Spatial::SpatialInteraction>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_SpatialInteraction[] = {
        { "_assign_array_", _assign_array_SpatialInteraction, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_SpatialInteraction), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_SpatialInteraction[] = {
        { "source_state", reinterpret_cast<getter>(SpatialInteraction_get_SourceState), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_SpatialInteraction[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_SpatialInteraction) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_SpatialInteraction) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_SpatialInteraction) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_SpatialInteraction) },
        { },
    };

    static PyType_Spec type_spec_SpatialInteraction =
    {
        "_winrt_Windows_UI_Input_Spatial.SpatialInteraction",
        sizeof(py::wrapper::Windows::UI::Input::Spatial::SpatialInteraction),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_SpatialInteraction
    };

    // ----- SpatialInteractionController class --------------------
    static constexpr const char* const type_name_SpatialInteractionController = "SpatialInteractionController";

    static PyObject* _new_SpatialInteractionController(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_SpatialInteractionController);
        return nullptr;
    }

    static void _dealloc_SpatialInteractionController(py::wrapper::Windows::UI::Input::Spatial::SpatialInteractionController* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* SpatialInteractionController_TryGetBatteryReport(py::wrapper::Windows::UI::Input::Spatial::SpatialInteractionController* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Input.Spatial.SpatialInteractionController", L"TryGetBatteryReport", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(self->obj.TryGetBatteryReport());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* SpatialInteractionController_TryGetRenderableModelAsync(py::wrapper::Windows::UI::Input::Spatial::SpatialInteractionController* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Input.Spatial.SpatialInteractionController", L"TryGetRenderableModelAsync", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(self->obj.TryGetRenderableModelAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* SpatialInteractionController_get_HasThumbstick(py::wrapper::Windows::UI::Input::Spatial::SpatialInteractionController* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Input.Spatial.SpatialInteractionController", L"HasThumbstick"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.HasThumbstick());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SpatialInteractionController_get_HasTouchpad(py::wrapper::Windows::UI::Input::Spatial::SpatialInteractionController* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Input.Spatial.SpatialInteractionController", L"HasTouchpad"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.HasTouchpad());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SpatialInteractionController_get_ProductId(py::wrapper::Windows::UI::Input::Spatial::SpatialInteractionController* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Input.Spatial.SpatialInteractionController", L"ProductId"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.ProductId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SpatialInteractionController_get_SimpleHapticsController(py::wrapper::Windows::UI::Input::Spatial::SpatialInteractionController* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Input.Spatial.SpatialInteractionController", L"SimpleHapticsController"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.SimpleHapticsController());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SpatialInteractionController_get_VendorId(py::wrapper::Windows::UI::Input::Spatial::SpatialInteractionController* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Input.Spatial.SpatialInteractionController", L"VendorId"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.VendorId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SpatialInteractionController_get_Version(py::wrapper::Windows::UI::Input::Spatial::SpatialInteractionController* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Input.Spatial.SpatialInteractionController", L"Version"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Version());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_SpatialInteractionController(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::Input::Spatial::SpatialInteractionController>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_SpatialInteractionController(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Input::Spatial::SpatialInteractionController>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_SpatialInteractionController[] = {
        { "try_get_battery_report", reinterpret_cast<PyCFunction>(SpatialInteractionController_TryGetBatteryReport), METH_VARARGS, nullptr },
        { "try_get_renderable_model_async", reinterpret_cast<PyCFunction>(SpatialInteractionController_TryGetRenderableModelAsync), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_SpatialInteractionController, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_SpatialInteractionController), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_SpatialInteractionController[] = {
        { "has_thumbstick", reinterpret_cast<getter>(SpatialInteractionController_get_HasThumbstick), nullptr, nullptr, nullptr },
        { "has_touchpad", reinterpret_cast<getter>(SpatialInteractionController_get_HasTouchpad), nullptr, nullptr, nullptr },
        { "product_id", reinterpret_cast<getter>(SpatialInteractionController_get_ProductId), nullptr, nullptr, nullptr },
        { "simple_haptics_controller", reinterpret_cast<getter>(SpatialInteractionController_get_SimpleHapticsController), nullptr, nullptr, nullptr },
        { "vendor_id", reinterpret_cast<getter>(SpatialInteractionController_get_VendorId), nullptr, nullptr, nullptr },
        { "version", reinterpret_cast<getter>(SpatialInteractionController_get_Version), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_SpatialInteractionController[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_SpatialInteractionController) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_SpatialInteractionController) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_SpatialInteractionController) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_SpatialInteractionController) },
        { },
    };

    static PyType_Spec type_spec_SpatialInteractionController =
    {
        "_winrt_Windows_UI_Input_Spatial.SpatialInteractionController",
        sizeof(py::wrapper::Windows::UI::Input::Spatial::SpatialInteractionController),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_SpatialInteractionController
    };

    // ----- SpatialInteractionControllerProperties class --------------------
    static constexpr const char* const type_name_SpatialInteractionControllerProperties = "SpatialInteractionControllerProperties";

    static PyObject* _new_SpatialInteractionControllerProperties(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_SpatialInteractionControllerProperties);
        return nullptr;
    }

    static void _dealloc_SpatialInteractionControllerProperties(py::wrapper::Windows::UI::Input::Spatial::SpatialInteractionControllerProperties* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* SpatialInteractionControllerProperties_get_IsThumbstickPressed(py::wrapper::Windows::UI::Input::Spatial::SpatialInteractionControllerProperties* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Input.Spatial.SpatialInteractionControllerProperties", L"IsThumbstickPressed"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.IsThumbstickPressed());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SpatialInteractionControllerProperties_get_IsTouchpadPressed(py::wrapper::Windows::UI::Input::Spatial::SpatialInteractionControllerProperties* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Input.Spatial.SpatialInteractionControllerProperties", L"IsTouchpadPressed"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.IsTouchpadPressed());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SpatialInteractionControllerProperties_get_IsTouchpadTouched(py::wrapper::Windows::UI::Input::Spatial::SpatialInteractionControllerProperties* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Input.Spatial.SpatialInteractionControllerProperties", L"IsTouchpadTouched"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.IsTouchpadTouched());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SpatialInteractionControllerProperties_get_ThumbstickX(py::wrapper::Windows::UI::Input::Spatial::SpatialInteractionControllerProperties* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Input.Spatial.SpatialInteractionControllerProperties", L"ThumbstickX"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.ThumbstickX());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SpatialInteractionControllerProperties_get_ThumbstickY(py::wrapper::Windows::UI::Input::Spatial::SpatialInteractionControllerProperties* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Input.Spatial.SpatialInteractionControllerProperties", L"ThumbstickY"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.ThumbstickY());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SpatialInteractionControllerProperties_get_TouchpadX(py::wrapper::Windows::UI::Input::Spatial::SpatialInteractionControllerProperties* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Input.Spatial.SpatialInteractionControllerProperties", L"TouchpadX"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.TouchpadX());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SpatialInteractionControllerProperties_get_TouchpadY(py::wrapper::Windows::UI::Input::Spatial::SpatialInteractionControllerProperties* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Input.Spatial.SpatialInteractionControllerProperties", L"TouchpadY"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.TouchpadY());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_SpatialInteractionControllerProperties(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::Input::Spatial::SpatialInteractionControllerProperties>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_SpatialInteractionControllerProperties(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Input::Spatial::SpatialInteractionControllerProperties>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_SpatialInteractionControllerProperties[] = {
        { "_assign_array_", _assign_array_SpatialInteractionControllerProperties, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_SpatialInteractionControllerProperties), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_SpatialInteractionControllerProperties[] = {
        { "is_thumbstick_pressed", reinterpret_cast<getter>(SpatialInteractionControllerProperties_get_IsThumbstickPressed), nullptr, nullptr, nullptr },
        { "is_touchpad_pressed", reinterpret_cast<getter>(SpatialInteractionControllerProperties_get_IsTouchpadPressed), nullptr, nullptr, nullptr },
        { "is_touchpad_touched", reinterpret_cast<getter>(SpatialInteractionControllerProperties_get_IsTouchpadTouched), nullptr, nullptr, nullptr },
        { "thumbstick_x", reinterpret_cast<getter>(SpatialInteractionControllerProperties_get_ThumbstickX), nullptr, nullptr, nullptr },
        { "thumbstick_y", reinterpret_cast<getter>(SpatialInteractionControllerProperties_get_ThumbstickY), nullptr, nullptr, nullptr },
        { "touchpad_x", reinterpret_cast<getter>(SpatialInteractionControllerProperties_get_TouchpadX), nullptr, nullptr, nullptr },
        { "touchpad_y", reinterpret_cast<getter>(SpatialInteractionControllerProperties_get_TouchpadY), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_SpatialInteractionControllerProperties[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_SpatialInteractionControllerProperties) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_SpatialInteractionControllerProperties) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_SpatialInteractionControllerProperties) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_SpatialInteractionControllerProperties) },
        { },
    };

    static PyType_Spec type_spec_SpatialInteractionControllerProperties =
    {
        "_winrt_Windows_UI_Input_Spatial.SpatialInteractionControllerProperties",
        sizeof(py::wrapper::Windows::UI::Input::Spatial::SpatialInteractionControllerProperties),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_SpatialInteractionControllerProperties
    };

    // ----- SpatialInteractionDetectedEventArgs class --------------------
    static constexpr const char* const type_name_SpatialInteractionDetectedEventArgs = "SpatialInteractionDetectedEventArgs";

    static PyObject* _new_SpatialInteractionDetectedEventArgs(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_SpatialInteractionDetectedEventArgs);
        return nullptr;
    }

    static void _dealloc_SpatialInteractionDetectedEventArgs(py::wrapper::Windows::UI::Input::Spatial::SpatialInteractionDetectedEventArgs* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* SpatialInteractionDetectedEventArgs_TryGetPointerPose(py::wrapper::Windows::UI::Input::Spatial::SpatialInteractionDetectedEventArgs* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Input.Spatial.SpatialInteractionDetectedEventArgs", L"TryGetPointerPose", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::Perception::Spatial::SpatialCoordinateSystem>(args, 0);

                return py::convert(self->obj.TryGetPointerPose(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* SpatialInteractionDetectedEventArgs_get_Interaction(py::wrapper::Windows::UI::Input::Spatial::SpatialInteractionDetectedEventArgs* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Input.Spatial.SpatialInteractionDetectedEventArgs", L"Interaction"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Interaction());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SpatialInteractionDetectedEventArgs_get_InteractionSourceKind(py::wrapper::Windows::UI::Input::Spatial::SpatialInteractionDetectedEventArgs* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Input.Spatial.SpatialInteractionDetectedEventArgs", L"InteractionSourceKind"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.InteractionSourceKind());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SpatialInteractionDetectedEventArgs_get_InteractionSource(py::wrapper::Windows::UI::Input::Spatial::SpatialInteractionDetectedEventArgs* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Input.Spatial.SpatialInteractionDetectedEventArgs", L"InteractionSource"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.InteractionSource());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_SpatialInteractionDetectedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::Input::Spatial::SpatialInteractionDetectedEventArgs>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_SpatialInteractionDetectedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Input::Spatial::SpatialInteractionDetectedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_SpatialInteractionDetectedEventArgs[] = {
        { "try_get_pointer_pose", reinterpret_cast<PyCFunction>(SpatialInteractionDetectedEventArgs_TryGetPointerPose), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_SpatialInteractionDetectedEventArgs, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_SpatialInteractionDetectedEventArgs), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_SpatialInteractionDetectedEventArgs[] = {
        { "interaction", reinterpret_cast<getter>(SpatialInteractionDetectedEventArgs_get_Interaction), nullptr, nullptr, nullptr },
        { "interaction_source_kind", reinterpret_cast<getter>(SpatialInteractionDetectedEventArgs_get_InteractionSourceKind), nullptr, nullptr, nullptr },
        { "interaction_source", reinterpret_cast<getter>(SpatialInteractionDetectedEventArgs_get_InteractionSource), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_SpatialInteractionDetectedEventArgs[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_SpatialInteractionDetectedEventArgs) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_SpatialInteractionDetectedEventArgs) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_SpatialInteractionDetectedEventArgs) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_SpatialInteractionDetectedEventArgs) },
        { },
    };

    static PyType_Spec type_spec_SpatialInteractionDetectedEventArgs =
    {
        "_winrt_Windows_UI_Input_Spatial.SpatialInteractionDetectedEventArgs",
        sizeof(py::wrapper::Windows::UI::Input::Spatial::SpatialInteractionDetectedEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_SpatialInteractionDetectedEventArgs
    };

    // ----- SpatialInteractionManager class --------------------
    static constexpr const char* const type_name_SpatialInteractionManager = "SpatialInteractionManager";

    static PyObject* _new_SpatialInteractionManager(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_SpatialInteractionManager);
        return nullptr;
    }

    static void _dealloc_SpatialInteractionManager(py::wrapper::Windows::UI::Input::Spatial::SpatialInteractionManager* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* SpatialInteractionManager_GetDetectedSourcesAtTimestamp(py::wrapper::Windows::UI::Input::Spatial::SpatialInteractionManager* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Input.Spatial.SpatialInteractionManager", L"GetDetectedSourcesAtTimestamp", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::Perception::PerceptionTimestamp>(args, 0);

                return py::convert(self->obj.GetDetectedSourcesAtTimestamp(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* SpatialInteractionManager_GetForCurrentView(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Input.Spatial.SpatialInteractionManager", L"GetForCurrentView", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(winrt::Windows::UI::Input::Spatial::SpatialInteractionManager::GetForCurrentView());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* SpatialInteractionManager_IsSourceKindSupported(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Input.Spatial.SpatialInteractionManager", L"IsSourceKindSupported", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::UI::Input::Spatial::SpatialInteractionSourceKind>(args, 0);

                return py::convert(winrt::Windows::UI::Input::Spatial::SpatialInteractionManager::IsSourceKindSupported(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* SpatialInteractionManager_add_InteractionDetected(py::wrapper::Windows::UI::Input::Spatial::SpatialInteractionManager* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.UI.Input.Spatial.SpatialInteractionManager", L"InteractionDetected"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::UI::Input::Spatial::SpatialInteractionManager, winrt::Windows::UI::Input::Spatial::SpatialInteractionDetectedEventArgs>>(arg);

            return py::convert(self->obj.InteractionDetected(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SpatialInteractionManager_remove_InteractionDetected(py::wrapper::Windows::UI::Input::Spatial::SpatialInteractionManager* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.UI.Input.Spatial.SpatialInteractionManager", L"InteractionDetected"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.InteractionDetected(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SpatialInteractionManager_add_SourceDetected(py::wrapper::Windows::UI::Input::Spatial::SpatialInteractionManager* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.UI.Input.Spatial.SpatialInteractionManager", L"SourceDetected"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::UI::Input::Spatial::SpatialInteractionManager, winrt::Windows::UI::Input::Spatial::SpatialInteractionSourceEventArgs>>(arg);

            return py::convert(self->obj.SourceDetected(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SpatialInteractionManager_remove_SourceDetected(py::wrapper::Windows::UI::Input::Spatial::SpatialInteractionManager* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.UI.Input.Spatial.SpatialInteractionManager", L"SourceDetected"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.SourceDetected(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SpatialInteractionManager_add_SourceLost(py::wrapper::Windows::UI::Input::Spatial::SpatialInteractionManager* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.UI.Input.Spatial.SpatialInteractionManager", L"SourceLost"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::UI::Input::Spatial::SpatialInteractionManager, winrt::Windows::UI::Input::Spatial::SpatialInteractionSourceEventArgs>>(arg);

            return py::convert(self->obj.SourceLost(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SpatialInteractionManager_remove_SourceLost(py::wrapper::Windows::UI::Input::Spatial::SpatialInteractionManager* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.UI.Input.Spatial.SpatialInteractionManager", L"SourceLost"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.SourceLost(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SpatialInteractionManager_add_SourcePressed(py::wrapper::Windows::UI::Input::Spatial::SpatialInteractionManager* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.UI.Input.Spatial.SpatialInteractionManager", L"SourcePressed"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::UI::Input::Spatial::SpatialInteractionManager, winrt::Windows::UI::Input::Spatial::SpatialInteractionSourceEventArgs>>(arg);

            return py::convert(self->obj.SourcePressed(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SpatialInteractionManager_remove_SourcePressed(py::wrapper::Windows::UI::Input::Spatial::SpatialInteractionManager* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.UI.Input.Spatial.SpatialInteractionManager", L"SourcePressed"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.SourcePressed(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SpatialInteractionManager_add_SourceReleased(py::wrapper::Windows::UI::Input::Spatial::SpatialInteractionManager* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.UI.Input.Spatial.SpatialInteractionManager", L"SourceReleased"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::UI::Input::Spatial::SpatialInteractionManager, winrt::Windows::UI::Input::Spatial::SpatialInteractionSourceEventArgs>>(arg);

            return py::convert(self->obj.SourceReleased(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SpatialInteractionManager_remove_SourceReleased(py::wrapper::Windows::UI::Input::Spatial::SpatialInteractionManager* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.UI.Input.Spatial.SpatialInteractionManager", L"SourceReleased"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.SourceReleased(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SpatialInteractionManager_add_SourceUpdated(py::wrapper::Windows::UI::Input::Spatial::SpatialInteractionManager* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.UI.Input.Spatial.SpatialInteractionManager", L"SourceUpdated"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::UI::Input::Spatial::SpatialInteractionManager, winrt::Windows::UI::Input::Spatial::SpatialInteractionSourceEventArgs>>(arg);

            return py::convert(self->obj.SourceUpdated(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SpatialInteractionManager_remove_SourceUpdated(py::wrapper::Windows::UI::Input::Spatial::SpatialInteractionManager* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.UI.Input.Spatial.SpatialInteractionManager", L"SourceUpdated"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.SourceUpdated(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_SpatialInteractionManager(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::Input::Spatial::SpatialInteractionManager>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_SpatialInteractionManager(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Input::Spatial::SpatialInteractionManager>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_SpatialInteractionManager[] = {
        { "get_detected_sources_at_timestamp", reinterpret_cast<PyCFunction>(SpatialInteractionManager_GetDetectedSourcesAtTimestamp), METH_VARARGS, nullptr },
        { "get_for_current_view", reinterpret_cast<PyCFunction>(SpatialInteractionManager_GetForCurrentView), METH_VARARGS | METH_STATIC, nullptr },
        { "is_source_kind_supported", reinterpret_cast<PyCFunction>(SpatialInteractionManager_IsSourceKindSupported), METH_VARARGS | METH_STATIC, nullptr },
        { "add_interaction_detected", reinterpret_cast<PyCFunction>(SpatialInteractionManager_add_InteractionDetected), METH_O, nullptr },
        { "remove_interaction_detected", reinterpret_cast<PyCFunction>(SpatialInteractionManager_remove_InteractionDetected), METH_O, nullptr },
        { "add_source_detected", reinterpret_cast<PyCFunction>(SpatialInteractionManager_add_SourceDetected), METH_O, nullptr },
        { "remove_source_detected", reinterpret_cast<PyCFunction>(SpatialInteractionManager_remove_SourceDetected), METH_O, nullptr },
        { "add_source_lost", reinterpret_cast<PyCFunction>(SpatialInteractionManager_add_SourceLost), METH_O, nullptr },
        { "remove_source_lost", reinterpret_cast<PyCFunction>(SpatialInteractionManager_remove_SourceLost), METH_O, nullptr },
        { "add_source_pressed", reinterpret_cast<PyCFunction>(SpatialInteractionManager_add_SourcePressed), METH_O, nullptr },
        { "remove_source_pressed", reinterpret_cast<PyCFunction>(SpatialInteractionManager_remove_SourcePressed), METH_O, nullptr },
        { "add_source_released", reinterpret_cast<PyCFunction>(SpatialInteractionManager_add_SourceReleased), METH_O, nullptr },
        { "remove_source_released", reinterpret_cast<PyCFunction>(SpatialInteractionManager_remove_SourceReleased), METH_O, nullptr },
        { "add_source_updated", reinterpret_cast<PyCFunction>(SpatialInteractionManager_add_SourceUpdated), METH_O, nullptr },
        { "remove_source_updated", reinterpret_cast<PyCFunction>(SpatialInteractionManager_remove_SourceUpdated), METH_O, nullptr },
        { "_assign_array_", _assign_array_SpatialInteractionManager, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_SpatialInteractionManager), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_SpatialInteractionManager[] = {
        { }
    };

    static PyType_Slot _type_slots_SpatialInteractionManager[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_SpatialInteractionManager) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_SpatialInteractionManager) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_SpatialInteractionManager) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_SpatialInteractionManager) },
        { },
    };

    static PyType_Spec type_spec_SpatialInteractionManager =
    {
        "_winrt_Windows_UI_Input_Spatial.SpatialInteractionManager",
        sizeof(py::wrapper::Windows::UI::Input::Spatial::SpatialInteractionManager),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_SpatialInteractionManager
    };

    // ----- SpatialInteractionSource class --------------------
    static constexpr const char* const type_name_SpatialInteractionSource = "SpatialInteractionSource";

    static PyObject* _new_SpatialInteractionSource(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_SpatialInteractionSource);
        return nullptr;
    }

    static void _dealloc_SpatialInteractionSource(py::wrapper::Windows::UI::Input::Spatial::SpatialInteractionSource* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* SpatialInteractionSource_TryCreateHandMeshObserver(py::wrapper::Windows::UI::Input::Spatial::SpatialInteractionSource* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Input.Spatial.SpatialInteractionSource", L"TryCreateHandMeshObserver", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(self->obj.TryCreateHandMeshObserver());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* SpatialInteractionSource_TryCreateHandMeshObserverAsync(py::wrapper::Windows::UI::Input::Spatial::SpatialInteractionSource* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Input.Spatial.SpatialInteractionSource", L"TryCreateHandMeshObserverAsync", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(self->obj.TryCreateHandMeshObserverAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* SpatialInteractionSource_TryGetStateAtTimestamp(py::wrapper::Windows::UI::Input::Spatial::SpatialInteractionSource* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Input.Spatial.SpatialInteractionSource", L"TryGetStateAtTimestamp", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::Perception::PerceptionTimestamp>(args, 0);

                return py::convert(self->obj.TryGetStateAtTimestamp(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* SpatialInteractionSource_get_Id(py::wrapper::Windows::UI::Input::Spatial::SpatialInteractionSource* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Input.Spatial.SpatialInteractionSource", L"Id"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Id());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SpatialInteractionSource_get_Kind(py::wrapper::Windows::UI::Input::Spatial::SpatialInteractionSource* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Input.Spatial.SpatialInteractionSource", L"Kind"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Kind());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SpatialInteractionSource_get_Controller(py::wrapper::Windows::UI::Input::Spatial::SpatialInteractionSource* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Input.Spatial.SpatialInteractionSource", L"Controller"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Controller());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SpatialInteractionSource_get_IsGraspSupported(py::wrapper::Windows::UI::Input::Spatial::SpatialInteractionSource* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Input.Spatial.SpatialInteractionSource", L"IsGraspSupported"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.IsGraspSupported());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SpatialInteractionSource_get_IsMenuSupported(py::wrapper::Windows::UI::Input::Spatial::SpatialInteractionSource* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Input.Spatial.SpatialInteractionSource", L"IsMenuSupported"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.IsMenuSupported());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SpatialInteractionSource_get_IsPointingSupported(py::wrapper::Windows::UI::Input::Spatial::SpatialInteractionSource* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Input.Spatial.SpatialInteractionSource", L"IsPointingSupported"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.IsPointingSupported());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SpatialInteractionSource_get_Handedness(py::wrapper::Windows::UI::Input::Spatial::SpatialInteractionSource* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Input.Spatial.SpatialInteractionSource", L"Handedness"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Handedness());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_SpatialInteractionSource(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::Input::Spatial::SpatialInteractionSource>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_SpatialInteractionSource(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Input::Spatial::SpatialInteractionSource>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_SpatialInteractionSource[] = {
        { "try_create_hand_mesh_observer", reinterpret_cast<PyCFunction>(SpatialInteractionSource_TryCreateHandMeshObserver), METH_VARARGS, nullptr },
        { "try_create_hand_mesh_observer_async", reinterpret_cast<PyCFunction>(SpatialInteractionSource_TryCreateHandMeshObserverAsync), METH_VARARGS, nullptr },
        { "try_get_state_at_timestamp", reinterpret_cast<PyCFunction>(SpatialInteractionSource_TryGetStateAtTimestamp), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_SpatialInteractionSource, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_SpatialInteractionSource), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_SpatialInteractionSource[] = {
        { "id", reinterpret_cast<getter>(SpatialInteractionSource_get_Id), nullptr, nullptr, nullptr },
        { "kind", reinterpret_cast<getter>(SpatialInteractionSource_get_Kind), nullptr, nullptr, nullptr },
        { "controller", reinterpret_cast<getter>(SpatialInteractionSource_get_Controller), nullptr, nullptr, nullptr },
        { "is_grasp_supported", reinterpret_cast<getter>(SpatialInteractionSource_get_IsGraspSupported), nullptr, nullptr, nullptr },
        { "is_menu_supported", reinterpret_cast<getter>(SpatialInteractionSource_get_IsMenuSupported), nullptr, nullptr, nullptr },
        { "is_pointing_supported", reinterpret_cast<getter>(SpatialInteractionSource_get_IsPointingSupported), nullptr, nullptr, nullptr },
        { "handedness", reinterpret_cast<getter>(SpatialInteractionSource_get_Handedness), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_SpatialInteractionSource[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_SpatialInteractionSource) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_SpatialInteractionSource) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_SpatialInteractionSource) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_SpatialInteractionSource) },
        { },
    };

    static PyType_Spec type_spec_SpatialInteractionSource =
    {
        "_winrt_Windows_UI_Input_Spatial.SpatialInteractionSource",
        sizeof(py::wrapper::Windows::UI::Input::Spatial::SpatialInteractionSource),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_SpatialInteractionSource
    };

    // ----- SpatialInteractionSourceEventArgs class --------------------
    static constexpr const char* const type_name_SpatialInteractionSourceEventArgs = "SpatialInteractionSourceEventArgs";

    static PyObject* _new_SpatialInteractionSourceEventArgs(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_SpatialInteractionSourceEventArgs);
        return nullptr;
    }

    static void _dealloc_SpatialInteractionSourceEventArgs(py::wrapper::Windows::UI::Input::Spatial::SpatialInteractionSourceEventArgs* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* SpatialInteractionSourceEventArgs_get_State(py::wrapper::Windows::UI::Input::Spatial::SpatialInteractionSourceEventArgs* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Input.Spatial.SpatialInteractionSourceEventArgs", L"State"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.State());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SpatialInteractionSourceEventArgs_get_PressKind(py::wrapper::Windows::UI::Input::Spatial::SpatialInteractionSourceEventArgs* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Input.Spatial.SpatialInteractionSourceEventArgs", L"PressKind"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.PressKind());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_SpatialInteractionSourceEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::Input::Spatial::SpatialInteractionSourceEventArgs>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_SpatialInteractionSourceEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Input::Spatial::SpatialInteractionSourceEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_SpatialInteractionSourceEventArgs[] = {
        { "_assign_array_", _assign_array_SpatialInteractionSourceEventArgs, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_SpatialInteractionSourceEventArgs), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_SpatialInteractionSourceEventArgs[] = {
        { "state", reinterpret_cast<getter>(SpatialInteractionSourceEventArgs_get_State), nullptr, nullptr, nullptr },
        { "press_kind", reinterpret_cast<getter>(SpatialInteractionSourceEventArgs_get_PressKind), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_SpatialInteractionSourceEventArgs[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_SpatialInteractionSourceEventArgs) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_SpatialInteractionSourceEventArgs) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_SpatialInteractionSourceEventArgs) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_SpatialInteractionSourceEventArgs) },
        { },
    };

    static PyType_Spec type_spec_SpatialInteractionSourceEventArgs =
    {
        "_winrt_Windows_UI_Input_Spatial.SpatialInteractionSourceEventArgs",
        sizeof(py::wrapper::Windows::UI::Input::Spatial::SpatialInteractionSourceEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_SpatialInteractionSourceEventArgs
    };

    // ----- SpatialInteractionSourceLocation class --------------------
    static constexpr const char* const type_name_SpatialInteractionSourceLocation = "SpatialInteractionSourceLocation";

    static PyObject* _new_SpatialInteractionSourceLocation(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_SpatialInteractionSourceLocation);
        return nullptr;
    }

    static void _dealloc_SpatialInteractionSourceLocation(py::wrapper::Windows::UI::Input::Spatial::SpatialInteractionSourceLocation* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* SpatialInteractionSourceLocation_get_Position(py::wrapper::Windows::UI::Input::Spatial::SpatialInteractionSourceLocation* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Input.Spatial.SpatialInteractionSourceLocation", L"Position"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Position());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SpatialInteractionSourceLocation_get_Velocity(py::wrapper::Windows::UI::Input::Spatial::SpatialInteractionSourceLocation* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Input.Spatial.SpatialInteractionSourceLocation", L"Velocity"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Velocity());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SpatialInteractionSourceLocation_get_Orientation(py::wrapper::Windows::UI::Input::Spatial::SpatialInteractionSourceLocation* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Input.Spatial.SpatialInteractionSourceLocation", L"Orientation"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Orientation());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SpatialInteractionSourceLocation_get_AngularVelocity(py::wrapper::Windows::UI::Input::Spatial::SpatialInteractionSourceLocation* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Input.Spatial.SpatialInteractionSourceLocation", L"AngularVelocity"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.AngularVelocity());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SpatialInteractionSourceLocation_get_PositionAccuracy(py::wrapper::Windows::UI::Input::Spatial::SpatialInteractionSourceLocation* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Input.Spatial.SpatialInteractionSourceLocation", L"PositionAccuracy"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.PositionAccuracy());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SpatialInteractionSourceLocation_get_SourcePointerPose(py::wrapper::Windows::UI::Input::Spatial::SpatialInteractionSourceLocation* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Input.Spatial.SpatialInteractionSourceLocation", L"SourcePointerPose"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.SourcePointerPose());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_SpatialInteractionSourceLocation(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::Input::Spatial::SpatialInteractionSourceLocation>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_SpatialInteractionSourceLocation(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Input::Spatial::SpatialInteractionSourceLocation>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_SpatialInteractionSourceLocation[] = {
        { "_assign_array_", _assign_array_SpatialInteractionSourceLocation, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_SpatialInteractionSourceLocation), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_SpatialInteractionSourceLocation[] = {
        { "position", reinterpret_cast<getter>(SpatialInteractionSourceLocation_get_Position), nullptr, nullptr, nullptr },
        { "velocity", reinterpret_cast<getter>(SpatialInteractionSourceLocation_get_Velocity), nullptr, nullptr, nullptr },
        { "orientation", reinterpret_cast<getter>(SpatialInteractionSourceLocation_get_Orientation), nullptr, nullptr, nullptr },
        { "angular_velocity", reinterpret_cast<getter>(SpatialInteractionSourceLocation_get_AngularVelocity), nullptr, nullptr, nullptr },
        { "position_accuracy", reinterpret_cast<getter>(SpatialInteractionSourceLocation_get_PositionAccuracy), nullptr, nullptr, nullptr },
        { "source_pointer_pose", reinterpret_cast<getter>(SpatialInteractionSourceLocation_get_SourcePointerPose), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_SpatialInteractionSourceLocation[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_SpatialInteractionSourceLocation) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_SpatialInteractionSourceLocation) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_SpatialInteractionSourceLocation) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_SpatialInteractionSourceLocation) },
        { },
    };

    static PyType_Spec type_spec_SpatialInteractionSourceLocation =
    {
        "_winrt_Windows_UI_Input_Spatial.SpatialInteractionSourceLocation",
        sizeof(py::wrapper::Windows::UI::Input::Spatial::SpatialInteractionSourceLocation),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_SpatialInteractionSourceLocation
    };

    // ----- SpatialInteractionSourceProperties class --------------------
    static constexpr const char* const type_name_SpatialInteractionSourceProperties = "SpatialInteractionSourceProperties";

    static PyObject* _new_SpatialInteractionSourceProperties(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_SpatialInteractionSourceProperties);
        return nullptr;
    }

    static void _dealloc_SpatialInteractionSourceProperties(py::wrapper::Windows::UI::Input::Spatial::SpatialInteractionSourceProperties* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* SpatialInteractionSourceProperties_TryGetLocation(py::wrapper::Windows::UI::Input::Spatial::SpatialInteractionSourceProperties* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Input.Spatial.SpatialInteractionSourceProperties", L"TryGetLocation", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::Perception::Spatial::SpatialCoordinateSystem>(args, 0);

                return py::convert(self->obj.TryGetLocation(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* SpatialInteractionSourceProperties_TryGetSourceLossMitigationDirection(py::wrapper::Windows::UI::Input::Spatial::SpatialInteractionSourceProperties* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Input.Spatial.SpatialInteractionSourceProperties", L"TryGetSourceLossMitigationDirection", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::Perception::Spatial::SpatialCoordinateSystem>(args, 0);

                return py::convert(self->obj.TryGetSourceLossMitigationDirection(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* SpatialInteractionSourceProperties_get_SourceLossRisk(py::wrapper::Windows::UI::Input::Spatial::SpatialInteractionSourceProperties* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Input.Spatial.SpatialInteractionSourceProperties", L"SourceLossRisk"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.SourceLossRisk());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_SpatialInteractionSourceProperties(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::Input::Spatial::SpatialInteractionSourceProperties>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_SpatialInteractionSourceProperties(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Input::Spatial::SpatialInteractionSourceProperties>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_SpatialInteractionSourceProperties[] = {
        { "try_get_location", reinterpret_cast<PyCFunction>(SpatialInteractionSourceProperties_TryGetLocation), METH_VARARGS, nullptr },
        { "try_get_source_loss_mitigation_direction", reinterpret_cast<PyCFunction>(SpatialInteractionSourceProperties_TryGetSourceLossMitigationDirection), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_SpatialInteractionSourceProperties, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_SpatialInteractionSourceProperties), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_SpatialInteractionSourceProperties[] = {
        { "source_loss_risk", reinterpret_cast<getter>(SpatialInteractionSourceProperties_get_SourceLossRisk), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_SpatialInteractionSourceProperties[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_SpatialInteractionSourceProperties) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_SpatialInteractionSourceProperties) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_SpatialInteractionSourceProperties) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_SpatialInteractionSourceProperties) },
        { },
    };

    static PyType_Spec type_spec_SpatialInteractionSourceProperties =
    {
        "_winrt_Windows_UI_Input_Spatial.SpatialInteractionSourceProperties",
        sizeof(py::wrapper::Windows::UI::Input::Spatial::SpatialInteractionSourceProperties),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_SpatialInteractionSourceProperties
    };

    // ----- SpatialInteractionSourceState class --------------------
    static constexpr const char* const type_name_SpatialInteractionSourceState = "SpatialInteractionSourceState";

    static PyObject* _new_SpatialInteractionSourceState(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_SpatialInteractionSourceState);
        return nullptr;
    }

    static void _dealloc_SpatialInteractionSourceState(py::wrapper::Windows::UI::Input::Spatial::SpatialInteractionSourceState* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* SpatialInteractionSourceState_TryGetHandPose(py::wrapper::Windows::UI::Input::Spatial::SpatialInteractionSourceState* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Input.Spatial.SpatialInteractionSourceState", L"TryGetHandPose", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(self->obj.TryGetHandPose());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* SpatialInteractionSourceState_TryGetPointerPose(py::wrapper::Windows::UI::Input::Spatial::SpatialInteractionSourceState* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Input.Spatial.SpatialInteractionSourceState", L"TryGetPointerPose", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::Perception::Spatial::SpatialCoordinateSystem>(args, 0);

                return py::convert(self->obj.TryGetPointerPose(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* SpatialInteractionSourceState_get_IsPressed(py::wrapper::Windows::UI::Input::Spatial::SpatialInteractionSourceState* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Input.Spatial.SpatialInteractionSourceState", L"IsPressed"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.IsPressed());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SpatialInteractionSourceState_get_Properties(py::wrapper::Windows::UI::Input::Spatial::SpatialInteractionSourceState* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Input.Spatial.SpatialInteractionSourceState", L"Properties"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Properties());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SpatialInteractionSourceState_get_Source(py::wrapper::Windows::UI::Input::Spatial::SpatialInteractionSourceState* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Input.Spatial.SpatialInteractionSourceState", L"Source"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Source());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SpatialInteractionSourceState_get_Timestamp(py::wrapper::Windows::UI::Input::Spatial::SpatialInteractionSourceState* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Input.Spatial.SpatialInteractionSourceState", L"Timestamp"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Timestamp());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SpatialInteractionSourceState_get_ControllerProperties(py::wrapper::Windows::UI::Input::Spatial::SpatialInteractionSourceState* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Input.Spatial.SpatialInteractionSourceState", L"ControllerProperties"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.ControllerProperties());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SpatialInteractionSourceState_get_IsGrasped(py::wrapper::Windows::UI::Input::Spatial::SpatialInteractionSourceState* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Input.Spatial.SpatialInteractionSourceState", L"IsGrasped"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.IsGrasped());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SpatialInteractionSourceState_get_IsMenuPressed(py::wrapper::Windows::UI::Input::Spatial::SpatialInteractionSourceState* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Input.Spatial.SpatialInteractionSourceState", L"IsMenuPressed"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.IsMenuPressed());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SpatialInteractionSourceState_get_IsSelectPressed(py::wrapper::Windows::UI::Input::Spatial::SpatialInteractionSourceState* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Input.Spatial.SpatialInteractionSourceState", L"IsSelectPressed"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.IsSelectPressed());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SpatialInteractionSourceState_get_SelectPressedValue(py::wrapper::Windows::UI::Input::Spatial::SpatialInteractionSourceState* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Input.Spatial.SpatialInteractionSourceState", L"SelectPressedValue"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.SelectPressedValue());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_SpatialInteractionSourceState(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::Input::Spatial::SpatialInteractionSourceState>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_SpatialInteractionSourceState(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Input::Spatial::SpatialInteractionSourceState>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_SpatialInteractionSourceState[] = {
        { "try_get_hand_pose", reinterpret_cast<PyCFunction>(SpatialInteractionSourceState_TryGetHandPose), METH_VARARGS, nullptr },
        { "try_get_pointer_pose", reinterpret_cast<PyCFunction>(SpatialInteractionSourceState_TryGetPointerPose), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_SpatialInteractionSourceState, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_SpatialInteractionSourceState), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_SpatialInteractionSourceState[] = {
        { "is_pressed", reinterpret_cast<getter>(SpatialInteractionSourceState_get_IsPressed), nullptr, nullptr, nullptr },
        { "properties", reinterpret_cast<getter>(SpatialInteractionSourceState_get_Properties), nullptr, nullptr, nullptr },
        { "source", reinterpret_cast<getter>(SpatialInteractionSourceState_get_Source), nullptr, nullptr, nullptr },
        { "timestamp", reinterpret_cast<getter>(SpatialInteractionSourceState_get_Timestamp), nullptr, nullptr, nullptr },
        { "controller_properties", reinterpret_cast<getter>(SpatialInteractionSourceState_get_ControllerProperties), nullptr, nullptr, nullptr },
        { "is_grasped", reinterpret_cast<getter>(SpatialInteractionSourceState_get_IsGrasped), nullptr, nullptr, nullptr },
        { "is_menu_pressed", reinterpret_cast<getter>(SpatialInteractionSourceState_get_IsMenuPressed), nullptr, nullptr, nullptr },
        { "is_select_pressed", reinterpret_cast<getter>(SpatialInteractionSourceState_get_IsSelectPressed), nullptr, nullptr, nullptr },
        { "select_pressed_value", reinterpret_cast<getter>(SpatialInteractionSourceState_get_SelectPressedValue), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_SpatialInteractionSourceState[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_SpatialInteractionSourceState) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_SpatialInteractionSourceState) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_SpatialInteractionSourceState) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_SpatialInteractionSourceState) },
        { },
    };

    static PyType_Spec type_spec_SpatialInteractionSourceState =
    {
        "_winrt_Windows_UI_Input_Spatial.SpatialInteractionSourceState",
        sizeof(py::wrapper::Windows::UI::Input::Spatial::SpatialInteractionSourceState),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_SpatialInteractionSourceState
    };

    // ----- SpatialManipulationCanceledEventArgs class --------------------
    static constexpr const char* const type_name_SpatialManipulationCanceledEventArgs = "SpatialManipulationCanceledEventArgs";

    static PyObject* _new_SpatialManipulationCanceledEventArgs(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_SpatialManipulationCanceledEventArgs);
        return nullptr;
    }

    static void _dealloc_SpatialManipulationCanceledEventArgs(py::wrapper::Windows::UI::Input::Spatial::SpatialManipulationCanceledEventArgs* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* SpatialManipulationCanceledEventArgs_get_InteractionSourceKind(py::wrapper::Windows::UI::Input::Spatial::SpatialManipulationCanceledEventArgs* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Input.Spatial.SpatialManipulationCanceledEventArgs", L"InteractionSourceKind"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.InteractionSourceKind());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_SpatialManipulationCanceledEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::Input::Spatial::SpatialManipulationCanceledEventArgs>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_SpatialManipulationCanceledEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Input::Spatial::SpatialManipulationCanceledEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_SpatialManipulationCanceledEventArgs[] = {
        { "_assign_array_", _assign_array_SpatialManipulationCanceledEventArgs, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_SpatialManipulationCanceledEventArgs), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_SpatialManipulationCanceledEventArgs[] = {
        { "interaction_source_kind", reinterpret_cast<getter>(SpatialManipulationCanceledEventArgs_get_InteractionSourceKind), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_SpatialManipulationCanceledEventArgs[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_SpatialManipulationCanceledEventArgs) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_SpatialManipulationCanceledEventArgs) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_SpatialManipulationCanceledEventArgs) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_SpatialManipulationCanceledEventArgs) },
        { },
    };

    static PyType_Spec type_spec_SpatialManipulationCanceledEventArgs =
    {
        "_winrt_Windows_UI_Input_Spatial.SpatialManipulationCanceledEventArgs",
        sizeof(py::wrapper::Windows::UI::Input::Spatial::SpatialManipulationCanceledEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_SpatialManipulationCanceledEventArgs
    };

    // ----- SpatialManipulationCompletedEventArgs class --------------------
    static constexpr const char* const type_name_SpatialManipulationCompletedEventArgs = "SpatialManipulationCompletedEventArgs";

    static PyObject* _new_SpatialManipulationCompletedEventArgs(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_SpatialManipulationCompletedEventArgs);
        return nullptr;
    }

    static void _dealloc_SpatialManipulationCompletedEventArgs(py::wrapper::Windows::UI::Input::Spatial::SpatialManipulationCompletedEventArgs* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* SpatialManipulationCompletedEventArgs_TryGetCumulativeDelta(py::wrapper::Windows::UI::Input::Spatial::SpatialManipulationCompletedEventArgs* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Input.Spatial.SpatialManipulationCompletedEventArgs", L"TryGetCumulativeDelta", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::Perception::Spatial::SpatialCoordinateSystem>(args, 0);

                return py::convert(self->obj.TryGetCumulativeDelta(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* SpatialManipulationCompletedEventArgs_get_InteractionSourceKind(py::wrapper::Windows::UI::Input::Spatial::SpatialManipulationCompletedEventArgs* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Input.Spatial.SpatialManipulationCompletedEventArgs", L"InteractionSourceKind"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.InteractionSourceKind());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_SpatialManipulationCompletedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::Input::Spatial::SpatialManipulationCompletedEventArgs>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_SpatialManipulationCompletedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Input::Spatial::SpatialManipulationCompletedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_SpatialManipulationCompletedEventArgs[] = {
        { "try_get_cumulative_delta", reinterpret_cast<PyCFunction>(SpatialManipulationCompletedEventArgs_TryGetCumulativeDelta), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_SpatialManipulationCompletedEventArgs, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_SpatialManipulationCompletedEventArgs), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_SpatialManipulationCompletedEventArgs[] = {
        { "interaction_source_kind", reinterpret_cast<getter>(SpatialManipulationCompletedEventArgs_get_InteractionSourceKind), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_SpatialManipulationCompletedEventArgs[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_SpatialManipulationCompletedEventArgs) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_SpatialManipulationCompletedEventArgs) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_SpatialManipulationCompletedEventArgs) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_SpatialManipulationCompletedEventArgs) },
        { },
    };

    static PyType_Spec type_spec_SpatialManipulationCompletedEventArgs =
    {
        "_winrt_Windows_UI_Input_Spatial.SpatialManipulationCompletedEventArgs",
        sizeof(py::wrapper::Windows::UI::Input::Spatial::SpatialManipulationCompletedEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_SpatialManipulationCompletedEventArgs
    };

    // ----- SpatialManipulationDelta class --------------------
    static constexpr const char* const type_name_SpatialManipulationDelta = "SpatialManipulationDelta";

    static PyObject* _new_SpatialManipulationDelta(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_SpatialManipulationDelta);
        return nullptr;
    }

    static void _dealloc_SpatialManipulationDelta(py::wrapper::Windows::UI::Input::Spatial::SpatialManipulationDelta* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* SpatialManipulationDelta_get_Translation(py::wrapper::Windows::UI::Input::Spatial::SpatialManipulationDelta* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Input.Spatial.SpatialManipulationDelta", L"Translation"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Translation());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_SpatialManipulationDelta(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::Input::Spatial::SpatialManipulationDelta>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_SpatialManipulationDelta(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Input::Spatial::SpatialManipulationDelta>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_SpatialManipulationDelta[] = {
        { "_assign_array_", _assign_array_SpatialManipulationDelta, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_SpatialManipulationDelta), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_SpatialManipulationDelta[] = {
        { "translation", reinterpret_cast<getter>(SpatialManipulationDelta_get_Translation), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_SpatialManipulationDelta[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_SpatialManipulationDelta) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_SpatialManipulationDelta) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_SpatialManipulationDelta) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_SpatialManipulationDelta) },
        { },
    };

    static PyType_Spec type_spec_SpatialManipulationDelta =
    {
        "_winrt_Windows_UI_Input_Spatial.SpatialManipulationDelta",
        sizeof(py::wrapper::Windows::UI::Input::Spatial::SpatialManipulationDelta),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_SpatialManipulationDelta
    };

    // ----- SpatialManipulationStartedEventArgs class --------------------
    static constexpr const char* const type_name_SpatialManipulationStartedEventArgs = "SpatialManipulationStartedEventArgs";

    static PyObject* _new_SpatialManipulationStartedEventArgs(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_SpatialManipulationStartedEventArgs);
        return nullptr;
    }

    static void _dealloc_SpatialManipulationStartedEventArgs(py::wrapper::Windows::UI::Input::Spatial::SpatialManipulationStartedEventArgs* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* SpatialManipulationStartedEventArgs_TryGetPointerPose(py::wrapper::Windows::UI::Input::Spatial::SpatialManipulationStartedEventArgs* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Input.Spatial.SpatialManipulationStartedEventArgs", L"TryGetPointerPose", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::Perception::Spatial::SpatialCoordinateSystem>(args, 0);

                return py::convert(self->obj.TryGetPointerPose(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* SpatialManipulationStartedEventArgs_get_InteractionSourceKind(py::wrapper::Windows::UI::Input::Spatial::SpatialManipulationStartedEventArgs* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Input.Spatial.SpatialManipulationStartedEventArgs", L"InteractionSourceKind"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.InteractionSourceKind());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_SpatialManipulationStartedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::Input::Spatial::SpatialManipulationStartedEventArgs>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_SpatialManipulationStartedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Input::Spatial::SpatialManipulationStartedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_SpatialManipulationStartedEventArgs[] = {
        { "try_get_pointer_pose", reinterpret_cast<PyCFunction>(SpatialManipulationStartedEventArgs_TryGetPointerPose), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_SpatialManipulationStartedEventArgs, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_SpatialManipulationStartedEventArgs), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_SpatialManipulationStartedEventArgs[] = {
        { "interaction_source_kind", reinterpret_cast<getter>(SpatialManipulationStartedEventArgs_get_InteractionSourceKind), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_SpatialManipulationStartedEventArgs[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_SpatialManipulationStartedEventArgs) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_SpatialManipulationStartedEventArgs) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_SpatialManipulationStartedEventArgs) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_SpatialManipulationStartedEventArgs) },
        { },
    };

    static PyType_Spec type_spec_SpatialManipulationStartedEventArgs =
    {
        "_winrt_Windows_UI_Input_Spatial.SpatialManipulationStartedEventArgs",
        sizeof(py::wrapper::Windows::UI::Input::Spatial::SpatialManipulationStartedEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_SpatialManipulationStartedEventArgs
    };

    // ----- SpatialManipulationUpdatedEventArgs class --------------------
    static constexpr const char* const type_name_SpatialManipulationUpdatedEventArgs = "SpatialManipulationUpdatedEventArgs";

    static PyObject* _new_SpatialManipulationUpdatedEventArgs(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_SpatialManipulationUpdatedEventArgs);
        return nullptr;
    }

    static void _dealloc_SpatialManipulationUpdatedEventArgs(py::wrapper::Windows::UI::Input::Spatial::SpatialManipulationUpdatedEventArgs* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* SpatialManipulationUpdatedEventArgs_TryGetCumulativeDelta(py::wrapper::Windows::UI::Input::Spatial::SpatialManipulationUpdatedEventArgs* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Input.Spatial.SpatialManipulationUpdatedEventArgs", L"TryGetCumulativeDelta", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::Perception::Spatial::SpatialCoordinateSystem>(args, 0);

                return py::convert(self->obj.TryGetCumulativeDelta(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* SpatialManipulationUpdatedEventArgs_get_InteractionSourceKind(py::wrapper::Windows::UI::Input::Spatial::SpatialManipulationUpdatedEventArgs* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Input.Spatial.SpatialManipulationUpdatedEventArgs", L"InteractionSourceKind"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.InteractionSourceKind());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_SpatialManipulationUpdatedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::Input::Spatial::SpatialManipulationUpdatedEventArgs>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_SpatialManipulationUpdatedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Input::Spatial::SpatialManipulationUpdatedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_SpatialManipulationUpdatedEventArgs[] = {
        { "try_get_cumulative_delta", reinterpret_cast<PyCFunction>(SpatialManipulationUpdatedEventArgs_TryGetCumulativeDelta), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_SpatialManipulationUpdatedEventArgs, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_SpatialManipulationUpdatedEventArgs), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_SpatialManipulationUpdatedEventArgs[] = {
        { "interaction_source_kind", reinterpret_cast<getter>(SpatialManipulationUpdatedEventArgs_get_InteractionSourceKind), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_SpatialManipulationUpdatedEventArgs[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_SpatialManipulationUpdatedEventArgs) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_SpatialManipulationUpdatedEventArgs) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_SpatialManipulationUpdatedEventArgs) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_SpatialManipulationUpdatedEventArgs) },
        { },
    };

    static PyType_Spec type_spec_SpatialManipulationUpdatedEventArgs =
    {
        "_winrt_Windows_UI_Input_Spatial.SpatialManipulationUpdatedEventArgs",
        sizeof(py::wrapper::Windows::UI::Input::Spatial::SpatialManipulationUpdatedEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_SpatialManipulationUpdatedEventArgs
    };

    // ----- SpatialNavigationCanceledEventArgs class --------------------
    static constexpr const char* const type_name_SpatialNavigationCanceledEventArgs = "SpatialNavigationCanceledEventArgs";

    static PyObject* _new_SpatialNavigationCanceledEventArgs(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_SpatialNavigationCanceledEventArgs);
        return nullptr;
    }

    static void _dealloc_SpatialNavigationCanceledEventArgs(py::wrapper::Windows::UI::Input::Spatial::SpatialNavigationCanceledEventArgs* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* SpatialNavigationCanceledEventArgs_get_InteractionSourceKind(py::wrapper::Windows::UI::Input::Spatial::SpatialNavigationCanceledEventArgs* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Input.Spatial.SpatialNavigationCanceledEventArgs", L"InteractionSourceKind"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.InteractionSourceKind());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_SpatialNavigationCanceledEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::Input::Spatial::SpatialNavigationCanceledEventArgs>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_SpatialNavigationCanceledEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Input::Spatial::SpatialNavigationCanceledEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_SpatialNavigationCanceledEventArgs[] = {
        { "_assign_array_", _assign_array_SpatialNavigationCanceledEventArgs, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_SpatialNavigationCanceledEventArgs), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_SpatialNavigationCanceledEventArgs[] = {
        { "interaction_source_kind", reinterpret_cast<getter>(SpatialNavigationCanceledEventArgs_get_InteractionSourceKind), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_SpatialNavigationCanceledEventArgs[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_SpatialNavigationCanceledEventArgs) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_SpatialNavigationCanceledEventArgs) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_SpatialNavigationCanceledEventArgs) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_SpatialNavigationCanceledEventArgs) },
        { },
    };

    static PyType_Spec type_spec_SpatialNavigationCanceledEventArgs =
    {
        "_winrt_Windows_UI_Input_Spatial.SpatialNavigationCanceledEventArgs",
        sizeof(py::wrapper::Windows::UI::Input::Spatial::SpatialNavigationCanceledEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_SpatialNavigationCanceledEventArgs
    };

    // ----- SpatialNavigationCompletedEventArgs class --------------------
    static constexpr const char* const type_name_SpatialNavigationCompletedEventArgs = "SpatialNavigationCompletedEventArgs";

    static PyObject* _new_SpatialNavigationCompletedEventArgs(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_SpatialNavigationCompletedEventArgs);
        return nullptr;
    }

    static void _dealloc_SpatialNavigationCompletedEventArgs(py::wrapper::Windows::UI::Input::Spatial::SpatialNavigationCompletedEventArgs* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* SpatialNavigationCompletedEventArgs_get_InteractionSourceKind(py::wrapper::Windows::UI::Input::Spatial::SpatialNavigationCompletedEventArgs* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Input.Spatial.SpatialNavigationCompletedEventArgs", L"InteractionSourceKind"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.InteractionSourceKind());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SpatialNavigationCompletedEventArgs_get_NormalizedOffset(py::wrapper::Windows::UI::Input::Spatial::SpatialNavigationCompletedEventArgs* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Input.Spatial.SpatialNavigationCompletedEventArgs", L"NormalizedOffset"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.NormalizedOffset());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_SpatialNavigationCompletedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::Input::Spatial::SpatialNavigationCompletedEventArgs>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_SpatialNavigationCompletedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Input::Spatial::SpatialNavigationCompletedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_SpatialNavigationCompletedEventArgs[] = {
        { "_assign_array_", _assign_array_SpatialNavigationCompletedEventArgs, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_SpatialNavigationCompletedEventArgs), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_SpatialNavigationCompletedEventArgs[] = {
        { "interaction_source_kind", reinterpret_cast<getter>(SpatialNavigationCompletedEventArgs_get_InteractionSourceKind), nullptr, nullptr, nullptr },
        { "normalized_offset", reinterpret_cast<getter>(SpatialNavigationCompletedEventArgs_get_NormalizedOffset), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_SpatialNavigationCompletedEventArgs[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_SpatialNavigationCompletedEventArgs) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_SpatialNavigationCompletedEventArgs) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_SpatialNavigationCompletedEventArgs) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_SpatialNavigationCompletedEventArgs) },
        { },
    };

    static PyType_Spec type_spec_SpatialNavigationCompletedEventArgs =
    {
        "_winrt_Windows_UI_Input_Spatial.SpatialNavigationCompletedEventArgs",
        sizeof(py::wrapper::Windows::UI::Input::Spatial::SpatialNavigationCompletedEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_SpatialNavigationCompletedEventArgs
    };

    // ----- SpatialNavigationStartedEventArgs class --------------------
    static constexpr const char* const type_name_SpatialNavigationStartedEventArgs = "SpatialNavigationStartedEventArgs";

    static PyObject* _new_SpatialNavigationStartedEventArgs(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_SpatialNavigationStartedEventArgs);
        return nullptr;
    }

    static void _dealloc_SpatialNavigationStartedEventArgs(py::wrapper::Windows::UI::Input::Spatial::SpatialNavigationStartedEventArgs* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* SpatialNavigationStartedEventArgs_TryGetPointerPose(py::wrapper::Windows::UI::Input::Spatial::SpatialNavigationStartedEventArgs* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Input.Spatial.SpatialNavigationStartedEventArgs", L"TryGetPointerPose", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::Perception::Spatial::SpatialCoordinateSystem>(args, 0);

                return py::convert(self->obj.TryGetPointerPose(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* SpatialNavigationStartedEventArgs_get_InteractionSourceKind(py::wrapper::Windows::UI::Input::Spatial::SpatialNavigationStartedEventArgs* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Input.Spatial.SpatialNavigationStartedEventArgs", L"InteractionSourceKind"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.InteractionSourceKind());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SpatialNavigationStartedEventArgs_get_IsNavigatingX(py::wrapper::Windows::UI::Input::Spatial::SpatialNavigationStartedEventArgs* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Input.Spatial.SpatialNavigationStartedEventArgs", L"IsNavigatingX"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.IsNavigatingX());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SpatialNavigationStartedEventArgs_get_IsNavigatingY(py::wrapper::Windows::UI::Input::Spatial::SpatialNavigationStartedEventArgs* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Input.Spatial.SpatialNavigationStartedEventArgs", L"IsNavigatingY"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.IsNavigatingY());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SpatialNavigationStartedEventArgs_get_IsNavigatingZ(py::wrapper::Windows::UI::Input::Spatial::SpatialNavigationStartedEventArgs* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Input.Spatial.SpatialNavigationStartedEventArgs", L"IsNavigatingZ"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.IsNavigatingZ());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_SpatialNavigationStartedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::Input::Spatial::SpatialNavigationStartedEventArgs>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_SpatialNavigationStartedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Input::Spatial::SpatialNavigationStartedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_SpatialNavigationStartedEventArgs[] = {
        { "try_get_pointer_pose", reinterpret_cast<PyCFunction>(SpatialNavigationStartedEventArgs_TryGetPointerPose), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_SpatialNavigationStartedEventArgs, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_SpatialNavigationStartedEventArgs), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_SpatialNavigationStartedEventArgs[] = {
        { "interaction_source_kind", reinterpret_cast<getter>(SpatialNavigationStartedEventArgs_get_InteractionSourceKind), nullptr, nullptr, nullptr },
        { "is_navigating_x", reinterpret_cast<getter>(SpatialNavigationStartedEventArgs_get_IsNavigatingX), nullptr, nullptr, nullptr },
        { "is_navigating_y", reinterpret_cast<getter>(SpatialNavigationStartedEventArgs_get_IsNavigatingY), nullptr, nullptr, nullptr },
        { "is_navigating_z", reinterpret_cast<getter>(SpatialNavigationStartedEventArgs_get_IsNavigatingZ), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_SpatialNavigationStartedEventArgs[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_SpatialNavigationStartedEventArgs) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_SpatialNavigationStartedEventArgs) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_SpatialNavigationStartedEventArgs) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_SpatialNavigationStartedEventArgs) },
        { },
    };

    static PyType_Spec type_spec_SpatialNavigationStartedEventArgs =
    {
        "_winrt_Windows_UI_Input_Spatial.SpatialNavigationStartedEventArgs",
        sizeof(py::wrapper::Windows::UI::Input::Spatial::SpatialNavigationStartedEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_SpatialNavigationStartedEventArgs
    };

    // ----- SpatialNavigationUpdatedEventArgs class --------------------
    static constexpr const char* const type_name_SpatialNavigationUpdatedEventArgs = "SpatialNavigationUpdatedEventArgs";

    static PyObject* _new_SpatialNavigationUpdatedEventArgs(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_SpatialNavigationUpdatedEventArgs);
        return nullptr;
    }

    static void _dealloc_SpatialNavigationUpdatedEventArgs(py::wrapper::Windows::UI::Input::Spatial::SpatialNavigationUpdatedEventArgs* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* SpatialNavigationUpdatedEventArgs_get_InteractionSourceKind(py::wrapper::Windows::UI::Input::Spatial::SpatialNavigationUpdatedEventArgs* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Input.Spatial.SpatialNavigationUpdatedEventArgs", L"InteractionSourceKind"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.InteractionSourceKind());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SpatialNavigationUpdatedEventArgs_get_NormalizedOffset(py::wrapper::Windows::UI::Input::Spatial::SpatialNavigationUpdatedEventArgs* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Input.Spatial.SpatialNavigationUpdatedEventArgs", L"NormalizedOffset"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.NormalizedOffset());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_SpatialNavigationUpdatedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::Input::Spatial::SpatialNavigationUpdatedEventArgs>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_SpatialNavigationUpdatedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Input::Spatial::SpatialNavigationUpdatedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_SpatialNavigationUpdatedEventArgs[] = {
        { "_assign_array_", _assign_array_SpatialNavigationUpdatedEventArgs, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_SpatialNavigationUpdatedEventArgs), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_SpatialNavigationUpdatedEventArgs[] = {
        { "interaction_source_kind", reinterpret_cast<getter>(SpatialNavigationUpdatedEventArgs_get_InteractionSourceKind), nullptr, nullptr, nullptr },
        { "normalized_offset", reinterpret_cast<getter>(SpatialNavigationUpdatedEventArgs_get_NormalizedOffset), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_SpatialNavigationUpdatedEventArgs[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_SpatialNavigationUpdatedEventArgs) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_SpatialNavigationUpdatedEventArgs) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_SpatialNavigationUpdatedEventArgs) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_SpatialNavigationUpdatedEventArgs) },
        { },
    };

    static PyType_Spec type_spec_SpatialNavigationUpdatedEventArgs =
    {
        "_winrt_Windows_UI_Input_Spatial.SpatialNavigationUpdatedEventArgs",
        sizeof(py::wrapper::Windows::UI::Input::Spatial::SpatialNavigationUpdatedEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_SpatialNavigationUpdatedEventArgs
    };

    // ----- SpatialPointerInteractionSourcePose class --------------------
    static constexpr const char* const type_name_SpatialPointerInteractionSourcePose = "SpatialPointerInteractionSourcePose";

    static PyObject* _new_SpatialPointerInteractionSourcePose(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_SpatialPointerInteractionSourcePose);
        return nullptr;
    }

    static void _dealloc_SpatialPointerInteractionSourcePose(py::wrapper::Windows::UI::Input::Spatial::SpatialPointerInteractionSourcePose* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* SpatialPointerInteractionSourcePose_get_ForwardDirection(py::wrapper::Windows::UI::Input::Spatial::SpatialPointerInteractionSourcePose* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Input.Spatial.SpatialPointerInteractionSourcePose", L"ForwardDirection"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.ForwardDirection());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SpatialPointerInteractionSourcePose_get_Position(py::wrapper::Windows::UI::Input::Spatial::SpatialPointerInteractionSourcePose* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Input.Spatial.SpatialPointerInteractionSourcePose", L"Position"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Position());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SpatialPointerInteractionSourcePose_get_UpDirection(py::wrapper::Windows::UI::Input::Spatial::SpatialPointerInteractionSourcePose* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Input.Spatial.SpatialPointerInteractionSourcePose", L"UpDirection"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.UpDirection());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SpatialPointerInteractionSourcePose_get_Orientation(py::wrapper::Windows::UI::Input::Spatial::SpatialPointerInteractionSourcePose* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Input.Spatial.SpatialPointerInteractionSourcePose", L"Orientation"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Orientation());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SpatialPointerInteractionSourcePose_get_PositionAccuracy(py::wrapper::Windows::UI::Input::Spatial::SpatialPointerInteractionSourcePose* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Input.Spatial.SpatialPointerInteractionSourcePose", L"PositionAccuracy"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.PositionAccuracy());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_SpatialPointerInteractionSourcePose(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::Input::Spatial::SpatialPointerInteractionSourcePose>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_SpatialPointerInteractionSourcePose(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Input::Spatial::SpatialPointerInteractionSourcePose>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_SpatialPointerInteractionSourcePose[] = {
        { "_assign_array_", _assign_array_SpatialPointerInteractionSourcePose, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_SpatialPointerInteractionSourcePose), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_SpatialPointerInteractionSourcePose[] = {
        { "forward_direction", reinterpret_cast<getter>(SpatialPointerInteractionSourcePose_get_ForwardDirection), nullptr, nullptr, nullptr },
        { "position", reinterpret_cast<getter>(SpatialPointerInteractionSourcePose_get_Position), nullptr, nullptr, nullptr },
        { "up_direction", reinterpret_cast<getter>(SpatialPointerInteractionSourcePose_get_UpDirection), nullptr, nullptr, nullptr },
        { "orientation", reinterpret_cast<getter>(SpatialPointerInteractionSourcePose_get_Orientation), nullptr, nullptr, nullptr },
        { "position_accuracy", reinterpret_cast<getter>(SpatialPointerInteractionSourcePose_get_PositionAccuracy), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_SpatialPointerInteractionSourcePose[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_SpatialPointerInteractionSourcePose) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_SpatialPointerInteractionSourcePose) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_SpatialPointerInteractionSourcePose) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_SpatialPointerInteractionSourcePose) },
        { },
    };

    static PyType_Spec type_spec_SpatialPointerInteractionSourcePose =
    {
        "_winrt_Windows_UI_Input_Spatial.SpatialPointerInteractionSourcePose",
        sizeof(py::wrapper::Windows::UI::Input::Spatial::SpatialPointerInteractionSourcePose),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_SpatialPointerInteractionSourcePose
    };

    // ----- SpatialPointerPose class --------------------
    static constexpr const char* const type_name_SpatialPointerPose = "SpatialPointerPose";

    static PyObject* _new_SpatialPointerPose(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_SpatialPointerPose);
        return nullptr;
    }

    static void _dealloc_SpatialPointerPose(py::wrapper::Windows::UI::Input::Spatial::SpatialPointerPose* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* SpatialPointerPose_TryGetAtTimestamp(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Input.Spatial.SpatialPointerPose", L"TryGetAtTimestamp", 2))
            {
                py::set_arg_count_version_error(2);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::Perception::Spatial::SpatialCoordinateSystem>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Perception::PerceptionTimestamp>(args, 1);

                return py::convert(winrt::Windows::UI::Input::Spatial::SpatialPointerPose::TryGetAtTimestamp(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* SpatialPointerPose_TryGetInteractionSourcePose(py::wrapper::Windows::UI::Input::Spatial::SpatialPointerPose* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Input.Spatial.SpatialPointerPose", L"TryGetInteractionSourcePose", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::UI::Input::Spatial::SpatialInteractionSource>(args, 0);

                return py::convert(self->obj.TryGetInteractionSourcePose(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* SpatialPointerPose_get_Head(py::wrapper::Windows::UI::Input::Spatial::SpatialPointerPose* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Input.Spatial.SpatialPointerPose", L"Head"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Head());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SpatialPointerPose_get_Timestamp(py::wrapper::Windows::UI::Input::Spatial::SpatialPointerPose* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Input.Spatial.SpatialPointerPose", L"Timestamp"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Timestamp());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SpatialPointerPose_get_Eyes(py::wrapper::Windows::UI::Input::Spatial::SpatialPointerPose* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Input.Spatial.SpatialPointerPose", L"Eyes"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Eyes());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SpatialPointerPose_get_IsHeadCapturedBySystem(py::wrapper::Windows::UI::Input::Spatial::SpatialPointerPose* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Input.Spatial.SpatialPointerPose", L"IsHeadCapturedBySystem"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.IsHeadCapturedBySystem());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_SpatialPointerPose(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::Input::Spatial::SpatialPointerPose>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_SpatialPointerPose(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Input::Spatial::SpatialPointerPose>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_SpatialPointerPose[] = {
        { "try_get_at_timestamp", reinterpret_cast<PyCFunction>(SpatialPointerPose_TryGetAtTimestamp), METH_VARARGS | METH_STATIC, nullptr },
        { "try_get_interaction_source_pose", reinterpret_cast<PyCFunction>(SpatialPointerPose_TryGetInteractionSourcePose), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_SpatialPointerPose, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_SpatialPointerPose), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_SpatialPointerPose[] = {
        { "head", reinterpret_cast<getter>(SpatialPointerPose_get_Head), nullptr, nullptr, nullptr },
        { "timestamp", reinterpret_cast<getter>(SpatialPointerPose_get_Timestamp), nullptr, nullptr, nullptr },
        { "eyes", reinterpret_cast<getter>(SpatialPointerPose_get_Eyes), nullptr, nullptr, nullptr },
        { "is_head_captured_by_system", reinterpret_cast<getter>(SpatialPointerPose_get_IsHeadCapturedBySystem), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_SpatialPointerPose[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_SpatialPointerPose) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_SpatialPointerPose) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_SpatialPointerPose) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_SpatialPointerPose) },
        { },
    };

    static PyType_Spec type_spec_SpatialPointerPose =
    {
        "_winrt_Windows_UI_Input_Spatial.SpatialPointerPose",
        sizeof(py::wrapper::Windows::UI::Input::Spatial::SpatialPointerPose),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_SpatialPointerPose
    };

    // ----- SpatialRecognitionEndedEventArgs class --------------------
    static constexpr const char* const type_name_SpatialRecognitionEndedEventArgs = "SpatialRecognitionEndedEventArgs";

    static PyObject* _new_SpatialRecognitionEndedEventArgs(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_SpatialRecognitionEndedEventArgs);
        return nullptr;
    }

    static void _dealloc_SpatialRecognitionEndedEventArgs(py::wrapper::Windows::UI::Input::Spatial::SpatialRecognitionEndedEventArgs* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* SpatialRecognitionEndedEventArgs_get_InteractionSourceKind(py::wrapper::Windows::UI::Input::Spatial::SpatialRecognitionEndedEventArgs* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Input.Spatial.SpatialRecognitionEndedEventArgs", L"InteractionSourceKind"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.InteractionSourceKind());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_SpatialRecognitionEndedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::Input::Spatial::SpatialRecognitionEndedEventArgs>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_SpatialRecognitionEndedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Input::Spatial::SpatialRecognitionEndedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_SpatialRecognitionEndedEventArgs[] = {
        { "_assign_array_", _assign_array_SpatialRecognitionEndedEventArgs, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_SpatialRecognitionEndedEventArgs), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_SpatialRecognitionEndedEventArgs[] = {
        { "interaction_source_kind", reinterpret_cast<getter>(SpatialRecognitionEndedEventArgs_get_InteractionSourceKind), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_SpatialRecognitionEndedEventArgs[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_SpatialRecognitionEndedEventArgs) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_SpatialRecognitionEndedEventArgs) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_SpatialRecognitionEndedEventArgs) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_SpatialRecognitionEndedEventArgs) },
        { },
    };

    static PyType_Spec type_spec_SpatialRecognitionEndedEventArgs =
    {
        "_winrt_Windows_UI_Input_Spatial.SpatialRecognitionEndedEventArgs",
        sizeof(py::wrapper::Windows::UI::Input::Spatial::SpatialRecognitionEndedEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_SpatialRecognitionEndedEventArgs
    };

    // ----- SpatialRecognitionStartedEventArgs class --------------------
    static constexpr const char* const type_name_SpatialRecognitionStartedEventArgs = "SpatialRecognitionStartedEventArgs";

    static PyObject* _new_SpatialRecognitionStartedEventArgs(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_SpatialRecognitionStartedEventArgs);
        return nullptr;
    }

    static void _dealloc_SpatialRecognitionStartedEventArgs(py::wrapper::Windows::UI::Input::Spatial::SpatialRecognitionStartedEventArgs* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* SpatialRecognitionStartedEventArgs_IsGesturePossible(py::wrapper::Windows::UI::Input::Spatial::SpatialRecognitionStartedEventArgs* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Input.Spatial.SpatialRecognitionStartedEventArgs", L"IsGesturePossible", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::UI::Input::Spatial::SpatialGestureSettings>(args, 0);

                return py::convert(self->obj.IsGesturePossible(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* SpatialRecognitionStartedEventArgs_TryGetPointerPose(py::wrapper::Windows::UI::Input::Spatial::SpatialRecognitionStartedEventArgs* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Input.Spatial.SpatialRecognitionStartedEventArgs", L"TryGetPointerPose", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::Perception::Spatial::SpatialCoordinateSystem>(args, 0);

                return py::convert(self->obj.TryGetPointerPose(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* SpatialRecognitionStartedEventArgs_get_InteractionSourceKind(py::wrapper::Windows::UI::Input::Spatial::SpatialRecognitionStartedEventArgs* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Input.Spatial.SpatialRecognitionStartedEventArgs", L"InteractionSourceKind"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.InteractionSourceKind());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_SpatialRecognitionStartedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::Input::Spatial::SpatialRecognitionStartedEventArgs>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_SpatialRecognitionStartedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Input::Spatial::SpatialRecognitionStartedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_SpatialRecognitionStartedEventArgs[] = {
        { "is_gesture_possible", reinterpret_cast<PyCFunction>(SpatialRecognitionStartedEventArgs_IsGesturePossible), METH_VARARGS, nullptr },
        { "try_get_pointer_pose", reinterpret_cast<PyCFunction>(SpatialRecognitionStartedEventArgs_TryGetPointerPose), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_SpatialRecognitionStartedEventArgs, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_SpatialRecognitionStartedEventArgs), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_SpatialRecognitionStartedEventArgs[] = {
        { "interaction_source_kind", reinterpret_cast<getter>(SpatialRecognitionStartedEventArgs_get_InteractionSourceKind), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_SpatialRecognitionStartedEventArgs[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_SpatialRecognitionStartedEventArgs) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_SpatialRecognitionStartedEventArgs) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_SpatialRecognitionStartedEventArgs) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_SpatialRecognitionStartedEventArgs) },
        { },
    };

    static PyType_Spec type_spec_SpatialRecognitionStartedEventArgs =
    {
        "_winrt_Windows_UI_Input_Spatial.SpatialRecognitionStartedEventArgs",
        sizeof(py::wrapper::Windows::UI::Input::Spatial::SpatialRecognitionStartedEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_SpatialRecognitionStartedEventArgs
    };

    // ----- SpatialTappedEventArgs class --------------------
    static constexpr const char* const type_name_SpatialTappedEventArgs = "SpatialTappedEventArgs";

    static PyObject* _new_SpatialTappedEventArgs(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_SpatialTappedEventArgs);
        return nullptr;
    }

    static void _dealloc_SpatialTappedEventArgs(py::wrapper::Windows::UI::Input::Spatial::SpatialTappedEventArgs* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* SpatialTappedEventArgs_TryGetPointerPose(py::wrapper::Windows::UI::Input::Spatial::SpatialTappedEventArgs* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Input.Spatial.SpatialTappedEventArgs", L"TryGetPointerPose", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::Perception::Spatial::SpatialCoordinateSystem>(args, 0);

                return py::convert(self->obj.TryGetPointerPose(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* SpatialTappedEventArgs_get_InteractionSourceKind(py::wrapper::Windows::UI::Input::Spatial::SpatialTappedEventArgs* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Input.Spatial.SpatialTappedEventArgs", L"InteractionSourceKind"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.InteractionSourceKind());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SpatialTappedEventArgs_get_TapCount(py::wrapper::Windows::UI::Input::Spatial::SpatialTappedEventArgs* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Input.Spatial.SpatialTappedEventArgs", L"TapCount"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.TapCount());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_SpatialTappedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::Input::Spatial::SpatialTappedEventArgs>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_SpatialTappedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Input::Spatial::SpatialTappedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_SpatialTappedEventArgs[] = {
        { "try_get_pointer_pose", reinterpret_cast<PyCFunction>(SpatialTappedEventArgs_TryGetPointerPose), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_SpatialTappedEventArgs, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_SpatialTappedEventArgs), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_SpatialTappedEventArgs[] = {
        { "interaction_source_kind", reinterpret_cast<getter>(SpatialTappedEventArgs_get_InteractionSourceKind), nullptr, nullptr, nullptr },
        { "tap_count", reinterpret_cast<getter>(SpatialTappedEventArgs_get_TapCount), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_SpatialTappedEventArgs[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_SpatialTappedEventArgs) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_SpatialTappedEventArgs) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_SpatialTappedEventArgs) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_SpatialTappedEventArgs) },
        { },
    };

    static PyType_Spec type_spec_SpatialTappedEventArgs =
    {
        "_winrt_Windows_UI_Input_Spatial.SpatialTappedEventArgs",
        sizeof(py::wrapper::Windows::UI::Input::Spatial::SpatialTappedEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_SpatialTappedEventArgs
    };

    // ----- Windows.UI.Input.Spatial Initialization --------------------
    PyDoc_STRVAR(module_doc, "Windows::UI::Input::Spatial");

    static PyMethodDef module_methods[] = {
        {"_register_SpatialGestureSettings", register_SpatialGestureSettings, METH_O, "registers type"},
        {"_register_SpatialInteractionPressKind", register_SpatialInteractionPressKind, METH_O, "registers type"},
        {"_register_SpatialInteractionSourceHandedness", register_SpatialInteractionSourceHandedness, METH_O, "registers type"},
        {"_register_SpatialInteractionSourceKind", register_SpatialInteractionSourceKind, METH_O, "registers type"},
        {"_register_SpatialInteractionSourcePositionAccuracy", register_SpatialInteractionSourcePositionAccuracy, METH_O, "registers type"},
        {}};


    static int module_traverse(PyObject* module, visitproc visit, void* arg) noexcept
    {
        auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));

        if (!state)
        {
            return 0;
        }

        Py_VISIT(state->type_SpatialGestureSettings);
        Py_VISIT(state->type_SpatialInteractionPressKind);
        Py_VISIT(state->type_SpatialInteractionSourceHandedness);
        Py_VISIT(state->type_SpatialInteractionSourceKind);
        Py_VISIT(state->type_SpatialInteractionSourcePositionAccuracy);
        Py_VISIT(state->type_SpatialGestureRecognizer);
        Py_VISIT(state->type_SpatialHoldCanceledEventArgs);
        Py_VISIT(state->type_SpatialHoldCompletedEventArgs);
        Py_VISIT(state->type_SpatialHoldStartedEventArgs);
        Py_VISIT(state->type_SpatialInteraction);
        Py_VISIT(state->type_SpatialInteractionController);
        Py_VISIT(state->type_SpatialInteractionControllerProperties);
        Py_VISIT(state->type_SpatialInteractionDetectedEventArgs);
        Py_VISIT(state->type_SpatialInteractionManager);
        Py_VISIT(state->type_SpatialInteractionSource);
        Py_VISIT(state->type_SpatialInteractionSourceEventArgs);
        Py_VISIT(state->type_SpatialInteractionSourceLocation);
        Py_VISIT(state->type_SpatialInteractionSourceProperties);
        Py_VISIT(state->type_SpatialInteractionSourceState);
        Py_VISIT(state->type_SpatialManipulationCanceledEventArgs);
        Py_VISIT(state->type_SpatialManipulationCompletedEventArgs);
        Py_VISIT(state->type_SpatialManipulationDelta);
        Py_VISIT(state->type_SpatialManipulationStartedEventArgs);
        Py_VISIT(state->type_SpatialManipulationUpdatedEventArgs);
        Py_VISIT(state->type_SpatialNavigationCanceledEventArgs);
        Py_VISIT(state->type_SpatialNavigationCompletedEventArgs);
        Py_VISIT(state->type_SpatialNavigationStartedEventArgs);
        Py_VISIT(state->type_SpatialNavigationUpdatedEventArgs);
        Py_VISIT(state->type_SpatialPointerInteractionSourcePose);
        Py_VISIT(state->type_SpatialPointerPose);
        Py_VISIT(state->type_SpatialRecognitionEndedEventArgs);
        Py_VISIT(state->type_SpatialRecognitionStartedEventArgs);
        Py_VISIT(state->type_SpatialTappedEventArgs);

        return 0;
    }

    static int module_clear(PyObject* module) noexcept
    {
        auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));

        if (!state)
        {
            return 0;
        }

        Py_CLEAR(state->type_SpatialGestureSettings);
        Py_CLEAR(state->type_SpatialInteractionPressKind);
        Py_CLEAR(state->type_SpatialInteractionSourceHandedness);
        Py_CLEAR(state->type_SpatialInteractionSourceKind);
        Py_CLEAR(state->type_SpatialInteractionSourcePositionAccuracy);
        Py_CLEAR(state->type_SpatialGestureRecognizer);
        Py_CLEAR(state->type_SpatialHoldCanceledEventArgs);
        Py_CLEAR(state->type_SpatialHoldCompletedEventArgs);
        Py_CLEAR(state->type_SpatialHoldStartedEventArgs);
        Py_CLEAR(state->type_SpatialInteraction);
        Py_CLEAR(state->type_SpatialInteractionController);
        Py_CLEAR(state->type_SpatialInteractionControllerProperties);
        Py_CLEAR(state->type_SpatialInteractionDetectedEventArgs);
        Py_CLEAR(state->type_SpatialInteractionManager);
        Py_CLEAR(state->type_SpatialInteractionSource);
        Py_CLEAR(state->type_SpatialInteractionSourceEventArgs);
        Py_CLEAR(state->type_SpatialInteractionSourceLocation);
        Py_CLEAR(state->type_SpatialInteractionSourceProperties);
        Py_CLEAR(state->type_SpatialInteractionSourceState);
        Py_CLEAR(state->type_SpatialManipulationCanceledEventArgs);
        Py_CLEAR(state->type_SpatialManipulationCompletedEventArgs);
        Py_CLEAR(state->type_SpatialManipulationDelta);
        Py_CLEAR(state->type_SpatialManipulationStartedEventArgs);
        Py_CLEAR(state->type_SpatialManipulationUpdatedEventArgs);
        Py_CLEAR(state->type_SpatialNavigationCanceledEventArgs);
        Py_CLEAR(state->type_SpatialNavigationCompletedEventArgs);
        Py_CLEAR(state->type_SpatialNavigationStartedEventArgs);
        Py_CLEAR(state->type_SpatialNavigationUpdatedEventArgs);
        Py_CLEAR(state->type_SpatialPointerInteractionSourcePose);
        Py_CLEAR(state->type_SpatialPointerPose);
        Py_CLEAR(state->type_SpatialRecognitionEndedEventArgs);
        Py_CLEAR(state->type_SpatialRecognitionStartedEventArgs);
        Py_CLEAR(state->type_SpatialTappedEventArgs);

        return 0;
    }


    static PyModuleDef module_def
        = {PyModuleDef_HEAD_INIT,
           "_winrt_Windows_UI_Input_Spatial",
           module_doc,
           sizeof(module_state),
           module_methods,
           nullptr,
           module_traverse,
           module_clear,
           nullptr};

} // py::cpp::Windows::UI::Input::Spatial

PyMODINIT_FUNC PyInit__winrt_Windows_UI_Input_Spatial(void) noexcept
{
    using namespace py::cpp::Windows::UI::Input::Spatial;

    py::pyobj_handle module{PyModule_Create(&module_def)};

    if (!module)
    {
        return nullptr;
    }

    auto object_type = py::get_python_type<py::Object>();
    if (!object_type)
    {
        return nullptr;
    }

    py::pyobj_handle object_bases{PyTuple_Pack(1, object_type)};

    if (!object_bases)
    {
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module.get()));
    WINRT_ASSERT(state);

    state->type_SpatialGestureRecognizer = py::register_python_type(module.get(), type_name_SpatialGestureRecognizer, &type_spec_SpatialGestureRecognizer, object_bases.get(), nullptr);
    if (!state->type_SpatialGestureRecognizer)
    {
        return nullptr;
    }

    state->type_SpatialHoldCanceledEventArgs = py::register_python_type(module.get(), type_name_SpatialHoldCanceledEventArgs, &type_spec_SpatialHoldCanceledEventArgs, object_bases.get(), nullptr);
    if (!state->type_SpatialHoldCanceledEventArgs)
    {
        return nullptr;
    }

    state->type_SpatialHoldCompletedEventArgs = py::register_python_type(module.get(), type_name_SpatialHoldCompletedEventArgs, &type_spec_SpatialHoldCompletedEventArgs, object_bases.get(), nullptr);
    if (!state->type_SpatialHoldCompletedEventArgs)
    {
        return nullptr;
    }

    state->type_SpatialHoldStartedEventArgs = py::register_python_type(module.get(), type_name_SpatialHoldStartedEventArgs, &type_spec_SpatialHoldStartedEventArgs, object_bases.get(), nullptr);
    if (!state->type_SpatialHoldStartedEventArgs)
    {
        return nullptr;
    }

    state->type_SpatialInteraction = py::register_python_type(module.get(), type_name_SpatialInteraction, &type_spec_SpatialInteraction, object_bases.get(), nullptr);
    if (!state->type_SpatialInteraction)
    {
        return nullptr;
    }

    state->type_SpatialInteractionController = py::register_python_type(module.get(), type_name_SpatialInteractionController, &type_spec_SpatialInteractionController, object_bases.get(), nullptr);
    if (!state->type_SpatialInteractionController)
    {
        return nullptr;
    }

    state->type_SpatialInteractionControllerProperties = py::register_python_type(module.get(), type_name_SpatialInteractionControllerProperties, &type_spec_SpatialInteractionControllerProperties, object_bases.get(), nullptr);
    if (!state->type_SpatialInteractionControllerProperties)
    {
        return nullptr;
    }

    state->type_SpatialInteractionDetectedEventArgs = py::register_python_type(module.get(), type_name_SpatialInteractionDetectedEventArgs, &type_spec_SpatialInteractionDetectedEventArgs, object_bases.get(), nullptr);
    if (!state->type_SpatialInteractionDetectedEventArgs)
    {
        return nullptr;
    }

    state->type_SpatialInteractionManager = py::register_python_type(module.get(), type_name_SpatialInteractionManager, &type_spec_SpatialInteractionManager, object_bases.get(), nullptr);
    if (!state->type_SpatialInteractionManager)
    {
        return nullptr;
    }

    state->type_SpatialInteractionSource = py::register_python_type(module.get(), type_name_SpatialInteractionSource, &type_spec_SpatialInteractionSource, object_bases.get(), nullptr);
    if (!state->type_SpatialInteractionSource)
    {
        return nullptr;
    }

    state->type_SpatialInteractionSourceEventArgs = py::register_python_type(module.get(), type_name_SpatialInteractionSourceEventArgs, &type_spec_SpatialInteractionSourceEventArgs, object_bases.get(), nullptr);
    if (!state->type_SpatialInteractionSourceEventArgs)
    {
        return nullptr;
    }

    state->type_SpatialInteractionSourceLocation = py::register_python_type(module.get(), type_name_SpatialInteractionSourceLocation, &type_spec_SpatialInteractionSourceLocation, object_bases.get(), nullptr);
    if (!state->type_SpatialInteractionSourceLocation)
    {
        return nullptr;
    }

    state->type_SpatialInteractionSourceProperties = py::register_python_type(module.get(), type_name_SpatialInteractionSourceProperties, &type_spec_SpatialInteractionSourceProperties, object_bases.get(), nullptr);
    if (!state->type_SpatialInteractionSourceProperties)
    {
        return nullptr;
    }

    state->type_SpatialInteractionSourceState = py::register_python_type(module.get(), type_name_SpatialInteractionSourceState, &type_spec_SpatialInteractionSourceState, object_bases.get(), nullptr);
    if (!state->type_SpatialInteractionSourceState)
    {
        return nullptr;
    }

    state->type_SpatialManipulationCanceledEventArgs = py::register_python_type(module.get(), type_name_SpatialManipulationCanceledEventArgs, &type_spec_SpatialManipulationCanceledEventArgs, object_bases.get(), nullptr);
    if (!state->type_SpatialManipulationCanceledEventArgs)
    {
        return nullptr;
    }

    state->type_SpatialManipulationCompletedEventArgs = py::register_python_type(module.get(), type_name_SpatialManipulationCompletedEventArgs, &type_spec_SpatialManipulationCompletedEventArgs, object_bases.get(), nullptr);
    if (!state->type_SpatialManipulationCompletedEventArgs)
    {
        return nullptr;
    }

    state->type_SpatialManipulationDelta = py::register_python_type(module.get(), type_name_SpatialManipulationDelta, &type_spec_SpatialManipulationDelta, object_bases.get(), nullptr);
    if (!state->type_SpatialManipulationDelta)
    {
        return nullptr;
    }

    state->type_SpatialManipulationStartedEventArgs = py::register_python_type(module.get(), type_name_SpatialManipulationStartedEventArgs, &type_spec_SpatialManipulationStartedEventArgs, object_bases.get(), nullptr);
    if (!state->type_SpatialManipulationStartedEventArgs)
    {
        return nullptr;
    }

    state->type_SpatialManipulationUpdatedEventArgs = py::register_python_type(module.get(), type_name_SpatialManipulationUpdatedEventArgs, &type_spec_SpatialManipulationUpdatedEventArgs, object_bases.get(), nullptr);
    if (!state->type_SpatialManipulationUpdatedEventArgs)
    {
        return nullptr;
    }

    state->type_SpatialNavigationCanceledEventArgs = py::register_python_type(module.get(), type_name_SpatialNavigationCanceledEventArgs, &type_spec_SpatialNavigationCanceledEventArgs, object_bases.get(), nullptr);
    if (!state->type_SpatialNavigationCanceledEventArgs)
    {
        return nullptr;
    }

    state->type_SpatialNavigationCompletedEventArgs = py::register_python_type(module.get(), type_name_SpatialNavigationCompletedEventArgs, &type_spec_SpatialNavigationCompletedEventArgs, object_bases.get(), nullptr);
    if (!state->type_SpatialNavigationCompletedEventArgs)
    {
        return nullptr;
    }

    state->type_SpatialNavigationStartedEventArgs = py::register_python_type(module.get(), type_name_SpatialNavigationStartedEventArgs, &type_spec_SpatialNavigationStartedEventArgs, object_bases.get(), nullptr);
    if (!state->type_SpatialNavigationStartedEventArgs)
    {
        return nullptr;
    }

    state->type_SpatialNavigationUpdatedEventArgs = py::register_python_type(module.get(), type_name_SpatialNavigationUpdatedEventArgs, &type_spec_SpatialNavigationUpdatedEventArgs, object_bases.get(), nullptr);
    if (!state->type_SpatialNavigationUpdatedEventArgs)
    {
        return nullptr;
    }

    state->type_SpatialPointerInteractionSourcePose = py::register_python_type(module.get(), type_name_SpatialPointerInteractionSourcePose, &type_spec_SpatialPointerInteractionSourcePose, object_bases.get(), nullptr);
    if (!state->type_SpatialPointerInteractionSourcePose)
    {
        return nullptr;
    }

    state->type_SpatialPointerPose = py::register_python_type(module.get(), type_name_SpatialPointerPose, &type_spec_SpatialPointerPose, object_bases.get(), nullptr);
    if (!state->type_SpatialPointerPose)
    {
        return nullptr;
    }

    state->type_SpatialRecognitionEndedEventArgs = py::register_python_type(module.get(), type_name_SpatialRecognitionEndedEventArgs, &type_spec_SpatialRecognitionEndedEventArgs, object_bases.get(), nullptr);
    if (!state->type_SpatialRecognitionEndedEventArgs)
    {
        return nullptr;
    }

    state->type_SpatialRecognitionStartedEventArgs = py::register_python_type(module.get(), type_name_SpatialRecognitionStartedEventArgs, &type_spec_SpatialRecognitionStartedEventArgs, object_bases.get(), nullptr);
    if (!state->type_SpatialRecognitionStartedEventArgs)
    {
        return nullptr;
    }

    state->type_SpatialTappedEventArgs = py::register_python_type(module.get(), type_name_SpatialTappedEventArgs, &type_spec_SpatialTappedEventArgs, object_bases.get(), nullptr);
    if (!state->type_SpatialTappedEventArgs)
    {
        return nullptr;
    }


    return module.detach();
}

PyObject* py::py_type<winrt::Windows::UI::Input::Spatial::SpatialGestureSettings>::get_python_type() noexcept {
    using namespace py::cpp::Windows::UI::Input::Spatial;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::UI::Input::Spatial");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_SpatialGestureSettings;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::UI::Input::Spatial::SpatialGestureSettings is not registered");
        return nullptr;
    }

    return python_type;
}

PyObject* py::py_type<winrt::Windows::UI::Input::Spatial::SpatialInteractionPressKind>::get_python_type() noexcept {
    using namespace py::cpp::Windows::UI::Input::Spatial;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::UI::Input::Spatial");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_SpatialInteractionPressKind;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::UI::Input::Spatial::SpatialInteractionPressKind is not registered");
        return nullptr;
    }

    return python_type;
}

PyObject* py::py_type<winrt::Windows::UI::Input::Spatial::SpatialInteractionSourceHandedness>::get_python_type() noexcept {
    using namespace py::cpp::Windows::UI::Input::Spatial;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::UI::Input::Spatial");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_SpatialInteractionSourceHandedness;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::UI::Input::Spatial::SpatialInteractionSourceHandedness is not registered");
        return nullptr;
    }

    return python_type;
}

PyObject* py::py_type<winrt::Windows::UI::Input::Spatial::SpatialInteractionSourceKind>::get_python_type() noexcept {
    using namespace py::cpp::Windows::UI::Input::Spatial;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::UI::Input::Spatial");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_SpatialInteractionSourceKind;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::UI::Input::Spatial::SpatialInteractionSourceKind is not registered");
        return nullptr;
    }

    return python_type;
}

PyObject* py::py_type<winrt::Windows::UI::Input::Spatial::SpatialInteractionSourcePositionAccuracy>::get_python_type() noexcept {
    using namespace py::cpp::Windows::UI::Input::Spatial;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::UI::Input::Spatial");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_SpatialInteractionSourcePositionAccuracy;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::UI::Input::Spatial::SpatialInteractionSourcePositionAccuracy is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::UI::Input::Spatial::SpatialGestureRecognizer>::get_python_type() noexcept {
    using namespace py::cpp::Windows::UI::Input::Spatial;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::UI::Input::Spatial");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_SpatialGestureRecognizer;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::UI::Input::Spatial::SpatialGestureRecognizer is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::UI::Input::Spatial::SpatialHoldCanceledEventArgs>::get_python_type() noexcept {
    using namespace py::cpp::Windows::UI::Input::Spatial;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::UI::Input::Spatial");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_SpatialHoldCanceledEventArgs;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::UI::Input::Spatial::SpatialHoldCanceledEventArgs is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::UI::Input::Spatial::SpatialHoldCompletedEventArgs>::get_python_type() noexcept {
    using namespace py::cpp::Windows::UI::Input::Spatial;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::UI::Input::Spatial");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_SpatialHoldCompletedEventArgs;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::UI::Input::Spatial::SpatialHoldCompletedEventArgs is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::UI::Input::Spatial::SpatialHoldStartedEventArgs>::get_python_type() noexcept {
    using namespace py::cpp::Windows::UI::Input::Spatial;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::UI::Input::Spatial");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_SpatialHoldStartedEventArgs;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::UI::Input::Spatial::SpatialHoldStartedEventArgs is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::UI::Input::Spatial::SpatialInteraction>::get_python_type() noexcept {
    using namespace py::cpp::Windows::UI::Input::Spatial;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::UI::Input::Spatial");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_SpatialInteraction;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::UI::Input::Spatial::SpatialInteraction is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::UI::Input::Spatial::SpatialInteractionController>::get_python_type() noexcept {
    using namespace py::cpp::Windows::UI::Input::Spatial;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::UI::Input::Spatial");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_SpatialInteractionController;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::UI::Input::Spatial::SpatialInteractionController is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::UI::Input::Spatial::SpatialInteractionControllerProperties>::get_python_type() noexcept {
    using namespace py::cpp::Windows::UI::Input::Spatial;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::UI::Input::Spatial");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_SpatialInteractionControllerProperties;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::UI::Input::Spatial::SpatialInteractionControllerProperties is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::UI::Input::Spatial::SpatialInteractionDetectedEventArgs>::get_python_type() noexcept {
    using namespace py::cpp::Windows::UI::Input::Spatial;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::UI::Input::Spatial");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_SpatialInteractionDetectedEventArgs;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::UI::Input::Spatial::SpatialInteractionDetectedEventArgs is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::UI::Input::Spatial::SpatialInteractionManager>::get_python_type() noexcept {
    using namespace py::cpp::Windows::UI::Input::Spatial;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::UI::Input::Spatial");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_SpatialInteractionManager;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::UI::Input::Spatial::SpatialInteractionManager is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::UI::Input::Spatial::SpatialInteractionSource>::get_python_type() noexcept {
    using namespace py::cpp::Windows::UI::Input::Spatial;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::UI::Input::Spatial");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_SpatialInteractionSource;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::UI::Input::Spatial::SpatialInteractionSource is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::UI::Input::Spatial::SpatialInteractionSourceEventArgs>::get_python_type() noexcept {
    using namespace py::cpp::Windows::UI::Input::Spatial;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::UI::Input::Spatial");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_SpatialInteractionSourceEventArgs;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::UI::Input::Spatial::SpatialInteractionSourceEventArgs is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::UI::Input::Spatial::SpatialInteractionSourceLocation>::get_python_type() noexcept {
    using namespace py::cpp::Windows::UI::Input::Spatial;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::UI::Input::Spatial");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_SpatialInteractionSourceLocation;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::UI::Input::Spatial::SpatialInteractionSourceLocation is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::UI::Input::Spatial::SpatialInteractionSourceProperties>::get_python_type() noexcept {
    using namespace py::cpp::Windows::UI::Input::Spatial;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::UI::Input::Spatial");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_SpatialInteractionSourceProperties;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::UI::Input::Spatial::SpatialInteractionSourceProperties is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::UI::Input::Spatial::SpatialInteractionSourceState>::get_python_type() noexcept {
    using namespace py::cpp::Windows::UI::Input::Spatial;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::UI::Input::Spatial");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_SpatialInteractionSourceState;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::UI::Input::Spatial::SpatialInteractionSourceState is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::UI::Input::Spatial::SpatialManipulationCanceledEventArgs>::get_python_type() noexcept {
    using namespace py::cpp::Windows::UI::Input::Spatial;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::UI::Input::Spatial");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_SpatialManipulationCanceledEventArgs;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::UI::Input::Spatial::SpatialManipulationCanceledEventArgs is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::UI::Input::Spatial::SpatialManipulationCompletedEventArgs>::get_python_type() noexcept {
    using namespace py::cpp::Windows::UI::Input::Spatial;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::UI::Input::Spatial");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_SpatialManipulationCompletedEventArgs;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::UI::Input::Spatial::SpatialManipulationCompletedEventArgs is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::UI::Input::Spatial::SpatialManipulationDelta>::get_python_type() noexcept {
    using namespace py::cpp::Windows::UI::Input::Spatial;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::UI::Input::Spatial");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_SpatialManipulationDelta;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::UI::Input::Spatial::SpatialManipulationDelta is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::UI::Input::Spatial::SpatialManipulationStartedEventArgs>::get_python_type() noexcept {
    using namespace py::cpp::Windows::UI::Input::Spatial;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::UI::Input::Spatial");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_SpatialManipulationStartedEventArgs;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::UI::Input::Spatial::SpatialManipulationStartedEventArgs is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::UI::Input::Spatial::SpatialManipulationUpdatedEventArgs>::get_python_type() noexcept {
    using namespace py::cpp::Windows::UI::Input::Spatial;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::UI::Input::Spatial");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_SpatialManipulationUpdatedEventArgs;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::UI::Input::Spatial::SpatialManipulationUpdatedEventArgs is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::UI::Input::Spatial::SpatialNavigationCanceledEventArgs>::get_python_type() noexcept {
    using namespace py::cpp::Windows::UI::Input::Spatial;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::UI::Input::Spatial");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_SpatialNavigationCanceledEventArgs;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::UI::Input::Spatial::SpatialNavigationCanceledEventArgs is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::UI::Input::Spatial::SpatialNavigationCompletedEventArgs>::get_python_type() noexcept {
    using namespace py::cpp::Windows::UI::Input::Spatial;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::UI::Input::Spatial");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_SpatialNavigationCompletedEventArgs;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::UI::Input::Spatial::SpatialNavigationCompletedEventArgs is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::UI::Input::Spatial::SpatialNavigationStartedEventArgs>::get_python_type() noexcept {
    using namespace py::cpp::Windows::UI::Input::Spatial;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::UI::Input::Spatial");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_SpatialNavigationStartedEventArgs;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::UI::Input::Spatial::SpatialNavigationStartedEventArgs is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::UI::Input::Spatial::SpatialNavigationUpdatedEventArgs>::get_python_type() noexcept {
    using namespace py::cpp::Windows::UI::Input::Spatial;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::UI::Input::Spatial");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_SpatialNavigationUpdatedEventArgs;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::UI::Input::Spatial::SpatialNavigationUpdatedEventArgs is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::UI::Input::Spatial::SpatialPointerInteractionSourcePose>::get_python_type() noexcept {
    using namespace py::cpp::Windows::UI::Input::Spatial;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::UI::Input::Spatial");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_SpatialPointerInteractionSourcePose;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::UI::Input::Spatial::SpatialPointerInteractionSourcePose is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::UI::Input::Spatial::SpatialPointerPose>::get_python_type() noexcept {
    using namespace py::cpp::Windows::UI::Input::Spatial;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::UI::Input::Spatial");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_SpatialPointerPose;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::UI::Input::Spatial::SpatialPointerPose is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::UI::Input::Spatial::SpatialRecognitionEndedEventArgs>::get_python_type() noexcept {
    using namespace py::cpp::Windows::UI::Input::Spatial;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::UI::Input::Spatial");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_SpatialRecognitionEndedEventArgs;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::UI::Input::Spatial::SpatialRecognitionEndedEventArgs is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::UI::Input::Spatial::SpatialRecognitionStartedEventArgs>::get_python_type() noexcept {
    using namespace py::cpp::Windows::UI::Input::Spatial;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::UI::Input::Spatial");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_SpatialRecognitionStartedEventArgs;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::UI::Input::Spatial::SpatialRecognitionStartedEventArgs is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::UI::Input::Spatial::SpatialTappedEventArgs>::get_python_type() noexcept {
    using namespace py::cpp::Windows::UI::Input::Spatial;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::UI::Input::Spatial");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_SpatialTappedEventArgs;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::UI::Input::Spatial::SpatialTappedEventArgs is not registered");
        return nullptr;
    }

    return python_type;
}
