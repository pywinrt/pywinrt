// WARNING: Please don't edit this file. It was generated by Python/WinRT v2.0.0-beta.2

#include "py.Windows.UI.Xaml.Media.Imaging.h"


namespace py::cpp::Windows::UI::Xaml::Media::Imaging
{
    // ----- BitmapImage class --------------------

    static PyObject* _new_BitmapImage(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Foundation::Uri>(args, 0);

                winrt::Windows::UI::Xaml::Media::Imaging::BitmapImage instance{ param0 };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 0)
        {
            try
            {
                winrt::Windows::UI::Xaml::Media::Imaging::BitmapImage instance{  };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_BitmapImage(py::wrapper::Windows::UI::Xaml::Media::Imaging::BitmapImage* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* BitmapImage_Play(py::wrapper::Windows::UI::Xaml::Media::Imaging::BitmapImage* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.Media.Imaging.BitmapImage", L"Play", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                self->obj.Play();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* BitmapImage_Stop(py::wrapper::Windows::UI::Xaml::Media::Imaging::BitmapImage* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.Media.Imaging.BitmapImage", L"Stop", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                self->obj.Stop();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* BitmapImage_get_UriSource(py::wrapper::Windows::UI::Xaml::Media::Imaging::BitmapImage* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Media.Imaging.BitmapImage", L"UriSource"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.UriSource());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int BitmapImage_put_UriSource(py::wrapper::Windows::UI::Xaml::Media::Imaging::BitmapImage* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Media.Imaging.BitmapImage", L"UriSource"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::Uri>(arg);

            self->obj.UriSource(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* BitmapImage_get_DecodePixelWidth(py::wrapper::Windows::UI::Xaml::Media::Imaging::BitmapImage* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Media.Imaging.BitmapImage", L"DecodePixelWidth"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.DecodePixelWidth());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int BitmapImage_put_DecodePixelWidth(py::wrapper::Windows::UI::Xaml::Media::Imaging::BitmapImage* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Media.Imaging.BitmapImage", L"DecodePixelWidth"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<int32_t>(arg);

            self->obj.DecodePixelWidth(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* BitmapImage_get_DecodePixelHeight(py::wrapper::Windows::UI::Xaml::Media::Imaging::BitmapImage* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Media.Imaging.BitmapImage", L"DecodePixelHeight"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.DecodePixelHeight());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int BitmapImage_put_DecodePixelHeight(py::wrapper::Windows::UI::Xaml::Media::Imaging::BitmapImage* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Media.Imaging.BitmapImage", L"DecodePixelHeight"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<int32_t>(arg);

            self->obj.DecodePixelHeight(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* BitmapImage_get_CreateOptions(py::wrapper::Windows::UI::Xaml::Media::Imaging::BitmapImage* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Media.Imaging.BitmapImage", L"CreateOptions"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.CreateOptions());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int BitmapImage_put_CreateOptions(py::wrapper::Windows::UI::Xaml::Media::Imaging::BitmapImage* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Media.Imaging.BitmapImage", L"CreateOptions"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::UI::Xaml::Media::Imaging::BitmapCreateOptions>(arg);

            self->obj.CreateOptions(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* BitmapImage_get_DecodePixelType(py::wrapper::Windows::UI::Xaml::Media::Imaging::BitmapImage* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Media.Imaging.BitmapImage", L"DecodePixelType"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.DecodePixelType());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int BitmapImage_put_DecodePixelType(py::wrapper::Windows::UI::Xaml::Media::Imaging::BitmapImage* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Media.Imaging.BitmapImage", L"DecodePixelType"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::UI::Xaml::Media::Imaging::DecodePixelType>(arg);

            self->obj.DecodePixelType(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* BitmapImage_get_AutoPlay(py::wrapper::Windows::UI::Xaml::Media::Imaging::BitmapImage* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Media.Imaging.BitmapImage", L"AutoPlay"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.AutoPlay());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int BitmapImage_put_AutoPlay(py::wrapper::Windows::UI::Xaml::Media::Imaging::BitmapImage* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Media.Imaging.BitmapImage", L"AutoPlay"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<bool>(arg);

            self->obj.AutoPlay(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* BitmapImage_get_IsAnimatedBitmap(py::wrapper::Windows::UI::Xaml::Media::Imaging::BitmapImage* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Media.Imaging.BitmapImage", L"IsAnimatedBitmap"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.IsAnimatedBitmap());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* BitmapImage_get_IsPlaying(py::wrapper::Windows::UI::Xaml::Media::Imaging::BitmapImage* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Media.Imaging.BitmapImage", L"IsPlaying"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.IsPlaying());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* BitmapImage_get_CreateOptionsProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Media.Imaging.BitmapImage", L"CreateOptionsProperty"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Windows::UI::Xaml::Media::Imaging::BitmapImage::CreateOptionsProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* BitmapImage_get_DecodePixelHeightProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Media.Imaging.BitmapImage", L"DecodePixelHeightProperty"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Windows::UI::Xaml::Media::Imaging::BitmapImage::DecodePixelHeightProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* BitmapImage_get_DecodePixelWidthProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Media.Imaging.BitmapImage", L"DecodePixelWidthProperty"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Windows::UI::Xaml::Media::Imaging::BitmapImage::DecodePixelWidthProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* BitmapImage_get_UriSourceProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Media.Imaging.BitmapImage", L"UriSourceProperty"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Windows::UI::Xaml::Media::Imaging::BitmapImage::UriSourceProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* BitmapImage_get_DecodePixelTypeProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Media.Imaging.BitmapImage", L"DecodePixelTypeProperty"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Windows::UI::Xaml::Media::Imaging::BitmapImage::DecodePixelTypeProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* BitmapImage_get_AutoPlayProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Media.Imaging.BitmapImage", L"AutoPlayProperty"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Windows::UI::Xaml::Media::Imaging::BitmapImage::AutoPlayProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* BitmapImage_get_IsAnimatedBitmapProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Media.Imaging.BitmapImage", L"IsAnimatedBitmapProperty"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Windows::UI::Xaml::Media::Imaging::BitmapImage::IsAnimatedBitmapProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* BitmapImage_get_IsPlayingProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Media.Imaging.BitmapImage", L"IsPlayingProperty"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Windows::UI::Xaml::Media::Imaging::BitmapImage::IsPlayingProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* BitmapImage_add_DownloadProgress(py::wrapper::Windows::UI::Xaml::Media::Imaging::BitmapImage* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.UI.Xaml.Media.Imaging.BitmapImage", L"DownloadProgress"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::UI::Xaml::Media::Imaging::DownloadProgressEventHandler>(arg);

            return py::convert(self->obj.DownloadProgress(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* BitmapImage_remove_DownloadProgress(py::wrapper::Windows::UI::Xaml::Media::Imaging::BitmapImage* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.UI.Xaml.Media.Imaging.BitmapImage", L"DownloadProgress"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.DownloadProgress(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* BitmapImage_add_ImageFailed(py::wrapper::Windows::UI::Xaml::Media::Imaging::BitmapImage* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.UI.Xaml.Media.Imaging.BitmapImage", L"ImageFailed"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::UI::Xaml::ExceptionRoutedEventHandler>(arg);

            return py::convert(self->obj.ImageFailed(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* BitmapImage_remove_ImageFailed(py::wrapper::Windows::UI::Xaml::Media::Imaging::BitmapImage* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.UI.Xaml.Media.Imaging.BitmapImage", L"ImageFailed"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.ImageFailed(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* BitmapImage_add_ImageOpened(py::wrapper::Windows::UI::Xaml::Media::Imaging::BitmapImage* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.UI.Xaml.Media.Imaging.BitmapImage", L"ImageOpened"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::UI::Xaml::RoutedEventHandler>(arg);

            return py::convert(self->obj.ImageOpened(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* BitmapImage_remove_ImageOpened(py::wrapper::Windows::UI::Xaml::Media::Imaging::BitmapImage* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.UI.Xaml.Media.Imaging.BitmapImage", L"ImageOpened"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.ImageOpened(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_BitmapImage(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::Xaml::Media::Imaging::BitmapImage>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_BitmapImage(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Xaml::Media::Imaging::BitmapImage>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_BitmapImage[] = {
        { "play", reinterpret_cast<PyCFunction>(BitmapImage_Play), METH_VARARGS, nullptr },
        { "stop", reinterpret_cast<PyCFunction>(BitmapImage_Stop), METH_VARARGS, nullptr },
        { "add_download_progress", reinterpret_cast<PyCFunction>(BitmapImage_add_DownloadProgress), METH_O, nullptr },
        { "remove_download_progress", reinterpret_cast<PyCFunction>(BitmapImage_remove_DownloadProgress), METH_O, nullptr },
        { "add_image_failed", reinterpret_cast<PyCFunction>(BitmapImage_add_ImageFailed), METH_O, nullptr },
        { "remove_image_failed", reinterpret_cast<PyCFunction>(BitmapImage_remove_ImageFailed), METH_O, nullptr },
        { "add_image_opened", reinterpret_cast<PyCFunction>(BitmapImage_add_ImageOpened), METH_O, nullptr },
        { "remove_image_opened", reinterpret_cast<PyCFunction>(BitmapImage_remove_ImageOpened), METH_O, nullptr },
        { "_assign_array_", _assign_array_BitmapImage, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_BitmapImage), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_BitmapImage[] = {
        { "uri_source", reinterpret_cast<getter>(BitmapImage_get_UriSource), reinterpret_cast<setter>(BitmapImage_put_UriSource), nullptr, nullptr },
        { "decode_pixel_width", reinterpret_cast<getter>(BitmapImage_get_DecodePixelWidth), reinterpret_cast<setter>(BitmapImage_put_DecodePixelWidth), nullptr, nullptr },
        { "decode_pixel_height", reinterpret_cast<getter>(BitmapImage_get_DecodePixelHeight), reinterpret_cast<setter>(BitmapImage_put_DecodePixelHeight), nullptr, nullptr },
        { "create_options", reinterpret_cast<getter>(BitmapImage_get_CreateOptions), reinterpret_cast<setter>(BitmapImage_put_CreateOptions), nullptr, nullptr },
        { "decode_pixel_type", reinterpret_cast<getter>(BitmapImage_get_DecodePixelType), reinterpret_cast<setter>(BitmapImage_put_DecodePixelType), nullptr, nullptr },
        { "auto_play", reinterpret_cast<getter>(BitmapImage_get_AutoPlay), reinterpret_cast<setter>(BitmapImage_put_AutoPlay), nullptr, nullptr },
        { "is_animated_bitmap", reinterpret_cast<getter>(BitmapImage_get_IsAnimatedBitmap), nullptr, nullptr, nullptr },
        { "is_playing", reinterpret_cast<getter>(BitmapImage_get_IsPlaying), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_BitmapImage[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_BitmapImage) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_BitmapImage) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_BitmapImage) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_BitmapImage) },
        { },
    };

    static PyType_Spec type_spec_BitmapImage =
    {
        "winrt._winrt_windows_ui_xaml_media_imaging.BitmapImage",
        sizeof(py::wrapper::Windows::UI::Xaml::Media::Imaging::BitmapImage),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_BitmapImage
    };

    static PyGetSetDef getset_BitmapImage_Static[] = {
        { "create_options_property", reinterpret_cast<getter>(BitmapImage_get_CreateOptionsProperty), nullptr, nullptr, nullptr },
        { "decode_pixel_height_property", reinterpret_cast<getter>(BitmapImage_get_DecodePixelHeightProperty), nullptr, nullptr, nullptr },
        { "decode_pixel_width_property", reinterpret_cast<getter>(BitmapImage_get_DecodePixelWidthProperty), nullptr, nullptr, nullptr },
        { "uri_source_property", reinterpret_cast<getter>(BitmapImage_get_UriSourceProperty), nullptr, nullptr, nullptr },
        { "decode_pixel_type_property", reinterpret_cast<getter>(BitmapImage_get_DecodePixelTypeProperty), nullptr, nullptr, nullptr },
        { "auto_play_property", reinterpret_cast<getter>(BitmapImage_get_AutoPlayProperty), nullptr, nullptr, nullptr },
        { "is_animated_bitmap_property", reinterpret_cast<getter>(BitmapImage_get_IsAnimatedBitmapProperty), nullptr, nullptr, nullptr },
        { "is_playing_property", reinterpret_cast<getter>(BitmapImage_get_IsPlayingProperty), nullptr, nullptr, nullptr },
        { }
    };

    static PyMethodDef methods_BitmapImage_Static[] = {
        { }
    };

    static PyType_Slot type_slots_BitmapImage_Static[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_BitmapImage_Static) },
        { Py_tp_methods, reinterpret_cast<void*>(methods_BitmapImage_Static) },
        { }
    };

    static PyType_Spec type_spec_BitmapImage_Static =
    {
        "winrt._winrt_windows_ui_xaml_media_imaging.BitmapImage_Static",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT,
        type_slots_BitmapImage_Static
    };

    // ----- BitmapSource class --------------------

    static PyObject* _new_BitmapSource(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::UI::Xaml::Media::Imaging::BitmapSource>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::UI::Xaml::Media::Imaging::BitmapSource>::type_name);
        return nullptr;
    }

    static void _dealloc_BitmapSource(py::wrapper::Windows::UI::Xaml::Media::Imaging::BitmapSource* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* BitmapSource_SetSource(py::wrapper::Windows::UI::Xaml::Media::Imaging::BitmapSource* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.Media.Imaging.BitmapSource", L"SetSource", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::Storage::Streams::IRandomAccessStream>(args, 0);

                self->obj.SetSource(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* BitmapSource_SetSourceAsync(py::wrapper::Windows::UI::Xaml::Media::Imaging::BitmapSource* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.Media.Imaging.BitmapSource", L"SetSourceAsync", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::Storage::Streams::IRandomAccessStream>(args, 0);

                return py::convert(self->obj.SetSourceAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* BitmapSource_get_PixelHeight(py::wrapper::Windows::UI::Xaml::Media::Imaging::BitmapSource* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Media.Imaging.BitmapSource", L"PixelHeight"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.PixelHeight());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* BitmapSource_get_PixelWidth(py::wrapper::Windows::UI::Xaml::Media::Imaging::BitmapSource* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Media.Imaging.BitmapSource", L"PixelWidth"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.PixelWidth());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* BitmapSource_get_PixelHeightProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Media.Imaging.BitmapSource", L"PixelHeightProperty"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Windows::UI::Xaml::Media::Imaging::BitmapSource::PixelHeightProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* BitmapSource_get_PixelWidthProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Media.Imaging.BitmapSource", L"PixelWidthProperty"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Windows::UI::Xaml::Media::Imaging::BitmapSource::PixelWidthProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_BitmapSource(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::Xaml::Media::Imaging::BitmapSource>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_BitmapSource(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Xaml::Media::Imaging::BitmapSource>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_BitmapSource[] = {
        { "set_source", reinterpret_cast<PyCFunction>(BitmapSource_SetSource), METH_VARARGS, nullptr },
        { "set_source_async", reinterpret_cast<PyCFunction>(BitmapSource_SetSourceAsync), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_BitmapSource, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_BitmapSource), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_BitmapSource[] = {
        { "pixel_height", reinterpret_cast<getter>(BitmapSource_get_PixelHeight), nullptr, nullptr, nullptr },
        { "pixel_width", reinterpret_cast<getter>(BitmapSource_get_PixelWidth), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_BitmapSource[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_BitmapSource) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_BitmapSource) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_BitmapSource) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_BitmapSource) },
        { },
    };

    static PyType_Spec type_spec_BitmapSource =
    {
        "winrt._winrt_windows_ui_xaml_media_imaging.BitmapSource",
        sizeof(py::wrapper::Windows::UI::Xaml::Media::Imaging::BitmapSource),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_BitmapSource
    };

    static PyGetSetDef getset_BitmapSource_Static[] = {
        { "pixel_height_property", reinterpret_cast<getter>(BitmapSource_get_PixelHeightProperty), nullptr, nullptr, nullptr },
        { "pixel_width_property", reinterpret_cast<getter>(BitmapSource_get_PixelWidthProperty), nullptr, nullptr, nullptr },
        { }
    };

    static PyMethodDef methods_BitmapSource_Static[] = {
        { }
    };

    static PyType_Slot type_slots_BitmapSource_Static[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_BitmapSource_Static) },
        { Py_tp_methods, reinterpret_cast<void*>(methods_BitmapSource_Static) },
        { }
    };

    static PyType_Spec type_spec_BitmapSource_Static =
    {
        "winrt._winrt_windows_ui_xaml_media_imaging.BitmapSource_Static",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT,
        type_slots_BitmapSource_Static
    };

    // ----- DownloadProgressEventArgs class --------------------

    static PyObject* _new_DownloadProgressEventArgs(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::UI::Xaml::Media::Imaging::DownloadProgressEventArgs>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::UI::Xaml::Media::Imaging::DownloadProgressEventArgs>::type_name);
        return nullptr;
    }

    static void _dealloc_DownloadProgressEventArgs(py::wrapper::Windows::UI::Xaml::Media::Imaging::DownloadProgressEventArgs* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* DownloadProgressEventArgs_get_Progress(py::wrapper::Windows::UI::Xaml::Media::Imaging::DownloadProgressEventArgs* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Media.Imaging.DownloadProgressEventArgs", L"Progress"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Progress());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int DownloadProgressEventArgs_put_Progress(py::wrapper::Windows::UI::Xaml::Media::Imaging::DownloadProgressEventArgs* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Media.Imaging.DownloadProgressEventArgs", L"Progress"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<int32_t>(arg);

            self->obj.Progress(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* _assign_array_DownloadProgressEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::Xaml::Media::Imaging::DownloadProgressEventArgs>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_DownloadProgressEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Xaml::Media::Imaging::DownloadProgressEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_DownloadProgressEventArgs[] = {
        { "_assign_array_", _assign_array_DownloadProgressEventArgs, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_DownloadProgressEventArgs), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_DownloadProgressEventArgs[] = {
        { "progress", reinterpret_cast<getter>(DownloadProgressEventArgs_get_Progress), reinterpret_cast<setter>(DownloadProgressEventArgs_put_Progress), nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_DownloadProgressEventArgs[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_DownloadProgressEventArgs) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_DownloadProgressEventArgs) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_DownloadProgressEventArgs) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_DownloadProgressEventArgs) },
        { },
    };

    static PyType_Spec type_spec_DownloadProgressEventArgs =
    {
        "winrt._winrt_windows_ui_xaml_media_imaging.DownloadProgressEventArgs",
        sizeof(py::wrapper::Windows::UI::Xaml::Media::Imaging::DownloadProgressEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_DownloadProgressEventArgs
    };

    // ----- RenderTargetBitmap class --------------------

    static PyObject* _new_RenderTargetBitmap(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 0)
        {
            try
            {
                winrt::Windows::UI::Xaml::Media::Imaging::RenderTargetBitmap instance{  };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_RenderTargetBitmap(py::wrapper::Windows::UI::Xaml::Media::Imaging::RenderTargetBitmap* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* RenderTargetBitmap_GetPixelsAsync(py::wrapper::Windows::UI::Xaml::Media::Imaging::RenderTargetBitmap* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.Media.Imaging.RenderTargetBitmap", L"GetPixelsAsync", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(self->obj.GetPixelsAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* RenderTargetBitmap_RenderAsync(py::wrapper::Windows::UI::Xaml::Media::Imaging::RenderTargetBitmap* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.Media.Imaging.RenderTargetBitmap", L"RenderAsync", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::UI::Xaml::UIElement>(args, 0);

                return py::convert(self->obj.RenderAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 3)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.Media.Imaging.RenderTargetBitmap", L"RenderAsync", 3))
            {
                py::set_arg_count_version_error(3);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::UI::Xaml::UIElement>(args, 0);
                auto param1 = py::convert_to<int32_t>(args, 1);
                auto param2 = py::convert_to<int32_t>(args, 2);

                return py::convert(self->obj.RenderAsync(param0, param1, param2));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* RenderTargetBitmap_get_PixelHeight(py::wrapper::Windows::UI::Xaml::Media::Imaging::RenderTargetBitmap* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Media.Imaging.RenderTargetBitmap", L"PixelHeight"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.PixelHeight());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* RenderTargetBitmap_get_PixelWidth(py::wrapper::Windows::UI::Xaml::Media::Imaging::RenderTargetBitmap* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Media.Imaging.RenderTargetBitmap", L"PixelWidth"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.PixelWidth());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* RenderTargetBitmap_get_PixelHeightProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Media.Imaging.RenderTargetBitmap", L"PixelHeightProperty"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Windows::UI::Xaml::Media::Imaging::RenderTargetBitmap::PixelHeightProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* RenderTargetBitmap_get_PixelWidthProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Media.Imaging.RenderTargetBitmap", L"PixelWidthProperty"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Windows::UI::Xaml::Media::Imaging::RenderTargetBitmap::PixelWidthProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_RenderTargetBitmap(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::Xaml::Media::Imaging::RenderTargetBitmap>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_RenderTargetBitmap(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Xaml::Media::Imaging::RenderTargetBitmap>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_RenderTargetBitmap[] = {
        { "get_pixels_async", reinterpret_cast<PyCFunction>(RenderTargetBitmap_GetPixelsAsync), METH_VARARGS, nullptr },
        { "render_async", reinterpret_cast<PyCFunction>(RenderTargetBitmap_RenderAsync), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_RenderTargetBitmap, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_RenderTargetBitmap), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_RenderTargetBitmap[] = {
        { "pixel_height", reinterpret_cast<getter>(RenderTargetBitmap_get_PixelHeight), nullptr, nullptr, nullptr },
        { "pixel_width", reinterpret_cast<getter>(RenderTargetBitmap_get_PixelWidth), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_RenderTargetBitmap[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_RenderTargetBitmap) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_RenderTargetBitmap) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_RenderTargetBitmap) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_RenderTargetBitmap) },
        { },
    };

    static PyType_Spec type_spec_RenderTargetBitmap =
    {
        "winrt._winrt_windows_ui_xaml_media_imaging.RenderTargetBitmap",
        sizeof(py::wrapper::Windows::UI::Xaml::Media::Imaging::RenderTargetBitmap),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_RenderTargetBitmap
    };

    static PyGetSetDef getset_RenderTargetBitmap_Static[] = {
        { "pixel_height_property", reinterpret_cast<getter>(RenderTargetBitmap_get_PixelHeightProperty), nullptr, nullptr, nullptr },
        { "pixel_width_property", reinterpret_cast<getter>(RenderTargetBitmap_get_PixelWidthProperty), nullptr, nullptr, nullptr },
        { }
    };

    static PyMethodDef methods_RenderTargetBitmap_Static[] = {
        { }
    };

    static PyType_Slot type_slots_RenderTargetBitmap_Static[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_RenderTargetBitmap_Static) },
        { Py_tp_methods, reinterpret_cast<void*>(methods_RenderTargetBitmap_Static) },
        { }
    };

    static PyType_Spec type_spec_RenderTargetBitmap_Static =
    {
        "winrt._winrt_windows_ui_xaml_media_imaging.RenderTargetBitmap_Static",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT,
        type_slots_RenderTargetBitmap_Static
    };

    // ----- SoftwareBitmapSource class --------------------

    static PyObject* _new_SoftwareBitmapSource(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 0)
        {
            try
            {
                winrt::Windows::UI::Xaml::Media::Imaging::SoftwareBitmapSource instance{  };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_SoftwareBitmapSource(py::wrapper::Windows::UI::Xaml::Media::Imaging::SoftwareBitmapSource* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* SoftwareBitmapSource_Close(py::wrapper::Windows::UI::Xaml::Media::Imaging::SoftwareBitmapSource* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.Media.Imaging.SoftwareBitmapSource", L"Close", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                self->obj.Close();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* SoftwareBitmapSource_SetBitmapAsync(py::wrapper::Windows::UI::Xaml::Media::Imaging::SoftwareBitmapSource* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.Media.Imaging.SoftwareBitmapSource", L"SetBitmapAsync", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::Graphics::Imaging::SoftwareBitmap>(args, 0);

                return py::convert(self->obj.SetBitmapAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* _assign_array_SoftwareBitmapSource(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::Xaml::Media::Imaging::SoftwareBitmapSource>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_SoftwareBitmapSource(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Xaml::Media::Imaging::SoftwareBitmapSource>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _enter_SoftwareBitmapSource(py::wrapper::Windows::UI::Xaml::Media::Imaging::SoftwareBitmapSource* self, PyObject* /*unused*/) noexcept
    {
        return Py_NewRef(self);
    }

    static PyObject* _exit_SoftwareBitmapSource(py::wrapper::Windows::UI::Xaml::Media::Imaging::SoftwareBitmapSource* self, PyObject* /*unused*/) noexcept
    {
        try
        {
            self->obj.Close();
            Py_RETURN_FALSE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_SoftwareBitmapSource[] = {
        { "close", reinterpret_cast<PyCFunction>(SoftwareBitmapSource_Close), METH_VARARGS, nullptr },
        { "set_bitmap_async", reinterpret_cast<PyCFunction>(SoftwareBitmapSource_SetBitmapAsync), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_SoftwareBitmapSource, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_SoftwareBitmapSource), METH_O | METH_STATIC, nullptr },
        { "__enter__", reinterpret_cast<PyCFunction>(_enter_SoftwareBitmapSource), METH_NOARGS, nullptr },
        { "__exit__",  reinterpret_cast<PyCFunction>(_exit_SoftwareBitmapSource), METH_VARARGS, nullptr },
        { }
    };

    static PyGetSetDef _getset_SoftwareBitmapSource[] = {
        { }
    };

    static PyType_Slot _type_slots_SoftwareBitmapSource[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_SoftwareBitmapSource) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_SoftwareBitmapSource) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_SoftwareBitmapSource) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_SoftwareBitmapSource) },
        { },
    };

    static PyType_Spec type_spec_SoftwareBitmapSource =
    {
        "winrt._winrt_windows_ui_xaml_media_imaging.SoftwareBitmapSource",
        sizeof(py::wrapper::Windows::UI::Xaml::Media::Imaging::SoftwareBitmapSource),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_SoftwareBitmapSource
    };

    // ----- SurfaceImageSource class --------------------

    static PyObject* _new_SurfaceImageSource(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<int32_t>(args, 0);
                auto param1 = py::convert_to<int32_t>(args, 1);

                winrt::Windows::UI::Xaml::Media::Imaging::SurfaceImageSource instance{ param0, param1 };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 3)
        {
            try
            {
                auto param0 = py::convert_to<int32_t>(args, 0);
                auto param1 = py::convert_to<int32_t>(args, 1);
                auto param2 = py::convert_to<bool>(args, 2);

                winrt::Windows::UI::Xaml::Media::Imaging::SurfaceImageSource instance{ param0, param1, param2 };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_SurfaceImageSource(py::wrapper::Windows::UI::Xaml::Media::Imaging::SurfaceImageSource* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* _assign_array_SurfaceImageSource(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::Xaml::Media::Imaging::SurfaceImageSource>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_SurfaceImageSource(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Xaml::Media::Imaging::SurfaceImageSource>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_SurfaceImageSource[] = {
        { "_assign_array_", _assign_array_SurfaceImageSource, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_SurfaceImageSource), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_SurfaceImageSource[] = {
        { }
    };

    static PyType_Slot _type_slots_SurfaceImageSource[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_SurfaceImageSource) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_SurfaceImageSource) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_SurfaceImageSource) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_SurfaceImageSource) },
        { },
    };

    static PyType_Spec type_spec_SurfaceImageSource =
    {
        "winrt._winrt_windows_ui_xaml_media_imaging.SurfaceImageSource",
        sizeof(py::wrapper::Windows::UI::Xaml::Media::Imaging::SurfaceImageSource),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_SurfaceImageSource
    };

    // ----- SvgImageSource class --------------------

    static PyObject* _new_SvgImageSource(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 0)
        {
            try
            {
                winrt::Windows::UI::Xaml::Media::Imaging::SvgImageSource instance{  };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Foundation::Uri>(args, 0);

                winrt::Windows::UI::Xaml::Media::Imaging::SvgImageSource instance{ param0 };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_SvgImageSource(py::wrapper::Windows::UI::Xaml::Media::Imaging::SvgImageSource* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* SvgImageSource_SetSourceAsync(py::wrapper::Windows::UI::Xaml::Media::Imaging::SvgImageSource* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.Media.Imaging.SvgImageSource", L"SetSourceAsync", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::Storage::Streams::IRandomAccessStream>(args, 0);

                return py::convert(self->obj.SetSourceAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* SvgImageSource_get_UriSource(py::wrapper::Windows::UI::Xaml::Media::Imaging::SvgImageSource* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Media.Imaging.SvgImageSource", L"UriSource"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.UriSource());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int SvgImageSource_put_UriSource(py::wrapper::Windows::UI::Xaml::Media::Imaging::SvgImageSource* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Media.Imaging.SvgImageSource", L"UriSource"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::Uri>(arg);

            self->obj.UriSource(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* SvgImageSource_get_RasterizePixelWidth(py::wrapper::Windows::UI::Xaml::Media::Imaging::SvgImageSource* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Media.Imaging.SvgImageSource", L"RasterizePixelWidth"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.RasterizePixelWidth());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int SvgImageSource_put_RasterizePixelWidth(py::wrapper::Windows::UI::Xaml::Media::Imaging::SvgImageSource* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Media.Imaging.SvgImageSource", L"RasterizePixelWidth"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<double>(arg);

            self->obj.RasterizePixelWidth(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* SvgImageSource_get_RasterizePixelHeight(py::wrapper::Windows::UI::Xaml::Media::Imaging::SvgImageSource* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Media.Imaging.SvgImageSource", L"RasterizePixelHeight"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.RasterizePixelHeight());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int SvgImageSource_put_RasterizePixelHeight(py::wrapper::Windows::UI::Xaml::Media::Imaging::SvgImageSource* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Media.Imaging.SvgImageSource", L"RasterizePixelHeight"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<double>(arg);

            self->obj.RasterizePixelHeight(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* SvgImageSource_get_RasterizePixelHeightProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Media.Imaging.SvgImageSource", L"RasterizePixelHeightProperty"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Windows::UI::Xaml::Media::Imaging::SvgImageSource::RasterizePixelHeightProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SvgImageSource_get_RasterizePixelWidthProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Media.Imaging.SvgImageSource", L"RasterizePixelWidthProperty"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Windows::UI::Xaml::Media::Imaging::SvgImageSource::RasterizePixelWidthProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SvgImageSource_get_UriSourceProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Media.Imaging.SvgImageSource", L"UriSourceProperty"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Windows::UI::Xaml::Media::Imaging::SvgImageSource::UriSourceProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SvgImageSource_add_OpenFailed(py::wrapper::Windows::UI::Xaml::Media::Imaging::SvgImageSource* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.UI.Xaml.Media.Imaging.SvgImageSource", L"OpenFailed"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::UI::Xaml::Media::Imaging::SvgImageSource, winrt::Windows::UI::Xaml::Media::Imaging::SvgImageSourceFailedEventArgs>>(arg);

            return py::convert(self->obj.OpenFailed(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SvgImageSource_remove_OpenFailed(py::wrapper::Windows::UI::Xaml::Media::Imaging::SvgImageSource* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.UI.Xaml.Media.Imaging.SvgImageSource", L"OpenFailed"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.OpenFailed(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SvgImageSource_add_Opened(py::wrapper::Windows::UI::Xaml::Media::Imaging::SvgImageSource* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.UI.Xaml.Media.Imaging.SvgImageSource", L"Opened"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::UI::Xaml::Media::Imaging::SvgImageSource, winrt::Windows::UI::Xaml::Media::Imaging::SvgImageSourceOpenedEventArgs>>(arg);

            return py::convert(self->obj.Opened(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SvgImageSource_remove_Opened(py::wrapper::Windows::UI::Xaml::Media::Imaging::SvgImageSource* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.UI.Xaml.Media.Imaging.SvgImageSource", L"Opened"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.Opened(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_SvgImageSource(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::Xaml::Media::Imaging::SvgImageSource>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_SvgImageSource(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Xaml::Media::Imaging::SvgImageSource>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_SvgImageSource[] = {
        { "set_source_async", reinterpret_cast<PyCFunction>(SvgImageSource_SetSourceAsync), METH_VARARGS, nullptr },
        { "add_open_failed", reinterpret_cast<PyCFunction>(SvgImageSource_add_OpenFailed), METH_O, nullptr },
        { "remove_open_failed", reinterpret_cast<PyCFunction>(SvgImageSource_remove_OpenFailed), METH_O, nullptr },
        { "add_opened", reinterpret_cast<PyCFunction>(SvgImageSource_add_Opened), METH_O, nullptr },
        { "remove_opened", reinterpret_cast<PyCFunction>(SvgImageSource_remove_Opened), METH_O, nullptr },
        { "_assign_array_", _assign_array_SvgImageSource, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_SvgImageSource), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_SvgImageSource[] = {
        { "uri_source", reinterpret_cast<getter>(SvgImageSource_get_UriSource), reinterpret_cast<setter>(SvgImageSource_put_UriSource), nullptr, nullptr },
        { "rasterize_pixel_width", reinterpret_cast<getter>(SvgImageSource_get_RasterizePixelWidth), reinterpret_cast<setter>(SvgImageSource_put_RasterizePixelWidth), nullptr, nullptr },
        { "rasterize_pixel_height", reinterpret_cast<getter>(SvgImageSource_get_RasterizePixelHeight), reinterpret_cast<setter>(SvgImageSource_put_RasterizePixelHeight), nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_SvgImageSource[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_SvgImageSource) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_SvgImageSource) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_SvgImageSource) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_SvgImageSource) },
        { },
    };

    static PyType_Spec type_spec_SvgImageSource =
    {
        "winrt._winrt_windows_ui_xaml_media_imaging.SvgImageSource",
        sizeof(py::wrapper::Windows::UI::Xaml::Media::Imaging::SvgImageSource),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_SvgImageSource
    };

    static PyGetSetDef getset_SvgImageSource_Static[] = {
        { "rasterize_pixel_height_property", reinterpret_cast<getter>(SvgImageSource_get_RasterizePixelHeightProperty), nullptr, nullptr, nullptr },
        { "rasterize_pixel_width_property", reinterpret_cast<getter>(SvgImageSource_get_RasterizePixelWidthProperty), nullptr, nullptr, nullptr },
        { "uri_source_property", reinterpret_cast<getter>(SvgImageSource_get_UriSourceProperty), nullptr, nullptr, nullptr },
        { }
    };

    static PyMethodDef methods_SvgImageSource_Static[] = {
        { }
    };

    static PyType_Slot type_slots_SvgImageSource_Static[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_SvgImageSource_Static) },
        { Py_tp_methods, reinterpret_cast<void*>(methods_SvgImageSource_Static) },
        { }
    };

    static PyType_Spec type_spec_SvgImageSource_Static =
    {
        "winrt._winrt_windows_ui_xaml_media_imaging.SvgImageSource_Static",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT,
        type_slots_SvgImageSource_Static
    };

    // ----- SvgImageSourceFailedEventArgs class --------------------

    static PyObject* _new_SvgImageSourceFailedEventArgs(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::UI::Xaml::Media::Imaging::SvgImageSourceFailedEventArgs>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::UI::Xaml::Media::Imaging::SvgImageSourceFailedEventArgs>::type_name);
        return nullptr;
    }

    static void _dealloc_SvgImageSourceFailedEventArgs(py::wrapper::Windows::UI::Xaml::Media::Imaging::SvgImageSourceFailedEventArgs* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* SvgImageSourceFailedEventArgs_get_Status(py::wrapper::Windows::UI::Xaml::Media::Imaging::SvgImageSourceFailedEventArgs* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Media.Imaging.SvgImageSourceFailedEventArgs", L"Status"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Status());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_SvgImageSourceFailedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::Xaml::Media::Imaging::SvgImageSourceFailedEventArgs>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_SvgImageSourceFailedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Xaml::Media::Imaging::SvgImageSourceFailedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_SvgImageSourceFailedEventArgs[] = {
        { "_assign_array_", _assign_array_SvgImageSourceFailedEventArgs, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_SvgImageSourceFailedEventArgs), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_SvgImageSourceFailedEventArgs[] = {
        { "status", reinterpret_cast<getter>(SvgImageSourceFailedEventArgs_get_Status), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_SvgImageSourceFailedEventArgs[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_SvgImageSourceFailedEventArgs) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_SvgImageSourceFailedEventArgs) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_SvgImageSourceFailedEventArgs) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_SvgImageSourceFailedEventArgs) },
        { },
    };

    static PyType_Spec type_spec_SvgImageSourceFailedEventArgs =
    {
        "winrt._winrt_windows_ui_xaml_media_imaging.SvgImageSourceFailedEventArgs",
        sizeof(py::wrapper::Windows::UI::Xaml::Media::Imaging::SvgImageSourceFailedEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_SvgImageSourceFailedEventArgs
    };

    // ----- SvgImageSourceOpenedEventArgs class --------------------

    static PyObject* _new_SvgImageSourceOpenedEventArgs(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::UI::Xaml::Media::Imaging::SvgImageSourceOpenedEventArgs>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::UI::Xaml::Media::Imaging::SvgImageSourceOpenedEventArgs>::type_name);
        return nullptr;
    }

    static void _dealloc_SvgImageSourceOpenedEventArgs(py::wrapper::Windows::UI::Xaml::Media::Imaging::SvgImageSourceOpenedEventArgs* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* _assign_array_SvgImageSourceOpenedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::Xaml::Media::Imaging::SvgImageSourceOpenedEventArgs>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_SvgImageSourceOpenedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Xaml::Media::Imaging::SvgImageSourceOpenedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_SvgImageSourceOpenedEventArgs[] = {
        { "_assign_array_", _assign_array_SvgImageSourceOpenedEventArgs, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_SvgImageSourceOpenedEventArgs), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_SvgImageSourceOpenedEventArgs[] = {
        { }
    };

    static PyType_Slot _type_slots_SvgImageSourceOpenedEventArgs[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_SvgImageSourceOpenedEventArgs) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_SvgImageSourceOpenedEventArgs) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_SvgImageSourceOpenedEventArgs) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_SvgImageSourceOpenedEventArgs) },
        { },
    };

    static PyType_Spec type_spec_SvgImageSourceOpenedEventArgs =
    {
        "winrt._winrt_windows_ui_xaml_media_imaging.SvgImageSourceOpenedEventArgs",
        sizeof(py::wrapper::Windows::UI::Xaml::Media::Imaging::SvgImageSourceOpenedEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_SvgImageSourceOpenedEventArgs
    };

    // ----- VirtualSurfaceImageSource class --------------------

    static PyObject* _new_VirtualSurfaceImageSource(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<int32_t>(args, 0);
                auto param1 = py::convert_to<int32_t>(args, 1);

                winrt::Windows::UI::Xaml::Media::Imaging::VirtualSurfaceImageSource instance{ param0, param1 };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 3)
        {
            try
            {
                auto param0 = py::convert_to<int32_t>(args, 0);
                auto param1 = py::convert_to<int32_t>(args, 1);
                auto param2 = py::convert_to<bool>(args, 2);

                winrt::Windows::UI::Xaml::Media::Imaging::VirtualSurfaceImageSource instance{ param0, param1, param2 };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_VirtualSurfaceImageSource(py::wrapper::Windows::UI::Xaml::Media::Imaging::VirtualSurfaceImageSource* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* _assign_array_VirtualSurfaceImageSource(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::Xaml::Media::Imaging::VirtualSurfaceImageSource>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_VirtualSurfaceImageSource(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Xaml::Media::Imaging::VirtualSurfaceImageSource>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_VirtualSurfaceImageSource[] = {
        { "_assign_array_", _assign_array_VirtualSurfaceImageSource, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_VirtualSurfaceImageSource), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_VirtualSurfaceImageSource[] = {
        { }
    };

    static PyType_Slot _type_slots_VirtualSurfaceImageSource[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_VirtualSurfaceImageSource) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_VirtualSurfaceImageSource) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_VirtualSurfaceImageSource) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_VirtualSurfaceImageSource) },
        { },
    };

    static PyType_Spec type_spec_VirtualSurfaceImageSource =
    {
        "winrt._winrt_windows_ui_xaml_media_imaging.VirtualSurfaceImageSource",
        sizeof(py::wrapper::Windows::UI::Xaml::Media::Imaging::VirtualSurfaceImageSource),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_VirtualSurfaceImageSource
    };

    // ----- WriteableBitmap class --------------------

    static PyObject* _new_WriteableBitmap(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<int32_t>(args, 0);
                auto param1 = py::convert_to<int32_t>(args, 1);

                winrt::Windows::UI::Xaml::Media::Imaging::WriteableBitmap instance{ param0, param1 };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_WriteableBitmap(py::wrapper::Windows::UI::Xaml::Media::Imaging::WriteableBitmap* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* WriteableBitmap_Invalidate(py::wrapper::Windows::UI::Xaml::Media::Imaging::WriteableBitmap* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.Media.Imaging.WriteableBitmap", L"Invalidate", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                self->obj.Invalidate();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* WriteableBitmap_get_PixelBuffer(py::wrapper::Windows::UI::Xaml::Media::Imaging::WriteableBitmap* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Media.Imaging.WriteableBitmap", L"PixelBuffer"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.PixelBuffer());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_WriteableBitmap(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::Xaml::Media::Imaging::WriteableBitmap>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_WriteableBitmap(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Xaml::Media::Imaging::WriteableBitmap>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_WriteableBitmap[] = {
        { "invalidate", reinterpret_cast<PyCFunction>(WriteableBitmap_Invalidate), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_WriteableBitmap, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_WriteableBitmap), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_WriteableBitmap[] = {
        { "pixel_buffer", reinterpret_cast<getter>(WriteableBitmap_get_PixelBuffer), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_WriteableBitmap[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_WriteableBitmap) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_WriteableBitmap) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_WriteableBitmap) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_WriteableBitmap) },
        { },
    };

    static PyType_Spec type_spec_WriteableBitmap =
    {
        "winrt._winrt_windows_ui_xaml_media_imaging.WriteableBitmap",
        sizeof(py::wrapper::Windows::UI::Xaml::Media::Imaging::WriteableBitmap),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_WriteableBitmap
    };

    // ----- XamlRenderingBackgroundTask class --------------------

    static PyObject* _new_XamlRenderingBackgroundTask(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::UI::Xaml::Media::Imaging::XamlRenderingBackgroundTask>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::UI::Xaml::Media::Imaging::XamlRenderingBackgroundTask>::type_name);
        return nullptr;
    }

    static void _dealloc_XamlRenderingBackgroundTask(py::wrapper::Windows::UI::Xaml::Media::Imaging::XamlRenderingBackgroundTask* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* XamlRenderingBackgroundTask_OnRun(py::wrapper::Windows::UI::Xaml::Media::Imaging::XamlRenderingBackgroundTask* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.Media.Imaging.XamlRenderingBackgroundTask", L"OnRun", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::ApplicationModel::Background::IBackgroundTaskInstance>(args, 0);

                self->obj.OnRun(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* _assign_array_XamlRenderingBackgroundTask(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::Xaml::Media::Imaging::XamlRenderingBackgroundTask>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_XamlRenderingBackgroundTask(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Xaml::Media::Imaging::XamlRenderingBackgroundTask>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_XamlRenderingBackgroundTask[] = {
        { "on_run", reinterpret_cast<PyCFunction>(XamlRenderingBackgroundTask_OnRun), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_XamlRenderingBackgroundTask, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_XamlRenderingBackgroundTask), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_XamlRenderingBackgroundTask[] = {
        { }
    };

    static PyType_Slot _type_slots_XamlRenderingBackgroundTask[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_XamlRenderingBackgroundTask) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_XamlRenderingBackgroundTask) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_XamlRenderingBackgroundTask) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_XamlRenderingBackgroundTask) },
        { },
    };

    static PyType_Spec type_spec_XamlRenderingBackgroundTask =
    {
        "winrt._winrt_windows_ui_xaml_media_imaging.XamlRenderingBackgroundTask",
        sizeof(py::wrapper::Windows::UI::Xaml::Media::Imaging::XamlRenderingBackgroundTask),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_XamlRenderingBackgroundTask
    };

    // ----- Windows.UI.Xaml.Media.Imaging Initialization --------------------
    PyDoc_STRVAR(module_doc, "Windows::UI::Xaml::Media::Imaging");


    static PyModuleDef module_def
        = {PyModuleDef_HEAD_INIT,
           "_winrt_windows_ui_xaml_media_imaging",
           module_doc,
           0,
           nullptr,
           nullptr,
           nullptr,
           nullptr,
           nullptr};

} // py::cpp::Windows::UI::Xaml::Media::Imaging

PyMODINIT_FUNC PyInit__winrt_windows_ui_xaml_media_imaging(void) noexcept
{
    using namespace py::cpp::Windows::UI::Xaml::Media::Imaging;

    if (py::import_winrt_runtime() == -1)
    {
        return nullptr;
    }

    py::pyobj_handle module{PyModule_Create(&module_def)};

    if (!module)
    {
        return nullptr;
    }

    auto object_type = py::get_object_type();
    if (!object_type)
    {
        return nullptr;
    }

    py::pyobj_handle object_bases{PyTuple_Pack(1, object_type)};

    if (!object_bases)
    {
        return nullptr;
    }

    py::pyobj_handle type_BitmapImage_Static{PyType_FromSpec(&type_spec_BitmapImage_Static)};
    if (!type_BitmapImage_Static)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_BitmapImage, object_bases.get(), reinterpret_cast<PyTypeObject*>(type_BitmapImage_Static.get())) == -1)
    {
        return nullptr;
    }

    py::pyobj_handle type_BitmapSource_Static{PyType_FromSpec(&type_spec_BitmapSource_Static)};
    if (!type_BitmapSource_Static)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_BitmapSource, object_bases.get(), reinterpret_cast<PyTypeObject*>(type_BitmapSource_Static.get())) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_DownloadProgressEventArgs, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    py::pyobj_handle type_RenderTargetBitmap_Static{PyType_FromSpec(&type_spec_RenderTargetBitmap_Static)};
    if (!type_RenderTargetBitmap_Static)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_RenderTargetBitmap, object_bases.get(), reinterpret_cast<PyTypeObject*>(type_RenderTargetBitmap_Static.get())) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_SoftwareBitmapSource, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_SurfaceImageSource, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    py::pyobj_handle type_SvgImageSource_Static{PyType_FromSpec(&type_spec_SvgImageSource_Static)};
    if (!type_SvgImageSource_Static)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_SvgImageSource, object_bases.get(), reinterpret_cast<PyTypeObject*>(type_SvgImageSource_Static.get())) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_SvgImageSourceFailedEventArgs, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_SvgImageSourceOpenedEventArgs, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_VirtualSurfaceImageSource, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_WriteableBitmap, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_XamlRenderingBackgroundTask, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }


    return module.detach();
}
