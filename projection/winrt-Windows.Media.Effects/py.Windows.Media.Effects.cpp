// WARNING: Please don't edit this file. It was generated by Python/WinRT v2.0.0-beta.2

#include "py.Windows.Media.Effects.h"


namespace py::cpp::Windows::Media::Effects
{
    // ----- AudioCaptureEffectsManager class --------------------

    static PyObject* _new_AudioCaptureEffectsManager(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Media::Effects::AudioCaptureEffectsManager>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Media::Effects::AudioCaptureEffectsManager>::type_name);
        return nullptr;
    }

    static void _dealloc_AudioCaptureEffectsManager(py::wrapper::Windows::Media::Effects::AudioCaptureEffectsManager* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* AudioCaptureEffectsManager_GetAudioCaptureEffects(py::wrapper::Windows::Media::Effects::AudioCaptureEffectsManager* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Effects.AudioCaptureEffectsManager", L"GetAudioCaptureEffects", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(self->obj.GetAudioCaptureEffects());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AudioCaptureEffectsManager_add_AudioCaptureEffectsChanged(py::wrapper::Windows::Media::Effects::AudioCaptureEffectsManager* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Media.Effects.AudioCaptureEffectsManager", L"AudioCaptureEffectsChanged"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Media::Effects::AudioCaptureEffectsManager, winrt::Windows::Foundation::IInspectable>>(arg);

            return py::convert(self->obj.AudioCaptureEffectsChanged(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AudioCaptureEffectsManager_remove_AudioCaptureEffectsChanged(py::wrapper::Windows::Media::Effects::AudioCaptureEffectsManager* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Media.Effects.AudioCaptureEffectsManager", L"AudioCaptureEffectsChanged"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.AudioCaptureEffectsChanged(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_AudioCaptureEffectsManager(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Media::Effects::AudioCaptureEffectsManager>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_AudioCaptureEffectsManager(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::Effects::AudioCaptureEffectsManager>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_AudioCaptureEffectsManager[] = {
        { "get_audio_capture_effects", reinterpret_cast<PyCFunction>(AudioCaptureEffectsManager_GetAudioCaptureEffects), METH_VARARGS, nullptr },
        { "add_audio_capture_effects_changed", reinterpret_cast<PyCFunction>(AudioCaptureEffectsManager_add_AudioCaptureEffectsChanged), METH_O, nullptr },
        { "remove_audio_capture_effects_changed", reinterpret_cast<PyCFunction>(AudioCaptureEffectsManager_remove_AudioCaptureEffectsChanged), METH_O, nullptr },
        { "_assign_array_", _assign_array_AudioCaptureEffectsManager, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_AudioCaptureEffectsManager), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_AudioCaptureEffectsManager[] = {
        { }
    };

    static PyType_Slot _type_slots_AudioCaptureEffectsManager[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_AudioCaptureEffectsManager) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_AudioCaptureEffectsManager) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_AudioCaptureEffectsManager) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_AudioCaptureEffectsManager) },
        { },
    };

    static PyType_Spec type_spec_AudioCaptureEffectsManager =
    {
        "winrt._winrt_windows_media_effects.AudioCaptureEffectsManager",
        sizeof(py::wrapper::Windows::Media::Effects::AudioCaptureEffectsManager),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_AudioCaptureEffectsManager
    };

    // ----- AudioEffect class --------------------

    static PyObject* _new_AudioEffect(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Media::Effects::AudioEffect>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Media::Effects::AudioEffect>::type_name);
        return nullptr;
    }

    static void _dealloc_AudioEffect(py::wrapper::Windows::Media::Effects::AudioEffect* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* AudioEffect_get_AudioEffectType(py::wrapper::Windows::Media::Effects::AudioEffect* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Effects.AudioEffect", L"AudioEffectType"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.AudioEffectType());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_AudioEffect(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Media::Effects::AudioEffect>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_AudioEffect(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::Effects::AudioEffect>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_AudioEffect[] = {
        { "_assign_array_", _assign_array_AudioEffect, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_AudioEffect), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_AudioEffect[] = {
        { "audio_effect_type", reinterpret_cast<getter>(AudioEffect_get_AudioEffectType), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_AudioEffect[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_AudioEffect) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_AudioEffect) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_AudioEffect) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_AudioEffect) },
        { },
    };

    static PyType_Spec type_spec_AudioEffect =
    {
        "winrt._winrt_windows_media_effects.AudioEffect",
        sizeof(py::wrapper::Windows::Media::Effects::AudioEffect),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_AudioEffect
    };

    // ----- AudioEffectDefinition class --------------------

    static PyObject* _new_AudioEffectDefinition(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                winrt::Windows::Media::Effects::AudioEffectDefinition instance{ param0 };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Foundation::Collections::IPropertySet>(args, 1);

                winrt::Windows::Media::Effects::AudioEffectDefinition instance{ param0, param1 };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_AudioEffectDefinition(py::wrapper::Windows::Media::Effects::AudioEffectDefinition* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* AudioEffectDefinition_get_ActivatableClassId(py::wrapper::Windows::Media::Effects::AudioEffectDefinition* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Effects.AudioEffectDefinition", L"ActivatableClassId"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.ActivatableClassId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AudioEffectDefinition_get_Properties(py::wrapper::Windows::Media::Effects::AudioEffectDefinition* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Effects.AudioEffectDefinition", L"Properties"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Properties());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_AudioEffectDefinition(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Media::Effects::AudioEffectDefinition>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_AudioEffectDefinition(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::Effects::AudioEffectDefinition>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_AudioEffectDefinition[] = {
        { "_assign_array_", _assign_array_AudioEffectDefinition, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_AudioEffectDefinition), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_AudioEffectDefinition[] = {
        { "activatable_class_id", reinterpret_cast<getter>(AudioEffectDefinition_get_ActivatableClassId), nullptr, nullptr, nullptr },
        { "properties", reinterpret_cast<getter>(AudioEffectDefinition_get_Properties), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_AudioEffectDefinition[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_AudioEffectDefinition) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_AudioEffectDefinition) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_AudioEffectDefinition) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_AudioEffectDefinition) },
        { },
    };

    static PyType_Spec type_spec_AudioEffectDefinition =
    {
        "winrt._winrt_windows_media_effects.AudioEffectDefinition",
        sizeof(py::wrapper::Windows::Media::Effects::AudioEffectDefinition),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_AudioEffectDefinition
    };

    // ----- AudioEffectsManager class --------------------

    static PyObject* _new_AudioEffectsManager(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Media::Effects::AudioEffectsManager>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Media::Effects::AudioEffectsManager>::type_name);
        return nullptr;
    }

    static PyObject* AudioEffectsManager_CreateAudioCaptureEffectsManager(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Effects.AudioEffectsManager", L"CreateAudioCaptureEffectsManager", 2))
            {
                py::set_arg_count_version_error(2);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Media::Capture::MediaCategory>(args, 1);

                return py::convert(winrt::Windows::Media::Effects::AudioEffectsManager::CreateAudioCaptureEffectsManager(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 3)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Effects.AudioEffectsManager", L"CreateAudioCaptureEffectsManager", 3))
            {
                py::set_arg_count_version_error(3);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Media::Capture::MediaCategory>(args, 1);
                auto param2 = py::convert_to<winrt::Windows::Media::AudioProcessing>(args, 2);

                return py::convert(winrt::Windows::Media::Effects::AudioEffectsManager::CreateAudioCaptureEffectsManager(param0, param1, param2));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AudioEffectsManager_CreateAudioRenderEffectsManager(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Effects.AudioEffectsManager", L"CreateAudioRenderEffectsManager", 2))
            {
                py::set_arg_count_version_error(2);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Media::Render::AudioRenderCategory>(args, 1);

                return py::convert(winrt::Windows::Media::Effects::AudioEffectsManager::CreateAudioRenderEffectsManager(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 3)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Effects.AudioEffectsManager", L"CreateAudioRenderEffectsManager", 3))
            {
                py::set_arg_count_version_error(3);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Media::Render::AudioRenderCategory>(args, 1);
                auto param2 = py::convert_to<winrt::Windows::Media::AudioProcessing>(args, 2);

                return py::convert(winrt::Windows::Media::Effects::AudioEffectsManager::CreateAudioRenderEffectsManager(param0, param1, param2));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyMethodDef _methods_AudioEffectsManager[] = {
        { }
    };

    static PyGetSetDef _getset_AudioEffectsManager[] = {
        { }
    };

    static PyType_Slot _type_slots_AudioEffectsManager[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_AudioEffectsManager) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_AudioEffectsManager) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_AudioEffectsManager) },
        { },
    };

    static PyType_Spec type_spec_AudioEffectsManager =
    {
        "winrt._winrt_windows_media_effects.AudioEffectsManager",
        0,
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_AudioEffectsManager
    };

    static PyGetSetDef getset_AudioEffectsManager_Static[] = {
        { }
    };

    static PyMethodDef methods_AudioEffectsManager_Static[] = {
        { "create_audio_capture_effects_manager", reinterpret_cast<PyCFunction>(AudioEffectsManager_CreateAudioCaptureEffectsManager), METH_VARARGS, nullptr },
        { "create_audio_render_effects_manager", reinterpret_cast<PyCFunction>(AudioEffectsManager_CreateAudioRenderEffectsManager), METH_VARARGS, nullptr },
        { }
    };

    static PyType_Slot type_slots_AudioEffectsManager_Static[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_AudioEffectsManager_Static) },
        { Py_tp_methods, reinterpret_cast<void*>(methods_AudioEffectsManager_Static) },
        { }
    };

    static PyType_Spec type_spec_AudioEffectsManager_Static =
    {
        "winrt._winrt_windows_media_effects.AudioEffectsManager_Static",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT,
        type_slots_AudioEffectsManager_Static
    };

    // ----- AudioRenderEffectsManager class --------------------

    static PyObject* _new_AudioRenderEffectsManager(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Media::Effects::AudioRenderEffectsManager>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Media::Effects::AudioRenderEffectsManager>::type_name);
        return nullptr;
    }

    static void _dealloc_AudioRenderEffectsManager(py::wrapper::Windows::Media::Effects::AudioRenderEffectsManager* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* AudioRenderEffectsManager_GetAudioRenderEffects(py::wrapper::Windows::Media::Effects::AudioRenderEffectsManager* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Effects.AudioRenderEffectsManager", L"GetAudioRenderEffects", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(self->obj.GetAudioRenderEffects());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AudioRenderEffectsManager_ShowSettingsUI(py::wrapper::Windows::Media::Effects::AudioRenderEffectsManager* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Effects.AudioRenderEffectsManager", L"ShowSettingsUI", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                self->obj.ShowSettingsUI();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AudioRenderEffectsManager_get_EffectsProviderSettingsLabel(py::wrapper::Windows::Media::Effects::AudioRenderEffectsManager* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Effects.AudioRenderEffectsManager", L"EffectsProviderSettingsLabel"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.EffectsProviderSettingsLabel());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AudioRenderEffectsManager_get_EffectsProviderThumbnail(py::wrapper::Windows::Media::Effects::AudioRenderEffectsManager* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Effects.AudioRenderEffectsManager", L"EffectsProviderThumbnail"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.EffectsProviderThumbnail());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AudioRenderEffectsManager_add_AudioRenderEffectsChanged(py::wrapper::Windows::Media::Effects::AudioRenderEffectsManager* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Media.Effects.AudioRenderEffectsManager", L"AudioRenderEffectsChanged"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Media::Effects::AudioRenderEffectsManager, winrt::Windows::Foundation::IInspectable>>(arg);

            return py::convert(self->obj.AudioRenderEffectsChanged(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AudioRenderEffectsManager_remove_AudioRenderEffectsChanged(py::wrapper::Windows::Media::Effects::AudioRenderEffectsManager* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Media.Effects.AudioRenderEffectsManager", L"AudioRenderEffectsChanged"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.AudioRenderEffectsChanged(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_AudioRenderEffectsManager(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Media::Effects::AudioRenderEffectsManager>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_AudioRenderEffectsManager(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::Effects::AudioRenderEffectsManager>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_AudioRenderEffectsManager[] = {
        { "get_audio_render_effects", reinterpret_cast<PyCFunction>(AudioRenderEffectsManager_GetAudioRenderEffects), METH_VARARGS, nullptr },
        { "show_settings_u_i", reinterpret_cast<PyCFunction>(AudioRenderEffectsManager_ShowSettingsUI), METH_VARARGS, nullptr },
        { "add_audio_render_effects_changed", reinterpret_cast<PyCFunction>(AudioRenderEffectsManager_add_AudioRenderEffectsChanged), METH_O, nullptr },
        { "remove_audio_render_effects_changed", reinterpret_cast<PyCFunction>(AudioRenderEffectsManager_remove_AudioRenderEffectsChanged), METH_O, nullptr },
        { "_assign_array_", _assign_array_AudioRenderEffectsManager, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_AudioRenderEffectsManager), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_AudioRenderEffectsManager[] = {
        { "effects_provider_settings_label", reinterpret_cast<getter>(AudioRenderEffectsManager_get_EffectsProviderSettingsLabel), nullptr, nullptr, nullptr },
        { "effects_provider_thumbnail", reinterpret_cast<getter>(AudioRenderEffectsManager_get_EffectsProviderThumbnail), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_AudioRenderEffectsManager[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_AudioRenderEffectsManager) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_AudioRenderEffectsManager) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_AudioRenderEffectsManager) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_AudioRenderEffectsManager) },
        { },
    };

    static PyType_Spec type_spec_AudioRenderEffectsManager =
    {
        "winrt._winrt_windows_media_effects.AudioRenderEffectsManager",
        sizeof(py::wrapper::Windows::Media::Effects::AudioRenderEffectsManager),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_AudioRenderEffectsManager
    };

    // ----- CompositeVideoFrameContext class --------------------

    static PyObject* _new_CompositeVideoFrameContext(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Media::Effects::CompositeVideoFrameContext>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Media::Effects::CompositeVideoFrameContext>::type_name);
        return nullptr;
    }

    static void _dealloc_CompositeVideoFrameContext(py::wrapper::Windows::Media::Effects::CompositeVideoFrameContext* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* CompositeVideoFrameContext_GetOverlayForSurface(py::wrapper::Windows::Media::Effects::CompositeVideoFrameContext* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Effects.CompositeVideoFrameContext", L"GetOverlayForSurface", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::Graphics::DirectX::Direct3D11::IDirect3DSurface>(args, 0);

                return py::convert(self->obj.GetOverlayForSurface(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* CompositeVideoFrameContext_get_BackgroundFrame(py::wrapper::Windows::Media::Effects::CompositeVideoFrameContext* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Effects.CompositeVideoFrameContext", L"BackgroundFrame"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.BackgroundFrame());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CompositeVideoFrameContext_get_OutputFrame(py::wrapper::Windows::Media::Effects::CompositeVideoFrameContext* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Effects.CompositeVideoFrameContext", L"OutputFrame"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.OutputFrame());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CompositeVideoFrameContext_get_SurfacesToOverlay(py::wrapper::Windows::Media::Effects::CompositeVideoFrameContext* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Effects.CompositeVideoFrameContext", L"SurfacesToOverlay"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.SurfacesToOverlay());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_CompositeVideoFrameContext(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Media::Effects::CompositeVideoFrameContext>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_CompositeVideoFrameContext(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::Effects::CompositeVideoFrameContext>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_CompositeVideoFrameContext[] = {
        { "get_overlay_for_surface", reinterpret_cast<PyCFunction>(CompositeVideoFrameContext_GetOverlayForSurface), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_CompositeVideoFrameContext, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_CompositeVideoFrameContext), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_CompositeVideoFrameContext[] = {
        { "background_frame", reinterpret_cast<getter>(CompositeVideoFrameContext_get_BackgroundFrame), nullptr, nullptr, nullptr },
        { "output_frame", reinterpret_cast<getter>(CompositeVideoFrameContext_get_OutputFrame), nullptr, nullptr, nullptr },
        { "surfaces_to_overlay", reinterpret_cast<getter>(CompositeVideoFrameContext_get_SurfacesToOverlay), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_CompositeVideoFrameContext[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_CompositeVideoFrameContext) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_CompositeVideoFrameContext) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_CompositeVideoFrameContext) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_CompositeVideoFrameContext) },
        { },
    };

    static PyType_Spec type_spec_CompositeVideoFrameContext =
    {
        "winrt._winrt_windows_media_effects.CompositeVideoFrameContext",
        sizeof(py::wrapper::Windows::Media::Effects::CompositeVideoFrameContext),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_CompositeVideoFrameContext
    };

    // ----- ProcessAudioFrameContext class --------------------

    static PyObject* _new_ProcessAudioFrameContext(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Media::Effects::ProcessAudioFrameContext>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Media::Effects::ProcessAudioFrameContext>::type_name);
        return nullptr;
    }

    static void _dealloc_ProcessAudioFrameContext(py::wrapper::Windows::Media::Effects::ProcessAudioFrameContext* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* ProcessAudioFrameContext_get_InputFrame(py::wrapper::Windows::Media::Effects::ProcessAudioFrameContext* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Effects.ProcessAudioFrameContext", L"InputFrame"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.InputFrame());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ProcessAudioFrameContext_get_OutputFrame(py::wrapper::Windows::Media::Effects::ProcessAudioFrameContext* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Effects.ProcessAudioFrameContext", L"OutputFrame"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.OutputFrame());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_ProcessAudioFrameContext(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Media::Effects::ProcessAudioFrameContext>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_ProcessAudioFrameContext(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::Effects::ProcessAudioFrameContext>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_ProcessAudioFrameContext[] = {
        { "_assign_array_", _assign_array_ProcessAudioFrameContext, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_ProcessAudioFrameContext), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_ProcessAudioFrameContext[] = {
        { "input_frame", reinterpret_cast<getter>(ProcessAudioFrameContext_get_InputFrame), nullptr, nullptr, nullptr },
        { "output_frame", reinterpret_cast<getter>(ProcessAudioFrameContext_get_OutputFrame), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_ProcessAudioFrameContext[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_ProcessAudioFrameContext) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_ProcessAudioFrameContext) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_ProcessAudioFrameContext) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_ProcessAudioFrameContext) },
        { },
    };

    static PyType_Spec type_spec_ProcessAudioFrameContext =
    {
        "winrt._winrt_windows_media_effects.ProcessAudioFrameContext",
        sizeof(py::wrapper::Windows::Media::Effects::ProcessAudioFrameContext),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_ProcessAudioFrameContext
    };

    // ----- ProcessVideoFrameContext class --------------------

    static PyObject* _new_ProcessVideoFrameContext(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Media::Effects::ProcessVideoFrameContext>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Media::Effects::ProcessVideoFrameContext>::type_name);
        return nullptr;
    }

    static void _dealloc_ProcessVideoFrameContext(py::wrapper::Windows::Media::Effects::ProcessVideoFrameContext* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* ProcessVideoFrameContext_get_InputFrame(py::wrapper::Windows::Media::Effects::ProcessVideoFrameContext* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Effects.ProcessVideoFrameContext", L"InputFrame"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.InputFrame());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ProcessVideoFrameContext_get_OutputFrame(py::wrapper::Windows::Media::Effects::ProcessVideoFrameContext* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Effects.ProcessVideoFrameContext", L"OutputFrame"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.OutputFrame());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_ProcessVideoFrameContext(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Media::Effects::ProcessVideoFrameContext>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_ProcessVideoFrameContext(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::Effects::ProcessVideoFrameContext>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_ProcessVideoFrameContext[] = {
        { "_assign_array_", _assign_array_ProcessVideoFrameContext, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_ProcessVideoFrameContext), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_ProcessVideoFrameContext[] = {
        { "input_frame", reinterpret_cast<getter>(ProcessVideoFrameContext_get_InputFrame), nullptr, nullptr, nullptr },
        { "output_frame", reinterpret_cast<getter>(ProcessVideoFrameContext_get_OutputFrame), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_ProcessVideoFrameContext[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_ProcessVideoFrameContext) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_ProcessVideoFrameContext) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_ProcessVideoFrameContext) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_ProcessVideoFrameContext) },
        { },
    };

    static PyType_Spec type_spec_ProcessVideoFrameContext =
    {
        "winrt._winrt_windows_media_effects.ProcessVideoFrameContext",
        sizeof(py::wrapper::Windows::Media::Effects::ProcessVideoFrameContext),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_ProcessVideoFrameContext
    };

    // ----- SlowMotionEffectDefinition class --------------------

    static PyObject* _new_SlowMotionEffectDefinition(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 0)
        {
            try
            {
                winrt::Windows::Media::Effects::SlowMotionEffectDefinition instance{  };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_SlowMotionEffectDefinition(py::wrapper::Windows::Media::Effects::SlowMotionEffectDefinition* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* SlowMotionEffectDefinition_get_TimeStretchRate(py::wrapper::Windows::Media::Effects::SlowMotionEffectDefinition* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Effects.SlowMotionEffectDefinition", L"TimeStretchRate"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.TimeStretchRate());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int SlowMotionEffectDefinition_put_TimeStretchRate(py::wrapper::Windows::Media::Effects::SlowMotionEffectDefinition* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Effects.SlowMotionEffectDefinition", L"TimeStretchRate"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<double>(arg);

            self->obj.TimeStretchRate(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* SlowMotionEffectDefinition_get_ActivatableClassId(py::wrapper::Windows::Media::Effects::SlowMotionEffectDefinition* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Effects.SlowMotionEffectDefinition", L"ActivatableClassId"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.ActivatableClassId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SlowMotionEffectDefinition_get_Properties(py::wrapper::Windows::Media::Effects::SlowMotionEffectDefinition* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Effects.SlowMotionEffectDefinition", L"Properties"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Properties());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_SlowMotionEffectDefinition(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Media::Effects::SlowMotionEffectDefinition>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_SlowMotionEffectDefinition(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::Effects::SlowMotionEffectDefinition>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_SlowMotionEffectDefinition[] = {
        { "_assign_array_", _assign_array_SlowMotionEffectDefinition, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_SlowMotionEffectDefinition), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_SlowMotionEffectDefinition[] = {
        { "time_stretch_rate", reinterpret_cast<getter>(SlowMotionEffectDefinition_get_TimeStretchRate), reinterpret_cast<setter>(SlowMotionEffectDefinition_put_TimeStretchRate), nullptr, nullptr },
        { "activatable_class_id", reinterpret_cast<getter>(SlowMotionEffectDefinition_get_ActivatableClassId), nullptr, nullptr, nullptr },
        { "properties", reinterpret_cast<getter>(SlowMotionEffectDefinition_get_Properties), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_SlowMotionEffectDefinition[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_SlowMotionEffectDefinition) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_SlowMotionEffectDefinition) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_SlowMotionEffectDefinition) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_SlowMotionEffectDefinition) },
        { },
    };

    static PyType_Spec type_spec_SlowMotionEffectDefinition =
    {
        "winrt._winrt_windows_media_effects.SlowMotionEffectDefinition",
        sizeof(py::wrapper::Windows::Media::Effects::SlowMotionEffectDefinition),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_SlowMotionEffectDefinition
    };

    // ----- VideoCompositorDefinition class --------------------

    static PyObject* _new_VideoCompositorDefinition(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                winrt::Windows::Media::Effects::VideoCompositorDefinition instance{ param0 };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Foundation::Collections::IPropertySet>(args, 1);

                winrt::Windows::Media::Effects::VideoCompositorDefinition instance{ param0, param1 };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_VideoCompositorDefinition(py::wrapper::Windows::Media::Effects::VideoCompositorDefinition* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* VideoCompositorDefinition_get_ActivatableClassId(py::wrapper::Windows::Media::Effects::VideoCompositorDefinition* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Effects.VideoCompositorDefinition", L"ActivatableClassId"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.ActivatableClassId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* VideoCompositorDefinition_get_Properties(py::wrapper::Windows::Media::Effects::VideoCompositorDefinition* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Effects.VideoCompositorDefinition", L"Properties"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Properties());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_VideoCompositorDefinition(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Media::Effects::VideoCompositorDefinition>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_VideoCompositorDefinition(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::Effects::VideoCompositorDefinition>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_VideoCompositorDefinition[] = {
        { "_assign_array_", _assign_array_VideoCompositorDefinition, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_VideoCompositorDefinition), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_VideoCompositorDefinition[] = {
        { "activatable_class_id", reinterpret_cast<getter>(VideoCompositorDefinition_get_ActivatableClassId), nullptr, nullptr, nullptr },
        { "properties", reinterpret_cast<getter>(VideoCompositorDefinition_get_Properties), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_VideoCompositorDefinition[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_VideoCompositorDefinition) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_VideoCompositorDefinition) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_VideoCompositorDefinition) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_VideoCompositorDefinition) },
        { },
    };

    static PyType_Spec type_spec_VideoCompositorDefinition =
    {
        "winrt._winrt_windows_media_effects.VideoCompositorDefinition",
        sizeof(py::wrapper::Windows::Media::Effects::VideoCompositorDefinition),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_VideoCompositorDefinition
    };

    // ----- VideoEffectDefinition class --------------------

    static PyObject* _new_VideoEffectDefinition(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                winrt::Windows::Media::Effects::VideoEffectDefinition instance{ param0 };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Foundation::Collections::IPropertySet>(args, 1);

                winrt::Windows::Media::Effects::VideoEffectDefinition instance{ param0, param1 };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_VideoEffectDefinition(py::wrapper::Windows::Media::Effects::VideoEffectDefinition* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* VideoEffectDefinition_get_ActivatableClassId(py::wrapper::Windows::Media::Effects::VideoEffectDefinition* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Effects.VideoEffectDefinition", L"ActivatableClassId"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.ActivatableClassId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* VideoEffectDefinition_get_Properties(py::wrapper::Windows::Media::Effects::VideoEffectDefinition* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Effects.VideoEffectDefinition", L"Properties"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Properties());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_VideoEffectDefinition(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Media::Effects::VideoEffectDefinition>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_VideoEffectDefinition(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::Effects::VideoEffectDefinition>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_VideoEffectDefinition[] = {
        { "_assign_array_", _assign_array_VideoEffectDefinition, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_VideoEffectDefinition), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_VideoEffectDefinition[] = {
        { "activatable_class_id", reinterpret_cast<getter>(VideoEffectDefinition_get_ActivatableClassId), nullptr, nullptr, nullptr },
        { "properties", reinterpret_cast<getter>(VideoEffectDefinition_get_Properties), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_VideoEffectDefinition[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_VideoEffectDefinition) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_VideoEffectDefinition) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_VideoEffectDefinition) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_VideoEffectDefinition) },
        { },
    };

    static PyType_Spec type_spec_VideoEffectDefinition =
    {
        "winrt._winrt_windows_media_effects.VideoEffectDefinition",
        sizeof(py::wrapper::Windows::Media::Effects::VideoEffectDefinition),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_VideoEffectDefinition
    };

    // ----- VideoTransformEffectDefinition class --------------------

    static PyObject* _new_VideoTransformEffectDefinition(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 0)
        {
            try
            {
                winrt::Windows::Media::Effects::VideoTransformEffectDefinition instance{  };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_VideoTransformEffectDefinition(py::wrapper::Windows::Media::Effects::VideoTransformEffectDefinition* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* VideoTransformEffectDefinition_get_ActivatableClassId(py::wrapper::Windows::Media::Effects::VideoTransformEffectDefinition* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Effects.VideoTransformEffectDefinition", L"ActivatableClassId"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.ActivatableClassId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* VideoTransformEffectDefinition_get_Properties(py::wrapper::Windows::Media::Effects::VideoTransformEffectDefinition* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Effects.VideoTransformEffectDefinition", L"Properties"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Properties());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* VideoTransformEffectDefinition_get_Rotation(py::wrapper::Windows::Media::Effects::VideoTransformEffectDefinition* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Effects.VideoTransformEffectDefinition", L"Rotation"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Rotation());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int VideoTransformEffectDefinition_put_Rotation(py::wrapper::Windows::Media::Effects::VideoTransformEffectDefinition* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Effects.VideoTransformEffectDefinition", L"Rotation"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Media::MediaProperties::MediaRotation>(arg);

            self->obj.Rotation(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* VideoTransformEffectDefinition_get_ProcessingAlgorithm(py::wrapper::Windows::Media::Effects::VideoTransformEffectDefinition* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Effects.VideoTransformEffectDefinition", L"ProcessingAlgorithm"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.ProcessingAlgorithm());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int VideoTransformEffectDefinition_put_ProcessingAlgorithm(py::wrapper::Windows::Media::Effects::VideoTransformEffectDefinition* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Effects.VideoTransformEffectDefinition", L"ProcessingAlgorithm"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Media::Transcoding::MediaVideoProcessingAlgorithm>(arg);

            self->obj.ProcessingAlgorithm(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* VideoTransformEffectDefinition_get_PaddingColor(py::wrapper::Windows::Media::Effects::VideoTransformEffectDefinition* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Effects.VideoTransformEffectDefinition", L"PaddingColor"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.PaddingColor());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int VideoTransformEffectDefinition_put_PaddingColor(py::wrapper::Windows::Media::Effects::VideoTransformEffectDefinition* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Effects.VideoTransformEffectDefinition", L"PaddingColor"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::UI::Color>(arg);

            self->obj.PaddingColor(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* VideoTransformEffectDefinition_get_OutputSize(py::wrapper::Windows::Media::Effects::VideoTransformEffectDefinition* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Effects.VideoTransformEffectDefinition", L"OutputSize"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.OutputSize());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int VideoTransformEffectDefinition_put_OutputSize(py::wrapper::Windows::Media::Effects::VideoTransformEffectDefinition* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Effects.VideoTransformEffectDefinition", L"OutputSize"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::Size>(arg);

            self->obj.OutputSize(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* VideoTransformEffectDefinition_get_Mirror(py::wrapper::Windows::Media::Effects::VideoTransformEffectDefinition* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Effects.VideoTransformEffectDefinition", L"Mirror"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Mirror());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int VideoTransformEffectDefinition_put_Mirror(py::wrapper::Windows::Media::Effects::VideoTransformEffectDefinition* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Effects.VideoTransformEffectDefinition", L"Mirror"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Media::MediaProperties::MediaMirroringOptions>(arg);

            self->obj.Mirror(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* VideoTransformEffectDefinition_get_CropRectangle(py::wrapper::Windows::Media::Effects::VideoTransformEffectDefinition* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Effects.VideoTransformEffectDefinition", L"CropRectangle"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.CropRectangle());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int VideoTransformEffectDefinition_put_CropRectangle(py::wrapper::Windows::Media::Effects::VideoTransformEffectDefinition* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Effects.VideoTransformEffectDefinition", L"CropRectangle"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::Rect>(arg);

            self->obj.CropRectangle(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* VideoTransformEffectDefinition_get_SphericalProjection(py::wrapper::Windows::Media::Effects::VideoTransformEffectDefinition* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Effects.VideoTransformEffectDefinition", L"SphericalProjection"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.SphericalProjection());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_VideoTransformEffectDefinition(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Media::Effects::VideoTransformEffectDefinition>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_VideoTransformEffectDefinition(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::Effects::VideoTransformEffectDefinition>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_VideoTransformEffectDefinition[] = {
        { "_assign_array_", _assign_array_VideoTransformEffectDefinition, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_VideoTransformEffectDefinition), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_VideoTransformEffectDefinition[] = {
        { "activatable_class_id", reinterpret_cast<getter>(VideoTransformEffectDefinition_get_ActivatableClassId), nullptr, nullptr, nullptr },
        { "properties", reinterpret_cast<getter>(VideoTransformEffectDefinition_get_Properties), nullptr, nullptr, nullptr },
        { "rotation", reinterpret_cast<getter>(VideoTransformEffectDefinition_get_Rotation), reinterpret_cast<setter>(VideoTransformEffectDefinition_put_Rotation), nullptr, nullptr },
        { "processing_algorithm", reinterpret_cast<getter>(VideoTransformEffectDefinition_get_ProcessingAlgorithm), reinterpret_cast<setter>(VideoTransformEffectDefinition_put_ProcessingAlgorithm), nullptr, nullptr },
        { "padding_color", reinterpret_cast<getter>(VideoTransformEffectDefinition_get_PaddingColor), reinterpret_cast<setter>(VideoTransformEffectDefinition_put_PaddingColor), nullptr, nullptr },
        { "output_size", reinterpret_cast<getter>(VideoTransformEffectDefinition_get_OutputSize), reinterpret_cast<setter>(VideoTransformEffectDefinition_put_OutputSize), nullptr, nullptr },
        { "mirror", reinterpret_cast<getter>(VideoTransformEffectDefinition_get_Mirror), reinterpret_cast<setter>(VideoTransformEffectDefinition_put_Mirror), nullptr, nullptr },
        { "crop_rectangle", reinterpret_cast<getter>(VideoTransformEffectDefinition_get_CropRectangle), reinterpret_cast<setter>(VideoTransformEffectDefinition_put_CropRectangle), nullptr, nullptr },
        { "spherical_projection", reinterpret_cast<getter>(VideoTransformEffectDefinition_get_SphericalProjection), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_VideoTransformEffectDefinition[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_VideoTransformEffectDefinition) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_VideoTransformEffectDefinition) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_VideoTransformEffectDefinition) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_VideoTransformEffectDefinition) },
        { },
    };

    static PyType_Spec type_spec_VideoTransformEffectDefinition =
    {
        "winrt._winrt_windows_media_effects.VideoTransformEffectDefinition",
        sizeof(py::wrapper::Windows::Media::Effects::VideoTransformEffectDefinition),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_VideoTransformEffectDefinition
    };

    // ----- VideoTransformSphericalProjection class --------------------

    static PyObject* _new_VideoTransformSphericalProjection(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Media::Effects::VideoTransformSphericalProjection>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Media::Effects::VideoTransformSphericalProjection>::type_name);
        return nullptr;
    }

    static void _dealloc_VideoTransformSphericalProjection(py::wrapper::Windows::Media::Effects::VideoTransformSphericalProjection* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* VideoTransformSphericalProjection_get_ViewOrientation(py::wrapper::Windows::Media::Effects::VideoTransformSphericalProjection* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Effects.VideoTransformSphericalProjection", L"ViewOrientation"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.ViewOrientation());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int VideoTransformSphericalProjection_put_ViewOrientation(py::wrapper::Windows::Media::Effects::VideoTransformSphericalProjection* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Effects.VideoTransformSphericalProjection", L"ViewOrientation"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::Numerics::quaternion>(arg);

            self->obj.ViewOrientation(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* VideoTransformSphericalProjection_get_ProjectionMode(py::wrapper::Windows::Media::Effects::VideoTransformSphericalProjection* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Effects.VideoTransformSphericalProjection", L"ProjectionMode"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.ProjectionMode());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int VideoTransformSphericalProjection_put_ProjectionMode(py::wrapper::Windows::Media::Effects::VideoTransformSphericalProjection* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Effects.VideoTransformSphericalProjection", L"ProjectionMode"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Media::Playback::SphericalVideoProjectionMode>(arg);

            self->obj.ProjectionMode(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* VideoTransformSphericalProjection_get_IsEnabled(py::wrapper::Windows::Media::Effects::VideoTransformSphericalProjection* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Effects.VideoTransformSphericalProjection", L"IsEnabled"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.IsEnabled());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int VideoTransformSphericalProjection_put_IsEnabled(py::wrapper::Windows::Media::Effects::VideoTransformSphericalProjection* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Effects.VideoTransformSphericalProjection", L"IsEnabled"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<bool>(arg);

            self->obj.IsEnabled(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* VideoTransformSphericalProjection_get_HorizontalFieldOfViewInDegrees(py::wrapper::Windows::Media::Effects::VideoTransformSphericalProjection* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Effects.VideoTransformSphericalProjection", L"HorizontalFieldOfViewInDegrees"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.HorizontalFieldOfViewInDegrees());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int VideoTransformSphericalProjection_put_HorizontalFieldOfViewInDegrees(py::wrapper::Windows::Media::Effects::VideoTransformSphericalProjection* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Effects.VideoTransformSphericalProjection", L"HorizontalFieldOfViewInDegrees"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<double>(arg);

            self->obj.HorizontalFieldOfViewInDegrees(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* VideoTransformSphericalProjection_get_FrameFormat(py::wrapper::Windows::Media::Effects::VideoTransformSphericalProjection* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Effects.VideoTransformSphericalProjection", L"FrameFormat"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.FrameFormat());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int VideoTransformSphericalProjection_put_FrameFormat(py::wrapper::Windows::Media::Effects::VideoTransformSphericalProjection* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Effects.VideoTransformSphericalProjection", L"FrameFormat"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Media::MediaProperties::SphericalVideoFrameFormat>(arg);

            self->obj.FrameFormat(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* _assign_array_VideoTransformSphericalProjection(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Media::Effects::VideoTransformSphericalProjection>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_VideoTransformSphericalProjection(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::Effects::VideoTransformSphericalProjection>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_VideoTransformSphericalProjection[] = {
        { "_assign_array_", _assign_array_VideoTransformSphericalProjection, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_VideoTransformSphericalProjection), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_VideoTransformSphericalProjection[] = {
        { "view_orientation", reinterpret_cast<getter>(VideoTransformSphericalProjection_get_ViewOrientation), reinterpret_cast<setter>(VideoTransformSphericalProjection_put_ViewOrientation), nullptr, nullptr },
        { "projection_mode", reinterpret_cast<getter>(VideoTransformSphericalProjection_get_ProjectionMode), reinterpret_cast<setter>(VideoTransformSphericalProjection_put_ProjectionMode), nullptr, nullptr },
        { "is_enabled", reinterpret_cast<getter>(VideoTransformSphericalProjection_get_IsEnabled), reinterpret_cast<setter>(VideoTransformSphericalProjection_put_IsEnabled), nullptr, nullptr },
        { "horizontal_field_of_view_in_degrees", reinterpret_cast<getter>(VideoTransformSphericalProjection_get_HorizontalFieldOfViewInDegrees), reinterpret_cast<setter>(VideoTransformSphericalProjection_put_HorizontalFieldOfViewInDegrees), nullptr, nullptr },
        { "frame_format", reinterpret_cast<getter>(VideoTransformSphericalProjection_get_FrameFormat), reinterpret_cast<setter>(VideoTransformSphericalProjection_put_FrameFormat), nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_VideoTransformSphericalProjection[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_VideoTransformSphericalProjection) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_VideoTransformSphericalProjection) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_VideoTransformSphericalProjection) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_VideoTransformSphericalProjection) },
        { },
    };

    static PyType_Spec type_spec_VideoTransformSphericalProjection =
    {
        "winrt._winrt_windows_media_effects.VideoTransformSphericalProjection",
        sizeof(py::wrapper::Windows::Media::Effects::VideoTransformSphericalProjection),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_VideoTransformSphericalProjection
    };

    // ----- IAudioEffectDefinition interface --------------------

    static PyObject* _new_IAudioEffectDefinition(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Media::Effects::IAudioEffectDefinition>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Media::Effects::IAudioEffectDefinition>::type_name);
        return nullptr;
    }

    static void _dealloc_IAudioEffectDefinition(py::wrapper::Windows::Media::Effects::IAudioEffectDefinition* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* IAudioEffectDefinition_get_ActivatableClassId(py::wrapper::Windows::Media::Effects::IAudioEffectDefinition* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Effects.IAudioEffectDefinition", L"ActivatableClassId"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.ActivatableClassId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IAudioEffectDefinition_get_Properties(py::wrapper::Windows::Media::Effects::IAudioEffectDefinition* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Effects.IAudioEffectDefinition", L"Properties"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Properties());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_IAudioEffectDefinition(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Media::Effects::IAudioEffectDefinition>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_IAudioEffectDefinition(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::Effects::IAudioEffectDefinition>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_IAudioEffectDefinition[] = {
        { "_assign_array_", _assign_array_IAudioEffectDefinition, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_IAudioEffectDefinition), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_IAudioEffectDefinition[] = {
        { "activatable_class_id", reinterpret_cast<getter>(IAudioEffectDefinition_get_ActivatableClassId), nullptr, nullptr, nullptr },
        { "properties", reinterpret_cast<getter>(IAudioEffectDefinition_get_Properties), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_IAudioEffectDefinition[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_IAudioEffectDefinition) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_IAudioEffectDefinition) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_IAudioEffectDefinition) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_IAudioEffectDefinition) },
        { },
    };

    static PyType_Spec type_spec_IAudioEffectDefinition =
    {
        "winrt._winrt_windows_media_effects.IAudioEffectDefinition",
        sizeof(py::wrapper::Windows::Media::Effects::IAudioEffectDefinition),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_IAudioEffectDefinition
    };

    // ----- IBasicAudioEffect interface --------------------

    static PyObject* _new_IBasicAudioEffect(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Media::Effects::IBasicAudioEffect>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Media::Effects::IBasicAudioEffect>::type_name);
        return nullptr;
    }

    static void _dealloc_IBasicAudioEffect(py::wrapper::Windows::Media::Effects::IBasicAudioEffect* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* IBasicAudioEffect_Close(py::wrapper::Windows::Media::Effects::IBasicAudioEffect* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Effects.IBasicAudioEffect", L"Close", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::Media::Effects::MediaEffectClosedReason>(args, 0);

                self->obj.Close(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* IBasicAudioEffect_DiscardQueuedFrames(py::wrapper::Windows::Media::Effects::IBasicAudioEffect* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Effects.IBasicAudioEffect", L"DiscardQueuedFrames", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                self->obj.DiscardQueuedFrames();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* IBasicAudioEffect_ProcessFrame(py::wrapper::Windows::Media::Effects::IBasicAudioEffect* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Effects.IBasicAudioEffect", L"ProcessFrame", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::Media::Effects::ProcessAudioFrameContext>(args, 0);

                self->obj.ProcessFrame(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* IBasicAudioEffect_SetEncodingProperties(py::wrapper::Windows::Media::Effects::IBasicAudioEffect* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Effects.IBasicAudioEffect", L"SetEncodingProperties", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::Media::MediaProperties::AudioEncodingProperties>(args, 0);

                self->obj.SetEncodingProperties(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* IBasicAudioEffect_SetProperties(py::wrapper::Windows::Media::Effects::IBasicAudioEffect* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.IMediaExtension", L"SetProperties", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::Foundation::Collections::IPropertySet>(args, 0);

                self->obj.SetProperties(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* IBasicAudioEffect_get_SupportedEncodingProperties(py::wrapper::Windows::Media::Effects::IBasicAudioEffect* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Effects.IBasicAudioEffect", L"SupportedEncodingProperties"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.SupportedEncodingProperties());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IBasicAudioEffect_get_UseInputFrameForOutput(py::wrapper::Windows::Media::Effects::IBasicAudioEffect* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Effects.IBasicAudioEffect", L"UseInputFrameForOutput"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.UseInputFrameForOutput());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_IBasicAudioEffect(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Media::Effects::IBasicAudioEffect>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_IBasicAudioEffect(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::Effects::IBasicAudioEffect>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_IBasicAudioEffect[] = {
        { "close", reinterpret_cast<PyCFunction>(IBasicAudioEffect_Close), METH_VARARGS, nullptr },
        { "discard_queued_frames", reinterpret_cast<PyCFunction>(IBasicAudioEffect_DiscardQueuedFrames), METH_VARARGS, nullptr },
        { "process_frame", reinterpret_cast<PyCFunction>(IBasicAudioEffect_ProcessFrame), METH_VARARGS, nullptr },
        { "set_encoding_properties", reinterpret_cast<PyCFunction>(IBasicAudioEffect_SetEncodingProperties), METH_VARARGS, nullptr },
        { "set_properties", reinterpret_cast<PyCFunction>(IBasicAudioEffect_SetProperties), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_IBasicAudioEffect, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_IBasicAudioEffect), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_IBasicAudioEffect[] = {
        { "supported_encoding_properties", reinterpret_cast<getter>(IBasicAudioEffect_get_SupportedEncodingProperties), nullptr, nullptr, nullptr },
        { "use_input_frame_for_output", reinterpret_cast<getter>(IBasicAudioEffect_get_UseInputFrameForOutput), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_IBasicAudioEffect[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_IBasicAudioEffect) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_IBasicAudioEffect) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_IBasicAudioEffect) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_IBasicAudioEffect) },
        { },
    };

    static PyType_Spec type_spec_IBasicAudioEffect =
    {
        "winrt._winrt_windows_media_effects.IBasicAudioEffect",
        sizeof(py::wrapper::Windows::Media::Effects::IBasicAudioEffect),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_IBasicAudioEffect
    };

    // ----- IBasicVideoEffect interface --------------------

    static PyObject* _new_IBasicVideoEffect(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Media::Effects::IBasicVideoEffect>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Media::Effects::IBasicVideoEffect>::type_name);
        return nullptr;
    }

    static void _dealloc_IBasicVideoEffect(py::wrapper::Windows::Media::Effects::IBasicVideoEffect* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* IBasicVideoEffect_Close(py::wrapper::Windows::Media::Effects::IBasicVideoEffect* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Effects.IBasicVideoEffect", L"Close", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::Media::Effects::MediaEffectClosedReason>(args, 0);

                self->obj.Close(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* IBasicVideoEffect_DiscardQueuedFrames(py::wrapper::Windows::Media::Effects::IBasicVideoEffect* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Effects.IBasicVideoEffect", L"DiscardQueuedFrames", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                self->obj.DiscardQueuedFrames();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* IBasicVideoEffect_ProcessFrame(py::wrapper::Windows::Media::Effects::IBasicVideoEffect* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Effects.IBasicVideoEffect", L"ProcessFrame", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::Media::Effects::ProcessVideoFrameContext>(args, 0);

                self->obj.ProcessFrame(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* IBasicVideoEffect_SetEncodingProperties(py::wrapper::Windows::Media::Effects::IBasicVideoEffect* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Effects.IBasicVideoEffect", L"SetEncodingProperties", 2))
            {
                py::set_arg_count_version_error(2);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::Media::MediaProperties::VideoEncodingProperties>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Graphics::DirectX::Direct3D11::IDirect3DDevice>(args, 1);

                self->obj.SetEncodingProperties(param0, param1);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* IBasicVideoEffect_SetProperties(py::wrapper::Windows::Media::Effects::IBasicVideoEffect* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.IMediaExtension", L"SetProperties", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::Foundation::Collections::IPropertySet>(args, 0);

                self->obj.SetProperties(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* IBasicVideoEffect_get_IsReadOnly(py::wrapper::Windows::Media::Effects::IBasicVideoEffect* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Effects.IBasicVideoEffect", L"IsReadOnly"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.IsReadOnly());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IBasicVideoEffect_get_SupportedEncodingProperties(py::wrapper::Windows::Media::Effects::IBasicVideoEffect* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Effects.IBasicVideoEffect", L"SupportedEncodingProperties"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.SupportedEncodingProperties());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IBasicVideoEffect_get_SupportedMemoryTypes(py::wrapper::Windows::Media::Effects::IBasicVideoEffect* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Effects.IBasicVideoEffect", L"SupportedMemoryTypes"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.SupportedMemoryTypes());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IBasicVideoEffect_get_TimeIndependent(py::wrapper::Windows::Media::Effects::IBasicVideoEffect* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Effects.IBasicVideoEffect", L"TimeIndependent"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.TimeIndependent());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_IBasicVideoEffect(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Media::Effects::IBasicVideoEffect>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_IBasicVideoEffect(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::Effects::IBasicVideoEffect>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_IBasicVideoEffect[] = {
        { "close", reinterpret_cast<PyCFunction>(IBasicVideoEffect_Close), METH_VARARGS, nullptr },
        { "discard_queued_frames", reinterpret_cast<PyCFunction>(IBasicVideoEffect_DiscardQueuedFrames), METH_VARARGS, nullptr },
        { "process_frame", reinterpret_cast<PyCFunction>(IBasicVideoEffect_ProcessFrame), METH_VARARGS, nullptr },
        { "set_encoding_properties", reinterpret_cast<PyCFunction>(IBasicVideoEffect_SetEncodingProperties), METH_VARARGS, nullptr },
        { "set_properties", reinterpret_cast<PyCFunction>(IBasicVideoEffect_SetProperties), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_IBasicVideoEffect, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_IBasicVideoEffect), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_IBasicVideoEffect[] = {
        { "is_read_only", reinterpret_cast<getter>(IBasicVideoEffect_get_IsReadOnly), nullptr, nullptr, nullptr },
        { "supported_encoding_properties", reinterpret_cast<getter>(IBasicVideoEffect_get_SupportedEncodingProperties), nullptr, nullptr, nullptr },
        { "supported_memory_types", reinterpret_cast<getter>(IBasicVideoEffect_get_SupportedMemoryTypes), nullptr, nullptr, nullptr },
        { "time_independent", reinterpret_cast<getter>(IBasicVideoEffect_get_TimeIndependent), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_IBasicVideoEffect[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_IBasicVideoEffect) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_IBasicVideoEffect) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_IBasicVideoEffect) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_IBasicVideoEffect) },
        { },
    };

    static PyType_Spec type_spec_IBasicVideoEffect =
    {
        "winrt._winrt_windows_media_effects.IBasicVideoEffect",
        sizeof(py::wrapper::Windows::Media::Effects::IBasicVideoEffect),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_IBasicVideoEffect
    };

    // ----- IVideoCompositor interface --------------------

    static PyObject* _new_IVideoCompositor(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Media::Effects::IVideoCompositor>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Media::Effects::IVideoCompositor>::type_name);
        return nullptr;
    }

    static void _dealloc_IVideoCompositor(py::wrapper::Windows::Media::Effects::IVideoCompositor* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* IVideoCompositor_Close(py::wrapper::Windows::Media::Effects::IVideoCompositor* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Effects.IVideoCompositor", L"Close", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::Media::Effects::MediaEffectClosedReason>(args, 0);

                self->obj.Close(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* IVideoCompositor_CompositeFrame(py::wrapper::Windows::Media::Effects::IVideoCompositor* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Effects.IVideoCompositor", L"CompositeFrame", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::Media::Effects::CompositeVideoFrameContext>(args, 0);

                self->obj.CompositeFrame(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* IVideoCompositor_DiscardQueuedFrames(py::wrapper::Windows::Media::Effects::IVideoCompositor* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Effects.IVideoCompositor", L"DiscardQueuedFrames", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                self->obj.DiscardQueuedFrames();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* IVideoCompositor_SetEncodingProperties(py::wrapper::Windows::Media::Effects::IVideoCompositor* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Effects.IVideoCompositor", L"SetEncodingProperties", 2))
            {
                py::set_arg_count_version_error(2);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::Media::MediaProperties::VideoEncodingProperties>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Graphics::DirectX::Direct3D11::IDirect3DDevice>(args, 1);

                self->obj.SetEncodingProperties(param0, param1);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* IVideoCompositor_SetProperties(py::wrapper::Windows::Media::Effects::IVideoCompositor* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.IMediaExtension", L"SetProperties", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::Foundation::Collections::IPropertySet>(args, 0);

                self->obj.SetProperties(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* IVideoCompositor_get_TimeIndependent(py::wrapper::Windows::Media::Effects::IVideoCompositor* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Effects.IVideoCompositor", L"TimeIndependent"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.TimeIndependent());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_IVideoCompositor(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Media::Effects::IVideoCompositor>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_IVideoCompositor(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::Effects::IVideoCompositor>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_IVideoCompositor[] = {
        { "close", reinterpret_cast<PyCFunction>(IVideoCompositor_Close), METH_VARARGS, nullptr },
        { "composite_frame", reinterpret_cast<PyCFunction>(IVideoCompositor_CompositeFrame), METH_VARARGS, nullptr },
        { "discard_queued_frames", reinterpret_cast<PyCFunction>(IVideoCompositor_DiscardQueuedFrames), METH_VARARGS, nullptr },
        { "set_encoding_properties", reinterpret_cast<PyCFunction>(IVideoCompositor_SetEncodingProperties), METH_VARARGS, nullptr },
        { "set_properties", reinterpret_cast<PyCFunction>(IVideoCompositor_SetProperties), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_IVideoCompositor, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_IVideoCompositor), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_IVideoCompositor[] = {
        { "time_independent", reinterpret_cast<getter>(IVideoCompositor_get_TimeIndependent), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_IVideoCompositor[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_IVideoCompositor) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_IVideoCompositor) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_IVideoCompositor) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_IVideoCompositor) },
        { },
    };

    static PyType_Spec type_spec_IVideoCompositor =
    {
        "winrt._winrt_windows_media_effects.IVideoCompositor",
        sizeof(py::wrapper::Windows::Media::Effects::IVideoCompositor),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_IVideoCompositor
    };

    // ----- IVideoCompositorDefinition interface --------------------

    static PyObject* _new_IVideoCompositorDefinition(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Media::Effects::IVideoCompositorDefinition>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Media::Effects::IVideoCompositorDefinition>::type_name);
        return nullptr;
    }

    static void _dealloc_IVideoCompositorDefinition(py::wrapper::Windows::Media::Effects::IVideoCompositorDefinition* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* IVideoCompositorDefinition_get_ActivatableClassId(py::wrapper::Windows::Media::Effects::IVideoCompositorDefinition* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Effects.IVideoCompositorDefinition", L"ActivatableClassId"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.ActivatableClassId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IVideoCompositorDefinition_get_Properties(py::wrapper::Windows::Media::Effects::IVideoCompositorDefinition* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Effects.IVideoCompositorDefinition", L"Properties"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Properties());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_IVideoCompositorDefinition(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Media::Effects::IVideoCompositorDefinition>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_IVideoCompositorDefinition(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::Effects::IVideoCompositorDefinition>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_IVideoCompositorDefinition[] = {
        { "_assign_array_", _assign_array_IVideoCompositorDefinition, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_IVideoCompositorDefinition), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_IVideoCompositorDefinition[] = {
        { "activatable_class_id", reinterpret_cast<getter>(IVideoCompositorDefinition_get_ActivatableClassId), nullptr, nullptr, nullptr },
        { "properties", reinterpret_cast<getter>(IVideoCompositorDefinition_get_Properties), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_IVideoCompositorDefinition[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_IVideoCompositorDefinition) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_IVideoCompositorDefinition) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_IVideoCompositorDefinition) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_IVideoCompositorDefinition) },
        { },
    };

    static PyType_Spec type_spec_IVideoCompositorDefinition =
    {
        "winrt._winrt_windows_media_effects.IVideoCompositorDefinition",
        sizeof(py::wrapper::Windows::Media::Effects::IVideoCompositorDefinition),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_IVideoCompositorDefinition
    };

    // ----- IVideoEffectDefinition interface --------------------

    static PyObject* _new_IVideoEffectDefinition(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Media::Effects::IVideoEffectDefinition>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Media::Effects::IVideoEffectDefinition>::type_name);
        return nullptr;
    }

    static void _dealloc_IVideoEffectDefinition(py::wrapper::Windows::Media::Effects::IVideoEffectDefinition* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* IVideoEffectDefinition_get_ActivatableClassId(py::wrapper::Windows::Media::Effects::IVideoEffectDefinition* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Effects.IVideoEffectDefinition", L"ActivatableClassId"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.ActivatableClassId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IVideoEffectDefinition_get_Properties(py::wrapper::Windows::Media::Effects::IVideoEffectDefinition* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Effects.IVideoEffectDefinition", L"Properties"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Properties());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_IVideoEffectDefinition(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Media::Effects::IVideoEffectDefinition>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_IVideoEffectDefinition(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::Effects::IVideoEffectDefinition>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_IVideoEffectDefinition[] = {
        { "_assign_array_", _assign_array_IVideoEffectDefinition, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_IVideoEffectDefinition), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_IVideoEffectDefinition[] = {
        { "activatable_class_id", reinterpret_cast<getter>(IVideoEffectDefinition_get_ActivatableClassId), nullptr, nullptr, nullptr },
        { "properties", reinterpret_cast<getter>(IVideoEffectDefinition_get_Properties), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_IVideoEffectDefinition[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_IVideoEffectDefinition) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_IVideoEffectDefinition) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_IVideoEffectDefinition) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_IVideoEffectDefinition) },
        { },
    };

    static PyType_Spec type_spec_IVideoEffectDefinition =
    {
        "winrt._winrt_windows_media_effects.IVideoEffectDefinition",
        sizeof(py::wrapper::Windows::Media::Effects::IVideoEffectDefinition),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_IVideoEffectDefinition
    };

    // ----- Windows.Media.Effects Initialization --------------------
    PyDoc_STRVAR(module_doc, "Windows::Media::Effects");


    static PyModuleDef module_def
        = {PyModuleDef_HEAD_INIT,
           "_winrt_windows_media_effects",
           module_doc,
           0,
           nullptr,
           nullptr,
           nullptr,
           nullptr,
           nullptr};

} // py::cpp::Windows::Media::Effects

PyMODINIT_FUNC PyInit__winrt_windows_media_effects(void) noexcept
{
    using namespace py::cpp::Windows::Media::Effects;

    if (py::import_winrt_runtime() == -1)
    {
        return nullptr;
    }

    py::pyobj_handle module{PyModule_Create(&module_def)};

    if (!module)
    {
        return nullptr;
    }

    auto object_type = py::get_object_type();
    if (!object_type)
    {
        return nullptr;
    }

    py::pyobj_handle object_bases{PyTuple_Pack(1, object_type)};

    if (!object_bases)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_AudioCaptureEffectsManager, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_AudioEffect, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_AudioEffectDefinition, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    py::pyobj_handle type_AudioEffectsManager_Static{PyType_FromSpec(&type_spec_AudioEffectsManager_Static)};
    if (!type_AudioEffectsManager_Static)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_AudioEffectsManager, object_bases.get(), reinterpret_cast<PyTypeObject*>(type_AudioEffectsManager_Static.get())) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_AudioRenderEffectsManager, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_CompositeVideoFrameContext, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_ProcessAudioFrameContext, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_ProcessVideoFrameContext, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_SlowMotionEffectDefinition, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_VideoCompositorDefinition, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_VideoEffectDefinition, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_VideoTransformEffectDefinition, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_VideoTransformSphericalProjection, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_IAudioEffectDefinition, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_IBasicAudioEffect, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_IBasicVideoEffect, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_IVideoCompositor, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_IVideoCompositorDefinition, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_IVideoEffectDefinition, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }


    return module.detach();
}
