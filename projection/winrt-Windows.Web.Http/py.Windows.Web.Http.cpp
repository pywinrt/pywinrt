// WARNING: Please don't edit this file. It was generated by Python/WinRT v0.0.0

#include "py.Windows.Web.Http.h"


namespace py::cpp::Windows::Web::Http
{
    // ----- HttpBufferContent class --------------------

    static PyObject* _new_HttpBufferContent(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Storage::Streams::IBuffer>(args, 0);

                winrt::Windows::Web::Http::HttpBufferContent instance{ param0 };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 3)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Storage::Streams::IBuffer>(args, 0);
                auto param1 = py::convert_to<uint32_t>(args, 1);
                auto param2 = py::convert_to<uint32_t>(args, 2);

                winrt::Windows::Web::Http::HttpBufferContent instance{ param0, param1, param2 };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_HttpBufferContent(py::wrapper::Windows::Web::Http::HttpBufferContent* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* HttpBufferContent_BufferAllAsync(py::wrapper::Windows::Web::Http::HttpBufferContent* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Web.Http.HttpBufferContent", L"BufferAllAsync", 0))
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert(self->obj.BufferAllAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* HttpBufferContent_Close(py::wrapper::Windows::Web::Http::HttpBufferContent* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Web.Http.HttpBufferContent", L"Close", 0))
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                self->obj.Close();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* HttpBufferContent_ReadAsBufferAsync(py::wrapper::Windows::Web::Http::HttpBufferContent* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Web.Http.HttpBufferContent", L"ReadAsBufferAsync", 0))
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert(self->obj.ReadAsBufferAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* HttpBufferContent_ReadAsInputStreamAsync(py::wrapper::Windows::Web::Http::HttpBufferContent* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Web.Http.HttpBufferContent", L"ReadAsInputStreamAsync", 0))
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert(self->obj.ReadAsInputStreamAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* HttpBufferContent_ReadAsStringAsync(py::wrapper::Windows::Web::Http::HttpBufferContent* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Web.Http.HttpBufferContent", L"ReadAsStringAsync", 0))
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert(self->obj.ReadAsStringAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* HttpBufferContent_ToString(py::wrapper::Windows::Web::Http::HttpBufferContent* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Web.Http.HttpBufferContent", L"ToString", 0))
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert(self->obj.ToString());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* HttpBufferContent_TryComputeLength(py::wrapper::Windows::Web::Http::HttpBufferContent* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Web.Http.HttpBufferContent", L"TryComputeLength", 0))
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                uint64_t param0 {  };

                auto return_value = self->obj.TryComputeLength(param0);

                py::pyobj_handle out_return_value{ py::convert(return_value) };
                if (!out_return_value)
                {
                    return nullptr;
                }
                py::pyobj_handle out0{ py::convert(param0) };
                if (!out0)
                {
                    return nullptr;
                }
                return PyTuple_Pack(2, out_return_value.get(), out0.get());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* HttpBufferContent_WriteToStreamAsync(py::wrapper::Windows::Web::Http::HttpBufferContent* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Web.Http.HttpBufferContent", L"WriteToStreamAsync", 1))
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Storage::Streams::IOutputStream>(args, 0);

                return py::convert(self->obj.WriteToStreamAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* HttpBufferContent_get_Headers(py::wrapper::Windows::Web::Http::HttpBufferContent* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Web.Http.HttpBufferContent", L"Headers"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Headers());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_HttpBufferContent(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Web::Http::HttpBufferContent>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_HttpBufferContent(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Web::Http::HttpBufferContent>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _enter_HttpBufferContent(py::wrapper::Windows::Web::Http::HttpBufferContent* self, PyObject* /*unused*/) noexcept
    {
        return Py_NewRef(self);
    }

    static PyObject* _exit_HttpBufferContent(py::wrapper::Windows::Web::Http::HttpBufferContent* self, PyObject* /*unused*/) noexcept
    {
        try
        {
            self->obj.Close();
            Py_RETURN_FALSE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _str_HttpBufferContent(py::wrapper::Windows::Web::Http::HttpBufferContent* self) noexcept
    {
        try
        {
            return py::convert(self->obj.ToString());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_HttpBufferContent[] = {
        { "buffer_all_async", reinterpret_cast<PyCFunction>(HttpBufferContent_BufferAllAsync), METH_VARARGS, nullptr },
        { "close", reinterpret_cast<PyCFunction>(HttpBufferContent_Close), METH_VARARGS, nullptr },
        { "read_as_buffer_async", reinterpret_cast<PyCFunction>(HttpBufferContent_ReadAsBufferAsync), METH_VARARGS, nullptr },
        { "read_as_input_stream_async", reinterpret_cast<PyCFunction>(HttpBufferContent_ReadAsInputStreamAsync), METH_VARARGS, nullptr },
        { "read_as_string_async", reinterpret_cast<PyCFunction>(HttpBufferContent_ReadAsStringAsync), METH_VARARGS, nullptr },
        { "to_string", reinterpret_cast<PyCFunction>(HttpBufferContent_ToString), METH_VARARGS, nullptr },
        { "try_compute_length", reinterpret_cast<PyCFunction>(HttpBufferContent_TryComputeLength), METH_VARARGS, nullptr },
        { "write_to_stream_async", reinterpret_cast<PyCFunction>(HttpBufferContent_WriteToStreamAsync), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_HttpBufferContent, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_HttpBufferContent), METH_O | METH_STATIC, nullptr },
        { "__enter__", reinterpret_cast<PyCFunction>(_enter_HttpBufferContent), METH_NOARGS, nullptr },
        { "__exit__",  reinterpret_cast<PyCFunction>(_exit_HttpBufferContent), METH_VARARGS, nullptr },
        { }
    };

    static PyGetSetDef _getset_HttpBufferContent[] = {
        { "headers", reinterpret_cast<getter>(HttpBufferContent_get_Headers), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_HttpBufferContent[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_HttpBufferContent) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_HttpBufferContent) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_HttpBufferContent) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_HttpBufferContent) },
        { Py_tp_str, reinterpret_cast<void*>(_str_HttpBufferContent) },
        { },
    };

    static PyType_Spec type_spec_HttpBufferContent =
    {
        "winrt._winrt_windows_web_http.HttpBufferContent",
        sizeof(py::wrapper::Windows::Web::Http::HttpBufferContent),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_HttpBufferContent
    };

    // ----- HttpClient class --------------------

    static PyObject* _new_HttpClient(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Web::Http::Filters::IHttpFilter>(args, 0);

                winrt::Windows::Web::Http::HttpClient instance{ param0 };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 0)
        {
            try
            {
                winrt::Windows::Web::Http::HttpClient instance{  };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_HttpClient(py::wrapper::Windows::Web::Http::HttpClient* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* HttpClient_Close(py::wrapper::Windows::Web::Http::HttpClient* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Web.Http.HttpClient", L"Close", 0))
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                self->obj.Close();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* HttpClient_DeleteAsync(py::wrapper::Windows::Web::Http::HttpClient* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Web.Http.HttpClient", L"DeleteAsync", 1))
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Foundation::Uri>(args, 0);

                return py::convert(self->obj.DeleteAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* HttpClient_GetAsync(py::wrapper::Windows::Web::Http::HttpClient* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Web.Http.HttpClient", L"GetAsync", 1))
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Foundation::Uri>(args, 0);

                return py::convert(self->obj.GetAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 2)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Web.Http.HttpClient", L"GetAsync", 2))
                {
                    py::set_arg_count_version_error(2);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Foundation::Uri>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Web::Http::HttpCompletionOption>(args, 1);

                return py::convert(self->obj.GetAsync(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* HttpClient_GetBufferAsync(py::wrapper::Windows::Web::Http::HttpClient* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Web.Http.HttpClient", L"GetBufferAsync", 1))
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Foundation::Uri>(args, 0);

                return py::convert(self->obj.GetBufferAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* HttpClient_GetInputStreamAsync(py::wrapper::Windows::Web::Http::HttpClient* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Web.Http.HttpClient", L"GetInputStreamAsync", 1))
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Foundation::Uri>(args, 0);

                return py::convert(self->obj.GetInputStreamAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* HttpClient_GetStringAsync(py::wrapper::Windows::Web::Http::HttpClient* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Web.Http.HttpClient", L"GetStringAsync", 1))
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Foundation::Uri>(args, 0);

                return py::convert(self->obj.GetStringAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* HttpClient_PostAsync(py::wrapper::Windows::Web::Http::HttpClient* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Web.Http.HttpClient", L"PostAsync", 2))
                {
                    py::set_arg_count_version_error(2);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Foundation::Uri>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Web::Http::IHttpContent>(args, 1);

                return py::convert(self->obj.PostAsync(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* HttpClient_PutAsync(py::wrapper::Windows::Web::Http::HttpClient* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Web.Http.HttpClient", L"PutAsync", 2))
                {
                    py::set_arg_count_version_error(2);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Foundation::Uri>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Web::Http::IHttpContent>(args, 1);

                return py::convert(self->obj.PutAsync(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* HttpClient_SendRequestAsync(py::wrapper::Windows::Web::Http::HttpClient* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Web.Http.HttpClient", L"SendRequestAsync", 1))
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Web::Http::HttpRequestMessage>(args, 0);

                return py::convert(self->obj.SendRequestAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 2)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Web.Http.HttpClient", L"SendRequestAsync", 2))
                {
                    py::set_arg_count_version_error(2);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Web::Http::HttpRequestMessage>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Web::Http::HttpCompletionOption>(args, 1);

                return py::convert(self->obj.SendRequestAsync(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* HttpClient_ToString(py::wrapper::Windows::Web::Http::HttpClient* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Web.Http.HttpClient", L"ToString", 0))
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert(self->obj.ToString());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* HttpClient_TryDeleteAsync(py::wrapper::Windows::Web::Http::HttpClient* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Web.Http.HttpClient", L"TryDeleteAsync", 1))
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Foundation::Uri>(args, 0);

                return py::convert(self->obj.TryDeleteAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* HttpClient_TryGetAsync(py::wrapper::Windows::Web::Http::HttpClient* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Web.Http.HttpClient", L"TryGetAsync", 1))
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Foundation::Uri>(args, 0);

                return py::convert(self->obj.TryGetAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 2)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Web.Http.HttpClient", L"TryGetAsync", 2))
                {
                    py::set_arg_count_version_error(2);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Foundation::Uri>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Web::Http::HttpCompletionOption>(args, 1);

                return py::convert(self->obj.TryGetAsync(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* HttpClient_TryGetBufferAsync(py::wrapper::Windows::Web::Http::HttpClient* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Web.Http.HttpClient", L"TryGetBufferAsync", 1))
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Foundation::Uri>(args, 0);

                return py::convert(self->obj.TryGetBufferAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* HttpClient_TryGetInputStreamAsync(py::wrapper::Windows::Web::Http::HttpClient* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Web.Http.HttpClient", L"TryGetInputStreamAsync", 1))
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Foundation::Uri>(args, 0);

                return py::convert(self->obj.TryGetInputStreamAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* HttpClient_TryGetStringAsync(py::wrapper::Windows::Web::Http::HttpClient* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Web.Http.HttpClient", L"TryGetStringAsync", 1))
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Foundation::Uri>(args, 0);

                return py::convert(self->obj.TryGetStringAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* HttpClient_TryPostAsync(py::wrapper::Windows::Web::Http::HttpClient* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Web.Http.HttpClient", L"TryPostAsync", 2))
                {
                    py::set_arg_count_version_error(2);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Foundation::Uri>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Web::Http::IHttpContent>(args, 1);

                return py::convert(self->obj.TryPostAsync(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* HttpClient_TryPutAsync(py::wrapper::Windows::Web::Http::HttpClient* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Web.Http.HttpClient", L"TryPutAsync", 2))
                {
                    py::set_arg_count_version_error(2);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Foundation::Uri>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Web::Http::IHttpContent>(args, 1);

                return py::convert(self->obj.TryPutAsync(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* HttpClient_TrySendRequestAsync(py::wrapper::Windows::Web::Http::HttpClient* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Web.Http.HttpClient", L"TrySendRequestAsync", 1))
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Web::Http::HttpRequestMessage>(args, 0);

                return py::convert(self->obj.TrySendRequestAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 2)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Web.Http.HttpClient", L"TrySendRequestAsync", 2))
                {
                    py::set_arg_count_version_error(2);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Web::Http::HttpRequestMessage>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Web::Http::HttpCompletionOption>(args, 1);

                return py::convert(self->obj.TrySendRequestAsync(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* HttpClient_get_DefaultRequestHeaders(py::wrapper::Windows::Web::Http::HttpClient* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Web.Http.HttpClient", L"DefaultRequestHeaders"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.DefaultRequestHeaders());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* HttpClient_get_DefaultPrivacyAnnotation(py::wrapper::Windows::Web::Http::HttpClient* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Web.Http.HttpClient", L"DefaultPrivacyAnnotation"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.DefaultPrivacyAnnotation());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int HttpClient_put_DefaultPrivacyAnnotation(py::wrapper::Windows::Web::Http::HttpClient* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Web.Http.HttpClient", L"DefaultPrivacyAnnotation"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.DefaultPrivacyAnnotation(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* _assign_array_HttpClient(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Web::Http::HttpClient>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_HttpClient(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Web::Http::HttpClient>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _enter_HttpClient(py::wrapper::Windows::Web::Http::HttpClient* self, PyObject* /*unused*/) noexcept
    {
        return Py_NewRef(self);
    }

    static PyObject* _exit_HttpClient(py::wrapper::Windows::Web::Http::HttpClient* self, PyObject* /*unused*/) noexcept
    {
        try
        {
            self->obj.Close();
            Py_RETURN_FALSE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _str_HttpClient(py::wrapper::Windows::Web::Http::HttpClient* self) noexcept
    {
        try
        {
            return py::convert(self->obj.ToString());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_HttpClient[] = {
        { "close", reinterpret_cast<PyCFunction>(HttpClient_Close), METH_VARARGS, nullptr },
        { "delete_async", reinterpret_cast<PyCFunction>(HttpClient_DeleteAsync), METH_VARARGS, nullptr },
        { "get_async", reinterpret_cast<PyCFunction>(HttpClient_GetAsync), METH_VARARGS, nullptr },
        { "get_buffer_async", reinterpret_cast<PyCFunction>(HttpClient_GetBufferAsync), METH_VARARGS, nullptr },
        { "get_input_stream_async", reinterpret_cast<PyCFunction>(HttpClient_GetInputStreamAsync), METH_VARARGS, nullptr },
        { "get_string_async", reinterpret_cast<PyCFunction>(HttpClient_GetStringAsync), METH_VARARGS, nullptr },
        { "post_async", reinterpret_cast<PyCFunction>(HttpClient_PostAsync), METH_VARARGS, nullptr },
        { "put_async", reinterpret_cast<PyCFunction>(HttpClient_PutAsync), METH_VARARGS, nullptr },
        { "send_request_async", reinterpret_cast<PyCFunction>(HttpClient_SendRequestAsync), METH_VARARGS, nullptr },
        { "to_string", reinterpret_cast<PyCFunction>(HttpClient_ToString), METH_VARARGS, nullptr },
        { "try_delete_async", reinterpret_cast<PyCFunction>(HttpClient_TryDeleteAsync), METH_VARARGS, nullptr },
        { "try_get_async", reinterpret_cast<PyCFunction>(HttpClient_TryGetAsync), METH_VARARGS, nullptr },
        { "try_get_buffer_async", reinterpret_cast<PyCFunction>(HttpClient_TryGetBufferAsync), METH_VARARGS, nullptr },
        { "try_get_input_stream_async", reinterpret_cast<PyCFunction>(HttpClient_TryGetInputStreamAsync), METH_VARARGS, nullptr },
        { "try_get_string_async", reinterpret_cast<PyCFunction>(HttpClient_TryGetStringAsync), METH_VARARGS, nullptr },
        { "try_post_async", reinterpret_cast<PyCFunction>(HttpClient_TryPostAsync), METH_VARARGS, nullptr },
        { "try_put_async", reinterpret_cast<PyCFunction>(HttpClient_TryPutAsync), METH_VARARGS, nullptr },
        { "try_send_request_async", reinterpret_cast<PyCFunction>(HttpClient_TrySendRequestAsync), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_HttpClient, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_HttpClient), METH_O | METH_STATIC, nullptr },
        { "__enter__", reinterpret_cast<PyCFunction>(_enter_HttpClient), METH_NOARGS, nullptr },
        { "__exit__",  reinterpret_cast<PyCFunction>(_exit_HttpClient), METH_VARARGS, nullptr },
        { }
    };

    static PyGetSetDef _getset_HttpClient[] = {
        { "default_request_headers", reinterpret_cast<getter>(HttpClient_get_DefaultRequestHeaders), nullptr, nullptr, nullptr },
        { "default_privacy_annotation", reinterpret_cast<getter>(HttpClient_get_DefaultPrivacyAnnotation), reinterpret_cast<setter>(HttpClient_put_DefaultPrivacyAnnotation), nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_HttpClient[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_HttpClient) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_HttpClient) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_HttpClient) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_HttpClient) },
        { Py_tp_str, reinterpret_cast<void*>(_str_HttpClient) },
        { },
    };

    static PyType_Spec type_spec_HttpClient =
    {
        "winrt._winrt_windows_web_http.HttpClient",
        sizeof(py::wrapper::Windows::Web::Http::HttpClient),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_HttpClient
    };

    // ----- HttpCookie class --------------------

    static PyObject* _new_HttpCookie(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 3)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::hstring>(args, 1);
                auto param2 = py::convert_to<winrt::hstring>(args, 2);

                winrt::Windows::Web::Http::HttpCookie instance{ param0, param1, param2 };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_HttpCookie(py::wrapper::Windows::Web::Http::HttpCookie* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* HttpCookie_ToString(py::wrapper::Windows::Web::Http::HttpCookie* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Web.Http.HttpCookie", L"ToString", 0))
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert(self->obj.ToString());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* HttpCookie_get_Value(py::wrapper::Windows::Web::Http::HttpCookie* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Web.Http.HttpCookie", L"Value"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Value());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int HttpCookie_put_Value(py::wrapper::Windows::Web::Http::HttpCookie* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Web.Http.HttpCookie", L"Value"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.Value(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* HttpCookie_get_Secure(py::wrapper::Windows::Web::Http::HttpCookie* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Web.Http.HttpCookie", L"Secure"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Secure());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int HttpCookie_put_Secure(py::wrapper::Windows::Web::Http::HttpCookie* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Web.Http.HttpCookie", L"Secure"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<bool>(arg);

            self->obj.Secure(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* HttpCookie_get_HttpOnly(py::wrapper::Windows::Web::Http::HttpCookie* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Web.Http.HttpCookie", L"HttpOnly"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.HttpOnly());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int HttpCookie_put_HttpOnly(py::wrapper::Windows::Web::Http::HttpCookie* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Web.Http.HttpCookie", L"HttpOnly"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<bool>(arg);

            self->obj.HttpOnly(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* HttpCookie_get_Expires(py::wrapper::Windows::Web::Http::HttpCookie* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Web.Http.HttpCookie", L"Expires"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Expires());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int HttpCookie_put_Expires(py::wrapper::Windows::Web::Http::HttpCookie* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Web.Http.HttpCookie", L"Expires"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::IReference<winrt::Windows::Foundation::DateTime>>(arg);

            self->obj.Expires(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* HttpCookie_get_Domain(py::wrapper::Windows::Web::Http::HttpCookie* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Web.Http.HttpCookie", L"Domain"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Domain());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* HttpCookie_get_Name(py::wrapper::Windows::Web::Http::HttpCookie* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Web.Http.HttpCookie", L"Name"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Name());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* HttpCookie_get_Path(py::wrapper::Windows::Web::Http::HttpCookie* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Web.Http.HttpCookie", L"Path"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Path());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_HttpCookie(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Web::Http::HttpCookie>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_HttpCookie(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Web::Http::HttpCookie>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _str_HttpCookie(py::wrapper::Windows::Web::Http::HttpCookie* self) noexcept
    {
        try
        {
            return py::convert(self->obj.ToString());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_HttpCookie[] = {
        { "to_string", reinterpret_cast<PyCFunction>(HttpCookie_ToString), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_HttpCookie, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_HttpCookie), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_HttpCookie[] = {
        { "value", reinterpret_cast<getter>(HttpCookie_get_Value), reinterpret_cast<setter>(HttpCookie_put_Value), nullptr, nullptr },
        { "secure", reinterpret_cast<getter>(HttpCookie_get_Secure), reinterpret_cast<setter>(HttpCookie_put_Secure), nullptr, nullptr },
        { "http_only", reinterpret_cast<getter>(HttpCookie_get_HttpOnly), reinterpret_cast<setter>(HttpCookie_put_HttpOnly), nullptr, nullptr },
        { "expires", reinterpret_cast<getter>(HttpCookie_get_Expires), reinterpret_cast<setter>(HttpCookie_put_Expires), nullptr, nullptr },
        { "domain", reinterpret_cast<getter>(HttpCookie_get_Domain), nullptr, nullptr, nullptr },
        { "name", reinterpret_cast<getter>(HttpCookie_get_Name), nullptr, nullptr, nullptr },
        { "path", reinterpret_cast<getter>(HttpCookie_get_Path), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_HttpCookie[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_HttpCookie) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_HttpCookie) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_HttpCookie) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_HttpCookie) },
        { Py_tp_str, reinterpret_cast<void*>(_str_HttpCookie) },
        { },
    };

    static PyType_Spec type_spec_HttpCookie =
    {
        "winrt._winrt_windows_web_http.HttpCookie",
        sizeof(py::wrapper::Windows::Web::Http::HttpCookie),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_HttpCookie
    };

    // ----- HttpCookieCollection class --------------------

    static PyObject* _new_HttpCookieCollection(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Web::Http::HttpCookieCollection>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Web::Http::HttpCookieCollection>::type_name);
        return nullptr;
    }

    static void _dealloc_HttpCookieCollection(py::wrapper::Windows::Web::Http::HttpCookieCollection* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* HttpCookieCollection_First(py::wrapper::Windows::Web::Http::HttpCookieCollection* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Web.Http.HttpCookieCollection", L"First", 0))
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert(self->obj.First());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* HttpCookieCollection_GetAt(py::wrapper::Windows::Web::Http::HttpCookieCollection* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Web.Http.HttpCookieCollection", L"GetAt", 1))
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<uint32_t>(args, 0);

                return py::convert(self->obj.GetAt(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* HttpCookieCollection_GetMany(py::wrapper::Windows::Web::Http::HttpCookieCollection* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Web.Http.HttpCookieCollection", L"GetMany", 1))
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<uint32_t>(args, 0);
                auto param1 = py::convert_to<py::pybuf_view<winrt::Windows::Web::Http::HttpCookie, true>>(args, 1);

                return py::convert(self->obj.GetMany(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* HttpCookieCollection_IndexOf(py::wrapper::Windows::Web::Http::HttpCookieCollection* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Web.Http.HttpCookieCollection", L"IndexOf", 1))
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Web::Http::HttpCookie>(args, 0);
                uint32_t param1 {  };

                auto return_value = self->obj.IndexOf(param0, param1);

                py::pyobj_handle out_return_value{ py::convert(return_value) };
                if (!out_return_value)
                {
                    return nullptr;
                }
                py::pyobj_handle out1{ py::convert(param1) };
                if (!out1)
                {
                    return nullptr;
                }
                return PyTuple_Pack(2, out_return_value.get(), out1.get());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* HttpCookieCollection_get_Size(py::wrapper::Windows::Web::Http::HttpCookieCollection* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Web.Http.HttpCookieCollection", L"Size"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Size());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_HttpCookieCollection(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Web::Http::HttpCookieCollection>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_HttpCookieCollection(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Web::Http::HttpCookieCollection>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _iterator_HttpCookieCollection(py::wrapper::Windows::Web::Http::HttpCookieCollection* self) noexcept
    {
        try
        {
            return py::convert(self->obj.First());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static Py_ssize_t _seq_length_HttpCookieCollection(py::wrapper::Windows::Web::Http::HttpCookieCollection* self) noexcept
    {
        try
        {
            return static_cast<Py_ssize_t>(self->obj.Size());
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* _seq_item_HttpCookieCollection(py::wrapper::Windows::Web::Http::HttpCookieCollection* self, Py_ssize_t i) noexcept
    {
        try
        {
            return py::convert(self->obj.GetAt(static_cast<uint32_t>(i)));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _seq_subscript_HttpCookieCollection(py::wrapper::Windows::Web::Http::HttpCookieCollection* self, PyObject* slice) noexcept
    {
        try
        {
            if (PyIndex_Check(slice))
            {
                pyobj_handle index{PyNumber_Index(slice)};

                if (!index)
                {
                    return nullptr;
                }

                auto i = PyNumber_AsSsize_t(index.get(), PyExc_IndexError);

                if (i == -1 && PyErr_Occurred())
                {
                    return nullptr;
                }

                return _seq_item_HttpCookieCollection(self, i);
            }

            if (!PySlice_Check(slice))
            {
                PyErr_Format(
                    PyExc_TypeError,
                    "indicies must be integers, not '%s'",
                    Py_TYPE(slice)->tp_name);
            }

            Py_ssize_t start, stop, step, length;

            if (PySlice_GetIndicesEx(
                    slice, self->obj.Size(), &start, &stop, &step, &length)
                < 0)
            {
                return nullptr;
            }

            if (step != 1)
            {
                PyErr_SetString(
                    PyExc_NotImplementedError,
                    "slices with step other than 1 are not implemented");
                return nullptr;
            }

            winrt::com_array<winrt::Windows::Web::Http::HttpCookie> items(static_cast<uint32_t>(length), empty_instance<winrt::Windows::Web::Http::HttpCookie>::get());

            auto count = self->obj.GetMany(static_cast<uint32_t>(start), items);

            if (count != static_cast<uint32_t>(length))
            {
                PyErr_Format(
                    PyExc_RuntimeError,
                    "returned count %d did not match requested length %zd",
                    count,
                    length);
                return nullptr;
            }

            return convert(items);
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_HttpCookieCollection[] = {
        { "first", reinterpret_cast<PyCFunction>(HttpCookieCollection_First), METH_VARARGS, nullptr },
        { "get_at", reinterpret_cast<PyCFunction>(HttpCookieCollection_GetAt), METH_VARARGS, nullptr },
        { "get_many", reinterpret_cast<PyCFunction>(HttpCookieCollection_GetMany), METH_VARARGS, nullptr },
        { "index_of", reinterpret_cast<PyCFunction>(HttpCookieCollection_IndexOf), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_HttpCookieCollection, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_HttpCookieCollection), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_HttpCookieCollection[] = {
        { "size", reinterpret_cast<getter>(HttpCookieCollection_get_Size), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_HttpCookieCollection[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_HttpCookieCollection) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_HttpCookieCollection) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_HttpCookieCollection) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_HttpCookieCollection) },
        { Py_tp_iter, reinterpret_cast<void*>(_iterator_HttpCookieCollection) },
        { Py_sq_length, reinterpret_cast<void*>(_seq_length_HttpCookieCollection) },
        { Py_sq_item, reinterpret_cast<void*>(_seq_item_HttpCookieCollection) },
        { Py_mp_subscript, reinterpret_cast<void*>(_seq_subscript_HttpCookieCollection) },
        { },
    };

    static PyType_Spec type_spec_HttpCookieCollection =
    {
        "winrt._winrt_windows_web_http.HttpCookieCollection",
        sizeof(py::wrapper::Windows::Web::Http::HttpCookieCollection),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_HttpCookieCollection
    };

    // ----- HttpCookieManager class --------------------

    static PyObject* _new_HttpCookieManager(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Web::Http::HttpCookieManager>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Web::Http::HttpCookieManager>::type_name);
        return nullptr;
    }

    static void _dealloc_HttpCookieManager(py::wrapper::Windows::Web::Http::HttpCookieManager* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* HttpCookieManager_DeleteCookie(py::wrapper::Windows::Web::Http::HttpCookieManager* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Web.Http.HttpCookieManager", L"DeleteCookie", 1))
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Web::Http::HttpCookie>(args, 0);

                self->obj.DeleteCookie(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* HttpCookieManager_GetCookies(py::wrapper::Windows::Web::Http::HttpCookieManager* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Web.Http.HttpCookieManager", L"GetCookies", 1))
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Foundation::Uri>(args, 0);

                return py::convert(self->obj.GetCookies(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* HttpCookieManager_SetCookie(py::wrapper::Windows::Web::Http::HttpCookieManager* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Web.Http.HttpCookieManager", L"SetCookie", 1))
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Web::Http::HttpCookie>(args, 0);

                return py::convert(self->obj.SetCookie(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 2)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Web.Http.HttpCookieManager", L"SetCookie", 2))
                {
                    py::set_arg_count_version_error(2);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Web::Http::HttpCookie>(args, 0);
                auto param1 = py::convert_to<bool>(args, 1);

                return py::convert(self->obj.SetCookie(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* _assign_array_HttpCookieManager(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Web::Http::HttpCookieManager>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_HttpCookieManager(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Web::Http::HttpCookieManager>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_HttpCookieManager[] = {
        { "delete_cookie", reinterpret_cast<PyCFunction>(HttpCookieManager_DeleteCookie), METH_VARARGS, nullptr },
        { "get_cookies", reinterpret_cast<PyCFunction>(HttpCookieManager_GetCookies), METH_VARARGS, nullptr },
        { "set_cookie", reinterpret_cast<PyCFunction>(HttpCookieManager_SetCookie), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_HttpCookieManager, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_HttpCookieManager), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_HttpCookieManager[] = {
        { }
    };

    static PyType_Slot _type_slots_HttpCookieManager[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_HttpCookieManager) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_HttpCookieManager) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_HttpCookieManager) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_HttpCookieManager) },
        { },
    };

    static PyType_Spec type_spec_HttpCookieManager =
    {
        "winrt._winrt_windows_web_http.HttpCookieManager",
        sizeof(py::wrapper::Windows::Web::Http::HttpCookieManager),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_HttpCookieManager
    };

    // ----- HttpFormUrlEncodedContent class --------------------

    static PyObject* _new_HttpFormUrlEncodedContent(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Foundation::Collections::IIterable<winrt::Windows::Foundation::Collections::IKeyValuePair<winrt::hstring, winrt::hstring>>>(args, 0);

                winrt::Windows::Web::Http::HttpFormUrlEncodedContent instance{ param0 };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_HttpFormUrlEncodedContent(py::wrapper::Windows::Web::Http::HttpFormUrlEncodedContent* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* HttpFormUrlEncodedContent_BufferAllAsync(py::wrapper::Windows::Web::Http::HttpFormUrlEncodedContent* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Web.Http.HttpFormUrlEncodedContent", L"BufferAllAsync", 0))
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert(self->obj.BufferAllAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* HttpFormUrlEncodedContent_Close(py::wrapper::Windows::Web::Http::HttpFormUrlEncodedContent* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Web.Http.HttpFormUrlEncodedContent", L"Close", 0))
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                self->obj.Close();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* HttpFormUrlEncodedContent_ReadAsBufferAsync(py::wrapper::Windows::Web::Http::HttpFormUrlEncodedContent* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Web.Http.HttpFormUrlEncodedContent", L"ReadAsBufferAsync", 0))
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert(self->obj.ReadAsBufferAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* HttpFormUrlEncodedContent_ReadAsInputStreamAsync(py::wrapper::Windows::Web::Http::HttpFormUrlEncodedContent* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Web.Http.HttpFormUrlEncodedContent", L"ReadAsInputStreamAsync", 0))
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert(self->obj.ReadAsInputStreamAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* HttpFormUrlEncodedContent_ReadAsStringAsync(py::wrapper::Windows::Web::Http::HttpFormUrlEncodedContent* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Web.Http.HttpFormUrlEncodedContent", L"ReadAsStringAsync", 0))
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert(self->obj.ReadAsStringAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* HttpFormUrlEncodedContent_ToString(py::wrapper::Windows::Web::Http::HttpFormUrlEncodedContent* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Web.Http.HttpFormUrlEncodedContent", L"ToString", 0))
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert(self->obj.ToString());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* HttpFormUrlEncodedContent_TryComputeLength(py::wrapper::Windows::Web::Http::HttpFormUrlEncodedContent* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Web.Http.HttpFormUrlEncodedContent", L"TryComputeLength", 0))
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                uint64_t param0 {  };

                auto return_value = self->obj.TryComputeLength(param0);

                py::pyobj_handle out_return_value{ py::convert(return_value) };
                if (!out_return_value)
                {
                    return nullptr;
                }
                py::pyobj_handle out0{ py::convert(param0) };
                if (!out0)
                {
                    return nullptr;
                }
                return PyTuple_Pack(2, out_return_value.get(), out0.get());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* HttpFormUrlEncodedContent_WriteToStreamAsync(py::wrapper::Windows::Web::Http::HttpFormUrlEncodedContent* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Web.Http.HttpFormUrlEncodedContent", L"WriteToStreamAsync", 1))
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Storage::Streams::IOutputStream>(args, 0);

                return py::convert(self->obj.WriteToStreamAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* HttpFormUrlEncodedContent_get_Headers(py::wrapper::Windows::Web::Http::HttpFormUrlEncodedContent* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Web.Http.HttpFormUrlEncodedContent", L"Headers"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Headers());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_HttpFormUrlEncodedContent(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Web::Http::HttpFormUrlEncodedContent>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_HttpFormUrlEncodedContent(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Web::Http::HttpFormUrlEncodedContent>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _enter_HttpFormUrlEncodedContent(py::wrapper::Windows::Web::Http::HttpFormUrlEncodedContent* self, PyObject* /*unused*/) noexcept
    {
        return Py_NewRef(self);
    }

    static PyObject* _exit_HttpFormUrlEncodedContent(py::wrapper::Windows::Web::Http::HttpFormUrlEncodedContent* self, PyObject* /*unused*/) noexcept
    {
        try
        {
            self->obj.Close();
            Py_RETURN_FALSE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _str_HttpFormUrlEncodedContent(py::wrapper::Windows::Web::Http::HttpFormUrlEncodedContent* self) noexcept
    {
        try
        {
            return py::convert(self->obj.ToString());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_HttpFormUrlEncodedContent[] = {
        { "buffer_all_async", reinterpret_cast<PyCFunction>(HttpFormUrlEncodedContent_BufferAllAsync), METH_VARARGS, nullptr },
        { "close", reinterpret_cast<PyCFunction>(HttpFormUrlEncodedContent_Close), METH_VARARGS, nullptr },
        { "read_as_buffer_async", reinterpret_cast<PyCFunction>(HttpFormUrlEncodedContent_ReadAsBufferAsync), METH_VARARGS, nullptr },
        { "read_as_input_stream_async", reinterpret_cast<PyCFunction>(HttpFormUrlEncodedContent_ReadAsInputStreamAsync), METH_VARARGS, nullptr },
        { "read_as_string_async", reinterpret_cast<PyCFunction>(HttpFormUrlEncodedContent_ReadAsStringAsync), METH_VARARGS, nullptr },
        { "to_string", reinterpret_cast<PyCFunction>(HttpFormUrlEncodedContent_ToString), METH_VARARGS, nullptr },
        { "try_compute_length", reinterpret_cast<PyCFunction>(HttpFormUrlEncodedContent_TryComputeLength), METH_VARARGS, nullptr },
        { "write_to_stream_async", reinterpret_cast<PyCFunction>(HttpFormUrlEncodedContent_WriteToStreamAsync), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_HttpFormUrlEncodedContent, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_HttpFormUrlEncodedContent), METH_O | METH_STATIC, nullptr },
        { "__enter__", reinterpret_cast<PyCFunction>(_enter_HttpFormUrlEncodedContent), METH_NOARGS, nullptr },
        { "__exit__",  reinterpret_cast<PyCFunction>(_exit_HttpFormUrlEncodedContent), METH_VARARGS, nullptr },
        { }
    };

    static PyGetSetDef _getset_HttpFormUrlEncodedContent[] = {
        { "headers", reinterpret_cast<getter>(HttpFormUrlEncodedContent_get_Headers), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_HttpFormUrlEncodedContent[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_HttpFormUrlEncodedContent) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_HttpFormUrlEncodedContent) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_HttpFormUrlEncodedContent) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_HttpFormUrlEncodedContent) },
        { Py_tp_str, reinterpret_cast<void*>(_str_HttpFormUrlEncodedContent) },
        { },
    };

    static PyType_Spec type_spec_HttpFormUrlEncodedContent =
    {
        "winrt._winrt_windows_web_http.HttpFormUrlEncodedContent",
        sizeof(py::wrapper::Windows::Web::Http::HttpFormUrlEncodedContent),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_HttpFormUrlEncodedContent
    };

    // ----- HttpGetBufferResult class --------------------

    static PyObject* _new_HttpGetBufferResult(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Web::Http::HttpGetBufferResult>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Web::Http::HttpGetBufferResult>::type_name);
        return nullptr;
    }

    static void _dealloc_HttpGetBufferResult(py::wrapper::Windows::Web::Http::HttpGetBufferResult* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* HttpGetBufferResult_Close(py::wrapper::Windows::Web::Http::HttpGetBufferResult* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Web.Http.HttpGetBufferResult", L"Close", 0))
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                self->obj.Close();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* HttpGetBufferResult_ToString(py::wrapper::Windows::Web::Http::HttpGetBufferResult* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Web.Http.HttpGetBufferResult", L"ToString", 0))
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert(self->obj.ToString());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* HttpGetBufferResult_get_ExtendedError(py::wrapper::Windows::Web::Http::HttpGetBufferResult* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Web.Http.HttpGetBufferResult", L"ExtendedError"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.ExtendedError());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* HttpGetBufferResult_get_RequestMessage(py::wrapper::Windows::Web::Http::HttpGetBufferResult* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Web.Http.HttpGetBufferResult", L"RequestMessage"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.RequestMessage());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* HttpGetBufferResult_get_ResponseMessage(py::wrapper::Windows::Web::Http::HttpGetBufferResult* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Web.Http.HttpGetBufferResult", L"ResponseMessage"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.ResponseMessage());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* HttpGetBufferResult_get_Succeeded(py::wrapper::Windows::Web::Http::HttpGetBufferResult* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Web.Http.HttpGetBufferResult", L"Succeeded"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Succeeded());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* HttpGetBufferResult_get_Value(py::wrapper::Windows::Web::Http::HttpGetBufferResult* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Web.Http.HttpGetBufferResult", L"Value"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Value());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_HttpGetBufferResult(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Web::Http::HttpGetBufferResult>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_HttpGetBufferResult(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Web::Http::HttpGetBufferResult>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _enter_HttpGetBufferResult(py::wrapper::Windows::Web::Http::HttpGetBufferResult* self, PyObject* /*unused*/) noexcept
    {
        return Py_NewRef(self);
    }

    static PyObject* _exit_HttpGetBufferResult(py::wrapper::Windows::Web::Http::HttpGetBufferResult* self, PyObject* /*unused*/) noexcept
    {
        try
        {
            self->obj.Close();
            Py_RETURN_FALSE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _str_HttpGetBufferResult(py::wrapper::Windows::Web::Http::HttpGetBufferResult* self) noexcept
    {
        try
        {
            return py::convert(self->obj.ToString());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_HttpGetBufferResult[] = {
        { "close", reinterpret_cast<PyCFunction>(HttpGetBufferResult_Close), METH_VARARGS, nullptr },
        { "to_string", reinterpret_cast<PyCFunction>(HttpGetBufferResult_ToString), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_HttpGetBufferResult, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_HttpGetBufferResult), METH_O | METH_STATIC, nullptr },
        { "__enter__", reinterpret_cast<PyCFunction>(_enter_HttpGetBufferResult), METH_NOARGS, nullptr },
        { "__exit__",  reinterpret_cast<PyCFunction>(_exit_HttpGetBufferResult), METH_VARARGS, nullptr },
        { }
    };

    static PyGetSetDef _getset_HttpGetBufferResult[] = {
        { "extended_error", reinterpret_cast<getter>(HttpGetBufferResult_get_ExtendedError), nullptr, nullptr, nullptr },
        { "request_message", reinterpret_cast<getter>(HttpGetBufferResult_get_RequestMessage), nullptr, nullptr, nullptr },
        { "response_message", reinterpret_cast<getter>(HttpGetBufferResult_get_ResponseMessage), nullptr, nullptr, nullptr },
        { "succeeded", reinterpret_cast<getter>(HttpGetBufferResult_get_Succeeded), nullptr, nullptr, nullptr },
        { "value", reinterpret_cast<getter>(HttpGetBufferResult_get_Value), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_HttpGetBufferResult[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_HttpGetBufferResult) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_HttpGetBufferResult) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_HttpGetBufferResult) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_HttpGetBufferResult) },
        { Py_tp_str, reinterpret_cast<void*>(_str_HttpGetBufferResult) },
        { },
    };

    static PyType_Spec type_spec_HttpGetBufferResult =
    {
        "winrt._winrt_windows_web_http.HttpGetBufferResult",
        sizeof(py::wrapper::Windows::Web::Http::HttpGetBufferResult),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_HttpGetBufferResult
    };

    // ----- HttpGetInputStreamResult class --------------------

    static PyObject* _new_HttpGetInputStreamResult(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Web::Http::HttpGetInputStreamResult>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Web::Http::HttpGetInputStreamResult>::type_name);
        return nullptr;
    }

    static void _dealloc_HttpGetInputStreamResult(py::wrapper::Windows::Web::Http::HttpGetInputStreamResult* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* HttpGetInputStreamResult_Close(py::wrapper::Windows::Web::Http::HttpGetInputStreamResult* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Web.Http.HttpGetInputStreamResult", L"Close", 0))
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                self->obj.Close();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* HttpGetInputStreamResult_ToString(py::wrapper::Windows::Web::Http::HttpGetInputStreamResult* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Web.Http.HttpGetInputStreamResult", L"ToString", 0))
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert(self->obj.ToString());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* HttpGetInputStreamResult_get_ExtendedError(py::wrapper::Windows::Web::Http::HttpGetInputStreamResult* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Web.Http.HttpGetInputStreamResult", L"ExtendedError"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.ExtendedError());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* HttpGetInputStreamResult_get_RequestMessage(py::wrapper::Windows::Web::Http::HttpGetInputStreamResult* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Web.Http.HttpGetInputStreamResult", L"RequestMessage"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.RequestMessage());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* HttpGetInputStreamResult_get_ResponseMessage(py::wrapper::Windows::Web::Http::HttpGetInputStreamResult* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Web.Http.HttpGetInputStreamResult", L"ResponseMessage"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.ResponseMessage());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* HttpGetInputStreamResult_get_Succeeded(py::wrapper::Windows::Web::Http::HttpGetInputStreamResult* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Web.Http.HttpGetInputStreamResult", L"Succeeded"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Succeeded());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* HttpGetInputStreamResult_get_Value(py::wrapper::Windows::Web::Http::HttpGetInputStreamResult* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Web.Http.HttpGetInputStreamResult", L"Value"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Value());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_HttpGetInputStreamResult(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Web::Http::HttpGetInputStreamResult>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_HttpGetInputStreamResult(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Web::Http::HttpGetInputStreamResult>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _enter_HttpGetInputStreamResult(py::wrapper::Windows::Web::Http::HttpGetInputStreamResult* self, PyObject* /*unused*/) noexcept
    {
        return Py_NewRef(self);
    }

    static PyObject* _exit_HttpGetInputStreamResult(py::wrapper::Windows::Web::Http::HttpGetInputStreamResult* self, PyObject* /*unused*/) noexcept
    {
        try
        {
            self->obj.Close();
            Py_RETURN_FALSE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _str_HttpGetInputStreamResult(py::wrapper::Windows::Web::Http::HttpGetInputStreamResult* self) noexcept
    {
        try
        {
            return py::convert(self->obj.ToString());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_HttpGetInputStreamResult[] = {
        { "close", reinterpret_cast<PyCFunction>(HttpGetInputStreamResult_Close), METH_VARARGS, nullptr },
        { "to_string", reinterpret_cast<PyCFunction>(HttpGetInputStreamResult_ToString), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_HttpGetInputStreamResult, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_HttpGetInputStreamResult), METH_O | METH_STATIC, nullptr },
        { "__enter__", reinterpret_cast<PyCFunction>(_enter_HttpGetInputStreamResult), METH_NOARGS, nullptr },
        { "__exit__",  reinterpret_cast<PyCFunction>(_exit_HttpGetInputStreamResult), METH_VARARGS, nullptr },
        { }
    };

    static PyGetSetDef _getset_HttpGetInputStreamResult[] = {
        { "extended_error", reinterpret_cast<getter>(HttpGetInputStreamResult_get_ExtendedError), nullptr, nullptr, nullptr },
        { "request_message", reinterpret_cast<getter>(HttpGetInputStreamResult_get_RequestMessage), nullptr, nullptr, nullptr },
        { "response_message", reinterpret_cast<getter>(HttpGetInputStreamResult_get_ResponseMessage), nullptr, nullptr, nullptr },
        { "succeeded", reinterpret_cast<getter>(HttpGetInputStreamResult_get_Succeeded), nullptr, nullptr, nullptr },
        { "value", reinterpret_cast<getter>(HttpGetInputStreamResult_get_Value), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_HttpGetInputStreamResult[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_HttpGetInputStreamResult) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_HttpGetInputStreamResult) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_HttpGetInputStreamResult) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_HttpGetInputStreamResult) },
        { Py_tp_str, reinterpret_cast<void*>(_str_HttpGetInputStreamResult) },
        { },
    };

    static PyType_Spec type_spec_HttpGetInputStreamResult =
    {
        "winrt._winrt_windows_web_http.HttpGetInputStreamResult",
        sizeof(py::wrapper::Windows::Web::Http::HttpGetInputStreamResult),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_HttpGetInputStreamResult
    };

    // ----- HttpGetStringResult class --------------------

    static PyObject* _new_HttpGetStringResult(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Web::Http::HttpGetStringResult>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Web::Http::HttpGetStringResult>::type_name);
        return nullptr;
    }

    static void _dealloc_HttpGetStringResult(py::wrapper::Windows::Web::Http::HttpGetStringResult* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* HttpGetStringResult_Close(py::wrapper::Windows::Web::Http::HttpGetStringResult* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Web.Http.HttpGetStringResult", L"Close", 0))
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                self->obj.Close();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* HttpGetStringResult_ToString(py::wrapper::Windows::Web::Http::HttpGetStringResult* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Web.Http.HttpGetStringResult", L"ToString", 0))
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert(self->obj.ToString());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* HttpGetStringResult_get_ExtendedError(py::wrapper::Windows::Web::Http::HttpGetStringResult* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Web.Http.HttpGetStringResult", L"ExtendedError"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.ExtendedError());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* HttpGetStringResult_get_RequestMessage(py::wrapper::Windows::Web::Http::HttpGetStringResult* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Web.Http.HttpGetStringResult", L"RequestMessage"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.RequestMessage());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* HttpGetStringResult_get_ResponseMessage(py::wrapper::Windows::Web::Http::HttpGetStringResult* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Web.Http.HttpGetStringResult", L"ResponseMessage"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.ResponseMessage());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* HttpGetStringResult_get_Succeeded(py::wrapper::Windows::Web::Http::HttpGetStringResult* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Web.Http.HttpGetStringResult", L"Succeeded"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Succeeded());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* HttpGetStringResult_get_Value(py::wrapper::Windows::Web::Http::HttpGetStringResult* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Web.Http.HttpGetStringResult", L"Value"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Value());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_HttpGetStringResult(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Web::Http::HttpGetStringResult>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_HttpGetStringResult(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Web::Http::HttpGetStringResult>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _enter_HttpGetStringResult(py::wrapper::Windows::Web::Http::HttpGetStringResult* self, PyObject* /*unused*/) noexcept
    {
        return Py_NewRef(self);
    }

    static PyObject* _exit_HttpGetStringResult(py::wrapper::Windows::Web::Http::HttpGetStringResult* self, PyObject* /*unused*/) noexcept
    {
        try
        {
            self->obj.Close();
            Py_RETURN_FALSE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _str_HttpGetStringResult(py::wrapper::Windows::Web::Http::HttpGetStringResult* self) noexcept
    {
        try
        {
            return py::convert(self->obj.ToString());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_HttpGetStringResult[] = {
        { "close", reinterpret_cast<PyCFunction>(HttpGetStringResult_Close), METH_VARARGS, nullptr },
        { "to_string", reinterpret_cast<PyCFunction>(HttpGetStringResult_ToString), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_HttpGetStringResult, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_HttpGetStringResult), METH_O | METH_STATIC, nullptr },
        { "__enter__", reinterpret_cast<PyCFunction>(_enter_HttpGetStringResult), METH_NOARGS, nullptr },
        { "__exit__",  reinterpret_cast<PyCFunction>(_exit_HttpGetStringResult), METH_VARARGS, nullptr },
        { }
    };

    static PyGetSetDef _getset_HttpGetStringResult[] = {
        { "extended_error", reinterpret_cast<getter>(HttpGetStringResult_get_ExtendedError), nullptr, nullptr, nullptr },
        { "request_message", reinterpret_cast<getter>(HttpGetStringResult_get_RequestMessage), nullptr, nullptr, nullptr },
        { "response_message", reinterpret_cast<getter>(HttpGetStringResult_get_ResponseMessage), nullptr, nullptr, nullptr },
        { "succeeded", reinterpret_cast<getter>(HttpGetStringResult_get_Succeeded), nullptr, nullptr, nullptr },
        { "value", reinterpret_cast<getter>(HttpGetStringResult_get_Value), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_HttpGetStringResult[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_HttpGetStringResult) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_HttpGetStringResult) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_HttpGetStringResult) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_HttpGetStringResult) },
        { Py_tp_str, reinterpret_cast<void*>(_str_HttpGetStringResult) },
        { },
    };

    static PyType_Spec type_spec_HttpGetStringResult =
    {
        "winrt._winrt_windows_web_http.HttpGetStringResult",
        sizeof(py::wrapper::Windows::Web::Http::HttpGetStringResult),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_HttpGetStringResult
    };

    // ----- HttpMethod class --------------------

    static PyObject* _new_HttpMethod(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                winrt::Windows::Web::Http::HttpMethod instance{ param0 };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_HttpMethod(py::wrapper::Windows::Web::Http::HttpMethod* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* HttpMethod_ToString(py::wrapper::Windows::Web::Http::HttpMethod* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Web.Http.HttpMethod", L"ToString", 0))
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert(self->obj.ToString());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* HttpMethod_get_Method(py::wrapper::Windows::Web::Http::HttpMethod* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Web.Http.HttpMethod", L"Method"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Method());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* HttpMethod_get_Delete(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Web.Http.HttpMethod", L"Delete"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::Web::Http::HttpMethod::Delete());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* HttpMethod_get_Get(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Web.Http.HttpMethod", L"Get"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::Web::Http::HttpMethod::Get());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* HttpMethod_get_Head(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Web.Http.HttpMethod", L"Head"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::Web::Http::HttpMethod::Head());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* HttpMethod_get_Options(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Web.Http.HttpMethod", L"Options"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::Web::Http::HttpMethod::Options());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* HttpMethod_get_Patch(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Web.Http.HttpMethod", L"Patch"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::Web::Http::HttpMethod::Patch());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* HttpMethod_get_Post(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Web.Http.HttpMethod", L"Post"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::Web::Http::HttpMethod::Post());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* HttpMethod_get_Put(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Web.Http.HttpMethod", L"Put"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::Web::Http::HttpMethod::Put());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_HttpMethod(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Web::Http::HttpMethod>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_HttpMethod(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Web::Http::HttpMethod>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _str_HttpMethod(py::wrapper::Windows::Web::Http::HttpMethod* self) noexcept
    {
        try
        {
            return py::convert(self->obj.ToString());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_HttpMethod[] = {
        { "to_string", reinterpret_cast<PyCFunction>(HttpMethod_ToString), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_HttpMethod, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_HttpMethod), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_HttpMethod[] = {
        { "method", reinterpret_cast<getter>(HttpMethod_get_Method), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_HttpMethod[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_HttpMethod) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_HttpMethod) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_HttpMethod) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_HttpMethod) },
        { Py_tp_str, reinterpret_cast<void*>(_str_HttpMethod) },
        { },
    };

    static PyType_Spec type_spec_HttpMethod =
    {
        "winrt._winrt_windows_web_http.HttpMethod",
        sizeof(py::wrapper::Windows::Web::Http::HttpMethod),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_HttpMethod
    };

    static PyGetSetDef getset_HttpMethod_Static[] = {
        { "delete", reinterpret_cast<getter>(HttpMethod_get_Delete), nullptr, nullptr, nullptr },
        { "get", reinterpret_cast<getter>(HttpMethod_get_Get), nullptr, nullptr, nullptr },
        { "head", reinterpret_cast<getter>(HttpMethod_get_Head), nullptr, nullptr, nullptr },
        { "options", reinterpret_cast<getter>(HttpMethod_get_Options), nullptr, nullptr, nullptr },
        { "patch", reinterpret_cast<getter>(HttpMethod_get_Patch), nullptr, nullptr, nullptr },
        { "post", reinterpret_cast<getter>(HttpMethod_get_Post), nullptr, nullptr, nullptr },
        { "put", reinterpret_cast<getter>(HttpMethod_get_Put), nullptr, nullptr, nullptr },
        { }
    };

    static PyMethodDef methods_HttpMethod_Static[] = {
        { }
    };

    static PyType_Slot type_slots_HttpMethod_Static[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_HttpMethod_Static) },
        { Py_tp_methods, reinterpret_cast<void*>(methods_HttpMethod_Static) },
        { }
    };

    static PyType_Spec type_spec_HttpMethod_Static =
    {
        "winrt._winrt_windows_web_http.HttpMethod_Static",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT,
        type_slots_HttpMethod_Static
    };

    // ----- HttpMultipartContent class --------------------

    static PyObject* _new_HttpMultipartContent(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                winrt::Windows::Web::Http::HttpMultipartContent instance{ param0 };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::hstring>(args, 1);

                winrt::Windows::Web::Http::HttpMultipartContent instance{ param0, param1 };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 0)
        {
            try
            {
                winrt::Windows::Web::Http::HttpMultipartContent instance{  };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_HttpMultipartContent(py::wrapper::Windows::Web::Http::HttpMultipartContent* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* HttpMultipartContent_Add(py::wrapper::Windows::Web::Http::HttpMultipartContent* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Web.Http.HttpMultipartContent", L"Add", 1))
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Web::Http::IHttpContent>(args, 0);

                self->obj.Add(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* HttpMultipartContent_BufferAllAsync(py::wrapper::Windows::Web::Http::HttpMultipartContent* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Web.Http.HttpMultipartContent", L"BufferAllAsync", 0))
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert(self->obj.BufferAllAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* HttpMultipartContent_Close(py::wrapper::Windows::Web::Http::HttpMultipartContent* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Web.Http.HttpMultipartContent", L"Close", 0))
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                self->obj.Close();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* HttpMultipartContent_First(py::wrapper::Windows::Web::Http::HttpMultipartContent* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Web.Http.HttpMultipartContent", L"First", 0))
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert(self->obj.First());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* HttpMultipartContent_ReadAsBufferAsync(py::wrapper::Windows::Web::Http::HttpMultipartContent* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Web.Http.HttpMultipartContent", L"ReadAsBufferAsync", 0))
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert(self->obj.ReadAsBufferAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* HttpMultipartContent_ReadAsInputStreamAsync(py::wrapper::Windows::Web::Http::HttpMultipartContent* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Web.Http.HttpMultipartContent", L"ReadAsInputStreamAsync", 0))
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert(self->obj.ReadAsInputStreamAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* HttpMultipartContent_ReadAsStringAsync(py::wrapper::Windows::Web::Http::HttpMultipartContent* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Web.Http.HttpMultipartContent", L"ReadAsStringAsync", 0))
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert(self->obj.ReadAsStringAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* HttpMultipartContent_ToString(py::wrapper::Windows::Web::Http::HttpMultipartContent* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Web.Http.HttpMultipartContent", L"ToString", 0))
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert(self->obj.ToString());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* HttpMultipartContent_TryComputeLength(py::wrapper::Windows::Web::Http::HttpMultipartContent* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Web.Http.HttpMultipartContent", L"TryComputeLength", 0))
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                uint64_t param0 {  };

                auto return_value = self->obj.TryComputeLength(param0);

                py::pyobj_handle out_return_value{ py::convert(return_value) };
                if (!out_return_value)
                {
                    return nullptr;
                }
                py::pyobj_handle out0{ py::convert(param0) };
                if (!out0)
                {
                    return nullptr;
                }
                return PyTuple_Pack(2, out_return_value.get(), out0.get());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* HttpMultipartContent_WriteToStreamAsync(py::wrapper::Windows::Web::Http::HttpMultipartContent* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Web.Http.HttpMultipartContent", L"WriteToStreamAsync", 1))
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Storage::Streams::IOutputStream>(args, 0);

                return py::convert(self->obj.WriteToStreamAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* HttpMultipartContent_get_Headers(py::wrapper::Windows::Web::Http::HttpMultipartContent* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Web.Http.HttpMultipartContent", L"Headers"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Headers());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_HttpMultipartContent(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Web::Http::HttpMultipartContent>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_HttpMultipartContent(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Web::Http::HttpMultipartContent>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _enter_HttpMultipartContent(py::wrapper::Windows::Web::Http::HttpMultipartContent* self, PyObject* /*unused*/) noexcept
    {
        return Py_NewRef(self);
    }

    static PyObject* _exit_HttpMultipartContent(py::wrapper::Windows::Web::Http::HttpMultipartContent* self, PyObject* /*unused*/) noexcept
    {
        try
        {
            self->obj.Close();
            Py_RETURN_FALSE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _str_HttpMultipartContent(py::wrapper::Windows::Web::Http::HttpMultipartContent* self) noexcept
    {
        try
        {
            return py::convert(self->obj.ToString());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _iterator_HttpMultipartContent(py::wrapper::Windows::Web::Http::HttpMultipartContent* self) noexcept
    {
        try
        {
            return py::convert(self->obj.First());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_HttpMultipartContent[] = {
        { "add", reinterpret_cast<PyCFunction>(HttpMultipartContent_Add), METH_VARARGS, nullptr },
        { "buffer_all_async", reinterpret_cast<PyCFunction>(HttpMultipartContent_BufferAllAsync), METH_VARARGS, nullptr },
        { "close", reinterpret_cast<PyCFunction>(HttpMultipartContent_Close), METH_VARARGS, nullptr },
        { "first", reinterpret_cast<PyCFunction>(HttpMultipartContent_First), METH_VARARGS, nullptr },
        { "read_as_buffer_async", reinterpret_cast<PyCFunction>(HttpMultipartContent_ReadAsBufferAsync), METH_VARARGS, nullptr },
        { "read_as_input_stream_async", reinterpret_cast<PyCFunction>(HttpMultipartContent_ReadAsInputStreamAsync), METH_VARARGS, nullptr },
        { "read_as_string_async", reinterpret_cast<PyCFunction>(HttpMultipartContent_ReadAsStringAsync), METH_VARARGS, nullptr },
        { "to_string", reinterpret_cast<PyCFunction>(HttpMultipartContent_ToString), METH_VARARGS, nullptr },
        { "try_compute_length", reinterpret_cast<PyCFunction>(HttpMultipartContent_TryComputeLength), METH_VARARGS, nullptr },
        { "write_to_stream_async", reinterpret_cast<PyCFunction>(HttpMultipartContent_WriteToStreamAsync), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_HttpMultipartContent, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_HttpMultipartContent), METH_O | METH_STATIC, nullptr },
        { "__enter__", reinterpret_cast<PyCFunction>(_enter_HttpMultipartContent), METH_NOARGS, nullptr },
        { "__exit__",  reinterpret_cast<PyCFunction>(_exit_HttpMultipartContent), METH_VARARGS, nullptr },
        { }
    };

    static PyGetSetDef _getset_HttpMultipartContent[] = {
        { "headers", reinterpret_cast<getter>(HttpMultipartContent_get_Headers), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_HttpMultipartContent[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_HttpMultipartContent) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_HttpMultipartContent) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_HttpMultipartContent) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_HttpMultipartContent) },
        { Py_tp_str, reinterpret_cast<void*>(_str_HttpMultipartContent) },
        { Py_tp_iter, reinterpret_cast<void*>(_iterator_HttpMultipartContent) },
        { },
    };

    static PyType_Spec type_spec_HttpMultipartContent =
    {
        "winrt._winrt_windows_web_http.HttpMultipartContent",
        sizeof(py::wrapper::Windows::Web::Http::HttpMultipartContent),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_HttpMultipartContent
    };

    // ----- HttpMultipartFormDataContent class --------------------

    static PyObject* _new_HttpMultipartFormDataContent(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                winrt::Windows::Web::Http::HttpMultipartFormDataContent instance{ param0 };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 0)
        {
            try
            {
                winrt::Windows::Web::Http::HttpMultipartFormDataContent instance{  };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_HttpMultipartFormDataContent(py::wrapper::Windows::Web::Http::HttpMultipartFormDataContent* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* HttpMultipartFormDataContent_Add(py::wrapper::Windows::Web::Http::HttpMultipartFormDataContent* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Web.Http.HttpMultipartFormDataContent", L"Add", 1))
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Web::Http::IHttpContent>(args, 0);

                self->obj.Add(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 2)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Web.Http.HttpMultipartFormDataContent", L"Add", 2))
                {
                    py::set_arg_count_version_error(2);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Web::Http::IHttpContent>(args, 0);
                auto param1 = py::convert_to<winrt::hstring>(args, 1);

                self->obj.Add(param0, param1);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 3)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Web.Http.HttpMultipartFormDataContent", L"Add", 3))
                {
                    py::set_arg_count_version_error(3);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Web::Http::IHttpContent>(args, 0);
                auto param1 = py::convert_to<winrt::hstring>(args, 1);
                auto param2 = py::convert_to<winrt::hstring>(args, 2);

                self->obj.Add(param0, param1, param2);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* HttpMultipartFormDataContent_BufferAllAsync(py::wrapper::Windows::Web::Http::HttpMultipartFormDataContent* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Web.Http.HttpMultipartFormDataContent", L"BufferAllAsync", 0))
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert(self->obj.BufferAllAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* HttpMultipartFormDataContent_Close(py::wrapper::Windows::Web::Http::HttpMultipartFormDataContent* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Web.Http.HttpMultipartFormDataContent", L"Close", 0))
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                self->obj.Close();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* HttpMultipartFormDataContent_First(py::wrapper::Windows::Web::Http::HttpMultipartFormDataContent* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Web.Http.HttpMultipartFormDataContent", L"First", 0))
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert(self->obj.First());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* HttpMultipartFormDataContent_ReadAsBufferAsync(py::wrapper::Windows::Web::Http::HttpMultipartFormDataContent* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Web.Http.HttpMultipartFormDataContent", L"ReadAsBufferAsync", 0))
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert(self->obj.ReadAsBufferAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* HttpMultipartFormDataContent_ReadAsInputStreamAsync(py::wrapper::Windows::Web::Http::HttpMultipartFormDataContent* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Web.Http.HttpMultipartFormDataContent", L"ReadAsInputStreamAsync", 0))
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert(self->obj.ReadAsInputStreamAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* HttpMultipartFormDataContent_ReadAsStringAsync(py::wrapper::Windows::Web::Http::HttpMultipartFormDataContent* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Web.Http.HttpMultipartFormDataContent", L"ReadAsStringAsync", 0))
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert(self->obj.ReadAsStringAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* HttpMultipartFormDataContent_ToString(py::wrapper::Windows::Web::Http::HttpMultipartFormDataContent* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Web.Http.HttpMultipartFormDataContent", L"ToString", 0))
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert(self->obj.ToString());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* HttpMultipartFormDataContent_TryComputeLength(py::wrapper::Windows::Web::Http::HttpMultipartFormDataContent* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Web.Http.HttpMultipartFormDataContent", L"TryComputeLength", 0))
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                uint64_t param0 {  };

                auto return_value = self->obj.TryComputeLength(param0);

                py::pyobj_handle out_return_value{ py::convert(return_value) };
                if (!out_return_value)
                {
                    return nullptr;
                }
                py::pyobj_handle out0{ py::convert(param0) };
                if (!out0)
                {
                    return nullptr;
                }
                return PyTuple_Pack(2, out_return_value.get(), out0.get());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* HttpMultipartFormDataContent_WriteToStreamAsync(py::wrapper::Windows::Web::Http::HttpMultipartFormDataContent* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Web.Http.HttpMultipartFormDataContent", L"WriteToStreamAsync", 1))
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Storage::Streams::IOutputStream>(args, 0);

                return py::convert(self->obj.WriteToStreamAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* HttpMultipartFormDataContent_get_Headers(py::wrapper::Windows::Web::Http::HttpMultipartFormDataContent* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Web.Http.HttpMultipartFormDataContent", L"Headers"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Headers());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_HttpMultipartFormDataContent(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Web::Http::HttpMultipartFormDataContent>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_HttpMultipartFormDataContent(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Web::Http::HttpMultipartFormDataContent>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _enter_HttpMultipartFormDataContent(py::wrapper::Windows::Web::Http::HttpMultipartFormDataContent* self, PyObject* /*unused*/) noexcept
    {
        return Py_NewRef(self);
    }

    static PyObject* _exit_HttpMultipartFormDataContent(py::wrapper::Windows::Web::Http::HttpMultipartFormDataContent* self, PyObject* /*unused*/) noexcept
    {
        try
        {
            self->obj.Close();
            Py_RETURN_FALSE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _str_HttpMultipartFormDataContent(py::wrapper::Windows::Web::Http::HttpMultipartFormDataContent* self) noexcept
    {
        try
        {
            return py::convert(self->obj.ToString());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _iterator_HttpMultipartFormDataContent(py::wrapper::Windows::Web::Http::HttpMultipartFormDataContent* self) noexcept
    {
        try
        {
            return py::convert(self->obj.First());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_HttpMultipartFormDataContent[] = {
        { "add", reinterpret_cast<PyCFunction>(HttpMultipartFormDataContent_Add), METH_VARARGS, nullptr },
        { "buffer_all_async", reinterpret_cast<PyCFunction>(HttpMultipartFormDataContent_BufferAllAsync), METH_VARARGS, nullptr },
        { "close", reinterpret_cast<PyCFunction>(HttpMultipartFormDataContent_Close), METH_VARARGS, nullptr },
        { "first", reinterpret_cast<PyCFunction>(HttpMultipartFormDataContent_First), METH_VARARGS, nullptr },
        { "read_as_buffer_async", reinterpret_cast<PyCFunction>(HttpMultipartFormDataContent_ReadAsBufferAsync), METH_VARARGS, nullptr },
        { "read_as_input_stream_async", reinterpret_cast<PyCFunction>(HttpMultipartFormDataContent_ReadAsInputStreamAsync), METH_VARARGS, nullptr },
        { "read_as_string_async", reinterpret_cast<PyCFunction>(HttpMultipartFormDataContent_ReadAsStringAsync), METH_VARARGS, nullptr },
        { "to_string", reinterpret_cast<PyCFunction>(HttpMultipartFormDataContent_ToString), METH_VARARGS, nullptr },
        { "try_compute_length", reinterpret_cast<PyCFunction>(HttpMultipartFormDataContent_TryComputeLength), METH_VARARGS, nullptr },
        { "write_to_stream_async", reinterpret_cast<PyCFunction>(HttpMultipartFormDataContent_WriteToStreamAsync), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_HttpMultipartFormDataContent, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_HttpMultipartFormDataContent), METH_O | METH_STATIC, nullptr },
        { "__enter__", reinterpret_cast<PyCFunction>(_enter_HttpMultipartFormDataContent), METH_NOARGS, nullptr },
        { "__exit__",  reinterpret_cast<PyCFunction>(_exit_HttpMultipartFormDataContent), METH_VARARGS, nullptr },
        { }
    };

    static PyGetSetDef _getset_HttpMultipartFormDataContent[] = {
        { "headers", reinterpret_cast<getter>(HttpMultipartFormDataContent_get_Headers), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_HttpMultipartFormDataContent[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_HttpMultipartFormDataContent) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_HttpMultipartFormDataContent) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_HttpMultipartFormDataContent) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_HttpMultipartFormDataContent) },
        { Py_tp_str, reinterpret_cast<void*>(_str_HttpMultipartFormDataContent) },
        { Py_tp_iter, reinterpret_cast<void*>(_iterator_HttpMultipartFormDataContent) },
        { },
    };

    static PyType_Spec type_spec_HttpMultipartFormDataContent =
    {
        "winrt._winrt_windows_web_http.HttpMultipartFormDataContent",
        sizeof(py::wrapper::Windows::Web::Http::HttpMultipartFormDataContent),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_HttpMultipartFormDataContent
    };

    // ----- HttpRequestMessage class --------------------

    static PyObject* _new_HttpRequestMessage(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Web::Http::HttpMethod>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Foundation::Uri>(args, 1);

                winrt::Windows::Web::Http::HttpRequestMessage instance{ param0, param1 };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 0)
        {
            try
            {
                winrt::Windows::Web::Http::HttpRequestMessage instance{  };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_HttpRequestMessage(py::wrapper::Windows::Web::Http::HttpRequestMessage* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* HttpRequestMessage_Close(py::wrapper::Windows::Web::Http::HttpRequestMessage* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Web.Http.HttpRequestMessage", L"Close", 0))
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                self->obj.Close();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* HttpRequestMessage_ToString(py::wrapper::Windows::Web::Http::HttpRequestMessage* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Web.Http.HttpRequestMessage", L"ToString", 0))
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert(self->obj.ToString());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* HttpRequestMessage_get_RequestUri(py::wrapper::Windows::Web::Http::HttpRequestMessage* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Web.Http.HttpRequestMessage", L"RequestUri"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.RequestUri());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int HttpRequestMessage_put_RequestUri(py::wrapper::Windows::Web::Http::HttpRequestMessage* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Web.Http.HttpRequestMessage", L"RequestUri"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::Uri>(arg);

            self->obj.RequestUri(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* HttpRequestMessage_get_Method(py::wrapper::Windows::Web::Http::HttpRequestMessage* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Web.Http.HttpRequestMessage", L"Method"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Method());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int HttpRequestMessage_put_Method(py::wrapper::Windows::Web::Http::HttpRequestMessage* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Web.Http.HttpRequestMessage", L"Method"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::Web::Http::HttpMethod>(arg);

            self->obj.Method(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* HttpRequestMessage_get_Content(py::wrapper::Windows::Web::Http::HttpRequestMessage* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Web.Http.HttpRequestMessage", L"Content"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Content());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int HttpRequestMessage_put_Content(py::wrapper::Windows::Web::Http::HttpRequestMessage* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Web.Http.HttpRequestMessage", L"Content"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::Web::Http::IHttpContent>(arg);

            self->obj.Content(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* HttpRequestMessage_get_Headers(py::wrapper::Windows::Web::Http::HttpRequestMessage* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Web.Http.HttpRequestMessage", L"Headers"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Headers());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* HttpRequestMessage_get_Properties(py::wrapper::Windows::Web::Http::HttpRequestMessage* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Web.Http.HttpRequestMessage", L"Properties"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Properties());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* HttpRequestMessage_get_TransportInformation(py::wrapper::Windows::Web::Http::HttpRequestMessage* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Web.Http.HttpRequestMessage", L"TransportInformation"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.TransportInformation());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* HttpRequestMessage_get_PrivacyAnnotation(py::wrapper::Windows::Web::Http::HttpRequestMessage* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Web.Http.HttpRequestMessage", L"PrivacyAnnotation"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.PrivacyAnnotation());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int HttpRequestMessage_put_PrivacyAnnotation(py::wrapper::Windows::Web::Http::HttpRequestMessage* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Web.Http.HttpRequestMessage", L"PrivacyAnnotation"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.PrivacyAnnotation(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* _assign_array_HttpRequestMessage(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Web::Http::HttpRequestMessage>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_HttpRequestMessage(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Web::Http::HttpRequestMessage>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _enter_HttpRequestMessage(py::wrapper::Windows::Web::Http::HttpRequestMessage* self, PyObject* /*unused*/) noexcept
    {
        return Py_NewRef(self);
    }

    static PyObject* _exit_HttpRequestMessage(py::wrapper::Windows::Web::Http::HttpRequestMessage* self, PyObject* /*unused*/) noexcept
    {
        try
        {
            self->obj.Close();
            Py_RETURN_FALSE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _str_HttpRequestMessage(py::wrapper::Windows::Web::Http::HttpRequestMessage* self) noexcept
    {
        try
        {
            return py::convert(self->obj.ToString());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_HttpRequestMessage[] = {
        { "close", reinterpret_cast<PyCFunction>(HttpRequestMessage_Close), METH_VARARGS, nullptr },
        { "to_string", reinterpret_cast<PyCFunction>(HttpRequestMessage_ToString), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_HttpRequestMessage, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_HttpRequestMessage), METH_O | METH_STATIC, nullptr },
        { "__enter__", reinterpret_cast<PyCFunction>(_enter_HttpRequestMessage), METH_NOARGS, nullptr },
        { "__exit__",  reinterpret_cast<PyCFunction>(_exit_HttpRequestMessage), METH_VARARGS, nullptr },
        { }
    };

    static PyGetSetDef _getset_HttpRequestMessage[] = {
        { "request_uri", reinterpret_cast<getter>(HttpRequestMessage_get_RequestUri), reinterpret_cast<setter>(HttpRequestMessage_put_RequestUri), nullptr, nullptr },
        { "method", reinterpret_cast<getter>(HttpRequestMessage_get_Method), reinterpret_cast<setter>(HttpRequestMessage_put_Method), nullptr, nullptr },
        { "content", reinterpret_cast<getter>(HttpRequestMessage_get_Content), reinterpret_cast<setter>(HttpRequestMessage_put_Content), nullptr, nullptr },
        { "headers", reinterpret_cast<getter>(HttpRequestMessage_get_Headers), nullptr, nullptr, nullptr },
        { "properties", reinterpret_cast<getter>(HttpRequestMessage_get_Properties), nullptr, nullptr, nullptr },
        { "transport_information", reinterpret_cast<getter>(HttpRequestMessage_get_TransportInformation), nullptr, nullptr, nullptr },
        { "privacy_annotation", reinterpret_cast<getter>(HttpRequestMessage_get_PrivacyAnnotation), reinterpret_cast<setter>(HttpRequestMessage_put_PrivacyAnnotation), nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_HttpRequestMessage[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_HttpRequestMessage) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_HttpRequestMessage) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_HttpRequestMessage) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_HttpRequestMessage) },
        { Py_tp_str, reinterpret_cast<void*>(_str_HttpRequestMessage) },
        { },
    };

    static PyType_Spec type_spec_HttpRequestMessage =
    {
        "winrt._winrt_windows_web_http.HttpRequestMessage",
        sizeof(py::wrapper::Windows::Web::Http::HttpRequestMessage),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_HttpRequestMessage
    };

    // ----- HttpRequestResult class --------------------

    static PyObject* _new_HttpRequestResult(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Web::Http::HttpRequestResult>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Web::Http::HttpRequestResult>::type_name);
        return nullptr;
    }

    static void _dealloc_HttpRequestResult(py::wrapper::Windows::Web::Http::HttpRequestResult* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* HttpRequestResult_Close(py::wrapper::Windows::Web::Http::HttpRequestResult* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Web.Http.HttpRequestResult", L"Close", 0))
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                self->obj.Close();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* HttpRequestResult_ToString(py::wrapper::Windows::Web::Http::HttpRequestResult* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Web.Http.HttpRequestResult", L"ToString", 0))
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert(self->obj.ToString());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* HttpRequestResult_get_ExtendedError(py::wrapper::Windows::Web::Http::HttpRequestResult* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Web.Http.HttpRequestResult", L"ExtendedError"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.ExtendedError());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* HttpRequestResult_get_RequestMessage(py::wrapper::Windows::Web::Http::HttpRequestResult* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Web.Http.HttpRequestResult", L"RequestMessage"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.RequestMessage());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* HttpRequestResult_get_ResponseMessage(py::wrapper::Windows::Web::Http::HttpRequestResult* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Web.Http.HttpRequestResult", L"ResponseMessage"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.ResponseMessage());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* HttpRequestResult_get_Succeeded(py::wrapper::Windows::Web::Http::HttpRequestResult* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Web.Http.HttpRequestResult", L"Succeeded"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Succeeded());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_HttpRequestResult(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Web::Http::HttpRequestResult>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_HttpRequestResult(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Web::Http::HttpRequestResult>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _enter_HttpRequestResult(py::wrapper::Windows::Web::Http::HttpRequestResult* self, PyObject* /*unused*/) noexcept
    {
        return Py_NewRef(self);
    }

    static PyObject* _exit_HttpRequestResult(py::wrapper::Windows::Web::Http::HttpRequestResult* self, PyObject* /*unused*/) noexcept
    {
        try
        {
            self->obj.Close();
            Py_RETURN_FALSE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _str_HttpRequestResult(py::wrapper::Windows::Web::Http::HttpRequestResult* self) noexcept
    {
        try
        {
            return py::convert(self->obj.ToString());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_HttpRequestResult[] = {
        { "close", reinterpret_cast<PyCFunction>(HttpRequestResult_Close), METH_VARARGS, nullptr },
        { "to_string", reinterpret_cast<PyCFunction>(HttpRequestResult_ToString), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_HttpRequestResult, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_HttpRequestResult), METH_O | METH_STATIC, nullptr },
        { "__enter__", reinterpret_cast<PyCFunction>(_enter_HttpRequestResult), METH_NOARGS, nullptr },
        { "__exit__",  reinterpret_cast<PyCFunction>(_exit_HttpRequestResult), METH_VARARGS, nullptr },
        { }
    };

    static PyGetSetDef _getset_HttpRequestResult[] = {
        { "extended_error", reinterpret_cast<getter>(HttpRequestResult_get_ExtendedError), nullptr, nullptr, nullptr },
        { "request_message", reinterpret_cast<getter>(HttpRequestResult_get_RequestMessage), nullptr, nullptr, nullptr },
        { "response_message", reinterpret_cast<getter>(HttpRequestResult_get_ResponseMessage), nullptr, nullptr, nullptr },
        { "succeeded", reinterpret_cast<getter>(HttpRequestResult_get_Succeeded), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_HttpRequestResult[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_HttpRequestResult) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_HttpRequestResult) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_HttpRequestResult) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_HttpRequestResult) },
        { Py_tp_str, reinterpret_cast<void*>(_str_HttpRequestResult) },
        { },
    };

    static PyType_Spec type_spec_HttpRequestResult =
    {
        "winrt._winrt_windows_web_http.HttpRequestResult",
        sizeof(py::wrapper::Windows::Web::Http::HttpRequestResult),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_HttpRequestResult
    };

    // ----- HttpResponseMessage class --------------------

    static PyObject* _new_HttpResponseMessage(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Web::Http::HttpStatusCode>(args, 0);

                winrt::Windows::Web::Http::HttpResponseMessage instance{ param0 };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 0)
        {
            try
            {
                winrt::Windows::Web::Http::HttpResponseMessage instance{  };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_HttpResponseMessage(py::wrapper::Windows::Web::Http::HttpResponseMessage* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* HttpResponseMessage_Close(py::wrapper::Windows::Web::Http::HttpResponseMessage* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Web.Http.HttpResponseMessage", L"Close", 0))
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                self->obj.Close();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* HttpResponseMessage_EnsureSuccessStatusCode(py::wrapper::Windows::Web::Http::HttpResponseMessage* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Web.Http.HttpResponseMessage", L"EnsureSuccessStatusCode", 0))
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert(self->obj.EnsureSuccessStatusCode());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* HttpResponseMessage_ToString(py::wrapper::Windows::Web::Http::HttpResponseMessage* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Web.Http.HttpResponseMessage", L"ToString", 0))
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert(self->obj.ToString());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* HttpResponseMessage_get_Version(py::wrapper::Windows::Web::Http::HttpResponseMessage* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Web.Http.HttpResponseMessage", L"Version"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Version());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int HttpResponseMessage_put_Version(py::wrapper::Windows::Web::Http::HttpResponseMessage* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Web.Http.HttpResponseMessage", L"Version"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::Web::Http::HttpVersion>(arg);

            self->obj.Version(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* HttpResponseMessage_get_StatusCode(py::wrapper::Windows::Web::Http::HttpResponseMessage* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Web.Http.HttpResponseMessage", L"StatusCode"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.StatusCode());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int HttpResponseMessage_put_StatusCode(py::wrapper::Windows::Web::Http::HttpResponseMessage* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Web.Http.HttpResponseMessage", L"StatusCode"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::Web::Http::HttpStatusCode>(arg);

            self->obj.StatusCode(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* HttpResponseMessage_get_Source(py::wrapper::Windows::Web::Http::HttpResponseMessage* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Web.Http.HttpResponseMessage", L"Source"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Source());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int HttpResponseMessage_put_Source(py::wrapper::Windows::Web::Http::HttpResponseMessage* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Web.Http.HttpResponseMessage", L"Source"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::Web::Http::HttpResponseMessageSource>(arg);

            self->obj.Source(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* HttpResponseMessage_get_RequestMessage(py::wrapper::Windows::Web::Http::HttpResponseMessage* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Web.Http.HttpResponseMessage", L"RequestMessage"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.RequestMessage());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int HttpResponseMessage_put_RequestMessage(py::wrapper::Windows::Web::Http::HttpResponseMessage* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Web.Http.HttpResponseMessage", L"RequestMessage"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::Web::Http::HttpRequestMessage>(arg);

            self->obj.RequestMessage(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* HttpResponseMessage_get_ReasonPhrase(py::wrapper::Windows::Web::Http::HttpResponseMessage* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Web.Http.HttpResponseMessage", L"ReasonPhrase"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.ReasonPhrase());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int HttpResponseMessage_put_ReasonPhrase(py::wrapper::Windows::Web::Http::HttpResponseMessage* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Web.Http.HttpResponseMessage", L"ReasonPhrase"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.ReasonPhrase(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* HttpResponseMessage_get_Content(py::wrapper::Windows::Web::Http::HttpResponseMessage* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Web.Http.HttpResponseMessage", L"Content"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Content());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int HttpResponseMessage_put_Content(py::wrapper::Windows::Web::Http::HttpResponseMessage* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Web.Http.HttpResponseMessage", L"Content"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::Web::Http::IHttpContent>(arg);

            self->obj.Content(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* HttpResponseMessage_get_Headers(py::wrapper::Windows::Web::Http::HttpResponseMessage* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Web.Http.HttpResponseMessage", L"Headers"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Headers());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* HttpResponseMessage_get_IsSuccessStatusCode(py::wrapper::Windows::Web::Http::HttpResponseMessage* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Web.Http.HttpResponseMessage", L"IsSuccessStatusCode"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.IsSuccessStatusCode());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_HttpResponseMessage(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Web::Http::HttpResponseMessage>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_HttpResponseMessage(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Web::Http::HttpResponseMessage>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _enter_HttpResponseMessage(py::wrapper::Windows::Web::Http::HttpResponseMessage* self, PyObject* /*unused*/) noexcept
    {
        return Py_NewRef(self);
    }

    static PyObject* _exit_HttpResponseMessage(py::wrapper::Windows::Web::Http::HttpResponseMessage* self, PyObject* /*unused*/) noexcept
    {
        try
        {
            self->obj.Close();
            Py_RETURN_FALSE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _str_HttpResponseMessage(py::wrapper::Windows::Web::Http::HttpResponseMessage* self) noexcept
    {
        try
        {
            return py::convert(self->obj.ToString());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_HttpResponseMessage[] = {
        { "close", reinterpret_cast<PyCFunction>(HttpResponseMessage_Close), METH_VARARGS, nullptr },
        { "ensure_success_status_code", reinterpret_cast<PyCFunction>(HttpResponseMessage_EnsureSuccessStatusCode), METH_VARARGS, nullptr },
        { "to_string", reinterpret_cast<PyCFunction>(HttpResponseMessage_ToString), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_HttpResponseMessage, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_HttpResponseMessage), METH_O | METH_STATIC, nullptr },
        { "__enter__", reinterpret_cast<PyCFunction>(_enter_HttpResponseMessage), METH_NOARGS, nullptr },
        { "__exit__",  reinterpret_cast<PyCFunction>(_exit_HttpResponseMessage), METH_VARARGS, nullptr },
        { }
    };

    static PyGetSetDef _getset_HttpResponseMessage[] = {
        { "version", reinterpret_cast<getter>(HttpResponseMessage_get_Version), reinterpret_cast<setter>(HttpResponseMessage_put_Version), nullptr, nullptr },
        { "status_code", reinterpret_cast<getter>(HttpResponseMessage_get_StatusCode), reinterpret_cast<setter>(HttpResponseMessage_put_StatusCode), nullptr, nullptr },
        { "source", reinterpret_cast<getter>(HttpResponseMessage_get_Source), reinterpret_cast<setter>(HttpResponseMessage_put_Source), nullptr, nullptr },
        { "request_message", reinterpret_cast<getter>(HttpResponseMessage_get_RequestMessage), reinterpret_cast<setter>(HttpResponseMessage_put_RequestMessage), nullptr, nullptr },
        { "reason_phrase", reinterpret_cast<getter>(HttpResponseMessage_get_ReasonPhrase), reinterpret_cast<setter>(HttpResponseMessage_put_ReasonPhrase), nullptr, nullptr },
        { "content", reinterpret_cast<getter>(HttpResponseMessage_get_Content), reinterpret_cast<setter>(HttpResponseMessage_put_Content), nullptr, nullptr },
        { "headers", reinterpret_cast<getter>(HttpResponseMessage_get_Headers), nullptr, nullptr, nullptr },
        { "is_success_status_code", reinterpret_cast<getter>(HttpResponseMessage_get_IsSuccessStatusCode), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_HttpResponseMessage[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_HttpResponseMessage) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_HttpResponseMessage) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_HttpResponseMessage) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_HttpResponseMessage) },
        { Py_tp_str, reinterpret_cast<void*>(_str_HttpResponseMessage) },
        { },
    };

    static PyType_Spec type_spec_HttpResponseMessage =
    {
        "winrt._winrt_windows_web_http.HttpResponseMessage",
        sizeof(py::wrapper::Windows::Web::Http::HttpResponseMessage),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_HttpResponseMessage
    };

    // ----- HttpStreamContent class --------------------

    static PyObject* _new_HttpStreamContent(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Storage::Streams::IInputStream>(args, 0);

                winrt::Windows::Web::Http::HttpStreamContent instance{ param0 };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_HttpStreamContent(py::wrapper::Windows::Web::Http::HttpStreamContent* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* HttpStreamContent_BufferAllAsync(py::wrapper::Windows::Web::Http::HttpStreamContent* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Web.Http.HttpStreamContent", L"BufferAllAsync", 0))
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert(self->obj.BufferAllAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* HttpStreamContent_Close(py::wrapper::Windows::Web::Http::HttpStreamContent* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Web.Http.HttpStreamContent", L"Close", 0))
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                self->obj.Close();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* HttpStreamContent_ReadAsBufferAsync(py::wrapper::Windows::Web::Http::HttpStreamContent* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Web.Http.HttpStreamContent", L"ReadAsBufferAsync", 0))
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert(self->obj.ReadAsBufferAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* HttpStreamContent_ReadAsInputStreamAsync(py::wrapper::Windows::Web::Http::HttpStreamContent* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Web.Http.HttpStreamContent", L"ReadAsInputStreamAsync", 0))
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert(self->obj.ReadAsInputStreamAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* HttpStreamContent_ReadAsStringAsync(py::wrapper::Windows::Web::Http::HttpStreamContent* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Web.Http.HttpStreamContent", L"ReadAsStringAsync", 0))
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert(self->obj.ReadAsStringAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* HttpStreamContent_ToString(py::wrapper::Windows::Web::Http::HttpStreamContent* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Web.Http.HttpStreamContent", L"ToString", 0))
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert(self->obj.ToString());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* HttpStreamContent_TryComputeLength(py::wrapper::Windows::Web::Http::HttpStreamContent* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Web.Http.HttpStreamContent", L"TryComputeLength", 0))
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                uint64_t param0 {  };

                auto return_value = self->obj.TryComputeLength(param0);

                py::pyobj_handle out_return_value{ py::convert(return_value) };
                if (!out_return_value)
                {
                    return nullptr;
                }
                py::pyobj_handle out0{ py::convert(param0) };
                if (!out0)
                {
                    return nullptr;
                }
                return PyTuple_Pack(2, out_return_value.get(), out0.get());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* HttpStreamContent_WriteToStreamAsync(py::wrapper::Windows::Web::Http::HttpStreamContent* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Web.Http.HttpStreamContent", L"WriteToStreamAsync", 1))
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Storage::Streams::IOutputStream>(args, 0);

                return py::convert(self->obj.WriteToStreamAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* HttpStreamContent_get_Headers(py::wrapper::Windows::Web::Http::HttpStreamContent* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Web.Http.HttpStreamContent", L"Headers"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Headers());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_HttpStreamContent(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Web::Http::HttpStreamContent>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_HttpStreamContent(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Web::Http::HttpStreamContent>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _enter_HttpStreamContent(py::wrapper::Windows::Web::Http::HttpStreamContent* self, PyObject* /*unused*/) noexcept
    {
        return Py_NewRef(self);
    }

    static PyObject* _exit_HttpStreamContent(py::wrapper::Windows::Web::Http::HttpStreamContent* self, PyObject* /*unused*/) noexcept
    {
        try
        {
            self->obj.Close();
            Py_RETURN_FALSE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _str_HttpStreamContent(py::wrapper::Windows::Web::Http::HttpStreamContent* self) noexcept
    {
        try
        {
            return py::convert(self->obj.ToString());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_HttpStreamContent[] = {
        { "buffer_all_async", reinterpret_cast<PyCFunction>(HttpStreamContent_BufferAllAsync), METH_VARARGS, nullptr },
        { "close", reinterpret_cast<PyCFunction>(HttpStreamContent_Close), METH_VARARGS, nullptr },
        { "read_as_buffer_async", reinterpret_cast<PyCFunction>(HttpStreamContent_ReadAsBufferAsync), METH_VARARGS, nullptr },
        { "read_as_input_stream_async", reinterpret_cast<PyCFunction>(HttpStreamContent_ReadAsInputStreamAsync), METH_VARARGS, nullptr },
        { "read_as_string_async", reinterpret_cast<PyCFunction>(HttpStreamContent_ReadAsStringAsync), METH_VARARGS, nullptr },
        { "to_string", reinterpret_cast<PyCFunction>(HttpStreamContent_ToString), METH_VARARGS, nullptr },
        { "try_compute_length", reinterpret_cast<PyCFunction>(HttpStreamContent_TryComputeLength), METH_VARARGS, nullptr },
        { "write_to_stream_async", reinterpret_cast<PyCFunction>(HttpStreamContent_WriteToStreamAsync), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_HttpStreamContent, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_HttpStreamContent), METH_O | METH_STATIC, nullptr },
        { "__enter__", reinterpret_cast<PyCFunction>(_enter_HttpStreamContent), METH_NOARGS, nullptr },
        { "__exit__",  reinterpret_cast<PyCFunction>(_exit_HttpStreamContent), METH_VARARGS, nullptr },
        { }
    };

    static PyGetSetDef _getset_HttpStreamContent[] = {
        { "headers", reinterpret_cast<getter>(HttpStreamContent_get_Headers), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_HttpStreamContent[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_HttpStreamContent) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_HttpStreamContent) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_HttpStreamContent) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_HttpStreamContent) },
        { Py_tp_str, reinterpret_cast<void*>(_str_HttpStreamContent) },
        { },
    };

    static PyType_Spec type_spec_HttpStreamContent =
    {
        "winrt._winrt_windows_web_http.HttpStreamContent",
        sizeof(py::wrapper::Windows::Web::Http::HttpStreamContent),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_HttpStreamContent
    };

    // ----- HttpStringContent class --------------------

    static PyObject* _new_HttpStringContent(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                winrt::Windows::Web::Http::HttpStringContent instance{ param0 };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Storage::Streams::UnicodeEncoding>(args, 1);

                winrt::Windows::Web::Http::HttpStringContent instance{ param0, param1 };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 3)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Storage::Streams::UnicodeEncoding>(args, 1);
                auto param2 = py::convert_to<winrt::hstring>(args, 2);

                winrt::Windows::Web::Http::HttpStringContent instance{ param0, param1, param2 };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_HttpStringContent(py::wrapper::Windows::Web::Http::HttpStringContent* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* HttpStringContent_BufferAllAsync(py::wrapper::Windows::Web::Http::HttpStringContent* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Web.Http.HttpStringContent", L"BufferAllAsync", 0))
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert(self->obj.BufferAllAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* HttpStringContent_Close(py::wrapper::Windows::Web::Http::HttpStringContent* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Web.Http.HttpStringContent", L"Close", 0))
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                self->obj.Close();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* HttpStringContent_ReadAsBufferAsync(py::wrapper::Windows::Web::Http::HttpStringContent* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Web.Http.HttpStringContent", L"ReadAsBufferAsync", 0))
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert(self->obj.ReadAsBufferAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* HttpStringContent_ReadAsInputStreamAsync(py::wrapper::Windows::Web::Http::HttpStringContent* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Web.Http.HttpStringContent", L"ReadAsInputStreamAsync", 0))
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert(self->obj.ReadAsInputStreamAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* HttpStringContent_ReadAsStringAsync(py::wrapper::Windows::Web::Http::HttpStringContent* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Web.Http.HttpStringContent", L"ReadAsStringAsync", 0))
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert(self->obj.ReadAsStringAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* HttpStringContent_ToString(py::wrapper::Windows::Web::Http::HttpStringContent* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Web.Http.HttpStringContent", L"ToString", 0))
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert(self->obj.ToString());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* HttpStringContent_TryComputeLength(py::wrapper::Windows::Web::Http::HttpStringContent* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Web.Http.HttpStringContent", L"TryComputeLength", 0))
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                uint64_t param0 {  };

                auto return_value = self->obj.TryComputeLength(param0);

                py::pyobj_handle out_return_value{ py::convert(return_value) };
                if (!out_return_value)
                {
                    return nullptr;
                }
                py::pyobj_handle out0{ py::convert(param0) };
                if (!out0)
                {
                    return nullptr;
                }
                return PyTuple_Pack(2, out_return_value.get(), out0.get());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* HttpStringContent_WriteToStreamAsync(py::wrapper::Windows::Web::Http::HttpStringContent* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Web.Http.HttpStringContent", L"WriteToStreamAsync", 1))
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Storage::Streams::IOutputStream>(args, 0);

                return py::convert(self->obj.WriteToStreamAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* HttpStringContent_get_Headers(py::wrapper::Windows::Web::Http::HttpStringContent* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Web.Http.HttpStringContent", L"Headers"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Headers());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_HttpStringContent(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Web::Http::HttpStringContent>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_HttpStringContent(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Web::Http::HttpStringContent>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _enter_HttpStringContent(py::wrapper::Windows::Web::Http::HttpStringContent* self, PyObject* /*unused*/) noexcept
    {
        return Py_NewRef(self);
    }

    static PyObject* _exit_HttpStringContent(py::wrapper::Windows::Web::Http::HttpStringContent* self, PyObject* /*unused*/) noexcept
    {
        try
        {
            self->obj.Close();
            Py_RETURN_FALSE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _str_HttpStringContent(py::wrapper::Windows::Web::Http::HttpStringContent* self) noexcept
    {
        try
        {
            return py::convert(self->obj.ToString());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_HttpStringContent[] = {
        { "buffer_all_async", reinterpret_cast<PyCFunction>(HttpStringContent_BufferAllAsync), METH_VARARGS, nullptr },
        { "close", reinterpret_cast<PyCFunction>(HttpStringContent_Close), METH_VARARGS, nullptr },
        { "read_as_buffer_async", reinterpret_cast<PyCFunction>(HttpStringContent_ReadAsBufferAsync), METH_VARARGS, nullptr },
        { "read_as_input_stream_async", reinterpret_cast<PyCFunction>(HttpStringContent_ReadAsInputStreamAsync), METH_VARARGS, nullptr },
        { "read_as_string_async", reinterpret_cast<PyCFunction>(HttpStringContent_ReadAsStringAsync), METH_VARARGS, nullptr },
        { "to_string", reinterpret_cast<PyCFunction>(HttpStringContent_ToString), METH_VARARGS, nullptr },
        { "try_compute_length", reinterpret_cast<PyCFunction>(HttpStringContent_TryComputeLength), METH_VARARGS, nullptr },
        { "write_to_stream_async", reinterpret_cast<PyCFunction>(HttpStringContent_WriteToStreamAsync), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_HttpStringContent, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_HttpStringContent), METH_O | METH_STATIC, nullptr },
        { "__enter__", reinterpret_cast<PyCFunction>(_enter_HttpStringContent), METH_NOARGS, nullptr },
        { "__exit__",  reinterpret_cast<PyCFunction>(_exit_HttpStringContent), METH_VARARGS, nullptr },
        { }
    };

    static PyGetSetDef _getset_HttpStringContent[] = {
        { "headers", reinterpret_cast<getter>(HttpStringContent_get_Headers), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_HttpStringContent[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_HttpStringContent) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_HttpStringContent) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_HttpStringContent) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_HttpStringContent) },
        { Py_tp_str, reinterpret_cast<void*>(_str_HttpStringContent) },
        { },
    };

    static PyType_Spec type_spec_HttpStringContent =
    {
        "winrt._winrt_windows_web_http.HttpStringContent",
        sizeof(py::wrapper::Windows::Web::Http::HttpStringContent),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_HttpStringContent
    };

    // ----- HttpTransportInformation class --------------------

    static PyObject* _new_HttpTransportInformation(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Web::Http::HttpTransportInformation>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Web::Http::HttpTransportInformation>::type_name);
        return nullptr;
    }

    static void _dealloc_HttpTransportInformation(py::wrapper::Windows::Web::Http::HttpTransportInformation* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* HttpTransportInformation_ToString(py::wrapper::Windows::Web::Http::HttpTransportInformation* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Web.Http.HttpTransportInformation", L"ToString", 0))
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert(self->obj.ToString());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* HttpTransportInformation_get_ServerCertificate(py::wrapper::Windows::Web::Http::HttpTransportInformation* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Web.Http.HttpTransportInformation", L"ServerCertificate"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.ServerCertificate());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* HttpTransportInformation_get_ServerCertificateErrorSeverity(py::wrapper::Windows::Web::Http::HttpTransportInformation* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Web.Http.HttpTransportInformation", L"ServerCertificateErrorSeverity"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.ServerCertificateErrorSeverity());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* HttpTransportInformation_get_ServerCertificateErrors(py::wrapper::Windows::Web::Http::HttpTransportInformation* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Web.Http.HttpTransportInformation", L"ServerCertificateErrors"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.ServerCertificateErrors());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* HttpTransportInformation_get_ServerIntermediateCertificates(py::wrapper::Windows::Web::Http::HttpTransportInformation* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Web.Http.HttpTransportInformation", L"ServerIntermediateCertificates"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.ServerIntermediateCertificates());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_HttpTransportInformation(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Web::Http::HttpTransportInformation>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_HttpTransportInformation(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Web::Http::HttpTransportInformation>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _str_HttpTransportInformation(py::wrapper::Windows::Web::Http::HttpTransportInformation* self) noexcept
    {
        try
        {
            return py::convert(self->obj.ToString());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_HttpTransportInformation[] = {
        { "to_string", reinterpret_cast<PyCFunction>(HttpTransportInformation_ToString), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_HttpTransportInformation, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_HttpTransportInformation), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_HttpTransportInformation[] = {
        { "server_certificate", reinterpret_cast<getter>(HttpTransportInformation_get_ServerCertificate), nullptr, nullptr, nullptr },
        { "server_certificate_error_severity", reinterpret_cast<getter>(HttpTransportInformation_get_ServerCertificateErrorSeverity), nullptr, nullptr, nullptr },
        { "server_certificate_errors", reinterpret_cast<getter>(HttpTransportInformation_get_ServerCertificateErrors), nullptr, nullptr, nullptr },
        { "server_intermediate_certificates", reinterpret_cast<getter>(HttpTransportInformation_get_ServerIntermediateCertificates), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_HttpTransportInformation[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_HttpTransportInformation) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_HttpTransportInformation) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_HttpTransportInformation) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_HttpTransportInformation) },
        { Py_tp_str, reinterpret_cast<void*>(_str_HttpTransportInformation) },
        { },
    };

    static PyType_Spec type_spec_HttpTransportInformation =
    {
        "winrt._winrt_windows_web_http.HttpTransportInformation",
        sizeof(py::wrapper::Windows::Web::Http::HttpTransportInformation),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_HttpTransportInformation
    };

    // ----- IHttpContent interface --------------------

    static PyObject* _new_IHttpContent(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Web::Http::IHttpContent>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Web::Http::IHttpContent>::type_name);
        return nullptr;
    }

    static void _dealloc_IHttpContent(py::wrapper::Windows::Web::Http::IHttpContent* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* IHttpContent_BufferAllAsync(py::wrapper::Windows::Web::Http::IHttpContent* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Web.Http.IHttpContent", L"BufferAllAsync", 0))
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert(self->obj.BufferAllAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* IHttpContent_Close(py::wrapper::Windows::Web::Http::IHttpContent* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Foundation.IClosable", L"Close", 0))
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                self->obj.Close();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* IHttpContent_ReadAsBufferAsync(py::wrapper::Windows::Web::Http::IHttpContent* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Web.Http.IHttpContent", L"ReadAsBufferAsync", 0))
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert(self->obj.ReadAsBufferAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* IHttpContent_ReadAsInputStreamAsync(py::wrapper::Windows::Web::Http::IHttpContent* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Web.Http.IHttpContent", L"ReadAsInputStreamAsync", 0))
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert(self->obj.ReadAsInputStreamAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* IHttpContent_ReadAsStringAsync(py::wrapper::Windows::Web::Http::IHttpContent* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Web.Http.IHttpContent", L"ReadAsStringAsync", 0))
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert(self->obj.ReadAsStringAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* IHttpContent_TryComputeLength(py::wrapper::Windows::Web::Http::IHttpContent* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Web.Http.IHttpContent", L"TryComputeLength", 0))
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                uint64_t param0 {  };

                auto return_value = self->obj.TryComputeLength(param0);

                py::pyobj_handle out_return_value{ py::convert(return_value) };
                if (!out_return_value)
                {
                    return nullptr;
                }
                py::pyobj_handle out0{ py::convert(param0) };
                if (!out0)
                {
                    return nullptr;
                }
                return PyTuple_Pack(2, out_return_value.get(), out0.get());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* IHttpContent_WriteToStreamAsync(py::wrapper::Windows::Web::Http::IHttpContent* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Web.Http.IHttpContent", L"WriteToStreamAsync", 1))
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Storage::Streams::IOutputStream>(args, 0);

                return py::convert(self->obj.WriteToStreamAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* IHttpContent_get_Headers(py::wrapper::Windows::Web::Http::IHttpContent* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Web.Http.IHttpContent", L"Headers"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Headers());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_IHttpContent(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Web::Http::IHttpContent>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_IHttpContent(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Web::Http::IHttpContent>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _enter_IHttpContent(py::wrapper::Windows::Web::Http::IHttpContent* self, PyObject* /*unused*/) noexcept
    {
        return Py_NewRef(self);
    }

    static PyObject* _exit_IHttpContent(py::wrapper::Windows::Web::Http::IHttpContent* self, PyObject* /*unused*/) noexcept
    {
        try
        {
            self->obj.Close();
            Py_RETURN_FALSE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_IHttpContent[] = {
        { "buffer_all_async", reinterpret_cast<PyCFunction>(IHttpContent_BufferAllAsync), METH_VARARGS, nullptr },
        { "close", reinterpret_cast<PyCFunction>(IHttpContent_Close), METH_VARARGS, nullptr },
        { "read_as_buffer_async", reinterpret_cast<PyCFunction>(IHttpContent_ReadAsBufferAsync), METH_VARARGS, nullptr },
        { "read_as_input_stream_async", reinterpret_cast<PyCFunction>(IHttpContent_ReadAsInputStreamAsync), METH_VARARGS, nullptr },
        { "read_as_string_async", reinterpret_cast<PyCFunction>(IHttpContent_ReadAsStringAsync), METH_VARARGS, nullptr },
        { "try_compute_length", reinterpret_cast<PyCFunction>(IHttpContent_TryComputeLength), METH_VARARGS, nullptr },
        { "write_to_stream_async", reinterpret_cast<PyCFunction>(IHttpContent_WriteToStreamAsync), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_IHttpContent, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_IHttpContent), METH_O | METH_STATIC, nullptr },
        { "__enter__", reinterpret_cast<PyCFunction>(_enter_IHttpContent), METH_NOARGS, nullptr },
        { "__exit__",  reinterpret_cast<PyCFunction>(_exit_IHttpContent), METH_VARARGS, nullptr },
        { }
    };

    static PyGetSetDef _getset_IHttpContent[] = {
        { "headers", reinterpret_cast<getter>(IHttpContent_get_Headers), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_IHttpContent[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_IHttpContent) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_IHttpContent) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_IHttpContent) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_IHttpContent) },
        { },
    };

    static PyType_Spec type_spec_IHttpContent =
    {
        "winrt._winrt_windows_web_http.IHttpContent",
        sizeof(py::wrapper::Windows::Web::Http::IHttpContent),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_IHttpContent
    };

    // ----- HttpProgress struct --------------------

    winrt_struct_wrapper<winrt::Windows::Web::Http::HttpProgress>* _new_HttpProgress(PyTypeObject* subclass, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        auto self = reinterpret_cast<winrt_struct_wrapper<winrt::Windows::Web::Http::HttpProgress>*>(subclass->tp_alloc(subclass, 0));

        if (!self)
        {
            return nullptr;
        }

        std::construct_at(&self->obj);

        return self;
    }

    int _init_HttpProgress(winrt_struct_wrapper<winrt::Windows::Web::Http::HttpProgress>* self, PyObject* args, PyObject* kwds) noexcept
    {
        auto tuple_size = PyTuple_Size(args);

        if ((tuple_size == 0) && (kwds == nullptr))
        {
            self->obj = {};
            return 0;
        }

        int32_t _Stage{};
        uint64_t _BytesSent{};
        uint64_t _TotalBytesToSend{};
        uint64_t _BytesReceived{};
        uint64_t _TotalBytesToReceive{};
        uint32_t _Retries{};

        static const char* kwlist[] = {"stage", "bytes_sent", "total_bytes_to_send", "bytes_received", "total_bytes_to_receive", "retries", nullptr};
        if (!PyArg_ParseTupleAndKeywords(args, kwds, "iKKKKI", const_cast<char**>(kwlist), &_Stage, &_BytesSent, &_TotalBytesToSend, &_BytesReceived, &_TotalBytesToReceive, &_Retries))
        {
            return -1;
        }

        try
        {
            self->obj = {static_cast<winrt::Windows::Web::Http::HttpProgressStage>(_Stage), _BytesSent, _TotalBytesToSend, _BytesReceived, _TotalBytesToReceive, _Retries};
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static void _dealloc_HttpProgress(py::wrapper::Windows::Web::Http::HttpProgress* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* _assign_array_HttpProgress(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Web::Http::HttpProgress>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyMethodDef _methods_HttpProgress[] = {
        { "_assign_array_", _assign_array_HttpProgress, METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyObject* HttpProgress_get_Stage(py::wrapper::Windows::Web::Http::HttpProgress* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Stage);
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int HttpProgress_set_Stage(py::wrapper::Windows::Web::Http::HttpProgress* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            self->obj.Stage = py::converter<winrt::Windows::Web::Http::HttpProgressStage>::convert_to(arg);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* HttpProgress_get_BytesSent(py::wrapper::Windows::Web::Http::HttpProgress* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.BytesSent);
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int HttpProgress_set_BytesSent(py::wrapper::Windows::Web::Http::HttpProgress* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            self->obj.BytesSent = py::converter<uint64_t>::convert_to(arg);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* HttpProgress_get_TotalBytesToSend(py::wrapper::Windows::Web::Http::HttpProgress* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.TotalBytesToSend);
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int HttpProgress_set_TotalBytesToSend(py::wrapper::Windows::Web::Http::HttpProgress* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            self->obj.TotalBytesToSend = py::converter<winrt::Windows::Foundation::IReference<uint64_t>>::convert_to(arg);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* HttpProgress_get_BytesReceived(py::wrapper::Windows::Web::Http::HttpProgress* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.BytesReceived);
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int HttpProgress_set_BytesReceived(py::wrapper::Windows::Web::Http::HttpProgress* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            self->obj.BytesReceived = py::converter<uint64_t>::convert_to(arg);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* HttpProgress_get_TotalBytesToReceive(py::wrapper::Windows::Web::Http::HttpProgress* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.TotalBytesToReceive);
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int HttpProgress_set_TotalBytesToReceive(py::wrapper::Windows::Web::Http::HttpProgress* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            self->obj.TotalBytesToReceive = py::converter<winrt::Windows::Foundation::IReference<uint64_t>>::convert_to(arg);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* HttpProgress_get_Retries(py::wrapper::Windows::Web::Http::HttpProgress* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Retries);
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int HttpProgress_set_Retries(py::wrapper::Windows::Web::Http::HttpProgress* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            self->obj.Retries = py::converter<uint32_t>::convert_to(arg);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyGetSetDef _getset_HttpProgress[] = {
        { "stage", reinterpret_cast<getter>(HttpProgress_get_Stage), reinterpret_cast<setter>(HttpProgress_set_Stage), nullptr, nullptr },
        { "bytes_sent", reinterpret_cast<getter>(HttpProgress_get_BytesSent), reinterpret_cast<setter>(HttpProgress_set_BytesSent), nullptr, nullptr },
        { "total_bytes_to_send", reinterpret_cast<getter>(HttpProgress_get_TotalBytesToSend), reinterpret_cast<setter>(HttpProgress_set_TotalBytesToSend), nullptr, nullptr },
        { "bytes_received", reinterpret_cast<getter>(HttpProgress_get_BytesReceived), reinterpret_cast<setter>(HttpProgress_set_BytesReceived), nullptr, nullptr },
        { "total_bytes_to_receive", reinterpret_cast<getter>(HttpProgress_get_TotalBytesToReceive), reinterpret_cast<setter>(HttpProgress_set_TotalBytesToReceive), nullptr, nullptr },
        { "retries", reinterpret_cast<getter>(HttpProgress_get_Retries), reinterpret_cast<setter>(HttpProgress_set_Retries), nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_HttpProgress[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_HttpProgress) },
        { Py_tp_init, reinterpret_cast<void*>(_init_HttpProgress) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_HttpProgress) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_HttpProgress) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_HttpProgress) },
        { },
    };

    static PyType_Spec type_spec_HttpProgress =
    {
        "winrt._winrt_windows_web_http.HttpProgress",
        sizeof(py::wrapper::Windows::Web::Http::HttpProgress),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_HttpProgress
    };

    // ----- Windows.Web.Http Initialization --------------------
    PyDoc_STRVAR(module_doc, "Windows::Web::Http");


    static PyModuleDef module_def
        = {PyModuleDef_HEAD_INIT,
           "_winrt_windows_web_http",
           module_doc,
           0,
           nullptr,
           nullptr,
           nullptr,
           nullptr,
           nullptr};

} // py::cpp::Windows::Web::Http

PyMODINIT_FUNC PyInit__winrt_windows_web_http(void) noexcept
{
    using namespace py::cpp::Windows::Web::Http;

    if (py::import_winrt_runtime() == -1)
    {
        return nullptr;
    }

    py::pyobj_handle module{PyModule_Create(&module_def)};

    if (!module)
    {
        return nullptr;
    }

    auto object_type = py::get_object_type();
    if (!object_type)
    {
        return nullptr;
    }

    py::pyobj_handle object_bases{PyTuple_Pack(1, object_type)};

    if (!object_bases)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_HttpBufferContent, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_HttpClient, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_HttpCookie, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_HttpCookieCollection, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_HttpCookieManager, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_HttpFormUrlEncodedContent, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_HttpGetBufferResult, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_HttpGetInputStreamResult, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_HttpGetStringResult, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    py::pyobj_handle type_HttpMethod_Static{PyType_FromSpec(&type_spec_HttpMethod_Static)};
    if (!type_HttpMethod_Static)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_HttpMethod, object_bases.get(), reinterpret_cast<PyTypeObject*>(type_HttpMethod_Static.get())) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_HttpMultipartContent, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_HttpMultipartFormDataContent, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_HttpRequestMessage, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_HttpRequestResult, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_HttpResponseMessage, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_HttpStreamContent, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_HttpStringContent, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_HttpTransportInformation, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_IHttpContent, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_HttpProgress, nullptr, nullptr) == -1)
    {
        return nullptr;
    }


    return module.detach();
}
