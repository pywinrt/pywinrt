// WARNING: Please don't edit this file. It was generated by Python/WinRT v0.0.0

#include "py.Windows.Devices.Bluetooth.GenericAttributeProfile.h"


namespace py::cpp::Windows::Devices::Bluetooth::GenericAttributeProfile
{
    // ----- GattCharacteristic class --------------------

    static PyObject* _new_GattCharacteristic(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Devices::Bluetooth::GenericAttributeProfile::GattCharacteristic>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Devices::Bluetooth::GenericAttributeProfile::GattCharacteristic>::type_name);
        return nullptr;
    }

    static void _dealloc_GattCharacteristic(py::wrapper::Windows::Devices::Bluetooth::GenericAttributeProfile::GattCharacteristic* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* GattCharacteristic_ConvertShortIdToUuid(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.Bluetooth.GenericAttributeProfile.GattCharacteristic", L"ConvertShortIdToUuid", 1))
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<uint16_t>(args, 0);

                return py::convert(winrt::Windows::Devices::Bluetooth::GenericAttributeProfile::GattCharacteristic::ConvertShortIdToUuid(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* GattCharacteristic_GetAllDescriptors(py::wrapper::Windows::Devices::Bluetooth::GenericAttributeProfile::GattCharacteristic* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.Bluetooth.GenericAttributeProfile.GattCharacteristic", L"GetAllDescriptors", 0))
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert(self->obj.GetAllDescriptors());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* GattCharacteristic_GetDescriptors(py::wrapper::Windows::Devices::Bluetooth::GenericAttributeProfile::GattCharacteristic* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.Bluetooth.GenericAttributeProfile.GattCharacteristic", L"GetDescriptors", 1))
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::guid>(args, 0);

                return py::convert(self->obj.GetDescriptors(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* GattCharacteristic_GetDescriptorsAsync(py::wrapper::Windows::Devices::Bluetooth::GenericAttributeProfile::GattCharacteristic* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.Bluetooth.GenericAttributeProfile.GattCharacteristic", L"GetDescriptorsAsync", 0))
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert(self->obj.GetDescriptorsAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 1)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.Bluetooth.GenericAttributeProfile.GattCharacteristic", L"GetDescriptorsAsync", 1))
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Devices::Bluetooth::BluetoothCacheMode>(args, 0);

                return py::convert(self->obj.GetDescriptorsAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* GattCharacteristic_GetDescriptorsForUuidAsync(py::wrapper::Windows::Devices::Bluetooth::GenericAttributeProfile::GattCharacteristic* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.Bluetooth.GenericAttributeProfile.GattCharacteristic", L"GetDescriptorsForUuidAsync", 1))
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::guid>(args, 0);

                return py::convert(self->obj.GetDescriptorsForUuidAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 2)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.Bluetooth.GenericAttributeProfile.GattCharacteristic", L"GetDescriptorsForUuidAsync", 2))
                {
                    py::set_arg_count_version_error(2);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::guid>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Devices::Bluetooth::BluetoothCacheMode>(args, 1);

                return py::convert(self->obj.GetDescriptorsForUuidAsync(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* GattCharacteristic_ReadClientCharacteristicConfigurationDescriptorAsync(py::wrapper::Windows::Devices::Bluetooth::GenericAttributeProfile::GattCharacteristic* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.Bluetooth.GenericAttributeProfile.GattCharacteristic", L"ReadClientCharacteristicConfigurationDescriptorAsync", 0))
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert(self->obj.ReadClientCharacteristicConfigurationDescriptorAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* GattCharacteristic_ReadValueAsync(py::wrapper::Windows::Devices::Bluetooth::GenericAttributeProfile::GattCharacteristic* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.Bluetooth.GenericAttributeProfile.GattCharacteristic", L"ReadValueAsync", 0))
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert(self->obj.ReadValueAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 1)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.Bluetooth.GenericAttributeProfile.GattCharacteristic", L"ReadValueAsync", 1))
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Devices::Bluetooth::BluetoothCacheMode>(args, 0);

                return py::convert(self->obj.ReadValueAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* GattCharacteristic_WriteClientCharacteristicConfigurationDescriptorAsync(py::wrapper::Windows::Devices::Bluetooth::GenericAttributeProfile::GattCharacteristic* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.Bluetooth.GenericAttributeProfile.GattCharacteristic", L"WriteClientCharacteristicConfigurationDescriptorAsync", 1))
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Devices::Bluetooth::GenericAttributeProfile::GattClientCharacteristicConfigurationDescriptorValue>(args, 0);

                return py::convert(self->obj.WriteClientCharacteristicConfigurationDescriptorAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* GattCharacteristic_WriteClientCharacteristicConfigurationDescriptorWithResultAsync(py::wrapper::Windows::Devices::Bluetooth::GenericAttributeProfile::GattCharacteristic* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.Bluetooth.GenericAttributeProfile.GattCharacteristic", L"WriteClientCharacteristicConfigurationDescriptorWithResultAsync", 1))
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Devices::Bluetooth::GenericAttributeProfile::GattClientCharacteristicConfigurationDescriptorValue>(args, 0);

                return py::convert(self->obj.WriteClientCharacteristicConfigurationDescriptorWithResultAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* GattCharacteristic_WriteValueAsync(py::wrapper::Windows::Devices::Bluetooth::GenericAttributeProfile::GattCharacteristic* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.Bluetooth.GenericAttributeProfile.GattCharacteristic", L"WriteValueAsync", 1))
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Storage::Streams::IBuffer>(args, 0);

                return py::convert(self->obj.WriteValueAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 2)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.Bluetooth.GenericAttributeProfile.GattCharacteristic", L"WriteValueAsync", 2))
                {
                    py::set_arg_count_version_error(2);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Storage::Streams::IBuffer>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Devices::Bluetooth::GenericAttributeProfile::GattWriteOption>(args, 1);

                return py::convert(self->obj.WriteValueAsync(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* GattCharacteristic_WriteValueWithResultAsync(py::wrapper::Windows::Devices::Bluetooth::GenericAttributeProfile::GattCharacteristic* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.Bluetooth.GenericAttributeProfile.GattCharacteristic", L"WriteValueWithResultAsync", 1))
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Storage::Streams::IBuffer>(args, 0);

                return py::convert(self->obj.WriteValueWithResultAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 2)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.Bluetooth.GenericAttributeProfile.GattCharacteristic", L"WriteValueWithResultAsync", 2))
                {
                    py::set_arg_count_version_error(2);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Storage::Streams::IBuffer>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Devices::Bluetooth::GenericAttributeProfile::GattWriteOption>(args, 1);

                return py::convert(self->obj.WriteValueWithResultAsync(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* GattCharacteristic_get_ProtectionLevel(py::wrapper::Windows::Devices::Bluetooth::GenericAttributeProfile::GattCharacteristic* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Bluetooth.GenericAttributeProfile.GattCharacteristic", L"ProtectionLevel"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.ProtectionLevel());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int GattCharacteristic_put_ProtectionLevel(py::wrapper::Windows::Devices::Bluetooth::GenericAttributeProfile::GattCharacteristic* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Bluetooth.GenericAttributeProfile.GattCharacteristic", L"ProtectionLevel"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::Devices::Bluetooth::GenericAttributeProfile::GattProtectionLevel>(arg);

            self->obj.ProtectionLevel(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* GattCharacteristic_get_AttributeHandle(py::wrapper::Windows::Devices::Bluetooth::GenericAttributeProfile::GattCharacteristic* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Bluetooth.GenericAttributeProfile.GattCharacteristic", L"AttributeHandle"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.AttributeHandle());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* GattCharacteristic_get_CharacteristicProperties(py::wrapper::Windows::Devices::Bluetooth::GenericAttributeProfile::GattCharacteristic* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Bluetooth.GenericAttributeProfile.GattCharacteristic", L"CharacteristicProperties"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.CharacteristicProperties());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* GattCharacteristic_get_PresentationFormats(py::wrapper::Windows::Devices::Bluetooth::GenericAttributeProfile::GattCharacteristic* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Bluetooth.GenericAttributeProfile.GattCharacteristic", L"PresentationFormats"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.PresentationFormats());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* GattCharacteristic_get_UserDescription(py::wrapper::Windows::Devices::Bluetooth::GenericAttributeProfile::GattCharacteristic* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Bluetooth.GenericAttributeProfile.GattCharacteristic", L"UserDescription"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.UserDescription());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* GattCharacteristic_get_Uuid(py::wrapper::Windows::Devices::Bluetooth::GenericAttributeProfile::GattCharacteristic* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Bluetooth.GenericAttributeProfile.GattCharacteristic", L"Uuid"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Uuid());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* GattCharacteristic_get_Service(py::wrapper::Windows::Devices::Bluetooth::GenericAttributeProfile::GattCharacteristic* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Bluetooth.GenericAttributeProfile.GattCharacteristic", L"Service"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Service());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* GattCharacteristic_add_ValueChanged(py::wrapper::Windows::Devices::Bluetooth::GenericAttributeProfile::GattCharacteristic* self, PyObject* arg) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Devices.Bluetooth.GenericAttributeProfile.GattCharacteristic", L"ValueChanged"))
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Devices::Bluetooth::GenericAttributeProfile::GattCharacteristic, winrt::Windows::Devices::Bluetooth::GenericAttributeProfile::GattValueChangedEventArgs>>(arg);

            return py::convert(self->obj.ValueChanged(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* GattCharacteristic_remove_ValueChanged(py::wrapper::Windows::Devices::Bluetooth::GenericAttributeProfile::GattCharacteristic* self, PyObject* arg) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Devices.Bluetooth.GenericAttributeProfile.GattCharacteristic", L"ValueChanged"))
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.ValueChanged(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_GattCharacteristic(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Devices::Bluetooth::GenericAttributeProfile::GattCharacteristic>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_GattCharacteristic(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Devices::Bluetooth::GenericAttributeProfile::GattCharacteristic>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_GattCharacteristic[] = {
        { "get_all_descriptors", reinterpret_cast<PyCFunction>(GattCharacteristic_GetAllDescriptors), METH_VARARGS, nullptr },
        { "get_descriptors", reinterpret_cast<PyCFunction>(GattCharacteristic_GetDescriptors), METH_VARARGS, nullptr },
        { "get_descriptors_async", reinterpret_cast<PyCFunction>(GattCharacteristic_GetDescriptorsAsync), METH_VARARGS, nullptr },
        { "get_descriptors_for_uuid_async", reinterpret_cast<PyCFunction>(GattCharacteristic_GetDescriptorsForUuidAsync), METH_VARARGS, nullptr },
        { "read_client_characteristic_configuration_descriptor_async", reinterpret_cast<PyCFunction>(GattCharacteristic_ReadClientCharacteristicConfigurationDescriptorAsync), METH_VARARGS, nullptr },
        { "read_value_async", reinterpret_cast<PyCFunction>(GattCharacteristic_ReadValueAsync), METH_VARARGS, nullptr },
        { "write_client_characteristic_configuration_descriptor_async", reinterpret_cast<PyCFunction>(GattCharacteristic_WriteClientCharacteristicConfigurationDescriptorAsync), METH_VARARGS, nullptr },
        { "write_client_characteristic_configuration_descriptor_with_result_async", reinterpret_cast<PyCFunction>(GattCharacteristic_WriteClientCharacteristicConfigurationDescriptorWithResultAsync), METH_VARARGS, nullptr },
        { "write_value_async", reinterpret_cast<PyCFunction>(GattCharacteristic_WriteValueAsync), METH_VARARGS, nullptr },
        { "write_value_with_result_async", reinterpret_cast<PyCFunction>(GattCharacteristic_WriteValueWithResultAsync), METH_VARARGS, nullptr },
        { "add_value_changed", reinterpret_cast<PyCFunction>(GattCharacteristic_add_ValueChanged), METH_O, nullptr },
        { "remove_value_changed", reinterpret_cast<PyCFunction>(GattCharacteristic_remove_ValueChanged), METH_O, nullptr },
        { "_assign_array_", _assign_array_GattCharacteristic, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_GattCharacteristic), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_GattCharacteristic[] = {
        { "protection_level", reinterpret_cast<getter>(GattCharacteristic_get_ProtectionLevel), reinterpret_cast<setter>(GattCharacteristic_put_ProtectionLevel), nullptr, nullptr },
        { "attribute_handle", reinterpret_cast<getter>(GattCharacteristic_get_AttributeHandle), nullptr, nullptr, nullptr },
        { "characteristic_properties", reinterpret_cast<getter>(GattCharacteristic_get_CharacteristicProperties), nullptr, nullptr, nullptr },
        { "presentation_formats", reinterpret_cast<getter>(GattCharacteristic_get_PresentationFormats), nullptr, nullptr, nullptr },
        { "user_description", reinterpret_cast<getter>(GattCharacteristic_get_UserDescription), nullptr, nullptr, nullptr },
        { "uuid", reinterpret_cast<getter>(GattCharacteristic_get_Uuid), nullptr, nullptr, nullptr },
        { "service", reinterpret_cast<getter>(GattCharacteristic_get_Service), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_GattCharacteristic[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_GattCharacteristic) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_GattCharacteristic) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_GattCharacteristic) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_GattCharacteristic) },
        { },
    };

    static PyType_Spec type_spec_GattCharacteristic =
    {
        "winrt._winrt_windows_devices_bluetooth_genericattributeprofile.GattCharacteristic",
        sizeof(py::wrapper::Windows::Devices::Bluetooth::GenericAttributeProfile::GattCharacteristic),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_GattCharacteristic
    };

    static PyGetSetDef getset_GattCharacteristic_Static[] = {
        { }
    };

    static PyMethodDef methods_GattCharacteristic_Static[] = {
        { "convert_short_id_to_uuid", reinterpret_cast<PyCFunction>(GattCharacteristic_ConvertShortIdToUuid), METH_VARARGS, nullptr },
        { }
    };

    static PyType_Slot type_slots_GattCharacteristic_Static[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_GattCharacteristic_Static) },
        { Py_tp_methods, reinterpret_cast<void*>(methods_GattCharacteristic_Static) },
        { }
    };

    static PyType_Spec type_spec_GattCharacteristic_Static =
    {
        "winrt._winrt_windows_devices_bluetooth_genericattributeprofile.GattCharacteristic_Static",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT,
        type_slots_GattCharacteristic_Static
    };

    // ----- GattCharacteristicUuids class --------------------

    static PyObject* _new_GattCharacteristicUuids(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Devices::Bluetooth::GenericAttributeProfile::GattCharacteristicUuids>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Devices::Bluetooth::GenericAttributeProfile::GattCharacteristicUuids>::type_name);
        return nullptr;
    }

    static PyObject* GattCharacteristicUuids_get_HeartRateMeasurement(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Bluetooth.GenericAttributeProfile.GattCharacteristicUuids", L"HeartRateMeasurement"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::Devices::Bluetooth::GenericAttributeProfile::GattCharacteristicUuids::HeartRateMeasurement());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* GattCharacteristicUuids_get_BatteryLevel(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Bluetooth.GenericAttributeProfile.GattCharacteristicUuids", L"BatteryLevel"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::Devices::Bluetooth::GenericAttributeProfile::GattCharacteristicUuids::BatteryLevel());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* GattCharacteristicUuids_get_BloodPressureFeature(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Bluetooth.GenericAttributeProfile.GattCharacteristicUuids", L"BloodPressureFeature"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::Devices::Bluetooth::GenericAttributeProfile::GattCharacteristicUuids::BloodPressureFeature());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* GattCharacteristicUuids_get_BloodPressureMeasurement(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Bluetooth.GenericAttributeProfile.GattCharacteristicUuids", L"BloodPressureMeasurement"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::Devices::Bluetooth::GenericAttributeProfile::GattCharacteristicUuids::BloodPressureMeasurement());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* GattCharacteristicUuids_get_BodySensorLocation(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Bluetooth.GenericAttributeProfile.GattCharacteristicUuids", L"BodySensorLocation"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::Devices::Bluetooth::GenericAttributeProfile::GattCharacteristicUuids::BodySensorLocation());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* GattCharacteristicUuids_get_CscFeature(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Bluetooth.GenericAttributeProfile.GattCharacteristicUuids", L"CscFeature"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::Devices::Bluetooth::GenericAttributeProfile::GattCharacteristicUuids::CscFeature());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* GattCharacteristicUuids_get_CscMeasurement(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Bluetooth.GenericAttributeProfile.GattCharacteristicUuids", L"CscMeasurement"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::Devices::Bluetooth::GenericAttributeProfile::GattCharacteristicUuids::CscMeasurement());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* GattCharacteristicUuids_get_GlucoseFeature(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Bluetooth.GenericAttributeProfile.GattCharacteristicUuids", L"GlucoseFeature"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::Devices::Bluetooth::GenericAttributeProfile::GattCharacteristicUuids::GlucoseFeature());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* GattCharacteristicUuids_get_GlucoseMeasurement(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Bluetooth.GenericAttributeProfile.GattCharacteristicUuids", L"GlucoseMeasurement"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::Devices::Bluetooth::GenericAttributeProfile::GattCharacteristicUuids::GlucoseMeasurement());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* GattCharacteristicUuids_get_GlucoseMeasurementContext(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Bluetooth.GenericAttributeProfile.GattCharacteristicUuids", L"GlucoseMeasurementContext"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::Devices::Bluetooth::GenericAttributeProfile::GattCharacteristicUuids::GlucoseMeasurementContext());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* GattCharacteristicUuids_get_HeartRateControlPoint(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Bluetooth.GenericAttributeProfile.GattCharacteristicUuids", L"HeartRateControlPoint"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::Devices::Bluetooth::GenericAttributeProfile::GattCharacteristicUuids::HeartRateControlPoint());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* GattCharacteristicUuids_get_IntermediateCuffPressure(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Bluetooth.GenericAttributeProfile.GattCharacteristicUuids", L"IntermediateCuffPressure"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::Devices::Bluetooth::GenericAttributeProfile::GattCharacteristicUuids::IntermediateCuffPressure());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* GattCharacteristicUuids_get_IntermediateTemperature(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Bluetooth.GenericAttributeProfile.GattCharacteristicUuids", L"IntermediateTemperature"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::Devices::Bluetooth::GenericAttributeProfile::GattCharacteristicUuids::IntermediateTemperature());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* GattCharacteristicUuids_get_MeasurementInterval(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Bluetooth.GenericAttributeProfile.GattCharacteristicUuids", L"MeasurementInterval"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::Devices::Bluetooth::GenericAttributeProfile::GattCharacteristicUuids::MeasurementInterval());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* GattCharacteristicUuids_get_RecordAccessControlPoint(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Bluetooth.GenericAttributeProfile.GattCharacteristicUuids", L"RecordAccessControlPoint"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::Devices::Bluetooth::GenericAttributeProfile::GattCharacteristicUuids::RecordAccessControlPoint());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* GattCharacteristicUuids_get_RscFeature(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Bluetooth.GenericAttributeProfile.GattCharacteristicUuids", L"RscFeature"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::Devices::Bluetooth::GenericAttributeProfile::GattCharacteristicUuids::RscFeature());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* GattCharacteristicUuids_get_RscMeasurement(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Bluetooth.GenericAttributeProfile.GattCharacteristicUuids", L"RscMeasurement"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::Devices::Bluetooth::GenericAttributeProfile::GattCharacteristicUuids::RscMeasurement());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* GattCharacteristicUuids_get_SCControlPoint(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Bluetooth.GenericAttributeProfile.GattCharacteristicUuids", L"SCControlPoint"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::Devices::Bluetooth::GenericAttributeProfile::GattCharacteristicUuids::SCControlPoint());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* GattCharacteristicUuids_get_SensorLocation(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Bluetooth.GenericAttributeProfile.GattCharacteristicUuids", L"SensorLocation"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::Devices::Bluetooth::GenericAttributeProfile::GattCharacteristicUuids::SensorLocation());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* GattCharacteristicUuids_get_TemperatureMeasurement(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Bluetooth.GenericAttributeProfile.GattCharacteristicUuids", L"TemperatureMeasurement"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::Devices::Bluetooth::GenericAttributeProfile::GattCharacteristicUuids::TemperatureMeasurement());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* GattCharacteristicUuids_get_TemperatureType(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Bluetooth.GenericAttributeProfile.GattCharacteristicUuids", L"TemperatureType"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::Devices::Bluetooth::GenericAttributeProfile::GattCharacteristicUuids::TemperatureType());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* GattCharacteristicUuids_get_GapPeripheralPreferredConnectionParameters(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Bluetooth.GenericAttributeProfile.GattCharacteristicUuids", L"GapPeripheralPreferredConnectionParameters"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::Devices::Bluetooth::GenericAttributeProfile::GattCharacteristicUuids::GapPeripheralPreferredConnectionParameters());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* GattCharacteristicUuids_get_GapPeripheralPrivacyFlag(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Bluetooth.GenericAttributeProfile.GattCharacteristicUuids", L"GapPeripheralPrivacyFlag"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::Devices::Bluetooth::GenericAttributeProfile::GattCharacteristicUuids::GapPeripheralPrivacyFlag());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* GattCharacteristicUuids_get_GapReconnectionAddress(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Bluetooth.GenericAttributeProfile.GattCharacteristicUuids", L"GapReconnectionAddress"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::Devices::Bluetooth::GenericAttributeProfile::GattCharacteristicUuids::GapReconnectionAddress());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* GattCharacteristicUuids_get_GattServiceChanged(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Bluetooth.GenericAttributeProfile.GattCharacteristicUuids", L"GattServiceChanged"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::Devices::Bluetooth::GenericAttributeProfile::GattCharacteristicUuids::GattServiceChanged());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* GattCharacteristicUuids_get_HardwareRevisionString(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Bluetooth.GenericAttributeProfile.GattCharacteristicUuids", L"HardwareRevisionString"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::Devices::Bluetooth::GenericAttributeProfile::GattCharacteristicUuids::HardwareRevisionString());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* GattCharacteristicUuids_get_HidControlPoint(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Bluetooth.GenericAttributeProfile.GattCharacteristicUuids", L"HidControlPoint"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::Devices::Bluetooth::GenericAttributeProfile::GattCharacteristicUuids::HidControlPoint());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* GattCharacteristicUuids_get_HidInformation(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Bluetooth.GenericAttributeProfile.GattCharacteristicUuids", L"HidInformation"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::Devices::Bluetooth::GenericAttributeProfile::GattCharacteristicUuids::HidInformation());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* GattCharacteristicUuids_get_Ieee1107320601RegulatoryCertificationDataList(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Bluetooth.GenericAttributeProfile.GattCharacteristicUuids", L"Ieee1107320601RegulatoryCertificationDataList"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::Devices::Bluetooth::GenericAttributeProfile::GattCharacteristicUuids::Ieee1107320601RegulatoryCertificationDataList());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* GattCharacteristicUuids_get_LnControlPoint(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Bluetooth.GenericAttributeProfile.GattCharacteristicUuids", L"LnControlPoint"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::Devices::Bluetooth::GenericAttributeProfile::GattCharacteristicUuids::LnControlPoint());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* GattCharacteristicUuids_get_LnFeature(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Bluetooth.GenericAttributeProfile.GattCharacteristicUuids", L"LnFeature"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::Devices::Bluetooth::GenericAttributeProfile::GattCharacteristicUuids::LnFeature());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* GattCharacteristicUuids_get_LocalTimeInformation(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Bluetooth.GenericAttributeProfile.GattCharacteristicUuids", L"LocalTimeInformation"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::Devices::Bluetooth::GenericAttributeProfile::GattCharacteristicUuids::LocalTimeInformation());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* GattCharacteristicUuids_get_LocationAndSpeed(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Bluetooth.GenericAttributeProfile.GattCharacteristicUuids", L"LocationAndSpeed"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::Devices::Bluetooth::GenericAttributeProfile::GattCharacteristicUuids::LocationAndSpeed());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* GattCharacteristicUuids_get_ManufacturerNameString(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Bluetooth.GenericAttributeProfile.GattCharacteristicUuids", L"ManufacturerNameString"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::Devices::Bluetooth::GenericAttributeProfile::GattCharacteristicUuids::ManufacturerNameString());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* GattCharacteristicUuids_get_ModelNumberString(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Bluetooth.GenericAttributeProfile.GattCharacteristicUuids", L"ModelNumberString"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::Devices::Bluetooth::GenericAttributeProfile::GattCharacteristicUuids::ModelNumberString());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* GattCharacteristicUuids_get_Navigation(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Bluetooth.GenericAttributeProfile.GattCharacteristicUuids", L"Navigation"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::Devices::Bluetooth::GenericAttributeProfile::GattCharacteristicUuids::Navigation());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* GattCharacteristicUuids_get_NewAlert(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Bluetooth.GenericAttributeProfile.GattCharacteristicUuids", L"NewAlert"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::Devices::Bluetooth::GenericAttributeProfile::GattCharacteristicUuids::NewAlert());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* GattCharacteristicUuids_get_PnpId(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Bluetooth.GenericAttributeProfile.GattCharacteristicUuids", L"PnpId"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::Devices::Bluetooth::GenericAttributeProfile::GattCharacteristicUuids::PnpId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* GattCharacteristicUuids_get_PositionQuality(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Bluetooth.GenericAttributeProfile.GattCharacteristicUuids", L"PositionQuality"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::Devices::Bluetooth::GenericAttributeProfile::GattCharacteristicUuids::PositionQuality());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* GattCharacteristicUuids_get_ProtocolMode(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Bluetooth.GenericAttributeProfile.GattCharacteristicUuids", L"ProtocolMode"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::Devices::Bluetooth::GenericAttributeProfile::GattCharacteristicUuids::ProtocolMode());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* GattCharacteristicUuids_get_CyclingPowerFeature(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Bluetooth.GenericAttributeProfile.GattCharacteristicUuids", L"CyclingPowerFeature"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::Devices::Bluetooth::GenericAttributeProfile::GattCharacteristicUuids::CyclingPowerFeature());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* GattCharacteristicUuids_get_Report(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Bluetooth.GenericAttributeProfile.GattCharacteristicUuids", L"Report"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::Devices::Bluetooth::GenericAttributeProfile::GattCharacteristicUuids::Report());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* GattCharacteristicUuids_get_ReportMap(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Bluetooth.GenericAttributeProfile.GattCharacteristicUuids", L"ReportMap"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::Devices::Bluetooth::GenericAttributeProfile::GattCharacteristicUuids::ReportMap());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* GattCharacteristicUuids_get_RingerControlPoint(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Bluetooth.GenericAttributeProfile.GattCharacteristicUuids", L"RingerControlPoint"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::Devices::Bluetooth::GenericAttributeProfile::GattCharacteristicUuids::RingerControlPoint());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* GattCharacteristicUuids_get_RingerSetting(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Bluetooth.GenericAttributeProfile.GattCharacteristicUuids", L"RingerSetting"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::Devices::Bluetooth::GenericAttributeProfile::GattCharacteristicUuids::RingerSetting());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* GattCharacteristicUuids_get_ScanIntervalWindow(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Bluetooth.GenericAttributeProfile.GattCharacteristicUuids", L"ScanIntervalWindow"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::Devices::Bluetooth::GenericAttributeProfile::GattCharacteristicUuids::ScanIntervalWindow());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* GattCharacteristicUuids_get_ScanRefresh(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Bluetooth.GenericAttributeProfile.GattCharacteristicUuids", L"ScanRefresh"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::Devices::Bluetooth::GenericAttributeProfile::GattCharacteristicUuids::ScanRefresh());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* GattCharacteristicUuids_get_SerialNumberString(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Bluetooth.GenericAttributeProfile.GattCharacteristicUuids", L"SerialNumberString"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::Devices::Bluetooth::GenericAttributeProfile::GattCharacteristicUuids::SerialNumberString());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* GattCharacteristicUuids_get_SoftwareRevisionString(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Bluetooth.GenericAttributeProfile.GattCharacteristicUuids", L"SoftwareRevisionString"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::Devices::Bluetooth::GenericAttributeProfile::GattCharacteristicUuids::SoftwareRevisionString());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* GattCharacteristicUuids_get_SupportUnreadAlertCategory(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Bluetooth.GenericAttributeProfile.GattCharacteristicUuids", L"SupportUnreadAlertCategory"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::Devices::Bluetooth::GenericAttributeProfile::GattCharacteristicUuids::SupportUnreadAlertCategory());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* GattCharacteristicUuids_get_SupportedNewAlertCategory(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Bluetooth.GenericAttributeProfile.GattCharacteristicUuids", L"SupportedNewAlertCategory"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::Devices::Bluetooth::GenericAttributeProfile::GattCharacteristicUuids::SupportedNewAlertCategory());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* GattCharacteristicUuids_get_SystemId(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Bluetooth.GenericAttributeProfile.GattCharacteristicUuids", L"SystemId"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::Devices::Bluetooth::GenericAttributeProfile::GattCharacteristicUuids::SystemId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* GattCharacteristicUuids_get_TimeAccuracy(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Bluetooth.GenericAttributeProfile.GattCharacteristicUuids", L"TimeAccuracy"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::Devices::Bluetooth::GenericAttributeProfile::GattCharacteristicUuids::TimeAccuracy());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* GattCharacteristicUuids_get_TimeSource(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Bluetooth.GenericAttributeProfile.GattCharacteristicUuids", L"TimeSource"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::Devices::Bluetooth::GenericAttributeProfile::GattCharacteristicUuids::TimeSource());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* GattCharacteristicUuids_get_TimeUpdateControlPoint(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Bluetooth.GenericAttributeProfile.GattCharacteristicUuids", L"TimeUpdateControlPoint"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::Devices::Bluetooth::GenericAttributeProfile::GattCharacteristicUuids::TimeUpdateControlPoint());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* GattCharacteristicUuids_get_TimeUpdateState(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Bluetooth.GenericAttributeProfile.GattCharacteristicUuids", L"TimeUpdateState"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::Devices::Bluetooth::GenericAttributeProfile::GattCharacteristicUuids::TimeUpdateState());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* GattCharacteristicUuids_get_TimeWithDst(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Bluetooth.GenericAttributeProfile.GattCharacteristicUuids", L"TimeWithDst"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::Devices::Bluetooth::GenericAttributeProfile::GattCharacteristicUuids::TimeWithDst());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* GattCharacteristicUuids_get_TimeZone(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Bluetooth.GenericAttributeProfile.GattCharacteristicUuids", L"TimeZone"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::Devices::Bluetooth::GenericAttributeProfile::GattCharacteristicUuids::TimeZone());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* GattCharacteristicUuids_get_TxPowerLevel(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Bluetooth.GenericAttributeProfile.GattCharacteristicUuids", L"TxPowerLevel"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::Devices::Bluetooth::GenericAttributeProfile::GattCharacteristicUuids::TxPowerLevel());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* GattCharacteristicUuids_get_UnreadAlertStatus(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Bluetooth.GenericAttributeProfile.GattCharacteristicUuids", L"UnreadAlertStatus"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::Devices::Bluetooth::GenericAttributeProfile::GattCharacteristicUuids::UnreadAlertStatus());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* GattCharacteristicUuids_get_AlertCategoryId(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Bluetooth.GenericAttributeProfile.GattCharacteristicUuids", L"AlertCategoryId"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::Devices::Bluetooth::GenericAttributeProfile::GattCharacteristicUuids::AlertCategoryId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* GattCharacteristicUuids_get_AlertCategoryIdBitMask(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Bluetooth.GenericAttributeProfile.GattCharacteristicUuids", L"AlertCategoryIdBitMask"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::Devices::Bluetooth::GenericAttributeProfile::GattCharacteristicUuids::AlertCategoryIdBitMask());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* GattCharacteristicUuids_get_AlertLevel(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Bluetooth.GenericAttributeProfile.GattCharacteristicUuids", L"AlertLevel"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::Devices::Bluetooth::GenericAttributeProfile::GattCharacteristicUuids::AlertLevel());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* GattCharacteristicUuids_get_AlertNotificationControlPoint(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Bluetooth.GenericAttributeProfile.GattCharacteristicUuids", L"AlertNotificationControlPoint"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::Devices::Bluetooth::GenericAttributeProfile::GattCharacteristicUuids::AlertNotificationControlPoint());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* GattCharacteristicUuids_get_AlertStatus(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Bluetooth.GenericAttributeProfile.GattCharacteristicUuids", L"AlertStatus"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::Devices::Bluetooth::GenericAttributeProfile::GattCharacteristicUuids::AlertStatus());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* GattCharacteristicUuids_get_BootKeyboardInputReport(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Bluetooth.GenericAttributeProfile.GattCharacteristicUuids", L"BootKeyboardInputReport"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::Devices::Bluetooth::GenericAttributeProfile::GattCharacteristicUuids::BootKeyboardInputReport());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* GattCharacteristicUuids_get_BootKeyboardOutputReport(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Bluetooth.GenericAttributeProfile.GattCharacteristicUuids", L"BootKeyboardOutputReport"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::Devices::Bluetooth::GenericAttributeProfile::GattCharacteristicUuids::BootKeyboardOutputReport());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* GattCharacteristicUuids_get_BootMouseInputReport(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Bluetooth.GenericAttributeProfile.GattCharacteristicUuids", L"BootMouseInputReport"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::Devices::Bluetooth::GenericAttributeProfile::GattCharacteristicUuids::BootMouseInputReport());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* GattCharacteristicUuids_get_CurrentTime(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Bluetooth.GenericAttributeProfile.GattCharacteristicUuids", L"CurrentTime"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::Devices::Bluetooth::GenericAttributeProfile::GattCharacteristicUuids::CurrentTime());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* GattCharacteristicUuids_get_CyclingPowerControlPoint(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Bluetooth.GenericAttributeProfile.GattCharacteristicUuids", L"CyclingPowerControlPoint"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::Devices::Bluetooth::GenericAttributeProfile::GattCharacteristicUuids::CyclingPowerControlPoint());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* GattCharacteristicUuids_get_ReferenceTimeInformation(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Bluetooth.GenericAttributeProfile.GattCharacteristicUuids", L"ReferenceTimeInformation"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::Devices::Bluetooth::GenericAttributeProfile::GattCharacteristicUuids::ReferenceTimeInformation());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* GattCharacteristicUuids_get_CyclingPowerMeasurement(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Bluetooth.GenericAttributeProfile.GattCharacteristicUuids", L"CyclingPowerMeasurement"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::Devices::Bluetooth::GenericAttributeProfile::GattCharacteristicUuids::CyclingPowerMeasurement());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* GattCharacteristicUuids_get_CyclingPowerVector(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Bluetooth.GenericAttributeProfile.GattCharacteristicUuids", L"CyclingPowerVector"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::Devices::Bluetooth::GenericAttributeProfile::GattCharacteristicUuids::CyclingPowerVector());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* GattCharacteristicUuids_get_DateTime(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Bluetooth.GenericAttributeProfile.GattCharacteristicUuids", L"DateTime"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::Devices::Bluetooth::GenericAttributeProfile::GattCharacteristicUuids::DateTime());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* GattCharacteristicUuids_get_DayDateTime(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Bluetooth.GenericAttributeProfile.GattCharacteristicUuids", L"DayDateTime"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::Devices::Bluetooth::GenericAttributeProfile::GattCharacteristicUuids::DayDateTime());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* GattCharacteristicUuids_get_DayOfWeek(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Bluetooth.GenericAttributeProfile.GattCharacteristicUuids", L"DayOfWeek"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::Devices::Bluetooth::GenericAttributeProfile::GattCharacteristicUuids::DayOfWeek());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* GattCharacteristicUuids_get_DstOffset(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Bluetooth.GenericAttributeProfile.GattCharacteristicUuids", L"DstOffset"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::Devices::Bluetooth::GenericAttributeProfile::GattCharacteristicUuids::DstOffset());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* GattCharacteristicUuids_get_ExactTime256(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Bluetooth.GenericAttributeProfile.GattCharacteristicUuids", L"ExactTime256"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::Devices::Bluetooth::GenericAttributeProfile::GattCharacteristicUuids::ExactTime256());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* GattCharacteristicUuids_get_FirmwareRevisionString(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Bluetooth.GenericAttributeProfile.GattCharacteristicUuids", L"FirmwareRevisionString"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::Devices::Bluetooth::GenericAttributeProfile::GattCharacteristicUuids::FirmwareRevisionString());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* GattCharacteristicUuids_get_GapAppearance(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Bluetooth.GenericAttributeProfile.GattCharacteristicUuids", L"GapAppearance"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::Devices::Bluetooth::GenericAttributeProfile::GattCharacteristicUuids::GapAppearance());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* GattCharacteristicUuids_get_GapDeviceName(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Bluetooth.GenericAttributeProfile.GattCharacteristicUuids", L"GapDeviceName"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::Devices::Bluetooth::GenericAttributeProfile::GattCharacteristicUuids::GapDeviceName());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_GattCharacteristicUuids[] = {
        { }
    };

    static PyGetSetDef _getset_GattCharacteristicUuids[] = {
        { }
    };

    static PyType_Slot _type_slots_GattCharacteristicUuids[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_GattCharacteristicUuids) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_GattCharacteristicUuids) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_GattCharacteristicUuids) },
        { },
    };

    static PyType_Spec type_spec_GattCharacteristicUuids =
    {
        "winrt._winrt_windows_devices_bluetooth_genericattributeprofile.GattCharacteristicUuids",
        0,
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_GattCharacteristicUuids
    };

    static PyGetSetDef getset_GattCharacteristicUuids_Static[] = {
        { "heart_rate_measurement", reinterpret_cast<getter>(GattCharacteristicUuids_get_HeartRateMeasurement), nullptr, nullptr, nullptr },
        { "battery_level", reinterpret_cast<getter>(GattCharacteristicUuids_get_BatteryLevel), nullptr, nullptr, nullptr },
        { "blood_pressure_feature", reinterpret_cast<getter>(GattCharacteristicUuids_get_BloodPressureFeature), nullptr, nullptr, nullptr },
        { "blood_pressure_measurement", reinterpret_cast<getter>(GattCharacteristicUuids_get_BloodPressureMeasurement), nullptr, nullptr, nullptr },
        { "body_sensor_location", reinterpret_cast<getter>(GattCharacteristicUuids_get_BodySensorLocation), nullptr, nullptr, nullptr },
        { "csc_feature", reinterpret_cast<getter>(GattCharacteristicUuids_get_CscFeature), nullptr, nullptr, nullptr },
        { "csc_measurement", reinterpret_cast<getter>(GattCharacteristicUuids_get_CscMeasurement), nullptr, nullptr, nullptr },
        { "glucose_feature", reinterpret_cast<getter>(GattCharacteristicUuids_get_GlucoseFeature), nullptr, nullptr, nullptr },
        { "glucose_measurement", reinterpret_cast<getter>(GattCharacteristicUuids_get_GlucoseMeasurement), nullptr, nullptr, nullptr },
        { "glucose_measurement_context", reinterpret_cast<getter>(GattCharacteristicUuids_get_GlucoseMeasurementContext), nullptr, nullptr, nullptr },
        { "heart_rate_control_point", reinterpret_cast<getter>(GattCharacteristicUuids_get_HeartRateControlPoint), nullptr, nullptr, nullptr },
        { "intermediate_cuff_pressure", reinterpret_cast<getter>(GattCharacteristicUuids_get_IntermediateCuffPressure), nullptr, nullptr, nullptr },
        { "intermediate_temperature", reinterpret_cast<getter>(GattCharacteristicUuids_get_IntermediateTemperature), nullptr, nullptr, nullptr },
        { "measurement_interval", reinterpret_cast<getter>(GattCharacteristicUuids_get_MeasurementInterval), nullptr, nullptr, nullptr },
        { "record_access_control_point", reinterpret_cast<getter>(GattCharacteristicUuids_get_RecordAccessControlPoint), nullptr, nullptr, nullptr },
        { "rsc_feature", reinterpret_cast<getter>(GattCharacteristicUuids_get_RscFeature), nullptr, nullptr, nullptr },
        { "rsc_measurement", reinterpret_cast<getter>(GattCharacteristicUuids_get_RscMeasurement), nullptr, nullptr, nullptr },
        { "s_c_control_point", reinterpret_cast<getter>(GattCharacteristicUuids_get_SCControlPoint), nullptr, nullptr, nullptr },
        { "sensor_location", reinterpret_cast<getter>(GattCharacteristicUuids_get_SensorLocation), nullptr, nullptr, nullptr },
        { "temperature_measurement", reinterpret_cast<getter>(GattCharacteristicUuids_get_TemperatureMeasurement), nullptr, nullptr, nullptr },
        { "temperature_type", reinterpret_cast<getter>(GattCharacteristicUuids_get_TemperatureType), nullptr, nullptr, nullptr },
        { "gap_peripheral_preferred_connection_parameters", reinterpret_cast<getter>(GattCharacteristicUuids_get_GapPeripheralPreferredConnectionParameters), nullptr, nullptr, nullptr },
        { "gap_peripheral_privacy_flag", reinterpret_cast<getter>(GattCharacteristicUuids_get_GapPeripheralPrivacyFlag), nullptr, nullptr, nullptr },
        { "gap_reconnection_address", reinterpret_cast<getter>(GattCharacteristicUuids_get_GapReconnectionAddress), nullptr, nullptr, nullptr },
        { "gatt_service_changed", reinterpret_cast<getter>(GattCharacteristicUuids_get_GattServiceChanged), nullptr, nullptr, nullptr },
        { "hardware_revision_string", reinterpret_cast<getter>(GattCharacteristicUuids_get_HardwareRevisionString), nullptr, nullptr, nullptr },
        { "hid_control_point", reinterpret_cast<getter>(GattCharacteristicUuids_get_HidControlPoint), nullptr, nullptr, nullptr },
        { "hid_information", reinterpret_cast<getter>(GattCharacteristicUuids_get_HidInformation), nullptr, nullptr, nullptr },
        { "ieee1107320601_regulatory_certification_data_list", reinterpret_cast<getter>(GattCharacteristicUuids_get_Ieee1107320601RegulatoryCertificationDataList), nullptr, nullptr, nullptr },
        { "ln_control_point", reinterpret_cast<getter>(GattCharacteristicUuids_get_LnControlPoint), nullptr, nullptr, nullptr },
        { "ln_feature", reinterpret_cast<getter>(GattCharacteristicUuids_get_LnFeature), nullptr, nullptr, nullptr },
        { "local_time_information", reinterpret_cast<getter>(GattCharacteristicUuids_get_LocalTimeInformation), nullptr, nullptr, nullptr },
        { "location_and_speed", reinterpret_cast<getter>(GattCharacteristicUuids_get_LocationAndSpeed), nullptr, nullptr, nullptr },
        { "manufacturer_name_string", reinterpret_cast<getter>(GattCharacteristicUuids_get_ManufacturerNameString), nullptr, nullptr, nullptr },
        { "model_number_string", reinterpret_cast<getter>(GattCharacteristicUuids_get_ModelNumberString), nullptr, nullptr, nullptr },
        { "navigation", reinterpret_cast<getter>(GattCharacteristicUuids_get_Navigation), nullptr, nullptr, nullptr },
        { "new_alert", reinterpret_cast<getter>(GattCharacteristicUuids_get_NewAlert), nullptr, nullptr, nullptr },
        { "pnp_id", reinterpret_cast<getter>(GattCharacteristicUuids_get_PnpId), nullptr, nullptr, nullptr },
        { "position_quality", reinterpret_cast<getter>(GattCharacteristicUuids_get_PositionQuality), nullptr, nullptr, nullptr },
        { "protocol_mode", reinterpret_cast<getter>(GattCharacteristicUuids_get_ProtocolMode), nullptr, nullptr, nullptr },
        { "cycling_power_feature", reinterpret_cast<getter>(GattCharacteristicUuids_get_CyclingPowerFeature), nullptr, nullptr, nullptr },
        { "report", reinterpret_cast<getter>(GattCharacteristicUuids_get_Report), nullptr, nullptr, nullptr },
        { "report_map", reinterpret_cast<getter>(GattCharacteristicUuids_get_ReportMap), nullptr, nullptr, nullptr },
        { "ringer_control_point", reinterpret_cast<getter>(GattCharacteristicUuids_get_RingerControlPoint), nullptr, nullptr, nullptr },
        { "ringer_setting", reinterpret_cast<getter>(GattCharacteristicUuids_get_RingerSetting), nullptr, nullptr, nullptr },
        { "scan_interval_window", reinterpret_cast<getter>(GattCharacteristicUuids_get_ScanIntervalWindow), nullptr, nullptr, nullptr },
        { "scan_refresh", reinterpret_cast<getter>(GattCharacteristicUuids_get_ScanRefresh), nullptr, nullptr, nullptr },
        { "serial_number_string", reinterpret_cast<getter>(GattCharacteristicUuids_get_SerialNumberString), nullptr, nullptr, nullptr },
        { "software_revision_string", reinterpret_cast<getter>(GattCharacteristicUuids_get_SoftwareRevisionString), nullptr, nullptr, nullptr },
        { "support_unread_alert_category", reinterpret_cast<getter>(GattCharacteristicUuids_get_SupportUnreadAlertCategory), nullptr, nullptr, nullptr },
        { "supported_new_alert_category", reinterpret_cast<getter>(GattCharacteristicUuids_get_SupportedNewAlertCategory), nullptr, nullptr, nullptr },
        { "system_id", reinterpret_cast<getter>(GattCharacteristicUuids_get_SystemId), nullptr, nullptr, nullptr },
        { "time_accuracy", reinterpret_cast<getter>(GattCharacteristicUuids_get_TimeAccuracy), nullptr, nullptr, nullptr },
        { "time_source", reinterpret_cast<getter>(GattCharacteristicUuids_get_TimeSource), nullptr, nullptr, nullptr },
        { "time_update_control_point", reinterpret_cast<getter>(GattCharacteristicUuids_get_TimeUpdateControlPoint), nullptr, nullptr, nullptr },
        { "time_update_state", reinterpret_cast<getter>(GattCharacteristicUuids_get_TimeUpdateState), nullptr, nullptr, nullptr },
        { "time_with_dst", reinterpret_cast<getter>(GattCharacteristicUuids_get_TimeWithDst), nullptr, nullptr, nullptr },
        { "time_zone", reinterpret_cast<getter>(GattCharacteristicUuids_get_TimeZone), nullptr, nullptr, nullptr },
        { "tx_power_level", reinterpret_cast<getter>(GattCharacteristicUuids_get_TxPowerLevel), nullptr, nullptr, nullptr },
        { "unread_alert_status", reinterpret_cast<getter>(GattCharacteristicUuids_get_UnreadAlertStatus), nullptr, nullptr, nullptr },
        { "alert_category_id", reinterpret_cast<getter>(GattCharacteristicUuids_get_AlertCategoryId), nullptr, nullptr, nullptr },
        { "alert_category_id_bit_mask", reinterpret_cast<getter>(GattCharacteristicUuids_get_AlertCategoryIdBitMask), nullptr, nullptr, nullptr },
        { "alert_level", reinterpret_cast<getter>(GattCharacteristicUuids_get_AlertLevel), nullptr, nullptr, nullptr },
        { "alert_notification_control_point", reinterpret_cast<getter>(GattCharacteristicUuids_get_AlertNotificationControlPoint), nullptr, nullptr, nullptr },
        { "alert_status", reinterpret_cast<getter>(GattCharacteristicUuids_get_AlertStatus), nullptr, nullptr, nullptr },
        { "boot_keyboard_input_report", reinterpret_cast<getter>(GattCharacteristicUuids_get_BootKeyboardInputReport), nullptr, nullptr, nullptr },
        { "boot_keyboard_output_report", reinterpret_cast<getter>(GattCharacteristicUuids_get_BootKeyboardOutputReport), nullptr, nullptr, nullptr },
        { "boot_mouse_input_report", reinterpret_cast<getter>(GattCharacteristicUuids_get_BootMouseInputReport), nullptr, nullptr, nullptr },
        { "current_time", reinterpret_cast<getter>(GattCharacteristicUuids_get_CurrentTime), nullptr, nullptr, nullptr },
        { "cycling_power_control_point", reinterpret_cast<getter>(GattCharacteristicUuids_get_CyclingPowerControlPoint), nullptr, nullptr, nullptr },
        { "reference_time_information", reinterpret_cast<getter>(GattCharacteristicUuids_get_ReferenceTimeInformation), nullptr, nullptr, nullptr },
        { "cycling_power_measurement", reinterpret_cast<getter>(GattCharacteristicUuids_get_CyclingPowerMeasurement), nullptr, nullptr, nullptr },
        { "cycling_power_vector", reinterpret_cast<getter>(GattCharacteristicUuids_get_CyclingPowerVector), nullptr, nullptr, nullptr },
        { "date_time", reinterpret_cast<getter>(GattCharacteristicUuids_get_DateTime), nullptr, nullptr, nullptr },
        { "day_date_time", reinterpret_cast<getter>(GattCharacteristicUuids_get_DayDateTime), nullptr, nullptr, nullptr },
        { "day_of_week", reinterpret_cast<getter>(GattCharacteristicUuids_get_DayOfWeek), nullptr, nullptr, nullptr },
        { "dst_offset", reinterpret_cast<getter>(GattCharacteristicUuids_get_DstOffset), nullptr, nullptr, nullptr },
        { "exact_time256", reinterpret_cast<getter>(GattCharacteristicUuids_get_ExactTime256), nullptr, nullptr, nullptr },
        { "firmware_revision_string", reinterpret_cast<getter>(GattCharacteristicUuids_get_FirmwareRevisionString), nullptr, nullptr, nullptr },
        { "gap_appearance", reinterpret_cast<getter>(GattCharacteristicUuids_get_GapAppearance), nullptr, nullptr, nullptr },
        { "gap_device_name", reinterpret_cast<getter>(GattCharacteristicUuids_get_GapDeviceName), nullptr, nullptr, nullptr },
        { }
    };

    static PyMethodDef methods_GattCharacteristicUuids_Static[] = {
        { }
    };

    static PyType_Slot type_slots_GattCharacteristicUuids_Static[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_GattCharacteristicUuids_Static) },
        { Py_tp_methods, reinterpret_cast<void*>(methods_GattCharacteristicUuids_Static) },
        { }
    };

    static PyType_Spec type_spec_GattCharacteristicUuids_Static =
    {
        "winrt._winrt_windows_devices_bluetooth_genericattributeprofile.GattCharacteristicUuids_Static",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT,
        type_slots_GattCharacteristicUuids_Static
    };

    // ----- GattCharacteristicsResult class --------------------

    static PyObject* _new_GattCharacteristicsResult(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Devices::Bluetooth::GenericAttributeProfile::GattCharacteristicsResult>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Devices::Bluetooth::GenericAttributeProfile::GattCharacteristicsResult>::type_name);
        return nullptr;
    }

    static void _dealloc_GattCharacteristicsResult(py::wrapper::Windows::Devices::Bluetooth::GenericAttributeProfile::GattCharacteristicsResult* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* GattCharacteristicsResult_get_Characteristics(py::wrapper::Windows::Devices::Bluetooth::GenericAttributeProfile::GattCharacteristicsResult* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Bluetooth.GenericAttributeProfile.GattCharacteristicsResult", L"Characteristics"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Characteristics());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* GattCharacteristicsResult_get_ProtocolError(py::wrapper::Windows::Devices::Bluetooth::GenericAttributeProfile::GattCharacteristicsResult* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Bluetooth.GenericAttributeProfile.GattCharacteristicsResult", L"ProtocolError"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.ProtocolError());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* GattCharacteristicsResult_get_Status(py::wrapper::Windows::Devices::Bluetooth::GenericAttributeProfile::GattCharacteristicsResult* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Bluetooth.GenericAttributeProfile.GattCharacteristicsResult", L"Status"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Status());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_GattCharacteristicsResult(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Devices::Bluetooth::GenericAttributeProfile::GattCharacteristicsResult>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_GattCharacteristicsResult(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Devices::Bluetooth::GenericAttributeProfile::GattCharacteristicsResult>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_GattCharacteristicsResult[] = {
        { "_assign_array_", _assign_array_GattCharacteristicsResult, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_GattCharacteristicsResult), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_GattCharacteristicsResult[] = {
        { "characteristics", reinterpret_cast<getter>(GattCharacteristicsResult_get_Characteristics), nullptr, nullptr, nullptr },
        { "protocol_error", reinterpret_cast<getter>(GattCharacteristicsResult_get_ProtocolError), nullptr, nullptr, nullptr },
        { "status", reinterpret_cast<getter>(GattCharacteristicsResult_get_Status), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_GattCharacteristicsResult[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_GattCharacteristicsResult) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_GattCharacteristicsResult) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_GattCharacteristicsResult) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_GattCharacteristicsResult) },
        { },
    };

    static PyType_Spec type_spec_GattCharacteristicsResult =
    {
        "winrt._winrt_windows_devices_bluetooth_genericattributeprofile.GattCharacteristicsResult",
        sizeof(py::wrapper::Windows::Devices::Bluetooth::GenericAttributeProfile::GattCharacteristicsResult),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_GattCharacteristicsResult
    };

    // ----- GattClientNotificationResult class --------------------

    static PyObject* _new_GattClientNotificationResult(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Devices::Bluetooth::GenericAttributeProfile::GattClientNotificationResult>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Devices::Bluetooth::GenericAttributeProfile::GattClientNotificationResult>::type_name);
        return nullptr;
    }

    static void _dealloc_GattClientNotificationResult(py::wrapper::Windows::Devices::Bluetooth::GenericAttributeProfile::GattClientNotificationResult* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* GattClientNotificationResult_get_ProtocolError(py::wrapper::Windows::Devices::Bluetooth::GenericAttributeProfile::GattClientNotificationResult* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Bluetooth.GenericAttributeProfile.GattClientNotificationResult", L"ProtocolError"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.ProtocolError());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* GattClientNotificationResult_get_Status(py::wrapper::Windows::Devices::Bluetooth::GenericAttributeProfile::GattClientNotificationResult* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Bluetooth.GenericAttributeProfile.GattClientNotificationResult", L"Status"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Status());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* GattClientNotificationResult_get_SubscribedClient(py::wrapper::Windows::Devices::Bluetooth::GenericAttributeProfile::GattClientNotificationResult* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Bluetooth.GenericAttributeProfile.GattClientNotificationResult", L"SubscribedClient"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.SubscribedClient());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* GattClientNotificationResult_get_BytesSent(py::wrapper::Windows::Devices::Bluetooth::GenericAttributeProfile::GattClientNotificationResult* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Bluetooth.GenericAttributeProfile.GattClientNotificationResult", L"BytesSent"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.BytesSent());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_GattClientNotificationResult(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Devices::Bluetooth::GenericAttributeProfile::GattClientNotificationResult>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_GattClientNotificationResult(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Devices::Bluetooth::GenericAttributeProfile::GattClientNotificationResult>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_GattClientNotificationResult[] = {
        { "_assign_array_", _assign_array_GattClientNotificationResult, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_GattClientNotificationResult), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_GattClientNotificationResult[] = {
        { "protocol_error", reinterpret_cast<getter>(GattClientNotificationResult_get_ProtocolError), nullptr, nullptr, nullptr },
        { "status", reinterpret_cast<getter>(GattClientNotificationResult_get_Status), nullptr, nullptr, nullptr },
        { "subscribed_client", reinterpret_cast<getter>(GattClientNotificationResult_get_SubscribedClient), nullptr, nullptr, nullptr },
        { "bytes_sent", reinterpret_cast<getter>(GattClientNotificationResult_get_BytesSent), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_GattClientNotificationResult[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_GattClientNotificationResult) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_GattClientNotificationResult) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_GattClientNotificationResult) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_GattClientNotificationResult) },
        { },
    };

    static PyType_Spec type_spec_GattClientNotificationResult =
    {
        "winrt._winrt_windows_devices_bluetooth_genericattributeprofile.GattClientNotificationResult",
        sizeof(py::wrapper::Windows::Devices::Bluetooth::GenericAttributeProfile::GattClientNotificationResult),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_GattClientNotificationResult
    };

    // ----- GattDescriptor class --------------------

    static PyObject* _new_GattDescriptor(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Devices::Bluetooth::GenericAttributeProfile::GattDescriptor>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Devices::Bluetooth::GenericAttributeProfile::GattDescriptor>::type_name);
        return nullptr;
    }

    static void _dealloc_GattDescriptor(py::wrapper::Windows::Devices::Bluetooth::GenericAttributeProfile::GattDescriptor* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* GattDescriptor_ConvertShortIdToUuid(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.Bluetooth.GenericAttributeProfile.GattDescriptor", L"ConvertShortIdToUuid", 1))
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<uint16_t>(args, 0);

                return py::convert(winrt::Windows::Devices::Bluetooth::GenericAttributeProfile::GattDescriptor::ConvertShortIdToUuid(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* GattDescriptor_ReadValueAsync(py::wrapper::Windows::Devices::Bluetooth::GenericAttributeProfile::GattDescriptor* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.Bluetooth.GenericAttributeProfile.GattDescriptor", L"ReadValueAsync", 0))
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert(self->obj.ReadValueAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 1)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.Bluetooth.GenericAttributeProfile.GattDescriptor", L"ReadValueAsync", 1))
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Devices::Bluetooth::BluetoothCacheMode>(args, 0);

                return py::convert(self->obj.ReadValueAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* GattDescriptor_WriteValueAsync(py::wrapper::Windows::Devices::Bluetooth::GenericAttributeProfile::GattDescriptor* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.Bluetooth.GenericAttributeProfile.GattDescriptor", L"WriteValueAsync", 1))
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Storage::Streams::IBuffer>(args, 0);

                return py::convert(self->obj.WriteValueAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* GattDescriptor_WriteValueWithResultAsync(py::wrapper::Windows::Devices::Bluetooth::GenericAttributeProfile::GattDescriptor* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.Bluetooth.GenericAttributeProfile.GattDescriptor", L"WriteValueWithResultAsync", 1))
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Storage::Streams::IBuffer>(args, 0);

                return py::convert(self->obj.WriteValueWithResultAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* GattDescriptor_get_ProtectionLevel(py::wrapper::Windows::Devices::Bluetooth::GenericAttributeProfile::GattDescriptor* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Bluetooth.GenericAttributeProfile.GattDescriptor", L"ProtectionLevel"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.ProtectionLevel());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int GattDescriptor_put_ProtectionLevel(py::wrapper::Windows::Devices::Bluetooth::GenericAttributeProfile::GattDescriptor* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Bluetooth.GenericAttributeProfile.GattDescriptor", L"ProtectionLevel"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::Devices::Bluetooth::GenericAttributeProfile::GattProtectionLevel>(arg);

            self->obj.ProtectionLevel(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* GattDescriptor_get_AttributeHandle(py::wrapper::Windows::Devices::Bluetooth::GenericAttributeProfile::GattDescriptor* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Bluetooth.GenericAttributeProfile.GattDescriptor", L"AttributeHandle"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.AttributeHandle());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* GattDescriptor_get_Uuid(py::wrapper::Windows::Devices::Bluetooth::GenericAttributeProfile::GattDescriptor* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Bluetooth.GenericAttributeProfile.GattDescriptor", L"Uuid"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Uuid());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_GattDescriptor(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Devices::Bluetooth::GenericAttributeProfile::GattDescriptor>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_GattDescriptor(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Devices::Bluetooth::GenericAttributeProfile::GattDescriptor>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_GattDescriptor[] = {
        { "read_value_async", reinterpret_cast<PyCFunction>(GattDescriptor_ReadValueAsync), METH_VARARGS, nullptr },
        { "write_value_async", reinterpret_cast<PyCFunction>(GattDescriptor_WriteValueAsync), METH_VARARGS, nullptr },
        { "write_value_with_result_async", reinterpret_cast<PyCFunction>(GattDescriptor_WriteValueWithResultAsync), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_GattDescriptor, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_GattDescriptor), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_GattDescriptor[] = {
        { "protection_level", reinterpret_cast<getter>(GattDescriptor_get_ProtectionLevel), reinterpret_cast<setter>(GattDescriptor_put_ProtectionLevel), nullptr, nullptr },
        { "attribute_handle", reinterpret_cast<getter>(GattDescriptor_get_AttributeHandle), nullptr, nullptr, nullptr },
        { "uuid", reinterpret_cast<getter>(GattDescriptor_get_Uuid), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_GattDescriptor[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_GattDescriptor) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_GattDescriptor) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_GattDescriptor) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_GattDescriptor) },
        { },
    };

    static PyType_Spec type_spec_GattDescriptor =
    {
        "winrt._winrt_windows_devices_bluetooth_genericattributeprofile.GattDescriptor",
        sizeof(py::wrapper::Windows::Devices::Bluetooth::GenericAttributeProfile::GattDescriptor),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_GattDescriptor
    };

    static PyGetSetDef getset_GattDescriptor_Static[] = {
        { }
    };

    static PyMethodDef methods_GattDescriptor_Static[] = {
        { "convert_short_id_to_uuid", reinterpret_cast<PyCFunction>(GattDescriptor_ConvertShortIdToUuid), METH_VARARGS, nullptr },
        { }
    };

    static PyType_Slot type_slots_GattDescriptor_Static[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_GattDescriptor_Static) },
        { Py_tp_methods, reinterpret_cast<void*>(methods_GattDescriptor_Static) },
        { }
    };

    static PyType_Spec type_spec_GattDescriptor_Static =
    {
        "winrt._winrt_windows_devices_bluetooth_genericattributeprofile.GattDescriptor_Static",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT,
        type_slots_GattDescriptor_Static
    };

    // ----- GattDescriptorUuids class --------------------

    static PyObject* _new_GattDescriptorUuids(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Devices::Bluetooth::GenericAttributeProfile::GattDescriptorUuids>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Devices::Bluetooth::GenericAttributeProfile::GattDescriptorUuids>::type_name);
        return nullptr;
    }

    static PyObject* GattDescriptorUuids_get_CharacteristicAggregateFormat(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Bluetooth.GenericAttributeProfile.GattDescriptorUuids", L"CharacteristicAggregateFormat"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::Devices::Bluetooth::GenericAttributeProfile::GattDescriptorUuids::CharacteristicAggregateFormat());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* GattDescriptorUuids_get_CharacteristicExtendedProperties(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Bluetooth.GenericAttributeProfile.GattDescriptorUuids", L"CharacteristicExtendedProperties"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::Devices::Bluetooth::GenericAttributeProfile::GattDescriptorUuids::CharacteristicExtendedProperties());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* GattDescriptorUuids_get_CharacteristicPresentationFormat(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Bluetooth.GenericAttributeProfile.GattDescriptorUuids", L"CharacteristicPresentationFormat"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::Devices::Bluetooth::GenericAttributeProfile::GattDescriptorUuids::CharacteristicPresentationFormat());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* GattDescriptorUuids_get_CharacteristicUserDescription(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Bluetooth.GenericAttributeProfile.GattDescriptorUuids", L"CharacteristicUserDescription"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::Devices::Bluetooth::GenericAttributeProfile::GattDescriptorUuids::CharacteristicUserDescription());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* GattDescriptorUuids_get_ClientCharacteristicConfiguration(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Bluetooth.GenericAttributeProfile.GattDescriptorUuids", L"ClientCharacteristicConfiguration"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::Devices::Bluetooth::GenericAttributeProfile::GattDescriptorUuids::ClientCharacteristicConfiguration());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* GattDescriptorUuids_get_ServerCharacteristicConfiguration(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Bluetooth.GenericAttributeProfile.GattDescriptorUuids", L"ServerCharacteristicConfiguration"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::Devices::Bluetooth::GenericAttributeProfile::GattDescriptorUuids::ServerCharacteristicConfiguration());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_GattDescriptorUuids[] = {
        { }
    };

    static PyGetSetDef _getset_GattDescriptorUuids[] = {
        { }
    };

    static PyType_Slot _type_slots_GattDescriptorUuids[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_GattDescriptorUuids) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_GattDescriptorUuids) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_GattDescriptorUuids) },
        { },
    };

    static PyType_Spec type_spec_GattDescriptorUuids =
    {
        "winrt._winrt_windows_devices_bluetooth_genericattributeprofile.GattDescriptorUuids",
        0,
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_GattDescriptorUuids
    };

    static PyGetSetDef getset_GattDescriptorUuids_Static[] = {
        { "characteristic_aggregate_format", reinterpret_cast<getter>(GattDescriptorUuids_get_CharacteristicAggregateFormat), nullptr, nullptr, nullptr },
        { "characteristic_extended_properties", reinterpret_cast<getter>(GattDescriptorUuids_get_CharacteristicExtendedProperties), nullptr, nullptr, nullptr },
        { "characteristic_presentation_format", reinterpret_cast<getter>(GattDescriptorUuids_get_CharacteristicPresentationFormat), nullptr, nullptr, nullptr },
        { "characteristic_user_description", reinterpret_cast<getter>(GattDescriptorUuids_get_CharacteristicUserDescription), nullptr, nullptr, nullptr },
        { "client_characteristic_configuration", reinterpret_cast<getter>(GattDescriptorUuids_get_ClientCharacteristicConfiguration), nullptr, nullptr, nullptr },
        { "server_characteristic_configuration", reinterpret_cast<getter>(GattDescriptorUuids_get_ServerCharacteristicConfiguration), nullptr, nullptr, nullptr },
        { }
    };

    static PyMethodDef methods_GattDescriptorUuids_Static[] = {
        { }
    };

    static PyType_Slot type_slots_GattDescriptorUuids_Static[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_GattDescriptorUuids_Static) },
        { Py_tp_methods, reinterpret_cast<void*>(methods_GattDescriptorUuids_Static) },
        { }
    };

    static PyType_Spec type_spec_GattDescriptorUuids_Static =
    {
        "winrt._winrt_windows_devices_bluetooth_genericattributeprofile.GattDescriptorUuids_Static",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT,
        type_slots_GattDescriptorUuids_Static
    };

    // ----- GattDescriptorsResult class --------------------

    static PyObject* _new_GattDescriptorsResult(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Devices::Bluetooth::GenericAttributeProfile::GattDescriptorsResult>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Devices::Bluetooth::GenericAttributeProfile::GattDescriptorsResult>::type_name);
        return nullptr;
    }

    static void _dealloc_GattDescriptorsResult(py::wrapper::Windows::Devices::Bluetooth::GenericAttributeProfile::GattDescriptorsResult* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* GattDescriptorsResult_get_Descriptors(py::wrapper::Windows::Devices::Bluetooth::GenericAttributeProfile::GattDescriptorsResult* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Bluetooth.GenericAttributeProfile.GattDescriptorsResult", L"Descriptors"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Descriptors());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* GattDescriptorsResult_get_ProtocolError(py::wrapper::Windows::Devices::Bluetooth::GenericAttributeProfile::GattDescriptorsResult* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Bluetooth.GenericAttributeProfile.GattDescriptorsResult", L"ProtocolError"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.ProtocolError());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* GattDescriptorsResult_get_Status(py::wrapper::Windows::Devices::Bluetooth::GenericAttributeProfile::GattDescriptorsResult* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Bluetooth.GenericAttributeProfile.GattDescriptorsResult", L"Status"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Status());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_GattDescriptorsResult(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Devices::Bluetooth::GenericAttributeProfile::GattDescriptorsResult>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_GattDescriptorsResult(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Devices::Bluetooth::GenericAttributeProfile::GattDescriptorsResult>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_GattDescriptorsResult[] = {
        { "_assign_array_", _assign_array_GattDescriptorsResult, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_GattDescriptorsResult), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_GattDescriptorsResult[] = {
        { "descriptors", reinterpret_cast<getter>(GattDescriptorsResult_get_Descriptors), nullptr, nullptr, nullptr },
        { "protocol_error", reinterpret_cast<getter>(GattDescriptorsResult_get_ProtocolError), nullptr, nullptr, nullptr },
        { "status", reinterpret_cast<getter>(GattDescriptorsResult_get_Status), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_GattDescriptorsResult[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_GattDescriptorsResult) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_GattDescriptorsResult) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_GattDescriptorsResult) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_GattDescriptorsResult) },
        { },
    };

    static PyType_Spec type_spec_GattDescriptorsResult =
    {
        "winrt._winrt_windows_devices_bluetooth_genericattributeprofile.GattDescriptorsResult",
        sizeof(py::wrapper::Windows::Devices::Bluetooth::GenericAttributeProfile::GattDescriptorsResult),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_GattDescriptorsResult
    };

    // ----- GattDeviceService class --------------------

    static PyObject* _new_GattDeviceService(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Devices::Bluetooth::GenericAttributeProfile::GattDeviceService>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Devices::Bluetooth::GenericAttributeProfile::GattDeviceService>::type_name);
        return nullptr;
    }

    static void _dealloc_GattDeviceService(py::wrapper::Windows::Devices::Bluetooth::GenericAttributeProfile::GattDeviceService* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* GattDeviceService_Close(py::wrapper::Windows::Devices::Bluetooth::GenericAttributeProfile::GattDeviceService* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.Bluetooth.GenericAttributeProfile.GattDeviceService", L"Close", 0))
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                self->obj.Close();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* GattDeviceService_ConvertShortIdToUuid(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.Bluetooth.GenericAttributeProfile.GattDeviceService", L"ConvertShortIdToUuid", 1))
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<uint16_t>(args, 0);

                return py::convert(winrt::Windows::Devices::Bluetooth::GenericAttributeProfile::GattDeviceService::ConvertShortIdToUuid(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* GattDeviceService_FromIdAsync(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.Bluetooth.GenericAttributeProfile.GattDeviceService", L"FromIdAsync", 1))
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                return py::convert(winrt::Windows::Devices::Bluetooth::GenericAttributeProfile::GattDeviceService::FromIdAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 2)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.Bluetooth.GenericAttributeProfile.GattDeviceService", L"FromIdAsync", 2))
                {
                    py::set_arg_count_version_error(2);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Devices::Bluetooth::GenericAttributeProfile::GattSharingMode>(args, 1);

                return py::convert(winrt::Windows::Devices::Bluetooth::GenericAttributeProfile::GattDeviceService::FromIdAsync(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* GattDeviceService_GetAllCharacteristics(py::wrapper::Windows::Devices::Bluetooth::GenericAttributeProfile::GattDeviceService* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.Bluetooth.GenericAttributeProfile.GattDeviceService", L"GetAllCharacteristics", 0))
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert(self->obj.GetAllCharacteristics());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* GattDeviceService_GetAllIncludedServices(py::wrapper::Windows::Devices::Bluetooth::GenericAttributeProfile::GattDeviceService* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.Bluetooth.GenericAttributeProfile.GattDeviceService", L"GetAllIncludedServices", 0))
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert(self->obj.GetAllIncludedServices());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* GattDeviceService_GetCharacteristics(py::wrapper::Windows::Devices::Bluetooth::GenericAttributeProfile::GattDeviceService* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.Bluetooth.GenericAttributeProfile.GattDeviceService", L"GetCharacteristics", 1))
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::guid>(args, 0);

                return py::convert(self->obj.GetCharacteristics(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* GattDeviceService_GetCharacteristicsAsync(py::wrapper::Windows::Devices::Bluetooth::GenericAttributeProfile::GattDeviceService* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.Bluetooth.GenericAttributeProfile.GattDeviceService", L"GetCharacteristicsAsync", 0))
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert(self->obj.GetCharacteristicsAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 1)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.Bluetooth.GenericAttributeProfile.GattDeviceService", L"GetCharacteristicsAsync", 1))
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Devices::Bluetooth::BluetoothCacheMode>(args, 0);

                return py::convert(self->obj.GetCharacteristicsAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* GattDeviceService_GetCharacteristicsForUuidAsync(py::wrapper::Windows::Devices::Bluetooth::GenericAttributeProfile::GattDeviceService* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.Bluetooth.GenericAttributeProfile.GattDeviceService", L"GetCharacteristicsForUuidAsync", 1))
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::guid>(args, 0);

                return py::convert(self->obj.GetCharacteristicsForUuidAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 2)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.Bluetooth.GenericAttributeProfile.GattDeviceService", L"GetCharacteristicsForUuidAsync", 2))
                {
                    py::set_arg_count_version_error(2);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::guid>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Devices::Bluetooth::BluetoothCacheMode>(args, 1);

                return py::convert(self->obj.GetCharacteristicsForUuidAsync(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* GattDeviceService_GetDeviceSelectorForBluetoothDeviceId(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.Bluetooth.GenericAttributeProfile.GattDeviceService", L"GetDeviceSelectorForBluetoothDeviceId", 1))
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Devices::Bluetooth::BluetoothDeviceId>(args, 0);

                return py::convert(winrt::Windows::Devices::Bluetooth::GenericAttributeProfile::GattDeviceService::GetDeviceSelectorForBluetoothDeviceId(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 2)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.Bluetooth.GenericAttributeProfile.GattDeviceService", L"GetDeviceSelectorForBluetoothDeviceId", 2))
                {
                    py::set_arg_count_version_error(2);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Devices::Bluetooth::BluetoothDeviceId>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Devices::Bluetooth::BluetoothCacheMode>(args, 1);

                return py::convert(winrt::Windows::Devices::Bluetooth::GenericAttributeProfile::GattDeviceService::GetDeviceSelectorForBluetoothDeviceId(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* GattDeviceService_GetDeviceSelectorForBluetoothDeviceIdAndUuid(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.Bluetooth.GenericAttributeProfile.GattDeviceService", L"GetDeviceSelectorForBluetoothDeviceIdAndUuid", 2))
                {
                    py::set_arg_count_version_error(2);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Devices::Bluetooth::BluetoothDeviceId>(args, 0);
                auto param1 = py::convert_to<winrt::guid>(args, 1);

                return py::convert(winrt::Windows::Devices::Bluetooth::GenericAttributeProfile::GattDeviceService::GetDeviceSelectorForBluetoothDeviceIdAndUuid(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 3)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.Bluetooth.GenericAttributeProfile.GattDeviceService", L"GetDeviceSelectorForBluetoothDeviceIdAndUuid", 3))
                {
                    py::set_arg_count_version_error(3);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Devices::Bluetooth::BluetoothDeviceId>(args, 0);
                auto param1 = py::convert_to<winrt::guid>(args, 1);
                auto param2 = py::convert_to<winrt::Windows::Devices::Bluetooth::BluetoothCacheMode>(args, 2);

                return py::convert(winrt::Windows::Devices::Bluetooth::GenericAttributeProfile::GattDeviceService::GetDeviceSelectorForBluetoothDeviceIdAndUuid(param0, param1, param2));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* GattDeviceService_GetDeviceSelectorFromShortId(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.Bluetooth.GenericAttributeProfile.GattDeviceService", L"GetDeviceSelectorFromShortId", 1))
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<uint16_t>(args, 0);

                return py::convert(winrt::Windows::Devices::Bluetooth::GenericAttributeProfile::GattDeviceService::GetDeviceSelectorFromShortId(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* GattDeviceService_GetDeviceSelectorFromUuid(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.Bluetooth.GenericAttributeProfile.GattDeviceService", L"GetDeviceSelectorFromUuid", 1))
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::guid>(args, 0);

                return py::convert(winrt::Windows::Devices::Bluetooth::GenericAttributeProfile::GattDeviceService::GetDeviceSelectorFromUuid(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* GattDeviceService_GetIncludedServices(py::wrapper::Windows::Devices::Bluetooth::GenericAttributeProfile::GattDeviceService* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.Bluetooth.GenericAttributeProfile.GattDeviceService", L"GetIncludedServices", 1))
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::guid>(args, 0);

                return py::convert(self->obj.GetIncludedServices(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* GattDeviceService_GetIncludedServicesAsync(py::wrapper::Windows::Devices::Bluetooth::GenericAttributeProfile::GattDeviceService* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.Bluetooth.GenericAttributeProfile.GattDeviceService", L"GetIncludedServicesAsync", 0))
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert(self->obj.GetIncludedServicesAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 1)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.Bluetooth.GenericAttributeProfile.GattDeviceService", L"GetIncludedServicesAsync", 1))
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Devices::Bluetooth::BluetoothCacheMode>(args, 0);

                return py::convert(self->obj.GetIncludedServicesAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* GattDeviceService_GetIncludedServicesForUuidAsync(py::wrapper::Windows::Devices::Bluetooth::GenericAttributeProfile::GattDeviceService* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.Bluetooth.GenericAttributeProfile.GattDeviceService", L"GetIncludedServicesForUuidAsync", 1))
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::guid>(args, 0);

                return py::convert(self->obj.GetIncludedServicesForUuidAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 2)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.Bluetooth.GenericAttributeProfile.GattDeviceService", L"GetIncludedServicesForUuidAsync", 2))
                {
                    py::set_arg_count_version_error(2);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::guid>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Devices::Bluetooth::BluetoothCacheMode>(args, 1);

                return py::convert(self->obj.GetIncludedServicesForUuidAsync(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* GattDeviceService_OpenAsync(py::wrapper::Windows::Devices::Bluetooth::GenericAttributeProfile::GattDeviceService* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.Bluetooth.GenericAttributeProfile.GattDeviceService", L"OpenAsync", 1))
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Devices::Bluetooth::GenericAttributeProfile::GattSharingMode>(args, 0);

                return py::convert(self->obj.OpenAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* GattDeviceService_RequestAccessAsync(py::wrapper::Windows::Devices::Bluetooth::GenericAttributeProfile::GattDeviceService* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.Bluetooth.GenericAttributeProfile.GattDeviceService", L"RequestAccessAsync", 0))
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert(self->obj.RequestAccessAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* GattDeviceService_get_AttributeHandle(py::wrapper::Windows::Devices::Bluetooth::GenericAttributeProfile::GattDeviceService* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Bluetooth.GenericAttributeProfile.GattDeviceService", L"AttributeHandle"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.AttributeHandle());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* GattDeviceService_get_DeviceId(py::wrapper::Windows::Devices::Bluetooth::GenericAttributeProfile::GattDeviceService* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Bluetooth.GenericAttributeProfile.GattDeviceService", L"DeviceId"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.DeviceId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* GattDeviceService_get_Uuid(py::wrapper::Windows::Devices::Bluetooth::GenericAttributeProfile::GattDeviceService* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Bluetooth.GenericAttributeProfile.GattDeviceService", L"Uuid"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Uuid());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* GattDeviceService_get_Device(py::wrapper::Windows::Devices::Bluetooth::GenericAttributeProfile::GattDeviceService* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Bluetooth.GenericAttributeProfile.GattDeviceService", L"Device"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Device());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* GattDeviceService_get_ParentServices(py::wrapper::Windows::Devices::Bluetooth::GenericAttributeProfile::GattDeviceService* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Bluetooth.GenericAttributeProfile.GattDeviceService", L"ParentServices"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.ParentServices());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* GattDeviceService_get_DeviceAccessInformation(py::wrapper::Windows::Devices::Bluetooth::GenericAttributeProfile::GattDeviceService* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Bluetooth.GenericAttributeProfile.GattDeviceService", L"DeviceAccessInformation"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.DeviceAccessInformation());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* GattDeviceService_get_Session(py::wrapper::Windows::Devices::Bluetooth::GenericAttributeProfile::GattDeviceService* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Bluetooth.GenericAttributeProfile.GattDeviceService", L"Session"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Session());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* GattDeviceService_get_SharingMode(py::wrapper::Windows::Devices::Bluetooth::GenericAttributeProfile::GattDeviceService* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Bluetooth.GenericAttributeProfile.GattDeviceService", L"SharingMode"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.SharingMode());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_GattDeviceService(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Devices::Bluetooth::GenericAttributeProfile::GattDeviceService>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_GattDeviceService(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Devices::Bluetooth::GenericAttributeProfile::GattDeviceService>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _enter_GattDeviceService(py::wrapper::Windows::Devices::Bluetooth::GenericAttributeProfile::GattDeviceService* self, PyObject* /*unused*/) noexcept
    {
        return Py_NewRef(self);
    }

    static PyObject* _exit_GattDeviceService(py::wrapper::Windows::Devices::Bluetooth::GenericAttributeProfile::GattDeviceService* self, PyObject* /*unused*/) noexcept
    {
        try
        {
            self->obj.Close();
            Py_RETURN_FALSE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_GattDeviceService[] = {
        { "close", reinterpret_cast<PyCFunction>(GattDeviceService_Close), METH_VARARGS, nullptr },
        { "get_all_characteristics", reinterpret_cast<PyCFunction>(GattDeviceService_GetAllCharacteristics), METH_VARARGS, nullptr },
        { "get_all_included_services", reinterpret_cast<PyCFunction>(GattDeviceService_GetAllIncludedServices), METH_VARARGS, nullptr },
        { "get_characteristics", reinterpret_cast<PyCFunction>(GattDeviceService_GetCharacteristics), METH_VARARGS, nullptr },
        { "get_characteristics_async", reinterpret_cast<PyCFunction>(GattDeviceService_GetCharacteristicsAsync), METH_VARARGS, nullptr },
        { "get_characteristics_for_uuid_async", reinterpret_cast<PyCFunction>(GattDeviceService_GetCharacteristicsForUuidAsync), METH_VARARGS, nullptr },
        { "get_included_services", reinterpret_cast<PyCFunction>(GattDeviceService_GetIncludedServices), METH_VARARGS, nullptr },
        { "get_included_services_async", reinterpret_cast<PyCFunction>(GattDeviceService_GetIncludedServicesAsync), METH_VARARGS, nullptr },
        { "get_included_services_for_uuid_async", reinterpret_cast<PyCFunction>(GattDeviceService_GetIncludedServicesForUuidAsync), METH_VARARGS, nullptr },
        { "open_async", reinterpret_cast<PyCFunction>(GattDeviceService_OpenAsync), METH_VARARGS, nullptr },
        { "request_access_async", reinterpret_cast<PyCFunction>(GattDeviceService_RequestAccessAsync), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_GattDeviceService, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_GattDeviceService), METH_O | METH_STATIC, nullptr },
        { "__enter__", reinterpret_cast<PyCFunction>(_enter_GattDeviceService), METH_NOARGS, nullptr },
        { "__exit__", reinterpret_cast<PyCFunction>(_exit_GattDeviceService), METH_VARARGS, nullptr },
        { }
    };

    static PyGetSetDef _getset_GattDeviceService[] = {
        { "attribute_handle", reinterpret_cast<getter>(GattDeviceService_get_AttributeHandle), nullptr, nullptr, nullptr },
        { "device_id", reinterpret_cast<getter>(GattDeviceService_get_DeviceId), nullptr, nullptr, nullptr },
        { "uuid", reinterpret_cast<getter>(GattDeviceService_get_Uuid), nullptr, nullptr, nullptr },
        { "device", reinterpret_cast<getter>(GattDeviceService_get_Device), nullptr, nullptr, nullptr },
        { "parent_services", reinterpret_cast<getter>(GattDeviceService_get_ParentServices), nullptr, nullptr, nullptr },
        { "device_access_information", reinterpret_cast<getter>(GattDeviceService_get_DeviceAccessInformation), nullptr, nullptr, nullptr },
        { "session", reinterpret_cast<getter>(GattDeviceService_get_Session), nullptr, nullptr, nullptr },
        { "sharing_mode", reinterpret_cast<getter>(GattDeviceService_get_SharingMode), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_GattDeviceService[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_GattDeviceService) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_GattDeviceService) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_GattDeviceService) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_GattDeviceService) },
        { },
    };

    static PyType_Spec type_spec_GattDeviceService =
    {
        "winrt._winrt_windows_devices_bluetooth_genericattributeprofile.GattDeviceService",
        sizeof(py::wrapper::Windows::Devices::Bluetooth::GenericAttributeProfile::GattDeviceService),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_GattDeviceService
    };

    static PyGetSetDef getset_GattDeviceService_Static[] = {
        { }
    };

    static PyMethodDef methods_GattDeviceService_Static[] = {
        { "convert_short_id_to_uuid", reinterpret_cast<PyCFunction>(GattDeviceService_ConvertShortIdToUuid), METH_VARARGS, nullptr },
        { "from_id_async", reinterpret_cast<PyCFunction>(GattDeviceService_FromIdAsync), METH_VARARGS, nullptr },
        { "get_device_selector_for_bluetooth_device_id", reinterpret_cast<PyCFunction>(GattDeviceService_GetDeviceSelectorForBluetoothDeviceId), METH_VARARGS, nullptr },
        { "get_device_selector_for_bluetooth_device_id_and_uuid", reinterpret_cast<PyCFunction>(GattDeviceService_GetDeviceSelectorForBluetoothDeviceIdAndUuid), METH_VARARGS, nullptr },
        { "get_device_selector_from_short_id", reinterpret_cast<PyCFunction>(GattDeviceService_GetDeviceSelectorFromShortId), METH_VARARGS, nullptr },
        { "get_device_selector_from_uuid", reinterpret_cast<PyCFunction>(GattDeviceService_GetDeviceSelectorFromUuid), METH_VARARGS, nullptr },
        { }
    };

    static PyType_Slot type_slots_GattDeviceService_Static[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_GattDeviceService_Static) },
        { Py_tp_methods, reinterpret_cast<void*>(methods_GattDeviceService_Static) },
        { }
    };

    static PyType_Spec type_spec_GattDeviceService_Static =
    {
        "winrt._winrt_windows_devices_bluetooth_genericattributeprofile.GattDeviceService_Static",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT,
        type_slots_GattDeviceService_Static
    };

    // ----- GattDeviceServicesResult class --------------------

    static PyObject* _new_GattDeviceServicesResult(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Devices::Bluetooth::GenericAttributeProfile::GattDeviceServicesResult>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Devices::Bluetooth::GenericAttributeProfile::GattDeviceServicesResult>::type_name);
        return nullptr;
    }

    static void _dealloc_GattDeviceServicesResult(py::wrapper::Windows::Devices::Bluetooth::GenericAttributeProfile::GattDeviceServicesResult* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* GattDeviceServicesResult_get_ProtocolError(py::wrapper::Windows::Devices::Bluetooth::GenericAttributeProfile::GattDeviceServicesResult* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Bluetooth.GenericAttributeProfile.GattDeviceServicesResult", L"ProtocolError"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.ProtocolError());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* GattDeviceServicesResult_get_Services(py::wrapper::Windows::Devices::Bluetooth::GenericAttributeProfile::GattDeviceServicesResult* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Bluetooth.GenericAttributeProfile.GattDeviceServicesResult", L"Services"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Services());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* GattDeviceServicesResult_get_Status(py::wrapper::Windows::Devices::Bluetooth::GenericAttributeProfile::GattDeviceServicesResult* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Bluetooth.GenericAttributeProfile.GattDeviceServicesResult", L"Status"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Status());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_GattDeviceServicesResult(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Devices::Bluetooth::GenericAttributeProfile::GattDeviceServicesResult>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_GattDeviceServicesResult(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Devices::Bluetooth::GenericAttributeProfile::GattDeviceServicesResult>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_GattDeviceServicesResult[] = {
        { "_assign_array_", _assign_array_GattDeviceServicesResult, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_GattDeviceServicesResult), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_GattDeviceServicesResult[] = {
        { "protocol_error", reinterpret_cast<getter>(GattDeviceServicesResult_get_ProtocolError), nullptr, nullptr, nullptr },
        { "services", reinterpret_cast<getter>(GattDeviceServicesResult_get_Services), nullptr, nullptr, nullptr },
        { "status", reinterpret_cast<getter>(GattDeviceServicesResult_get_Status), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_GattDeviceServicesResult[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_GattDeviceServicesResult) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_GattDeviceServicesResult) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_GattDeviceServicesResult) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_GattDeviceServicesResult) },
        { },
    };

    static PyType_Spec type_spec_GattDeviceServicesResult =
    {
        "winrt._winrt_windows_devices_bluetooth_genericattributeprofile.GattDeviceServicesResult",
        sizeof(py::wrapper::Windows::Devices::Bluetooth::GenericAttributeProfile::GattDeviceServicesResult),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_GattDeviceServicesResult
    };

    // ----- GattLocalCharacteristic class --------------------

    static PyObject* _new_GattLocalCharacteristic(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Devices::Bluetooth::GenericAttributeProfile::GattLocalCharacteristic>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Devices::Bluetooth::GenericAttributeProfile::GattLocalCharacteristic>::type_name);
        return nullptr;
    }

    static void _dealloc_GattLocalCharacteristic(py::wrapper::Windows::Devices::Bluetooth::GenericAttributeProfile::GattLocalCharacteristic* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* GattLocalCharacteristic_CreateDescriptorAsync(py::wrapper::Windows::Devices::Bluetooth::GenericAttributeProfile::GattLocalCharacteristic* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.Bluetooth.GenericAttributeProfile.GattLocalCharacteristic", L"CreateDescriptorAsync", 2))
                {
                    py::set_arg_count_version_error(2);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::guid>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Devices::Bluetooth::GenericAttributeProfile::GattLocalDescriptorParameters>(args, 1);

                return py::convert(self->obj.CreateDescriptorAsync(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* GattLocalCharacteristic_NotifyValueAsync(py::wrapper::Windows::Devices::Bluetooth::GenericAttributeProfile::GattLocalCharacteristic* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.Bluetooth.GenericAttributeProfile.GattLocalCharacteristic", L"NotifyValueAsync", 1))
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Storage::Streams::IBuffer>(args, 0);

                return py::convert(self->obj.NotifyValueAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 2)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.Bluetooth.GenericAttributeProfile.GattLocalCharacteristic", L"NotifyValueAsync", 2))
                {
                    py::set_arg_count_version_error(2);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Storage::Streams::IBuffer>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Devices::Bluetooth::GenericAttributeProfile::GattSubscribedClient>(args, 1);

                return py::convert(self->obj.NotifyValueAsync(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* GattLocalCharacteristic_get_CharacteristicProperties(py::wrapper::Windows::Devices::Bluetooth::GenericAttributeProfile::GattLocalCharacteristic* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Bluetooth.GenericAttributeProfile.GattLocalCharacteristic", L"CharacteristicProperties"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.CharacteristicProperties());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* GattLocalCharacteristic_get_Descriptors(py::wrapper::Windows::Devices::Bluetooth::GenericAttributeProfile::GattLocalCharacteristic* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Bluetooth.GenericAttributeProfile.GattLocalCharacteristic", L"Descriptors"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Descriptors());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* GattLocalCharacteristic_get_PresentationFormats(py::wrapper::Windows::Devices::Bluetooth::GenericAttributeProfile::GattLocalCharacteristic* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Bluetooth.GenericAttributeProfile.GattLocalCharacteristic", L"PresentationFormats"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.PresentationFormats());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* GattLocalCharacteristic_get_ReadProtectionLevel(py::wrapper::Windows::Devices::Bluetooth::GenericAttributeProfile::GattLocalCharacteristic* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Bluetooth.GenericAttributeProfile.GattLocalCharacteristic", L"ReadProtectionLevel"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.ReadProtectionLevel());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* GattLocalCharacteristic_get_StaticValue(py::wrapper::Windows::Devices::Bluetooth::GenericAttributeProfile::GattLocalCharacteristic* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Bluetooth.GenericAttributeProfile.GattLocalCharacteristic", L"StaticValue"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.StaticValue());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* GattLocalCharacteristic_get_SubscribedClients(py::wrapper::Windows::Devices::Bluetooth::GenericAttributeProfile::GattLocalCharacteristic* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Bluetooth.GenericAttributeProfile.GattLocalCharacteristic", L"SubscribedClients"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.SubscribedClients());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* GattLocalCharacteristic_get_UserDescription(py::wrapper::Windows::Devices::Bluetooth::GenericAttributeProfile::GattLocalCharacteristic* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Bluetooth.GenericAttributeProfile.GattLocalCharacteristic", L"UserDescription"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.UserDescription());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* GattLocalCharacteristic_get_Uuid(py::wrapper::Windows::Devices::Bluetooth::GenericAttributeProfile::GattLocalCharacteristic* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Bluetooth.GenericAttributeProfile.GattLocalCharacteristic", L"Uuid"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Uuid());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* GattLocalCharacteristic_get_WriteProtectionLevel(py::wrapper::Windows::Devices::Bluetooth::GenericAttributeProfile::GattLocalCharacteristic* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Bluetooth.GenericAttributeProfile.GattLocalCharacteristic", L"WriteProtectionLevel"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.WriteProtectionLevel());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* GattLocalCharacteristic_add_ReadRequested(py::wrapper::Windows::Devices::Bluetooth::GenericAttributeProfile::GattLocalCharacteristic* self, PyObject* arg) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Devices.Bluetooth.GenericAttributeProfile.GattLocalCharacteristic", L"ReadRequested"))
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Devices::Bluetooth::GenericAttributeProfile::GattLocalCharacteristic, winrt::Windows::Devices::Bluetooth::GenericAttributeProfile::GattReadRequestedEventArgs>>(arg);

            return py::convert(self->obj.ReadRequested(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* GattLocalCharacteristic_remove_ReadRequested(py::wrapper::Windows::Devices::Bluetooth::GenericAttributeProfile::GattLocalCharacteristic* self, PyObject* arg) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Devices.Bluetooth.GenericAttributeProfile.GattLocalCharacteristic", L"ReadRequested"))
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.ReadRequested(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* GattLocalCharacteristic_add_SubscribedClientsChanged(py::wrapper::Windows::Devices::Bluetooth::GenericAttributeProfile::GattLocalCharacteristic* self, PyObject* arg) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Devices.Bluetooth.GenericAttributeProfile.GattLocalCharacteristic", L"SubscribedClientsChanged"))
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Devices::Bluetooth::GenericAttributeProfile::GattLocalCharacteristic, winrt::Windows::Foundation::IInspectable>>(arg);

            return py::convert(self->obj.SubscribedClientsChanged(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* GattLocalCharacteristic_remove_SubscribedClientsChanged(py::wrapper::Windows::Devices::Bluetooth::GenericAttributeProfile::GattLocalCharacteristic* self, PyObject* arg) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Devices.Bluetooth.GenericAttributeProfile.GattLocalCharacteristic", L"SubscribedClientsChanged"))
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.SubscribedClientsChanged(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* GattLocalCharacteristic_add_WriteRequested(py::wrapper::Windows::Devices::Bluetooth::GenericAttributeProfile::GattLocalCharacteristic* self, PyObject* arg) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Devices.Bluetooth.GenericAttributeProfile.GattLocalCharacteristic", L"WriteRequested"))
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Devices::Bluetooth::GenericAttributeProfile::GattLocalCharacteristic, winrt::Windows::Devices::Bluetooth::GenericAttributeProfile::GattWriteRequestedEventArgs>>(arg);

            return py::convert(self->obj.WriteRequested(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* GattLocalCharacteristic_remove_WriteRequested(py::wrapper::Windows::Devices::Bluetooth::GenericAttributeProfile::GattLocalCharacteristic* self, PyObject* arg) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Devices.Bluetooth.GenericAttributeProfile.GattLocalCharacteristic", L"WriteRequested"))
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.WriteRequested(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_GattLocalCharacteristic(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Devices::Bluetooth::GenericAttributeProfile::GattLocalCharacteristic>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_GattLocalCharacteristic(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Devices::Bluetooth::GenericAttributeProfile::GattLocalCharacteristic>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_GattLocalCharacteristic[] = {
        { "create_descriptor_async", reinterpret_cast<PyCFunction>(GattLocalCharacteristic_CreateDescriptorAsync), METH_VARARGS, nullptr },
        { "notify_value_async", reinterpret_cast<PyCFunction>(GattLocalCharacteristic_NotifyValueAsync), METH_VARARGS, nullptr },
        { "add_read_requested", reinterpret_cast<PyCFunction>(GattLocalCharacteristic_add_ReadRequested), METH_O, nullptr },
        { "remove_read_requested", reinterpret_cast<PyCFunction>(GattLocalCharacteristic_remove_ReadRequested), METH_O, nullptr },
        { "add_subscribed_clients_changed", reinterpret_cast<PyCFunction>(GattLocalCharacteristic_add_SubscribedClientsChanged), METH_O, nullptr },
        { "remove_subscribed_clients_changed", reinterpret_cast<PyCFunction>(GattLocalCharacteristic_remove_SubscribedClientsChanged), METH_O, nullptr },
        { "add_write_requested", reinterpret_cast<PyCFunction>(GattLocalCharacteristic_add_WriteRequested), METH_O, nullptr },
        { "remove_write_requested", reinterpret_cast<PyCFunction>(GattLocalCharacteristic_remove_WriteRequested), METH_O, nullptr },
        { "_assign_array_", _assign_array_GattLocalCharacteristic, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_GattLocalCharacteristic), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_GattLocalCharacteristic[] = {
        { "characteristic_properties", reinterpret_cast<getter>(GattLocalCharacteristic_get_CharacteristicProperties), nullptr, nullptr, nullptr },
        { "descriptors", reinterpret_cast<getter>(GattLocalCharacteristic_get_Descriptors), nullptr, nullptr, nullptr },
        { "presentation_formats", reinterpret_cast<getter>(GattLocalCharacteristic_get_PresentationFormats), nullptr, nullptr, nullptr },
        { "read_protection_level", reinterpret_cast<getter>(GattLocalCharacteristic_get_ReadProtectionLevel), nullptr, nullptr, nullptr },
        { "static_value", reinterpret_cast<getter>(GattLocalCharacteristic_get_StaticValue), nullptr, nullptr, nullptr },
        { "subscribed_clients", reinterpret_cast<getter>(GattLocalCharacteristic_get_SubscribedClients), nullptr, nullptr, nullptr },
        { "user_description", reinterpret_cast<getter>(GattLocalCharacteristic_get_UserDescription), nullptr, nullptr, nullptr },
        { "uuid", reinterpret_cast<getter>(GattLocalCharacteristic_get_Uuid), nullptr, nullptr, nullptr },
        { "write_protection_level", reinterpret_cast<getter>(GattLocalCharacteristic_get_WriteProtectionLevel), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_GattLocalCharacteristic[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_GattLocalCharacteristic) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_GattLocalCharacteristic) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_GattLocalCharacteristic) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_GattLocalCharacteristic) },
        { },
    };

    static PyType_Spec type_spec_GattLocalCharacteristic =
    {
        "winrt._winrt_windows_devices_bluetooth_genericattributeprofile.GattLocalCharacteristic",
        sizeof(py::wrapper::Windows::Devices::Bluetooth::GenericAttributeProfile::GattLocalCharacteristic),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_GattLocalCharacteristic
    };

    // ----- GattLocalCharacteristicParameters class --------------------

    static PyObject* _new_GattLocalCharacteristicParameters(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 0)
        {
            try
            {
                winrt::Windows::Devices::Bluetooth::GenericAttributeProfile::GattLocalCharacteristicParameters instance{  };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_GattLocalCharacteristicParameters(py::wrapper::Windows::Devices::Bluetooth::GenericAttributeProfile::GattLocalCharacteristicParameters* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* GattLocalCharacteristicParameters_get_WriteProtectionLevel(py::wrapper::Windows::Devices::Bluetooth::GenericAttributeProfile::GattLocalCharacteristicParameters* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Bluetooth.GenericAttributeProfile.GattLocalCharacteristicParameters", L"WriteProtectionLevel"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.WriteProtectionLevel());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int GattLocalCharacteristicParameters_put_WriteProtectionLevel(py::wrapper::Windows::Devices::Bluetooth::GenericAttributeProfile::GattLocalCharacteristicParameters* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Bluetooth.GenericAttributeProfile.GattLocalCharacteristicParameters", L"WriteProtectionLevel"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::Devices::Bluetooth::GenericAttributeProfile::GattProtectionLevel>(arg);

            self->obj.WriteProtectionLevel(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* GattLocalCharacteristicParameters_get_UserDescription(py::wrapper::Windows::Devices::Bluetooth::GenericAttributeProfile::GattLocalCharacteristicParameters* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Bluetooth.GenericAttributeProfile.GattLocalCharacteristicParameters", L"UserDescription"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.UserDescription());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int GattLocalCharacteristicParameters_put_UserDescription(py::wrapper::Windows::Devices::Bluetooth::GenericAttributeProfile::GattLocalCharacteristicParameters* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Bluetooth.GenericAttributeProfile.GattLocalCharacteristicParameters", L"UserDescription"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.UserDescription(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* GattLocalCharacteristicParameters_get_StaticValue(py::wrapper::Windows::Devices::Bluetooth::GenericAttributeProfile::GattLocalCharacteristicParameters* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Bluetooth.GenericAttributeProfile.GattLocalCharacteristicParameters", L"StaticValue"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.StaticValue());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int GattLocalCharacteristicParameters_put_StaticValue(py::wrapper::Windows::Devices::Bluetooth::GenericAttributeProfile::GattLocalCharacteristicParameters* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Bluetooth.GenericAttributeProfile.GattLocalCharacteristicParameters", L"StaticValue"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::Storage::Streams::IBuffer>(arg);

            self->obj.StaticValue(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* GattLocalCharacteristicParameters_get_ReadProtectionLevel(py::wrapper::Windows::Devices::Bluetooth::GenericAttributeProfile::GattLocalCharacteristicParameters* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Bluetooth.GenericAttributeProfile.GattLocalCharacteristicParameters", L"ReadProtectionLevel"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.ReadProtectionLevel());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int GattLocalCharacteristicParameters_put_ReadProtectionLevel(py::wrapper::Windows::Devices::Bluetooth::GenericAttributeProfile::GattLocalCharacteristicParameters* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Bluetooth.GenericAttributeProfile.GattLocalCharacteristicParameters", L"ReadProtectionLevel"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::Devices::Bluetooth::GenericAttributeProfile::GattProtectionLevel>(arg);

            self->obj.ReadProtectionLevel(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* GattLocalCharacteristicParameters_get_CharacteristicProperties(py::wrapper::Windows::Devices::Bluetooth::GenericAttributeProfile::GattLocalCharacteristicParameters* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Bluetooth.GenericAttributeProfile.GattLocalCharacteristicParameters", L"CharacteristicProperties"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.CharacteristicProperties());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int GattLocalCharacteristicParameters_put_CharacteristicProperties(py::wrapper::Windows::Devices::Bluetooth::GenericAttributeProfile::GattLocalCharacteristicParameters* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Bluetooth.GenericAttributeProfile.GattLocalCharacteristicParameters", L"CharacteristicProperties"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::Devices::Bluetooth::GenericAttributeProfile::GattCharacteristicProperties>(arg);

            self->obj.CharacteristicProperties(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* GattLocalCharacteristicParameters_get_PresentationFormats(py::wrapper::Windows::Devices::Bluetooth::GenericAttributeProfile::GattLocalCharacteristicParameters* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Bluetooth.GenericAttributeProfile.GattLocalCharacteristicParameters", L"PresentationFormats"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.PresentationFormats());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_GattLocalCharacteristicParameters(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Devices::Bluetooth::GenericAttributeProfile::GattLocalCharacteristicParameters>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_GattLocalCharacteristicParameters(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Devices::Bluetooth::GenericAttributeProfile::GattLocalCharacteristicParameters>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_GattLocalCharacteristicParameters[] = {
        { "_assign_array_", _assign_array_GattLocalCharacteristicParameters, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_GattLocalCharacteristicParameters), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_GattLocalCharacteristicParameters[] = {
        { "write_protection_level", reinterpret_cast<getter>(GattLocalCharacteristicParameters_get_WriteProtectionLevel), reinterpret_cast<setter>(GattLocalCharacteristicParameters_put_WriteProtectionLevel), nullptr, nullptr },
        { "user_description", reinterpret_cast<getter>(GattLocalCharacteristicParameters_get_UserDescription), reinterpret_cast<setter>(GattLocalCharacteristicParameters_put_UserDescription), nullptr, nullptr },
        { "static_value", reinterpret_cast<getter>(GattLocalCharacteristicParameters_get_StaticValue), reinterpret_cast<setter>(GattLocalCharacteristicParameters_put_StaticValue), nullptr, nullptr },
        { "read_protection_level", reinterpret_cast<getter>(GattLocalCharacteristicParameters_get_ReadProtectionLevel), reinterpret_cast<setter>(GattLocalCharacteristicParameters_put_ReadProtectionLevel), nullptr, nullptr },
        { "characteristic_properties", reinterpret_cast<getter>(GattLocalCharacteristicParameters_get_CharacteristicProperties), reinterpret_cast<setter>(GattLocalCharacteristicParameters_put_CharacteristicProperties), nullptr, nullptr },
        { "presentation_formats", reinterpret_cast<getter>(GattLocalCharacteristicParameters_get_PresentationFormats), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_GattLocalCharacteristicParameters[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_GattLocalCharacteristicParameters) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_GattLocalCharacteristicParameters) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_GattLocalCharacteristicParameters) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_GattLocalCharacteristicParameters) },
        { },
    };

    static PyType_Spec type_spec_GattLocalCharacteristicParameters =
    {
        "winrt._winrt_windows_devices_bluetooth_genericattributeprofile.GattLocalCharacteristicParameters",
        sizeof(py::wrapper::Windows::Devices::Bluetooth::GenericAttributeProfile::GattLocalCharacteristicParameters),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_GattLocalCharacteristicParameters
    };

    // ----- GattLocalCharacteristicResult class --------------------

    static PyObject* _new_GattLocalCharacteristicResult(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Devices::Bluetooth::GenericAttributeProfile::GattLocalCharacteristicResult>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Devices::Bluetooth::GenericAttributeProfile::GattLocalCharacteristicResult>::type_name);
        return nullptr;
    }

    static void _dealloc_GattLocalCharacteristicResult(py::wrapper::Windows::Devices::Bluetooth::GenericAttributeProfile::GattLocalCharacteristicResult* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* GattLocalCharacteristicResult_get_Characteristic(py::wrapper::Windows::Devices::Bluetooth::GenericAttributeProfile::GattLocalCharacteristicResult* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Bluetooth.GenericAttributeProfile.GattLocalCharacteristicResult", L"Characteristic"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Characteristic());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* GattLocalCharacteristicResult_get_Error(py::wrapper::Windows::Devices::Bluetooth::GenericAttributeProfile::GattLocalCharacteristicResult* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Bluetooth.GenericAttributeProfile.GattLocalCharacteristicResult", L"Error"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Error());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_GattLocalCharacteristicResult(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Devices::Bluetooth::GenericAttributeProfile::GattLocalCharacteristicResult>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_GattLocalCharacteristicResult(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Devices::Bluetooth::GenericAttributeProfile::GattLocalCharacteristicResult>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_GattLocalCharacteristicResult[] = {
        { "_assign_array_", _assign_array_GattLocalCharacteristicResult, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_GattLocalCharacteristicResult), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_GattLocalCharacteristicResult[] = {
        { "characteristic", reinterpret_cast<getter>(GattLocalCharacteristicResult_get_Characteristic), nullptr, nullptr, nullptr },
        { "error", reinterpret_cast<getter>(GattLocalCharacteristicResult_get_Error), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_GattLocalCharacteristicResult[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_GattLocalCharacteristicResult) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_GattLocalCharacteristicResult) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_GattLocalCharacteristicResult) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_GattLocalCharacteristicResult) },
        { },
    };

    static PyType_Spec type_spec_GattLocalCharacteristicResult =
    {
        "winrt._winrt_windows_devices_bluetooth_genericattributeprofile.GattLocalCharacteristicResult",
        sizeof(py::wrapper::Windows::Devices::Bluetooth::GenericAttributeProfile::GattLocalCharacteristicResult),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_GattLocalCharacteristicResult
    };

    // ----- GattLocalDescriptor class --------------------

    static PyObject* _new_GattLocalDescriptor(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Devices::Bluetooth::GenericAttributeProfile::GattLocalDescriptor>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Devices::Bluetooth::GenericAttributeProfile::GattLocalDescriptor>::type_name);
        return nullptr;
    }

    static void _dealloc_GattLocalDescriptor(py::wrapper::Windows::Devices::Bluetooth::GenericAttributeProfile::GattLocalDescriptor* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* GattLocalDescriptor_get_ReadProtectionLevel(py::wrapper::Windows::Devices::Bluetooth::GenericAttributeProfile::GattLocalDescriptor* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Bluetooth.GenericAttributeProfile.GattLocalDescriptor", L"ReadProtectionLevel"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.ReadProtectionLevel());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* GattLocalDescriptor_get_StaticValue(py::wrapper::Windows::Devices::Bluetooth::GenericAttributeProfile::GattLocalDescriptor* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Bluetooth.GenericAttributeProfile.GattLocalDescriptor", L"StaticValue"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.StaticValue());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* GattLocalDescriptor_get_Uuid(py::wrapper::Windows::Devices::Bluetooth::GenericAttributeProfile::GattLocalDescriptor* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Bluetooth.GenericAttributeProfile.GattLocalDescriptor", L"Uuid"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Uuid());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* GattLocalDescriptor_get_WriteProtectionLevel(py::wrapper::Windows::Devices::Bluetooth::GenericAttributeProfile::GattLocalDescriptor* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Bluetooth.GenericAttributeProfile.GattLocalDescriptor", L"WriteProtectionLevel"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.WriteProtectionLevel());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* GattLocalDescriptor_add_ReadRequested(py::wrapper::Windows::Devices::Bluetooth::GenericAttributeProfile::GattLocalDescriptor* self, PyObject* arg) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Devices.Bluetooth.GenericAttributeProfile.GattLocalDescriptor", L"ReadRequested"))
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Devices::Bluetooth::GenericAttributeProfile::GattLocalDescriptor, winrt::Windows::Devices::Bluetooth::GenericAttributeProfile::GattReadRequestedEventArgs>>(arg);

            return py::convert(self->obj.ReadRequested(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* GattLocalDescriptor_remove_ReadRequested(py::wrapper::Windows::Devices::Bluetooth::GenericAttributeProfile::GattLocalDescriptor* self, PyObject* arg) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Devices.Bluetooth.GenericAttributeProfile.GattLocalDescriptor", L"ReadRequested"))
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.ReadRequested(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* GattLocalDescriptor_add_WriteRequested(py::wrapper::Windows::Devices::Bluetooth::GenericAttributeProfile::GattLocalDescriptor* self, PyObject* arg) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Devices.Bluetooth.GenericAttributeProfile.GattLocalDescriptor", L"WriteRequested"))
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Devices::Bluetooth::GenericAttributeProfile::GattLocalDescriptor, winrt::Windows::Devices::Bluetooth::GenericAttributeProfile::GattWriteRequestedEventArgs>>(arg);

            return py::convert(self->obj.WriteRequested(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* GattLocalDescriptor_remove_WriteRequested(py::wrapper::Windows::Devices::Bluetooth::GenericAttributeProfile::GattLocalDescriptor* self, PyObject* arg) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Devices.Bluetooth.GenericAttributeProfile.GattLocalDescriptor", L"WriteRequested"))
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.WriteRequested(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_GattLocalDescriptor(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Devices::Bluetooth::GenericAttributeProfile::GattLocalDescriptor>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_GattLocalDescriptor(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Devices::Bluetooth::GenericAttributeProfile::GattLocalDescriptor>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_GattLocalDescriptor[] = {
        { "add_read_requested", reinterpret_cast<PyCFunction>(GattLocalDescriptor_add_ReadRequested), METH_O, nullptr },
        { "remove_read_requested", reinterpret_cast<PyCFunction>(GattLocalDescriptor_remove_ReadRequested), METH_O, nullptr },
        { "add_write_requested", reinterpret_cast<PyCFunction>(GattLocalDescriptor_add_WriteRequested), METH_O, nullptr },
        { "remove_write_requested", reinterpret_cast<PyCFunction>(GattLocalDescriptor_remove_WriteRequested), METH_O, nullptr },
        { "_assign_array_", _assign_array_GattLocalDescriptor, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_GattLocalDescriptor), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_GattLocalDescriptor[] = {
        { "read_protection_level", reinterpret_cast<getter>(GattLocalDescriptor_get_ReadProtectionLevel), nullptr, nullptr, nullptr },
        { "static_value", reinterpret_cast<getter>(GattLocalDescriptor_get_StaticValue), nullptr, nullptr, nullptr },
        { "uuid", reinterpret_cast<getter>(GattLocalDescriptor_get_Uuid), nullptr, nullptr, nullptr },
        { "write_protection_level", reinterpret_cast<getter>(GattLocalDescriptor_get_WriteProtectionLevel), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_GattLocalDescriptor[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_GattLocalDescriptor) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_GattLocalDescriptor) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_GattLocalDescriptor) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_GattLocalDescriptor) },
        { },
    };

    static PyType_Spec type_spec_GattLocalDescriptor =
    {
        "winrt._winrt_windows_devices_bluetooth_genericattributeprofile.GattLocalDescriptor",
        sizeof(py::wrapper::Windows::Devices::Bluetooth::GenericAttributeProfile::GattLocalDescriptor),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_GattLocalDescriptor
    };

    // ----- GattLocalDescriptorParameters class --------------------

    static PyObject* _new_GattLocalDescriptorParameters(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 0)
        {
            try
            {
                winrt::Windows::Devices::Bluetooth::GenericAttributeProfile::GattLocalDescriptorParameters instance{  };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_GattLocalDescriptorParameters(py::wrapper::Windows::Devices::Bluetooth::GenericAttributeProfile::GattLocalDescriptorParameters* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* GattLocalDescriptorParameters_get_WriteProtectionLevel(py::wrapper::Windows::Devices::Bluetooth::GenericAttributeProfile::GattLocalDescriptorParameters* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Bluetooth.GenericAttributeProfile.GattLocalDescriptorParameters", L"WriteProtectionLevel"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.WriteProtectionLevel());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int GattLocalDescriptorParameters_put_WriteProtectionLevel(py::wrapper::Windows::Devices::Bluetooth::GenericAttributeProfile::GattLocalDescriptorParameters* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Bluetooth.GenericAttributeProfile.GattLocalDescriptorParameters", L"WriteProtectionLevel"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::Devices::Bluetooth::GenericAttributeProfile::GattProtectionLevel>(arg);

            self->obj.WriteProtectionLevel(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* GattLocalDescriptorParameters_get_StaticValue(py::wrapper::Windows::Devices::Bluetooth::GenericAttributeProfile::GattLocalDescriptorParameters* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Bluetooth.GenericAttributeProfile.GattLocalDescriptorParameters", L"StaticValue"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.StaticValue());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int GattLocalDescriptorParameters_put_StaticValue(py::wrapper::Windows::Devices::Bluetooth::GenericAttributeProfile::GattLocalDescriptorParameters* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Bluetooth.GenericAttributeProfile.GattLocalDescriptorParameters", L"StaticValue"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::Storage::Streams::IBuffer>(arg);

            self->obj.StaticValue(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* GattLocalDescriptorParameters_get_ReadProtectionLevel(py::wrapper::Windows::Devices::Bluetooth::GenericAttributeProfile::GattLocalDescriptorParameters* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Bluetooth.GenericAttributeProfile.GattLocalDescriptorParameters", L"ReadProtectionLevel"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.ReadProtectionLevel());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int GattLocalDescriptorParameters_put_ReadProtectionLevel(py::wrapper::Windows::Devices::Bluetooth::GenericAttributeProfile::GattLocalDescriptorParameters* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Bluetooth.GenericAttributeProfile.GattLocalDescriptorParameters", L"ReadProtectionLevel"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::Devices::Bluetooth::GenericAttributeProfile::GattProtectionLevel>(arg);

            self->obj.ReadProtectionLevel(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* _assign_array_GattLocalDescriptorParameters(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Devices::Bluetooth::GenericAttributeProfile::GattLocalDescriptorParameters>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_GattLocalDescriptorParameters(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Devices::Bluetooth::GenericAttributeProfile::GattLocalDescriptorParameters>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_GattLocalDescriptorParameters[] = {
        { "_assign_array_", _assign_array_GattLocalDescriptorParameters, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_GattLocalDescriptorParameters), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_GattLocalDescriptorParameters[] = {
        { "write_protection_level", reinterpret_cast<getter>(GattLocalDescriptorParameters_get_WriteProtectionLevel), reinterpret_cast<setter>(GattLocalDescriptorParameters_put_WriteProtectionLevel), nullptr, nullptr },
        { "static_value", reinterpret_cast<getter>(GattLocalDescriptorParameters_get_StaticValue), reinterpret_cast<setter>(GattLocalDescriptorParameters_put_StaticValue), nullptr, nullptr },
        { "read_protection_level", reinterpret_cast<getter>(GattLocalDescriptorParameters_get_ReadProtectionLevel), reinterpret_cast<setter>(GattLocalDescriptorParameters_put_ReadProtectionLevel), nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_GattLocalDescriptorParameters[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_GattLocalDescriptorParameters) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_GattLocalDescriptorParameters) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_GattLocalDescriptorParameters) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_GattLocalDescriptorParameters) },
        { },
    };

    static PyType_Spec type_spec_GattLocalDescriptorParameters =
    {
        "winrt._winrt_windows_devices_bluetooth_genericattributeprofile.GattLocalDescriptorParameters",
        sizeof(py::wrapper::Windows::Devices::Bluetooth::GenericAttributeProfile::GattLocalDescriptorParameters),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_GattLocalDescriptorParameters
    };

    // ----- GattLocalDescriptorResult class --------------------

    static PyObject* _new_GattLocalDescriptorResult(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Devices::Bluetooth::GenericAttributeProfile::GattLocalDescriptorResult>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Devices::Bluetooth::GenericAttributeProfile::GattLocalDescriptorResult>::type_name);
        return nullptr;
    }

    static void _dealloc_GattLocalDescriptorResult(py::wrapper::Windows::Devices::Bluetooth::GenericAttributeProfile::GattLocalDescriptorResult* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* GattLocalDescriptorResult_get_Descriptor(py::wrapper::Windows::Devices::Bluetooth::GenericAttributeProfile::GattLocalDescriptorResult* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Bluetooth.GenericAttributeProfile.GattLocalDescriptorResult", L"Descriptor"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Descriptor());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* GattLocalDescriptorResult_get_Error(py::wrapper::Windows::Devices::Bluetooth::GenericAttributeProfile::GattLocalDescriptorResult* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Bluetooth.GenericAttributeProfile.GattLocalDescriptorResult", L"Error"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Error());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_GattLocalDescriptorResult(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Devices::Bluetooth::GenericAttributeProfile::GattLocalDescriptorResult>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_GattLocalDescriptorResult(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Devices::Bluetooth::GenericAttributeProfile::GattLocalDescriptorResult>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_GattLocalDescriptorResult[] = {
        { "_assign_array_", _assign_array_GattLocalDescriptorResult, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_GattLocalDescriptorResult), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_GattLocalDescriptorResult[] = {
        { "descriptor", reinterpret_cast<getter>(GattLocalDescriptorResult_get_Descriptor), nullptr, nullptr, nullptr },
        { "error", reinterpret_cast<getter>(GattLocalDescriptorResult_get_Error), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_GattLocalDescriptorResult[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_GattLocalDescriptorResult) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_GattLocalDescriptorResult) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_GattLocalDescriptorResult) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_GattLocalDescriptorResult) },
        { },
    };

    static PyType_Spec type_spec_GattLocalDescriptorResult =
    {
        "winrt._winrt_windows_devices_bluetooth_genericattributeprofile.GattLocalDescriptorResult",
        sizeof(py::wrapper::Windows::Devices::Bluetooth::GenericAttributeProfile::GattLocalDescriptorResult),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_GattLocalDescriptorResult
    };

    // ----- GattLocalService class --------------------

    static PyObject* _new_GattLocalService(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Devices::Bluetooth::GenericAttributeProfile::GattLocalService>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Devices::Bluetooth::GenericAttributeProfile::GattLocalService>::type_name);
        return nullptr;
    }

    static void _dealloc_GattLocalService(py::wrapper::Windows::Devices::Bluetooth::GenericAttributeProfile::GattLocalService* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* GattLocalService_CreateCharacteristicAsync(py::wrapper::Windows::Devices::Bluetooth::GenericAttributeProfile::GattLocalService* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.Bluetooth.GenericAttributeProfile.GattLocalService", L"CreateCharacteristicAsync", 2))
                {
                    py::set_arg_count_version_error(2);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::guid>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Devices::Bluetooth::GenericAttributeProfile::GattLocalCharacteristicParameters>(args, 1);

                return py::convert(self->obj.CreateCharacteristicAsync(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* GattLocalService_get_Characteristics(py::wrapper::Windows::Devices::Bluetooth::GenericAttributeProfile::GattLocalService* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Bluetooth.GenericAttributeProfile.GattLocalService", L"Characteristics"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Characteristics());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* GattLocalService_get_Uuid(py::wrapper::Windows::Devices::Bluetooth::GenericAttributeProfile::GattLocalService* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Bluetooth.GenericAttributeProfile.GattLocalService", L"Uuid"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Uuid());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_GattLocalService(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Devices::Bluetooth::GenericAttributeProfile::GattLocalService>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_GattLocalService(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Devices::Bluetooth::GenericAttributeProfile::GattLocalService>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_GattLocalService[] = {
        { "create_characteristic_async", reinterpret_cast<PyCFunction>(GattLocalService_CreateCharacteristicAsync), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_GattLocalService, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_GattLocalService), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_GattLocalService[] = {
        { "characteristics", reinterpret_cast<getter>(GattLocalService_get_Characteristics), nullptr, nullptr, nullptr },
        { "uuid", reinterpret_cast<getter>(GattLocalService_get_Uuid), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_GattLocalService[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_GattLocalService) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_GattLocalService) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_GattLocalService) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_GattLocalService) },
        { },
    };

    static PyType_Spec type_spec_GattLocalService =
    {
        "winrt._winrt_windows_devices_bluetooth_genericattributeprofile.GattLocalService",
        sizeof(py::wrapper::Windows::Devices::Bluetooth::GenericAttributeProfile::GattLocalService),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_GattLocalService
    };

    // ----- GattPresentationFormat class --------------------

    static PyObject* _new_GattPresentationFormat(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Devices::Bluetooth::GenericAttributeProfile::GattPresentationFormat>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Devices::Bluetooth::GenericAttributeProfile::GattPresentationFormat>::type_name);
        return nullptr;
    }

    static void _dealloc_GattPresentationFormat(py::wrapper::Windows::Devices::Bluetooth::GenericAttributeProfile::GattPresentationFormat* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* GattPresentationFormat_FromParts(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 5)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.Bluetooth.GenericAttributeProfile.GattPresentationFormat", L"FromParts", 5))
                {
                    py::set_arg_count_version_error(5);
                    return nullptr;
                }

                auto param0 = py::convert_to<uint8_t>(args, 0);
                auto param1 = py::convert_to<int32_t>(args, 1);
                auto param2 = py::convert_to<uint16_t>(args, 2);
                auto param3 = py::convert_to<uint8_t>(args, 3);
                auto param4 = py::convert_to<uint16_t>(args, 4);

                return py::convert(winrt::Windows::Devices::Bluetooth::GenericAttributeProfile::GattPresentationFormat::FromParts(param0, param1, param2, param3, param4));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* GattPresentationFormat_get_Description(py::wrapper::Windows::Devices::Bluetooth::GenericAttributeProfile::GattPresentationFormat* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Bluetooth.GenericAttributeProfile.GattPresentationFormat", L"Description"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Description());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* GattPresentationFormat_get_Exponent(py::wrapper::Windows::Devices::Bluetooth::GenericAttributeProfile::GattPresentationFormat* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Bluetooth.GenericAttributeProfile.GattPresentationFormat", L"Exponent"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Exponent());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* GattPresentationFormat_get_FormatType(py::wrapper::Windows::Devices::Bluetooth::GenericAttributeProfile::GattPresentationFormat* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Bluetooth.GenericAttributeProfile.GattPresentationFormat", L"FormatType"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.FormatType());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* GattPresentationFormat_get_Namespace(py::wrapper::Windows::Devices::Bluetooth::GenericAttributeProfile::GattPresentationFormat* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Bluetooth.GenericAttributeProfile.GattPresentationFormat", L"Namespace"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Namespace());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* GattPresentationFormat_get_Unit(py::wrapper::Windows::Devices::Bluetooth::GenericAttributeProfile::GattPresentationFormat* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Bluetooth.GenericAttributeProfile.GattPresentationFormat", L"Unit"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Unit());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* GattPresentationFormat_get_BluetoothSigAssignedNumbers(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Bluetooth.GenericAttributeProfile.GattPresentationFormat", L"BluetoothSigAssignedNumbers"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::Devices::Bluetooth::GenericAttributeProfile::GattPresentationFormat::BluetoothSigAssignedNumbers());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_GattPresentationFormat(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Devices::Bluetooth::GenericAttributeProfile::GattPresentationFormat>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_GattPresentationFormat(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Devices::Bluetooth::GenericAttributeProfile::GattPresentationFormat>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_GattPresentationFormat[] = {
        { "_assign_array_", _assign_array_GattPresentationFormat, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_GattPresentationFormat), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_GattPresentationFormat[] = {
        { "description", reinterpret_cast<getter>(GattPresentationFormat_get_Description), nullptr, nullptr, nullptr },
        { "exponent", reinterpret_cast<getter>(GattPresentationFormat_get_Exponent), nullptr, nullptr, nullptr },
        { "format_type", reinterpret_cast<getter>(GattPresentationFormat_get_FormatType), nullptr, nullptr, nullptr },
        { "namespace", reinterpret_cast<getter>(GattPresentationFormat_get_Namespace), nullptr, nullptr, nullptr },
        { "unit", reinterpret_cast<getter>(GattPresentationFormat_get_Unit), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_GattPresentationFormat[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_GattPresentationFormat) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_GattPresentationFormat) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_GattPresentationFormat) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_GattPresentationFormat) },
        { },
    };

    static PyType_Spec type_spec_GattPresentationFormat =
    {
        "winrt._winrt_windows_devices_bluetooth_genericattributeprofile.GattPresentationFormat",
        sizeof(py::wrapper::Windows::Devices::Bluetooth::GenericAttributeProfile::GattPresentationFormat),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_GattPresentationFormat
    };

    static PyGetSetDef getset_GattPresentationFormat_Static[] = {
        { "bluetooth_sig_assigned_numbers", reinterpret_cast<getter>(GattPresentationFormat_get_BluetoothSigAssignedNumbers), nullptr, nullptr, nullptr },
        { }
    };

    static PyMethodDef methods_GattPresentationFormat_Static[] = {
        { "from_parts", reinterpret_cast<PyCFunction>(GattPresentationFormat_FromParts), METH_VARARGS, nullptr },
        { }
    };

    static PyType_Slot type_slots_GattPresentationFormat_Static[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_GattPresentationFormat_Static) },
        { Py_tp_methods, reinterpret_cast<void*>(methods_GattPresentationFormat_Static) },
        { }
    };

    static PyType_Spec type_spec_GattPresentationFormat_Static =
    {
        "winrt._winrt_windows_devices_bluetooth_genericattributeprofile.GattPresentationFormat_Static",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT,
        type_slots_GattPresentationFormat_Static
    };

    // ----- GattPresentationFormatTypes class --------------------

    static PyObject* _new_GattPresentationFormatTypes(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Devices::Bluetooth::GenericAttributeProfile::GattPresentationFormatTypes>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Devices::Bluetooth::GenericAttributeProfile::GattPresentationFormatTypes>::type_name);
        return nullptr;
    }

    static PyObject* GattPresentationFormatTypes_get_Bit2(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Bluetooth.GenericAttributeProfile.GattPresentationFormatTypes", L"Bit2"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::Devices::Bluetooth::GenericAttributeProfile::GattPresentationFormatTypes::Bit2());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* GattPresentationFormatTypes_get_Boolean(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Bluetooth.GenericAttributeProfile.GattPresentationFormatTypes", L"Boolean"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::Devices::Bluetooth::GenericAttributeProfile::GattPresentationFormatTypes::Boolean());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* GattPresentationFormatTypes_get_DUInt16(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Bluetooth.GenericAttributeProfile.GattPresentationFormatTypes", L"DUInt16"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::Devices::Bluetooth::GenericAttributeProfile::GattPresentationFormatTypes::DUInt16());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* GattPresentationFormatTypes_get_Float(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Bluetooth.GenericAttributeProfile.GattPresentationFormatTypes", L"Float"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::Devices::Bluetooth::GenericAttributeProfile::GattPresentationFormatTypes::Float());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* GattPresentationFormatTypes_get_Float32(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Bluetooth.GenericAttributeProfile.GattPresentationFormatTypes", L"Float32"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::Devices::Bluetooth::GenericAttributeProfile::GattPresentationFormatTypes::Float32());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* GattPresentationFormatTypes_get_Float64(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Bluetooth.GenericAttributeProfile.GattPresentationFormatTypes", L"Float64"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::Devices::Bluetooth::GenericAttributeProfile::GattPresentationFormatTypes::Float64());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* GattPresentationFormatTypes_get_Nibble(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Bluetooth.GenericAttributeProfile.GattPresentationFormatTypes", L"Nibble"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::Devices::Bluetooth::GenericAttributeProfile::GattPresentationFormatTypes::Nibble());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* GattPresentationFormatTypes_get_SFloat(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Bluetooth.GenericAttributeProfile.GattPresentationFormatTypes", L"SFloat"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::Devices::Bluetooth::GenericAttributeProfile::GattPresentationFormatTypes::SFloat());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* GattPresentationFormatTypes_get_SInt12(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Bluetooth.GenericAttributeProfile.GattPresentationFormatTypes", L"SInt12"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::Devices::Bluetooth::GenericAttributeProfile::GattPresentationFormatTypes::SInt12());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* GattPresentationFormatTypes_get_SInt128(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Bluetooth.GenericAttributeProfile.GattPresentationFormatTypes", L"SInt128"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::Devices::Bluetooth::GenericAttributeProfile::GattPresentationFormatTypes::SInt128());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* GattPresentationFormatTypes_get_SInt16(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Bluetooth.GenericAttributeProfile.GattPresentationFormatTypes", L"SInt16"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::Devices::Bluetooth::GenericAttributeProfile::GattPresentationFormatTypes::SInt16());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* GattPresentationFormatTypes_get_SInt24(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Bluetooth.GenericAttributeProfile.GattPresentationFormatTypes", L"SInt24"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::Devices::Bluetooth::GenericAttributeProfile::GattPresentationFormatTypes::SInt24());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* GattPresentationFormatTypes_get_SInt32(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Bluetooth.GenericAttributeProfile.GattPresentationFormatTypes", L"SInt32"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::Devices::Bluetooth::GenericAttributeProfile::GattPresentationFormatTypes::SInt32());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* GattPresentationFormatTypes_get_SInt48(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Bluetooth.GenericAttributeProfile.GattPresentationFormatTypes", L"SInt48"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::Devices::Bluetooth::GenericAttributeProfile::GattPresentationFormatTypes::SInt48());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* GattPresentationFormatTypes_get_SInt64(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Bluetooth.GenericAttributeProfile.GattPresentationFormatTypes", L"SInt64"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::Devices::Bluetooth::GenericAttributeProfile::GattPresentationFormatTypes::SInt64());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* GattPresentationFormatTypes_get_SInt8(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Bluetooth.GenericAttributeProfile.GattPresentationFormatTypes", L"SInt8"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::Devices::Bluetooth::GenericAttributeProfile::GattPresentationFormatTypes::SInt8());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* GattPresentationFormatTypes_get_Struct(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Bluetooth.GenericAttributeProfile.GattPresentationFormatTypes", L"Struct"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::Devices::Bluetooth::GenericAttributeProfile::GattPresentationFormatTypes::Struct());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* GattPresentationFormatTypes_get_UInt12(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Bluetooth.GenericAttributeProfile.GattPresentationFormatTypes", L"UInt12"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::Devices::Bluetooth::GenericAttributeProfile::GattPresentationFormatTypes::UInt12());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* GattPresentationFormatTypes_get_UInt128(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Bluetooth.GenericAttributeProfile.GattPresentationFormatTypes", L"UInt128"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::Devices::Bluetooth::GenericAttributeProfile::GattPresentationFormatTypes::UInt128());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* GattPresentationFormatTypes_get_UInt16(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Bluetooth.GenericAttributeProfile.GattPresentationFormatTypes", L"UInt16"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::Devices::Bluetooth::GenericAttributeProfile::GattPresentationFormatTypes::UInt16());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* GattPresentationFormatTypes_get_UInt24(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Bluetooth.GenericAttributeProfile.GattPresentationFormatTypes", L"UInt24"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::Devices::Bluetooth::GenericAttributeProfile::GattPresentationFormatTypes::UInt24());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* GattPresentationFormatTypes_get_UInt32(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Bluetooth.GenericAttributeProfile.GattPresentationFormatTypes", L"UInt32"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::Devices::Bluetooth::GenericAttributeProfile::GattPresentationFormatTypes::UInt32());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* GattPresentationFormatTypes_get_UInt48(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Bluetooth.GenericAttributeProfile.GattPresentationFormatTypes", L"UInt48"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::Devices::Bluetooth::GenericAttributeProfile::GattPresentationFormatTypes::UInt48());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* GattPresentationFormatTypes_get_UInt64(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Bluetooth.GenericAttributeProfile.GattPresentationFormatTypes", L"UInt64"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::Devices::Bluetooth::GenericAttributeProfile::GattPresentationFormatTypes::UInt64());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* GattPresentationFormatTypes_get_UInt8(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Bluetooth.GenericAttributeProfile.GattPresentationFormatTypes", L"UInt8"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::Devices::Bluetooth::GenericAttributeProfile::GattPresentationFormatTypes::UInt8());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* GattPresentationFormatTypes_get_Utf16(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Bluetooth.GenericAttributeProfile.GattPresentationFormatTypes", L"Utf16"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::Devices::Bluetooth::GenericAttributeProfile::GattPresentationFormatTypes::Utf16());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* GattPresentationFormatTypes_get_Utf8(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Bluetooth.GenericAttributeProfile.GattPresentationFormatTypes", L"Utf8"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::Devices::Bluetooth::GenericAttributeProfile::GattPresentationFormatTypes::Utf8());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_GattPresentationFormatTypes[] = {
        { }
    };

    static PyGetSetDef _getset_GattPresentationFormatTypes[] = {
        { }
    };

    static PyType_Slot _type_slots_GattPresentationFormatTypes[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_GattPresentationFormatTypes) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_GattPresentationFormatTypes) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_GattPresentationFormatTypes) },
        { },
    };

    static PyType_Spec type_spec_GattPresentationFormatTypes =
    {
        "winrt._winrt_windows_devices_bluetooth_genericattributeprofile.GattPresentationFormatTypes",
        0,
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_GattPresentationFormatTypes
    };

    static PyGetSetDef getset_GattPresentationFormatTypes_Static[] = {
        { "bit2", reinterpret_cast<getter>(GattPresentationFormatTypes_get_Bit2), nullptr, nullptr, nullptr },
        { "boolean", reinterpret_cast<getter>(GattPresentationFormatTypes_get_Boolean), nullptr, nullptr, nullptr },
        { "d_uint16", reinterpret_cast<getter>(GattPresentationFormatTypes_get_DUInt16), nullptr, nullptr, nullptr },
        { "float", reinterpret_cast<getter>(GattPresentationFormatTypes_get_Float), nullptr, nullptr, nullptr },
        { "float32", reinterpret_cast<getter>(GattPresentationFormatTypes_get_Float32), nullptr, nullptr, nullptr },
        { "float64", reinterpret_cast<getter>(GattPresentationFormatTypes_get_Float64), nullptr, nullptr, nullptr },
        { "nibble", reinterpret_cast<getter>(GattPresentationFormatTypes_get_Nibble), nullptr, nullptr, nullptr },
        { "s_float", reinterpret_cast<getter>(GattPresentationFormatTypes_get_SFloat), nullptr, nullptr, nullptr },
        { "s_int12", reinterpret_cast<getter>(GattPresentationFormatTypes_get_SInt12), nullptr, nullptr, nullptr },
        { "s_int128", reinterpret_cast<getter>(GattPresentationFormatTypes_get_SInt128), nullptr, nullptr, nullptr },
        { "s_int16", reinterpret_cast<getter>(GattPresentationFormatTypes_get_SInt16), nullptr, nullptr, nullptr },
        { "s_int24", reinterpret_cast<getter>(GattPresentationFormatTypes_get_SInt24), nullptr, nullptr, nullptr },
        { "s_int32", reinterpret_cast<getter>(GattPresentationFormatTypes_get_SInt32), nullptr, nullptr, nullptr },
        { "s_int48", reinterpret_cast<getter>(GattPresentationFormatTypes_get_SInt48), nullptr, nullptr, nullptr },
        { "s_int64", reinterpret_cast<getter>(GattPresentationFormatTypes_get_SInt64), nullptr, nullptr, nullptr },
        { "s_int8", reinterpret_cast<getter>(GattPresentationFormatTypes_get_SInt8), nullptr, nullptr, nullptr },
        { "struct", reinterpret_cast<getter>(GattPresentationFormatTypes_get_Struct), nullptr, nullptr, nullptr },
        { "uint12", reinterpret_cast<getter>(GattPresentationFormatTypes_get_UInt12), nullptr, nullptr, nullptr },
        { "uint128", reinterpret_cast<getter>(GattPresentationFormatTypes_get_UInt128), nullptr, nullptr, nullptr },
        { "uint16", reinterpret_cast<getter>(GattPresentationFormatTypes_get_UInt16), nullptr, nullptr, nullptr },
        { "uint24", reinterpret_cast<getter>(GattPresentationFormatTypes_get_UInt24), nullptr, nullptr, nullptr },
        { "uint32", reinterpret_cast<getter>(GattPresentationFormatTypes_get_UInt32), nullptr, nullptr, nullptr },
        { "uint48", reinterpret_cast<getter>(GattPresentationFormatTypes_get_UInt48), nullptr, nullptr, nullptr },
        { "uint64", reinterpret_cast<getter>(GattPresentationFormatTypes_get_UInt64), nullptr, nullptr, nullptr },
        { "uint8", reinterpret_cast<getter>(GattPresentationFormatTypes_get_UInt8), nullptr, nullptr, nullptr },
        { "utf16", reinterpret_cast<getter>(GattPresentationFormatTypes_get_Utf16), nullptr, nullptr, nullptr },
        { "utf8", reinterpret_cast<getter>(GattPresentationFormatTypes_get_Utf8), nullptr, nullptr, nullptr },
        { }
    };

    static PyMethodDef methods_GattPresentationFormatTypes_Static[] = {
        { }
    };

    static PyType_Slot type_slots_GattPresentationFormatTypes_Static[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_GattPresentationFormatTypes_Static) },
        { Py_tp_methods, reinterpret_cast<void*>(methods_GattPresentationFormatTypes_Static) },
        { }
    };

    static PyType_Spec type_spec_GattPresentationFormatTypes_Static =
    {
        "winrt._winrt_windows_devices_bluetooth_genericattributeprofile.GattPresentationFormatTypes_Static",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT,
        type_slots_GattPresentationFormatTypes_Static
    };

    // ----- GattProtocolError class --------------------

    static PyObject* _new_GattProtocolError(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Devices::Bluetooth::GenericAttributeProfile::GattProtocolError>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Devices::Bluetooth::GenericAttributeProfile::GattProtocolError>::type_name);
        return nullptr;
    }

    static PyObject* GattProtocolError_get_AttributeNotFound(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Bluetooth.GenericAttributeProfile.GattProtocolError", L"AttributeNotFound"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::Devices::Bluetooth::GenericAttributeProfile::GattProtocolError::AttributeNotFound());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* GattProtocolError_get_AttributeNotLong(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Bluetooth.GenericAttributeProfile.GattProtocolError", L"AttributeNotLong"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::Devices::Bluetooth::GenericAttributeProfile::GattProtocolError::AttributeNotLong());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* GattProtocolError_get_InsufficientAuthentication(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Bluetooth.GenericAttributeProfile.GattProtocolError", L"InsufficientAuthentication"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::Devices::Bluetooth::GenericAttributeProfile::GattProtocolError::InsufficientAuthentication());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* GattProtocolError_get_InsufficientAuthorization(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Bluetooth.GenericAttributeProfile.GattProtocolError", L"InsufficientAuthorization"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::Devices::Bluetooth::GenericAttributeProfile::GattProtocolError::InsufficientAuthorization());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* GattProtocolError_get_InsufficientEncryption(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Bluetooth.GenericAttributeProfile.GattProtocolError", L"InsufficientEncryption"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::Devices::Bluetooth::GenericAttributeProfile::GattProtocolError::InsufficientEncryption());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* GattProtocolError_get_InsufficientEncryptionKeySize(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Bluetooth.GenericAttributeProfile.GattProtocolError", L"InsufficientEncryptionKeySize"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::Devices::Bluetooth::GenericAttributeProfile::GattProtocolError::InsufficientEncryptionKeySize());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* GattProtocolError_get_InsufficientResources(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Bluetooth.GenericAttributeProfile.GattProtocolError", L"InsufficientResources"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::Devices::Bluetooth::GenericAttributeProfile::GattProtocolError::InsufficientResources());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* GattProtocolError_get_InvalidAttributeValueLength(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Bluetooth.GenericAttributeProfile.GattProtocolError", L"InvalidAttributeValueLength"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::Devices::Bluetooth::GenericAttributeProfile::GattProtocolError::InvalidAttributeValueLength());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* GattProtocolError_get_InvalidHandle(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Bluetooth.GenericAttributeProfile.GattProtocolError", L"InvalidHandle"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::Devices::Bluetooth::GenericAttributeProfile::GattProtocolError::InvalidHandle());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* GattProtocolError_get_InvalidOffset(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Bluetooth.GenericAttributeProfile.GattProtocolError", L"InvalidOffset"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::Devices::Bluetooth::GenericAttributeProfile::GattProtocolError::InvalidOffset());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* GattProtocolError_get_InvalidPdu(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Bluetooth.GenericAttributeProfile.GattProtocolError", L"InvalidPdu"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::Devices::Bluetooth::GenericAttributeProfile::GattProtocolError::InvalidPdu());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* GattProtocolError_get_PrepareQueueFull(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Bluetooth.GenericAttributeProfile.GattProtocolError", L"PrepareQueueFull"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::Devices::Bluetooth::GenericAttributeProfile::GattProtocolError::PrepareQueueFull());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* GattProtocolError_get_ReadNotPermitted(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Bluetooth.GenericAttributeProfile.GattProtocolError", L"ReadNotPermitted"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::Devices::Bluetooth::GenericAttributeProfile::GattProtocolError::ReadNotPermitted());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* GattProtocolError_get_RequestNotSupported(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Bluetooth.GenericAttributeProfile.GattProtocolError", L"RequestNotSupported"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::Devices::Bluetooth::GenericAttributeProfile::GattProtocolError::RequestNotSupported());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* GattProtocolError_get_UnlikelyError(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Bluetooth.GenericAttributeProfile.GattProtocolError", L"UnlikelyError"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::Devices::Bluetooth::GenericAttributeProfile::GattProtocolError::UnlikelyError());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* GattProtocolError_get_UnsupportedGroupType(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Bluetooth.GenericAttributeProfile.GattProtocolError", L"UnsupportedGroupType"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::Devices::Bluetooth::GenericAttributeProfile::GattProtocolError::UnsupportedGroupType());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* GattProtocolError_get_WriteNotPermitted(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Bluetooth.GenericAttributeProfile.GattProtocolError", L"WriteNotPermitted"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::Devices::Bluetooth::GenericAttributeProfile::GattProtocolError::WriteNotPermitted());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_GattProtocolError[] = {
        { }
    };

    static PyGetSetDef _getset_GattProtocolError[] = {
        { }
    };

    static PyType_Slot _type_slots_GattProtocolError[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_GattProtocolError) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_GattProtocolError) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_GattProtocolError) },
        { },
    };

    static PyType_Spec type_spec_GattProtocolError =
    {
        "winrt._winrt_windows_devices_bluetooth_genericattributeprofile.GattProtocolError",
        0,
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_GattProtocolError
    };

    static PyGetSetDef getset_GattProtocolError_Static[] = {
        { "attribute_not_found", reinterpret_cast<getter>(GattProtocolError_get_AttributeNotFound), nullptr, nullptr, nullptr },
        { "attribute_not_long", reinterpret_cast<getter>(GattProtocolError_get_AttributeNotLong), nullptr, nullptr, nullptr },
        { "insufficient_authentication", reinterpret_cast<getter>(GattProtocolError_get_InsufficientAuthentication), nullptr, nullptr, nullptr },
        { "insufficient_authorization", reinterpret_cast<getter>(GattProtocolError_get_InsufficientAuthorization), nullptr, nullptr, nullptr },
        { "insufficient_encryption", reinterpret_cast<getter>(GattProtocolError_get_InsufficientEncryption), nullptr, nullptr, nullptr },
        { "insufficient_encryption_key_size", reinterpret_cast<getter>(GattProtocolError_get_InsufficientEncryptionKeySize), nullptr, nullptr, nullptr },
        { "insufficient_resources", reinterpret_cast<getter>(GattProtocolError_get_InsufficientResources), nullptr, nullptr, nullptr },
        { "invalid_attribute_value_length", reinterpret_cast<getter>(GattProtocolError_get_InvalidAttributeValueLength), nullptr, nullptr, nullptr },
        { "invalid_handle", reinterpret_cast<getter>(GattProtocolError_get_InvalidHandle), nullptr, nullptr, nullptr },
        { "invalid_offset", reinterpret_cast<getter>(GattProtocolError_get_InvalidOffset), nullptr, nullptr, nullptr },
        { "invalid_pdu", reinterpret_cast<getter>(GattProtocolError_get_InvalidPdu), nullptr, nullptr, nullptr },
        { "prepare_queue_full", reinterpret_cast<getter>(GattProtocolError_get_PrepareQueueFull), nullptr, nullptr, nullptr },
        { "read_not_permitted", reinterpret_cast<getter>(GattProtocolError_get_ReadNotPermitted), nullptr, nullptr, nullptr },
        { "request_not_supported", reinterpret_cast<getter>(GattProtocolError_get_RequestNotSupported), nullptr, nullptr, nullptr },
        { "unlikely_error", reinterpret_cast<getter>(GattProtocolError_get_UnlikelyError), nullptr, nullptr, nullptr },
        { "unsupported_group_type", reinterpret_cast<getter>(GattProtocolError_get_UnsupportedGroupType), nullptr, nullptr, nullptr },
        { "write_not_permitted", reinterpret_cast<getter>(GattProtocolError_get_WriteNotPermitted), nullptr, nullptr, nullptr },
        { }
    };

    static PyMethodDef methods_GattProtocolError_Static[] = {
        { }
    };

    static PyType_Slot type_slots_GattProtocolError_Static[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_GattProtocolError_Static) },
        { Py_tp_methods, reinterpret_cast<void*>(methods_GattProtocolError_Static) },
        { }
    };

    static PyType_Spec type_spec_GattProtocolError_Static =
    {
        "winrt._winrt_windows_devices_bluetooth_genericattributeprofile.GattProtocolError_Static",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT,
        type_slots_GattProtocolError_Static
    };

    // ----- GattReadClientCharacteristicConfigurationDescriptorResult class --------------------

    static PyObject* _new_GattReadClientCharacteristicConfigurationDescriptorResult(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Devices::Bluetooth::GenericAttributeProfile::GattReadClientCharacteristicConfigurationDescriptorResult>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Devices::Bluetooth::GenericAttributeProfile::GattReadClientCharacteristicConfigurationDescriptorResult>::type_name);
        return nullptr;
    }

    static void _dealloc_GattReadClientCharacteristicConfigurationDescriptorResult(py::wrapper::Windows::Devices::Bluetooth::GenericAttributeProfile::GattReadClientCharacteristicConfigurationDescriptorResult* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* GattReadClientCharacteristicConfigurationDescriptorResult_get_ClientCharacteristicConfigurationDescriptor(py::wrapper::Windows::Devices::Bluetooth::GenericAttributeProfile::GattReadClientCharacteristicConfigurationDescriptorResult* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Bluetooth.GenericAttributeProfile.GattReadClientCharacteristicConfigurationDescriptorResult", L"ClientCharacteristicConfigurationDescriptor"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.ClientCharacteristicConfigurationDescriptor());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* GattReadClientCharacteristicConfigurationDescriptorResult_get_Status(py::wrapper::Windows::Devices::Bluetooth::GenericAttributeProfile::GattReadClientCharacteristicConfigurationDescriptorResult* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Bluetooth.GenericAttributeProfile.GattReadClientCharacteristicConfigurationDescriptorResult", L"Status"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Status());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* GattReadClientCharacteristicConfigurationDescriptorResult_get_ProtocolError(py::wrapper::Windows::Devices::Bluetooth::GenericAttributeProfile::GattReadClientCharacteristicConfigurationDescriptorResult* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Bluetooth.GenericAttributeProfile.GattReadClientCharacteristicConfigurationDescriptorResult", L"ProtocolError"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.ProtocolError());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_GattReadClientCharacteristicConfigurationDescriptorResult(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Devices::Bluetooth::GenericAttributeProfile::GattReadClientCharacteristicConfigurationDescriptorResult>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_GattReadClientCharacteristicConfigurationDescriptorResult(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Devices::Bluetooth::GenericAttributeProfile::GattReadClientCharacteristicConfigurationDescriptorResult>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_GattReadClientCharacteristicConfigurationDescriptorResult[] = {
        { "_assign_array_", _assign_array_GattReadClientCharacteristicConfigurationDescriptorResult, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_GattReadClientCharacteristicConfigurationDescriptorResult), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_GattReadClientCharacteristicConfigurationDescriptorResult[] = {
        { "client_characteristic_configuration_descriptor", reinterpret_cast<getter>(GattReadClientCharacteristicConfigurationDescriptorResult_get_ClientCharacteristicConfigurationDescriptor), nullptr, nullptr, nullptr },
        { "status", reinterpret_cast<getter>(GattReadClientCharacteristicConfigurationDescriptorResult_get_Status), nullptr, nullptr, nullptr },
        { "protocol_error", reinterpret_cast<getter>(GattReadClientCharacteristicConfigurationDescriptorResult_get_ProtocolError), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_GattReadClientCharacteristicConfigurationDescriptorResult[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_GattReadClientCharacteristicConfigurationDescriptorResult) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_GattReadClientCharacteristicConfigurationDescriptorResult) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_GattReadClientCharacteristicConfigurationDescriptorResult) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_GattReadClientCharacteristicConfigurationDescriptorResult) },
        { },
    };

    static PyType_Spec type_spec_GattReadClientCharacteristicConfigurationDescriptorResult =
    {
        "winrt._winrt_windows_devices_bluetooth_genericattributeprofile.GattReadClientCharacteristicConfigurationDescriptorResult",
        sizeof(py::wrapper::Windows::Devices::Bluetooth::GenericAttributeProfile::GattReadClientCharacteristicConfigurationDescriptorResult),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_GattReadClientCharacteristicConfigurationDescriptorResult
    };

    // ----- GattReadRequest class --------------------

    static PyObject* _new_GattReadRequest(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Devices::Bluetooth::GenericAttributeProfile::GattReadRequest>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Devices::Bluetooth::GenericAttributeProfile::GattReadRequest>::type_name);
        return nullptr;
    }

    static void _dealloc_GattReadRequest(py::wrapper::Windows::Devices::Bluetooth::GenericAttributeProfile::GattReadRequest* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* GattReadRequest_RespondWithProtocolError(py::wrapper::Windows::Devices::Bluetooth::GenericAttributeProfile::GattReadRequest* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.Bluetooth.GenericAttributeProfile.GattReadRequest", L"RespondWithProtocolError", 1))
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<uint8_t>(args, 0);

                self->obj.RespondWithProtocolError(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* GattReadRequest_RespondWithValue(py::wrapper::Windows::Devices::Bluetooth::GenericAttributeProfile::GattReadRequest* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.Bluetooth.GenericAttributeProfile.GattReadRequest", L"RespondWithValue", 1))
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Storage::Streams::IBuffer>(args, 0);

                self->obj.RespondWithValue(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* GattReadRequest_get_Length(py::wrapper::Windows::Devices::Bluetooth::GenericAttributeProfile::GattReadRequest* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Bluetooth.GenericAttributeProfile.GattReadRequest", L"Length"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Length());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* GattReadRequest_get_Offset(py::wrapper::Windows::Devices::Bluetooth::GenericAttributeProfile::GattReadRequest* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Bluetooth.GenericAttributeProfile.GattReadRequest", L"Offset"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Offset());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* GattReadRequest_get_State(py::wrapper::Windows::Devices::Bluetooth::GenericAttributeProfile::GattReadRequest* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Bluetooth.GenericAttributeProfile.GattReadRequest", L"State"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.State());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* GattReadRequest_add_StateChanged(py::wrapper::Windows::Devices::Bluetooth::GenericAttributeProfile::GattReadRequest* self, PyObject* arg) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Devices.Bluetooth.GenericAttributeProfile.GattReadRequest", L"StateChanged"))
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Devices::Bluetooth::GenericAttributeProfile::GattReadRequest, winrt::Windows::Devices::Bluetooth::GenericAttributeProfile::GattRequestStateChangedEventArgs>>(arg);

            return py::convert(self->obj.StateChanged(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* GattReadRequest_remove_StateChanged(py::wrapper::Windows::Devices::Bluetooth::GenericAttributeProfile::GattReadRequest* self, PyObject* arg) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Devices.Bluetooth.GenericAttributeProfile.GattReadRequest", L"StateChanged"))
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.StateChanged(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_GattReadRequest(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Devices::Bluetooth::GenericAttributeProfile::GattReadRequest>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_GattReadRequest(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Devices::Bluetooth::GenericAttributeProfile::GattReadRequest>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_GattReadRequest[] = {
        { "respond_with_protocol_error", reinterpret_cast<PyCFunction>(GattReadRequest_RespondWithProtocolError), METH_VARARGS, nullptr },
        { "respond_with_value", reinterpret_cast<PyCFunction>(GattReadRequest_RespondWithValue), METH_VARARGS, nullptr },
        { "add_state_changed", reinterpret_cast<PyCFunction>(GattReadRequest_add_StateChanged), METH_O, nullptr },
        { "remove_state_changed", reinterpret_cast<PyCFunction>(GattReadRequest_remove_StateChanged), METH_O, nullptr },
        { "_assign_array_", _assign_array_GattReadRequest, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_GattReadRequest), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_GattReadRequest[] = {
        { "length", reinterpret_cast<getter>(GattReadRequest_get_Length), nullptr, nullptr, nullptr },
        { "offset", reinterpret_cast<getter>(GattReadRequest_get_Offset), nullptr, nullptr, nullptr },
        { "state", reinterpret_cast<getter>(GattReadRequest_get_State), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_GattReadRequest[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_GattReadRequest) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_GattReadRequest) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_GattReadRequest) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_GattReadRequest) },
        { },
    };

    static PyType_Spec type_spec_GattReadRequest =
    {
        "winrt._winrt_windows_devices_bluetooth_genericattributeprofile.GattReadRequest",
        sizeof(py::wrapper::Windows::Devices::Bluetooth::GenericAttributeProfile::GattReadRequest),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_GattReadRequest
    };

    // ----- GattReadRequestedEventArgs class --------------------

    static PyObject* _new_GattReadRequestedEventArgs(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Devices::Bluetooth::GenericAttributeProfile::GattReadRequestedEventArgs>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Devices::Bluetooth::GenericAttributeProfile::GattReadRequestedEventArgs>::type_name);
        return nullptr;
    }

    static void _dealloc_GattReadRequestedEventArgs(py::wrapper::Windows::Devices::Bluetooth::GenericAttributeProfile::GattReadRequestedEventArgs* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* GattReadRequestedEventArgs_GetDeferral(py::wrapper::Windows::Devices::Bluetooth::GenericAttributeProfile::GattReadRequestedEventArgs* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.Bluetooth.GenericAttributeProfile.GattReadRequestedEventArgs", L"GetDeferral", 0))
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert(self->obj.GetDeferral());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* GattReadRequestedEventArgs_GetRequestAsync(py::wrapper::Windows::Devices::Bluetooth::GenericAttributeProfile::GattReadRequestedEventArgs* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.Bluetooth.GenericAttributeProfile.GattReadRequestedEventArgs", L"GetRequestAsync", 0))
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert(self->obj.GetRequestAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* GattReadRequestedEventArgs_get_Session(py::wrapper::Windows::Devices::Bluetooth::GenericAttributeProfile::GattReadRequestedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Bluetooth.GenericAttributeProfile.GattReadRequestedEventArgs", L"Session"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Session());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_GattReadRequestedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Devices::Bluetooth::GenericAttributeProfile::GattReadRequestedEventArgs>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_GattReadRequestedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Devices::Bluetooth::GenericAttributeProfile::GattReadRequestedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_GattReadRequestedEventArgs[] = {
        { "get_deferral", reinterpret_cast<PyCFunction>(GattReadRequestedEventArgs_GetDeferral), METH_VARARGS, nullptr },
        { "get_request_async", reinterpret_cast<PyCFunction>(GattReadRequestedEventArgs_GetRequestAsync), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_GattReadRequestedEventArgs, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_GattReadRequestedEventArgs), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_GattReadRequestedEventArgs[] = {
        { "session", reinterpret_cast<getter>(GattReadRequestedEventArgs_get_Session), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_GattReadRequestedEventArgs[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_GattReadRequestedEventArgs) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_GattReadRequestedEventArgs) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_GattReadRequestedEventArgs) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_GattReadRequestedEventArgs) },
        { },
    };

    static PyType_Spec type_spec_GattReadRequestedEventArgs =
    {
        "winrt._winrt_windows_devices_bluetooth_genericattributeprofile.GattReadRequestedEventArgs",
        sizeof(py::wrapper::Windows::Devices::Bluetooth::GenericAttributeProfile::GattReadRequestedEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_GattReadRequestedEventArgs
    };

    // ----- GattReadResult class --------------------

    static PyObject* _new_GattReadResult(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Devices::Bluetooth::GenericAttributeProfile::GattReadResult>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Devices::Bluetooth::GenericAttributeProfile::GattReadResult>::type_name);
        return nullptr;
    }

    static void _dealloc_GattReadResult(py::wrapper::Windows::Devices::Bluetooth::GenericAttributeProfile::GattReadResult* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* GattReadResult_get_Status(py::wrapper::Windows::Devices::Bluetooth::GenericAttributeProfile::GattReadResult* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Bluetooth.GenericAttributeProfile.GattReadResult", L"Status"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Status());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* GattReadResult_get_Value(py::wrapper::Windows::Devices::Bluetooth::GenericAttributeProfile::GattReadResult* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Bluetooth.GenericAttributeProfile.GattReadResult", L"Value"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Value());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* GattReadResult_get_ProtocolError(py::wrapper::Windows::Devices::Bluetooth::GenericAttributeProfile::GattReadResult* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Bluetooth.GenericAttributeProfile.GattReadResult", L"ProtocolError"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.ProtocolError());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_GattReadResult(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Devices::Bluetooth::GenericAttributeProfile::GattReadResult>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_GattReadResult(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Devices::Bluetooth::GenericAttributeProfile::GattReadResult>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_GattReadResult[] = {
        { "_assign_array_", _assign_array_GattReadResult, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_GattReadResult), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_GattReadResult[] = {
        { "status", reinterpret_cast<getter>(GattReadResult_get_Status), nullptr, nullptr, nullptr },
        { "value", reinterpret_cast<getter>(GattReadResult_get_Value), nullptr, nullptr, nullptr },
        { "protocol_error", reinterpret_cast<getter>(GattReadResult_get_ProtocolError), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_GattReadResult[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_GattReadResult) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_GattReadResult) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_GattReadResult) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_GattReadResult) },
        { },
    };

    static PyType_Spec type_spec_GattReadResult =
    {
        "winrt._winrt_windows_devices_bluetooth_genericattributeprofile.GattReadResult",
        sizeof(py::wrapper::Windows::Devices::Bluetooth::GenericAttributeProfile::GattReadResult),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_GattReadResult
    };

    // ----- GattReliableWriteTransaction class --------------------

    static PyObject* _new_GattReliableWriteTransaction(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 0)
        {
            try
            {
                winrt::Windows::Devices::Bluetooth::GenericAttributeProfile::GattReliableWriteTransaction instance{  };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_GattReliableWriteTransaction(py::wrapper::Windows::Devices::Bluetooth::GenericAttributeProfile::GattReliableWriteTransaction* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* GattReliableWriteTransaction_CommitAsync(py::wrapper::Windows::Devices::Bluetooth::GenericAttributeProfile::GattReliableWriteTransaction* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.Bluetooth.GenericAttributeProfile.GattReliableWriteTransaction", L"CommitAsync", 0))
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert(self->obj.CommitAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* GattReliableWriteTransaction_CommitWithResultAsync(py::wrapper::Windows::Devices::Bluetooth::GenericAttributeProfile::GattReliableWriteTransaction* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.Bluetooth.GenericAttributeProfile.GattReliableWriteTransaction", L"CommitWithResultAsync", 0))
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert(self->obj.CommitWithResultAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* GattReliableWriteTransaction_WriteValue(py::wrapper::Windows::Devices::Bluetooth::GenericAttributeProfile::GattReliableWriteTransaction* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.Bluetooth.GenericAttributeProfile.GattReliableWriteTransaction", L"WriteValue", 2))
                {
                    py::set_arg_count_version_error(2);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Devices::Bluetooth::GenericAttributeProfile::GattCharacteristic>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Storage::Streams::IBuffer>(args, 1);

                self->obj.WriteValue(param0, param1);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* _assign_array_GattReliableWriteTransaction(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Devices::Bluetooth::GenericAttributeProfile::GattReliableWriteTransaction>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_GattReliableWriteTransaction(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Devices::Bluetooth::GenericAttributeProfile::GattReliableWriteTransaction>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_GattReliableWriteTransaction[] = {
        { "commit_async", reinterpret_cast<PyCFunction>(GattReliableWriteTransaction_CommitAsync), METH_VARARGS, nullptr },
        { "commit_with_result_async", reinterpret_cast<PyCFunction>(GattReliableWriteTransaction_CommitWithResultAsync), METH_VARARGS, nullptr },
        { "write_value", reinterpret_cast<PyCFunction>(GattReliableWriteTransaction_WriteValue), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_GattReliableWriteTransaction, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_GattReliableWriteTransaction), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_GattReliableWriteTransaction[] = {
        { }
    };

    static PyType_Slot _type_slots_GattReliableWriteTransaction[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_GattReliableWriteTransaction) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_GattReliableWriteTransaction) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_GattReliableWriteTransaction) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_GattReliableWriteTransaction) },
        { },
    };

    static PyType_Spec type_spec_GattReliableWriteTransaction =
    {
        "winrt._winrt_windows_devices_bluetooth_genericattributeprofile.GattReliableWriteTransaction",
        sizeof(py::wrapper::Windows::Devices::Bluetooth::GenericAttributeProfile::GattReliableWriteTransaction),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_GattReliableWriteTransaction
    };

    // ----- GattRequestStateChangedEventArgs class --------------------

    static PyObject* _new_GattRequestStateChangedEventArgs(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Devices::Bluetooth::GenericAttributeProfile::GattRequestStateChangedEventArgs>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Devices::Bluetooth::GenericAttributeProfile::GattRequestStateChangedEventArgs>::type_name);
        return nullptr;
    }

    static void _dealloc_GattRequestStateChangedEventArgs(py::wrapper::Windows::Devices::Bluetooth::GenericAttributeProfile::GattRequestStateChangedEventArgs* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* GattRequestStateChangedEventArgs_get_Error(py::wrapper::Windows::Devices::Bluetooth::GenericAttributeProfile::GattRequestStateChangedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Bluetooth.GenericAttributeProfile.GattRequestStateChangedEventArgs", L"Error"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Error());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* GattRequestStateChangedEventArgs_get_State(py::wrapper::Windows::Devices::Bluetooth::GenericAttributeProfile::GattRequestStateChangedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Bluetooth.GenericAttributeProfile.GattRequestStateChangedEventArgs", L"State"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.State());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_GattRequestStateChangedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Devices::Bluetooth::GenericAttributeProfile::GattRequestStateChangedEventArgs>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_GattRequestStateChangedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Devices::Bluetooth::GenericAttributeProfile::GattRequestStateChangedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_GattRequestStateChangedEventArgs[] = {
        { "_assign_array_", _assign_array_GattRequestStateChangedEventArgs, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_GattRequestStateChangedEventArgs), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_GattRequestStateChangedEventArgs[] = {
        { "error", reinterpret_cast<getter>(GattRequestStateChangedEventArgs_get_Error), nullptr, nullptr, nullptr },
        { "state", reinterpret_cast<getter>(GattRequestStateChangedEventArgs_get_State), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_GattRequestStateChangedEventArgs[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_GattRequestStateChangedEventArgs) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_GattRequestStateChangedEventArgs) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_GattRequestStateChangedEventArgs) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_GattRequestStateChangedEventArgs) },
        { },
    };

    static PyType_Spec type_spec_GattRequestStateChangedEventArgs =
    {
        "winrt._winrt_windows_devices_bluetooth_genericattributeprofile.GattRequestStateChangedEventArgs",
        sizeof(py::wrapper::Windows::Devices::Bluetooth::GenericAttributeProfile::GattRequestStateChangedEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_GattRequestStateChangedEventArgs
    };

    // ----- GattServiceProvider class --------------------

    static PyObject* _new_GattServiceProvider(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Devices::Bluetooth::GenericAttributeProfile::GattServiceProvider>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Devices::Bluetooth::GenericAttributeProfile::GattServiceProvider>::type_name);
        return nullptr;
    }

    static void _dealloc_GattServiceProvider(py::wrapper::Windows::Devices::Bluetooth::GenericAttributeProfile::GattServiceProvider* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* GattServiceProvider_CreateAsync(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.Bluetooth.GenericAttributeProfile.GattServiceProvider", L"CreateAsync", 1))
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::guid>(args, 0);

                return py::convert(winrt::Windows::Devices::Bluetooth::GenericAttributeProfile::GattServiceProvider::CreateAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* GattServiceProvider_StartAdvertising(py::wrapper::Windows::Devices::Bluetooth::GenericAttributeProfile::GattServiceProvider* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.Bluetooth.GenericAttributeProfile.GattServiceProvider", L"StartAdvertising", 0))
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                self->obj.StartAdvertising();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 1)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.Bluetooth.GenericAttributeProfile.GattServiceProvider", L"StartAdvertising", 1))
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Devices::Bluetooth::GenericAttributeProfile::GattServiceProviderAdvertisingParameters>(args, 0);

                self->obj.StartAdvertising(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* GattServiceProvider_StopAdvertising(py::wrapper::Windows::Devices::Bluetooth::GenericAttributeProfile::GattServiceProvider* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.Bluetooth.GenericAttributeProfile.GattServiceProvider", L"StopAdvertising", 0))
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                self->obj.StopAdvertising();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* GattServiceProvider_get_AdvertisementStatus(py::wrapper::Windows::Devices::Bluetooth::GenericAttributeProfile::GattServiceProvider* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Bluetooth.GenericAttributeProfile.GattServiceProvider", L"AdvertisementStatus"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.AdvertisementStatus());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* GattServiceProvider_get_Service(py::wrapper::Windows::Devices::Bluetooth::GenericAttributeProfile::GattServiceProvider* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Bluetooth.GenericAttributeProfile.GattServiceProvider", L"Service"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Service());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* GattServiceProvider_add_AdvertisementStatusChanged(py::wrapper::Windows::Devices::Bluetooth::GenericAttributeProfile::GattServiceProvider* self, PyObject* arg) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Devices.Bluetooth.GenericAttributeProfile.GattServiceProvider", L"AdvertisementStatusChanged"))
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Devices::Bluetooth::GenericAttributeProfile::GattServiceProvider, winrt::Windows::Devices::Bluetooth::GenericAttributeProfile::GattServiceProviderAdvertisementStatusChangedEventArgs>>(arg);

            return py::convert(self->obj.AdvertisementStatusChanged(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* GattServiceProvider_remove_AdvertisementStatusChanged(py::wrapper::Windows::Devices::Bluetooth::GenericAttributeProfile::GattServiceProvider* self, PyObject* arg) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Devices.Bluetooth.GenericAttributeProfile.GattServiceProvider", L"AdvertisementStatusChanged"))
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.AdvertisementStatusChanged(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_GattServiceProvider(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Devices::Bluetooth::GenericAttributeProfile::GattServiceProvider>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_GattServiceProvider(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Devices::Bluetooth::GenericAttributeProfile::GattServiceProvider>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_GattServiceProvider[] = {
        { "start_advertising", reinterpret_cast<PyCFunction>(GattServiceProvider_StartAdvertising), METH_VARARGS, nullptr },
        { "stop_advertising", reinterpret_cast<PyCFunction>(GattServiceProvider_StopAdvertising), METH_VARARGS, nullptr },
        { "add_advertisement_status_changed", reinterpret_cast<PyCFunction>(GattServiceProvider_add_AdvertisementStatusChanged), METH_O, nullptr },
        { "remove_advertisement_status_changed", reinterpret_cast<PyCFunction>(GattServiceProvider_remove_AdvertisementStatusChanged), METH_O, nullptr },
        { "_assign_array_", _assign_array_GattServiceProvider, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_GattServiceProvider), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_GattServiceProvider[] = {
        { "advertisement_status", reinterpret_cast<getter>(GattServiceProvider_get_AdvertisementStatus), nullptr, nullptr, nullptr },
        { "service", reinterpret_cast<getter>(GattServiceProvider_get_Service), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_GattServiceProvider[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_GattServiceProvider) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_GattServiceProvider) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_GattServiceProvider) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_GattServiceProvider) },
        { },
    };

    static PyType_Spec type_spec_GattServiceProvider =
    {
        "winrt._winrt_windows_devices_bluetooth_genericattributeprofile.GattServiceProvider",
        sizeof(py::wrapper::Windows::Devices::Bluetooth::GenericAttributeProfile::GattServiceProvider),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_GattServiceProvider
    };

    static PyGetSetDef getset_GattServiceProvider_Static[] = {
        { }
    };

    static PyMethodDef methods_GattServiceProvider_Static[] = {
        { "create_async", reinterpret_cast<PyCFunction>(GattServiceProvider_CreateAsync), METH_VARARGS, nullptr },
        { }
    };

    static PyType_Slot type_slots_GattServiceProvider_Static[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_GattServiceProvider_Static) },
        { Py_tp_methods, reinterpret_cast<void*>(methods_GattServiceProvider_Static) },
        { }
    };

    static PyType_Spec type_spec_GattServiceProvider_Static =
    {
        "winrt._winrt_windows_devices_bluetooth_genericattributeprofile.GattServiceProvider_Static",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT,
        type_slots_GattServiceProvider_Static
    };

    // ----- GattServiceProviderAdvertisementStatusChangedEventArgs class --------------------

    static PyObject* _new_GattServiceProviderAdvertisementStatusChangedEventArgs(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Devices::Bluetooth::GenericAttributeProfile::GattServiceProviderAdvertisementStatusChangedEventArgs>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Devices::Bluetooth::GenericAttributeProfile::GattServiceProviderAdvertisementStatusChangedEventArgs>::type_name);
        return nullptr;
    }

    static void _dealloc_GattServiceProviderAdvertisementStatusChangedEventArgs(py::wrapper::Windows::Devices::Bluetooth::GenericAttributeProfile::GattServiceProviderAdvertisementStatusChangedEventArgs* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* GattServiceProviderAdvertisementStatusChangedEventArgs_get_Error(py::wrapper::Windows::Devices::Bluetooth::GenericAttributeProfile::GattServiceProviderAdvertisementStatusChangedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Bluetooth.GenericAttributeProfile.GattServiceProviderAdvertisementStatusChangedEventArgs", L"Error"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Error());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* GattServiceProviderAdvertisementStatusChangedEventArgs_get_Status(py::wrapper::Windows::Devices::Bluetooth::GenericAttributeProfile::GattServiceProviderAdvertisementStatusChangedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Bluetooth.GenericAttributeProfile.GattServiceProviderAdvertisementStatusChangedEventArgs", L"Status"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Status());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_GattServiceProviderAdvertisementStatusChangedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Devices::Bluetooth::GenericAttributeProfile::GattServiceProviderAdvertisementStatusChangedEventArgs>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_GattServiceProviderAdvertisementStatusChangedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Devices::Bluetooth::GenericAttributeProfile::GattServiceProviderAdvertisementStatusChangedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_GattServiceProviderAdvertisementStatusChangedEventArgs[] = {
        { "_assign_array_", _assign_array_GattServiceProviderAdvertisementStatusChangedEventArgs, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_GattServiceProviderAdvertisementStatusChangedEventArgs), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_GattServiceProviderAdvertisementStatusChangedEventArgs[] = {
        { "error", reinterpret_cast<getter>(GattServiceProviderAdvertisementStatusChangedEventArgs_get_Error), nullptr, nullptr, nullptr },
        { "status", reinterpret_cast<getter>(GattServiceProviderAdvertisementStatusChangedEventArgs_get_Status), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_GattServiceProviderAdvertisementStatusChangedEventArgs[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_GattServiceProviderAdvertisementStatusChangedEventArgs) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_GattServiceProviderAdvertisementStatusChangedEventArgs) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_GattServiceProviderAdvertisementStatusChangedEventArgs) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_GattServiceProviderAdvertisementStatusChangedEventArgs) },
        { },
    };

    static PyType_Spec type_spec_GattServiceProviderAdvertisementStatusChangedEventArgs =
    {
        "winrt._winrt_windows_devices_bluetooth_genericattributeprofile.GattServiceProviderAdvertisementStatusChangedEventArgs",
        sizeof(py::wrapper::Windows::Devices::Bluetooth::GenericAttributeProfile::GattServiceProviderAdvertisementStatusChangedEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_GattServiceProviderAdvertisementStatusChangedEventArgs
    };

    // ----- GattServiceProviderAdvertisingParameters class --------------------

    static PyObject* _new_GattServiceProviderAdvertisingParameters(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 0)
        {
            try
            {
                winrt::Windows::Devices::Bluetooth::GenericAttributeProfile::GattServiceProviderAdvertisingParameters instance{  };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_GattServiceProviderAdvertisingParameters(py::wrapper::Windows::Devices::Bluetooth::GenericAttributeProfile::GattServiceProviderAdvertisingParameters* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* GattServiceProviderAdvertisingParameters_get_IsDiscoverable(py::wrapper::Windows::Devices::Bluetooth::GenericAttributeProfile::GattServiceProviderAdvertisingParameters* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Bluetooth.GenericAttributeProfile.GattServiceProviderAdvertisingParameters", L"IsDiscoverable"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.IsDiscoverable());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int GattServiceProviderAdvertisingParameters_put_IsDiscoverable(py::wrapper::Windows::Devices::Bluetooth::GenericAttributeProfile::GattServiceProviderAdvertisingParameters* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Bluetooth.GenericAttributeProfile.GattServiceProviderAdvertisingParameters", L"IsDiscoverable"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<bool>(arg);

            self->obj.IsDiscoverable(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* GattServiceProviderAdvertisingParameters_get_IsConnectable(py::wrapper::Windows::Devices::Bluetooth::GenericAttributeProfile::GattServiceProviderAdvertisingParameters* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Bluetooth.GenericAttributeProfile.GattServiceProviderAdvertisingParameters", L"IsConnectable"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.IsConnectable());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int GattServiceProviderAdvertisingParameters_put_IsConnectable(py::wrapper::Windows::Devices::Bluetooth::GenericAttributeProfile::GattServiceProviderAdvertisingParameters* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Bluetooth.GenericAttributeProfile.GattServiceProviderAdvertisingParameters", L"IsConnectable"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<bool>(arg);

            self->obj.IsConnectable(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* GattServiceProviderAdvertisingParameters_get_ServiceData(py::wrapper::Windows::Devices::Bluetooth::GenericAttributeProfile::GattServiceProviderAdvertisingParameters* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Bluetooth.GenericAttributeProfile.GattServiceProviderAdvertisingParameters", L"ServiceData"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.ServiceData());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int GattServiceProviderAdvertisingParameters_put_ServiceData(py::wrapper::Windows::Devices::Bluetooth::GenericAttributeProfile::GattServiceProviderAdvertisingParameters* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Bluetooth.GenericAttributeProfile.GattServiceProviderAdvertisingParameters", L"ServiceData"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::Storage::Streams::IBuffer>(arg);

            self->obj.ServiceData(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* _assign_array_GattServiceProviderAdvertisingParameters(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Devices::Bluetooth::GenericAttributeProfile::GattServiceProviderAdvertisingParameters>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_GattServiceProviderAdvertisingParameters(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Devices::Bluetooth::GenericAttributeProfile::GattServiceProviderAdvertisingParameters>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_GattServiceProviderAdvertisingParameters[] = {
        { "_assign_array_", _assign_array_GattServiceProviderAdvertisingParameters, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_GattServiceProviderAdvertisingParameters), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_GattServiceProviderAdvertisingParameters[] = {
        { "is_discoverable", reinterpret_cast<getter>(GattServiceProviderAdvertisingParameters_get_IsDiscoverable), reinterpret_cast<setter>(GattServiceProviderAdvertisingParameters_put_IsDiscoverable), nullptr, nullptr },
        { "is_connectable", reinterpret_cast<getter>(GattServiceProviderAdvertisingParameters_get_IsConnectable), reinterpret_cast<setter>(GattServiceProviderAdvertisingParameters_put_IsConnectable), nullptr, nullptr },
        { "service_data", reinterpret_cast<getter>(GattServiceProviderAdvertisingParameters_get_ServiceData), reinterpret_cast<setter>(GattServiceProviderAdvertisingParameters_put_ServiceData), nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_GattServiceProviderAdvertisingParameters[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_GattServiceProviderAdvertisingParameters) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_GattServiceProviderAdvertisingParameters) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_GattServiceProviderAdvertisingParameters) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_GattServiceProviderAdvertisingParameters) },
        { },
    };

    static PyType_Spec type_spec_GattServiceProviderAdvertisingParameters =
    {
        "winrt._winrt_windows_devices_bluetooth_genericattributeprofile.GattServiceProviderAdvertisingParameters",
        sizeof(py::wrapper::Windows::Devices::Bluetooth::GenericAttributeProfile::GattServiceProviderAdvertisingParameters),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_GattServiceProviderAdvertisingParameters
    };

    // ----- GattServiceProviderResult class --------------------

    static PyObject* _new_GattServiceProviderResult(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Devices::Bluetooth::GenericAttributeProfile::GattServiceProviderResult>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Devices::Bluetooth::GenericAttributeProfile::GattServiceProviderResult>::type_name);
        return nullptr;
    }

    static void _dealloc_GattServiceProviderResult(py::wrapper::Windows::Devices::Bluetooth::GenericAttributeProfile::GattServiceProviderResult* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* GattServiceProviderResult_get_Error(py::wrapper::Windows::Devices::Bluetooth::GenericAttributeProfile::GattServiceProviderResult* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Bluetooth.GenericAttributeProfile.GattServiceProviderResult", L"Error"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Error());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* GattServiceProviderResult_get_ServiceProvider(py::wrapper::Windows::Devices::Bluetooth::GenericAttributeProfile::GattServiceProviderResult* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Bluetooth.GenericAttributeProfile.GattServiceProviderResult", L"ServiceProvider"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.ServiceProvider());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_GattServiceProviderResult(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Devices::Bluetooth::GenericAttributeProfile::GattServiceProviderResult>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_GattServiceProviderResult(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Devices::Bluetooth::GenericAttributeProfile::GattServiceProviderResult>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_GattServiceProviderResult[] = {
        { "_assign_array_", _assign_array_GattServiceProviderResult, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_GattServiceProviderResult), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_GattServiceProviderResult[] = {
        { "error", reinterpret_cast<getter>(GattServiceProviderResult_get_Error), nullptr, nullptr, nullptr },
        { "service_provider", reinterpret_cast<getter>(GattServiceProviderResult_get_ServiceProvider), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_GattServiceProviderResult[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_GattServiceProviderResult) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_GattServiceProviderResult) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_GattServiceProviderResult) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_GattServiceProviderResult) },
        { },
    };

    static PyType_Spec type_spec_GattServiceProviderResult =
    {
        "winrt._winrt_windows_devices_bluetooth_genericattributeprofile.GattServiceProviderResult",
        sizeof(py::wrapper::Windows::Devices::Bluetooth::GenericAttributeProfile::GattServiceProviderResult),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_GattServiceProviderResult
    };

    // ----- GattServiceUuids class --------------------

    static PyObject* _new_GattServiceUuids(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Devices::Bluetooth::GenericAttributeProfile::GattServiceUuids>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Devices::Bluetooth::GenericAttributeProfile::GattServiceUuids>::type_name);
        return nullptr;
    }

    static PyObject* GattServiceUuids_get_Battery(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Bluetooth.GenericAttributeProfile.GattServiceUuids", L"Battery"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::Devices::Bluetooth::GenericAttributeProfile::GattServiceUuids::Battery());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* GattServiceUuids_get_BloodPressure(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Bluetooth.GenericAttributeProfile.GattServiceUuids", L"BloodPressure"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::Devices::Bluetooth::GenericAttributeProfile::GattServiceUuids::BloodPressure());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* GattServiceUuids_get_CyclingSpeedAndCadence(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Bluetooth.GenericAttributeProfile.GattServiceUuids", L"CyclingSpeedAndCadence"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::Devices::Bluetooth::GenericAttributeProfile::GattServiceUuids::CyclingSpeedAndCadence());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* GattServiceUuids_get_GenericAccess(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Bluetooth.GenericAttributeProfile.GattServiceUuids", L"GenericAccess"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::Devices::Bluetooth::GenericAttributeProfile::GattServiceUuids::GenericAccess());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* GattServiceUuids_get_GenericAttribute(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Bluetooth.GenericAttributeProfile.GattServiceUuids", L"GenericAttribute"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::Devices::Bluetooth::GenericAttributeProfile::GattServiceUuids::GenericAttribute());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* GattServiceUuids_get_Glucose(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Bluetooth.GenericAttributeProfile.GattServiceUuids", L"Glucose"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::Devices::Bluetooth::GenericAttributeProfile::GattServiceUuids::Glucose());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* GattServiceUuids_get_HealthThermometer(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Bluetooth.GenericAttributeProfile.GattServiceUuids", L"HealthThermometer"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::Devices::Bluetooth::GenericAttributeProfile::GattServiceUuids::HealthThermometer());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* GattServiceUuids_get_HeartRate(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Bluetooth.GenericAttributeProfile.GattServiceUuids", L"HeartRate"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::Devices::Bluetooth::GenericAttributeProfile::GattServiceUuids::HeartRate());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* GattServiceUuids_get_RunningSpeedAndCadence(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Bluetooth.GenericAttributeProfile.GattServiceUuids", L"RunningSpeedAndCadence"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::Devices::Bluetooth::GenericAttributeProfile::GattServiceUuids::RunningSpeedAndCadence());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* GattServiceUuids_get_AlertNotification(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Bluetooth.GenericAttributeProfile.GattServiceUuids", L"AlertNotification"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::Devices::Bluetooth::GenericAttributeProfile::GattServiceUuids::AlertNotification());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* GattServiceUuids_get_CurrentTime(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Bluetooth.GenericAttributeProfile.GattServiceUuids", L"CurrentTime"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::Devices::Bluetooth::GenericAttributeProfile::GattServiceUuids::CurrentTime());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* GattServiceUuids_get_CyclingPower(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Bluetooth.GenericAttributeProfile.GattServiceUuids", L"CyclingPower"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::Devices::Bluetooth::GenericAttributeProfile::GattServiceUuids::CyclingPower());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* GattServiceUuids_get_DeviceInformation(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Bluetooth.GenericAttributeProfile.GattServiceUuids", L"DeviceInformation"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::Devices::Bluetooth::GenericAttributeProfile::GattServiceUuids::DeviceInformation());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* GattServiceUuids_get_HumanInterfaceDevice(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Bluetooth.GenericAttributeProfile.GattServiceUuids", L"HumanInterfaceDevice"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::Devices::Bluetooth::GenericAttributeProfile::GattServiceUuids::HumanInterfaceDevice());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* GattServiceUuids_get_ImmediateAlert(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Bluetooth.GenericAttributeProfile.GattServiceUuids", L"ImmediateAlert"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::Devices::Bluetooth::GenericAttributeProfile::GattServiceUuids::ImmediateAlert());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* GattServiceUuids_get_LinkLoss(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Bluetooth.GenericAttributeProfile.GattServiceUuids", L"LinkLoss"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::Devices::Bluetooth::GenericAttributeProfile::GattServiceUuids::LinkLoss());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* GattServiceUuids_get_LocationAndNavigation(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Bluetooth.GenericAttributeProfile.GattServiceUuids", L"LocationAndNavigation"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::Devices::Bluetooth::GenericAttributeProfile::GattServiceUuids::LocationAndNavigation());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* GattServiceUuids_get_NextDstChange(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Bluetooth.GenericAttributeProfile.GattServiceUuids", L"NextDstChange"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::Devices::Bluetooth::GenericAttributeProfile::GattServiceUuids::NextDstChange());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* GattServiceUuids_get_PhoneAlertStatus(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Bluetooth.GenericAttributeProfile.GattServiceUuids", L"PhoneAlertStatus"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::Devices::Bluetooth::GenericAttributeProfile::GattServiceUuids::PhoneAlertStatus());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* GattServiceUuids_get_ReferenceTimeUpdate(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Bluetooth.GenericAttributeProfile.GattServiceUuids", L"ReferenceTimeUpdate"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::Devices::Bluetooth::GenericAttributeProfile::GattServiceUuids::ReferenceTimeUpdate());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* GattServiceUuids_get_ScanParameters(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Bluetooth.GenericAttributeProfile.GattServiceUuids", L"ScanParameters"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::Devices::Bluetooth::GenericAttributeProfile::GattServiceUuids::ScanParameters());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* GattServiceUuids_get_TxPower(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Bluetooth.GenericAttributeProfile.GattServiceUuids", L"TxPower"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::Devices::Bluetooth::GenericAttributeProfile::GattServiceUuids::TxPower());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_GattServiceUuids[] = {
        { }
    };

    static PyGetSetDef _getset_GattServiceUuids[] = {
        { }
    };

    static PyType_Slot _type_slots_GattServiceUuids[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_GattServiceUuids) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_GattServiceUuids) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_GattServiceUuids) },
        { },
    };

    static PyType_Spec type_spec_GattServiceUuids =
    {
        "winrt._winrt_windows_devices_bluetooth_genericattributeprofile.GattServiceUuids",
        0,
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_GattServiceUuids
    };

    static PyGetSetDef getset_GattServiceUuids_Static[] = {
        { "battery", reinterpret_cast<getter>(GattServiceUuids_get_Battery), nullptr, nullptr, nullptr },
        { "blood_pressure", reinterpret_cast<getter>(GattServiceUuids_get_BloodPressure), nullptr, nullptr, nullptr },
        { "cycling_speed_and_cadence", reinterpret_cast<getter>(GattServiceUuids_get_CyclingSpeedAndCadence), nullptr, nullptr, nullptr },
        { "generic_access", reinterpret_cast<getter>(GattServiceUuids_get_GenericAccess), nullptr, nullptr, nullptr },
        { "generic_attribute", reinterpret_cast<getter>(GattServiceUuids_get_GenericAttribute), nullptr, nullptr, nullptr },
        { "glucose", reinterpret_cast<getter>(GattServiceUuids_get_Glucose), nullptr, nullptr, nullptr },
        { "health_thermometer", reinterpret_cast<getter>(GattServiceUuids_get_HealthThermometer), nullptr, nullptr, nullptr },
        { "heart_rate", reinterpret_cast<getter>(GattServiceUuids_get_HeartRate), nullptr, nullptr, nullptr },
        { "running_speed_and_cadence", reinterpret_cast<getter>(GattServiceUuids_get_RunningSpeedAndCadence), nullptr, nullptr, nullptr },
        { "alert_notification", reinterpret_cast<getter>(GattServiceUuids_get_AlertNotification), nullptr, nullptr, nullptr },
        { "current_time", reinterpret_cast<getter>(GattServiceUuids_get_CurrentTime), nullptr, nullptr, nullptr },
        { "cycling_power", reinterpret_cast<getter>(GattServiceUuids_get_CyclingPower), nullptr, nullptr, nullptr },
        { "device_information", reinterpret_cast<getter>(GattServiceUuids_get_DeviceInformation), nullptr, nullptr, nullptr },
        { "human_interface_device", reinterpret_cast<getter>(GattServiceUuids_get_HumanInterfaceDevice), nullptr, nullptr, nullptr },
        { "immediate_alert", reinterpret_cast<getter>(GattServiceUuids_get_ImmediateAlert), nullptr, nullptr, nullptr },
        { "link_loss", reinterpret_cast<getter>(GattServiceUuids_get_LinkLoss), nullptr, nullptr, nullptr },
        { "location_and_navigation", reinterpret_cast<getter>(GattServiceUuids_get_LocationAndNavigation), nullptr, nullptr, nullptr },
        { "next_dst_change", reinterpret_cast<getter>(GattServiceUuids_get_NextDstChange), nullptr, nullptr, nullptr },
        { "phone_alert_status", reinterpret_cast<getter>(GattServiceUuids_get_PhoneAlertStatus), nullptr, nullptr, nullptr },
        { "reference_time_update", reinterpret_cast<getter>(GattServiceUuids_get_ReferenceTimeUpdate), nullptr, nullptr, nullptr },
        { "scan_parameters", reinterpret_cast<getter>(GattServiceUuids_get_ScanParameters), nullptr, nullptr, nullptr },
        { "tx_power", reinterpret_cast<getter>(GattServiceUuids_get_TxPower), nullptr, nullptr, nullptr },
        { }
    };

    static PyMethodDef methods_GattServiceUuids_Static[] = {
        { }
    };

    static PyType_Slot type_slots_GattServiceUuids_Static[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_GattServiceUuids_Static) },
        { Py_tp_methods, reinterpret_cast<void*>(methods_GattServiceUuids_Static) },
        { }
    };

    static PyType_Spec type_spec_GattServiceUuids_Static =
    {
        "winrt._winrt_windows_devices_bluetooth_genericattributeprofile.GattServiceUuids_Static",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT,
        type_slots_GattServiceUuids_Static
    };

    // ----- GattSession class --------------------

    static PyObject* _new_GattSession(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Devices::Bluetooth::GenericAttributeProfile::GattSession>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Devices::Bluetooth::GenericAttributeProfile::GattSession>::type_name);
        return nullptr;
    }

    static void _dealloc_GattSession(py::wrapper::Windows::Devices::Bluetooth::GenericAttributeProfile::GattSession* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* GattSession_Close(py::wrapper::Windows::Devices::Bluetooth::GenericAttributeProfile::GattSession* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.Bluetooth.GenericAttributeProfile.GattSession", L"Close", 0))
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                self->obj.Close();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* GattSession_FromDeviceIdAsync(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.Bluetooth.GenericAttributeProfile.GattSession", L"FromDeviceIdAsync", 1))
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Devices::Bluetooth::BluetoothDeviceId>(args, 0);

                return py::convert(winrt::Windows::Devices::Bluetooth::GenericAttributeProfile::GattSession::FromDeviceIdAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* GattSession_get_MaintainConnection(py::wrapper::Windows::Devices::Bluetooth::GenericAttributeProfile::GattSession* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Bluetooth.GenericAttributeProfile.GattSession", L"MaintainConnection"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.MaintainConnection());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int GattSession_put_MaintainConnection(py::wrapper::Windows::Devices::Bluetooth::GenericAttributeProfile::GattSession* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Bluetooth.GenericAttributeProfile.GattSession", L"MaintainConnection"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<bool>(arg);

            self->obj.MaintainConnection(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* GattSession_get_CanMaintainConnection(py::wrapper::Windows::Devices::Bluetooth::GenericAttributeProfile::GattSession* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Bluetooth.GenericAttributeProfile.GattSession", L"CanMaintainConnection"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.CanMaintainConnection());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* GattSession_get_DeviceId(py::wrapper::Windows::Devices::Bluetooth::GenericAttributeProfile::GattSession* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Bluetooth.GenericAttributeProfile.GattSession", L"DeviceId"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.DeviceId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* GattSession_get_MaxPduSize(py::wrapper::Windows::Devices::Bluetooth::GenericAttributeProfile::GattSession* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Bluetooth.GenericAttributeProfile.GattSession", L"MaxPduSize"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.MaxPduSize());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* GattSession_get_SessionStatus(py::wrapper::Windows::Devices::Bluetooth::GenericAttributeProfile::GattSession* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Bluetooth.GenericAttributeProfile.GattSession", L"SessionStatus"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.SessionStatus());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* GattSession_add_MaxPduSizeChanged(py::wrapper::Windows::Devices::Bluetooth::GenericAttributeProfile::GattSession* self, PyObject* arg) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Devices.Bluetooth.GenericAttributeProfile.GattSession", L"MaxPduSizeChanged"))
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Devices::Bluetooth::GenericAttributeProfile::GattSession, winrt::Windows::Foundation::IInspectable>>(arg);

            return py::convert(self->obj.MaxPduSizeChanged(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* GattSession_remove_MaxPduSizeChanged(py::wrapper::Windows::Devices::Bluetooth::GenericAttributeProfile::GattSession* self, PyObject* arg) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Devices.Bluetooth.GenericAttributeProfile.GattSession", L"MaxPduSizeChanged"))
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.MaxPduSizeChanged(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* GattSession_add_SessionStatusChanged(py::wrapper::Windows::Devices::Bluetooth::GenericAttributeProfile::GattSession* self, PyObject* arg) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Devices.Bluetooth.GenericAttributeProfile.GattSession", L"SessionStatusChanged"))
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Devices::Bluetooth::GenericAttributeProfile::GattSession, winrt::Windows::Devices::Bluetooth::GenericAttributeProfile::GattSessionStatusChangedEventArgs>>(arg);

            return py::convert(self->obj.SessionStatusChanged(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* GattSession_remove_SessionStatusChanged(py::wrapper::Windows::Devices::Bluetooth::GenericAttributeProfile::GattSession* self, PyObject* arg) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Devices.Bluetooth.GenericAttributeProfile.GattSession", L"SessionStatusChanged"))
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.SessionStatusChanged(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_GattSession(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Devices::Bluetooth::GenericAttributeProfile::GattSession>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_GattSession(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Devices::Bluetooth::GenericAttributeProfile::GattSession>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _enter_GattSession(py::wrapper::Windows::Devices::Bluetooth::GenericAttributeProfile::GattSession* self, PyObject* /*unused*/) noexcept
    {
        return Py_NewRef(self);
    }

    static PyObject* _exit_GattSession(py::wrapper::Windows::Devices::Bluetooth::GenericAttributeProfile::GattSession* self, PyObject* /*unused*/) noexcept
    {
        try
        {
            self->obj.Close();
            Py_RETURN_FALSE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_GattSession[] = {
        { "close", reinterpret_cast<PyCFunction>(GattSession_Close), METH_VARARGS, nullptr },
        { "add_max_pdu_size_changed", reinterpret_cast<PyCFunction>(GattSession_add_MaxPduSizeChanged), METH_O, nullptr },
        { "remove_max_pdu_size_changed", reinterpret_cast<PyCFunction>(GattSession_remove_MaxPduSizeChanged), METH_O, nullptr },
        { "add_session_status_changed", reinterpret_cast<PyCFunction>(GattSession_add_SessionStatusChanged), METH_O, nullptr },
        { "remove_session_status_changed", reinterpret_cast<PyCFunction>(GattSession_remove_SessionStatusChanged), METH_O, nullptr },
        { "_assign_array_", _assign_array_GattSession, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_GattSession), METH_O | METH_STATIC, nullptr },
        { "__enter__", reinterpret_cast<PyCFunction>(_enter_GattSession), METH_NOARGS, nullptr },
        { "__exit__", reinterpret_cast<PyCFunction>(_exit_GattSession), METH_VARARGS, nullptr },
        { }
    };

    static PyGetSetDef _getset_GattSession[] = {
        { "maintain_connection", reinterpret_cast<getter>(GattSession_get_MaintainConnection), reinterpret_cast<setter>(GattSession_put_MaintainConnection), nullptr, nullptr },
        { "can_maintain_connection", reinterpret_cast<getter>(GattSession_get_CanMaintainConnection), nullptr, nullptr, nullptr },
        { "device_id", reinterpret_cast<getter>(GattSession_get_DeviceId), nullptr, nullptr, nullptr },
        { "max_pdu_size", reinterpret_cast<getter>(GattSession_get_MaxPduSize), nullptr, nullptr, nullptr },
        { "session_status", reinterpret_cast<getter>(GattSession_get_SessionStatus), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_GattSession[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_GattSession) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_GattSession) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_GattSession) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_GattSession) },
        { },
    };

    static PyType_Spec type_spec_GattSession =
    {
        "winrt._winrt_windows_devices_bluetooth_genericattributeprofile.GattSession",
        sizeof(py::wrapper::Windows::Devices::Bluetooth::GenericAttributeProfile::GattSession),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_GattSession
    };

    static PyGetSetDef getset_GattSession_Static[] = {
        { }
    };

    static PyMethodDef methods_GattSession_Static[] = {
        { "from_device_id_async", reinterpret_cast<PyCFunction>(GattSession_FromDeviceIdAsync), METH_VARARGS, nullptr },
        { }
    };

    static PyType_Slot type_slots_GattSession_Static[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_GattSession_Static) },
        { Py_tp_methods, reinterpret_cast<void*>(methods_GattSession_Static) },
        { }
    };

    static PyType_Spec type_spec_GattSession_Static =
    {
        "winrt._winrt_windows_devices_bluetooth_genericattributeprofile.GattSession_Static",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT,
        type_slots_GattSession_Static
    };

    // ----- GattSessionStatusChangedEventArgs class --------------------

    static PyObject* _new_GattSessionStatusChangedEventArgs(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Devices::Bluetooth::GenericAttributeProfile::GattSessionStatusChangedEventArgs>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Devices::Bluetooth::GenericAttributeProfile::GattSessionStatusChangedEventArgs>::type_name);
        return nullptr;
    }

    static void _dealloc_GattSessionStatusChangedEventArgs(py::wrapper::Windows::Devices::Bluetooth::GenericAttributeProfile::GattSessionStatusChangedEventArgs* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* GattSessionStatusChangedEventArgs_get_Error(py::wrapper::Windows::Devices::Bluetooth::GenericAttributeProfile::GattSessionStatusChangedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Bluetooth.GenericAttributeProfile.GattSessionStatusChangedEventArgs", L"Error"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Error());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* GattSessionStatusChangedEventArgs_get_Status(py::wrapper::Windows::Devices::Bluetooth::GenericAttributeProfile::GattSessionStatusChangedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Bluetooth.GenericAttributeProfile.GattSessionStatusChangedEventArgs", L"Status"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Status());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_GattSessionStatusChangedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Devices::Bluetooth::GenericAttributeProfile::GattSessionStatusChangedEventArgs>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_GattSessionStatusChangedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Devices::Bluetooth::GenericAttributeProfile::GattSessionStatusChangedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_GattSessionStatusChangedEventArgs[] = {
        { "_assign_array_", _assign_array_GattSessionStatusChangedEventArgs, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_GattSessionStatusChangedEventArgs), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_GattSessionStatusChangedEventArgs[] = {
        { "error", reinterpret_cast<getter>(GattSessionStatusChangedEventArgs_get_Error), nullptr, nullptr, nullptr },
        { "status", reinterpret_cast<getter>(GattSessionStatusChangedEventArgs_get_Status), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_GattSessionStatusChangedEventArgs[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_GattSessionStatusChangedEventArgs) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_GattSessionStatusChangedEventArgs) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_GattSessionStatusChangedEventArgs) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_GattSessionStatusChangedEventArgs) },
        { },
    };

    static PyType_Spec type_spec_GattSessionStatusChangedEventArgs =
    {
        "winrt._winrt_windows_devices_bluetooth_genericattributeprofile.GattSessionStatusChangedEventArgs",
        sizeof(py::wrapper::Windows::Devices::Bluetooth::GenericAttributeProfile::GattSessionStatusChangedEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_GattSessionStatusChangedEventArgs
    };

    // ----- GattSubscribedClient class --------------------

    static PyObject* _new_GattSubscribedClient(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Devices::Bluetooth::GenericAttributeProfile::GattSubscribedClient>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Devices::Bluetooth::GenericAttributeProfile::GattSubscribedClient>::type_name);
        return nullptr;
    }

    static void _dealloc_GattSubscribedClient(py::wrapper::Windows::Devices::Bluetooth::GenericAttributeProfile::GattSubscribedClient* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* GattSubscribedClient_get_MaxNotificationSize(py::wrapper::Windows::Devices::Bluetooth::GenericAttributeProfile::GattSubscribedClient* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Bluetooth.GenericAttributeProfile.GattSubscribedClient", L"MaxNotificationSize"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.MaxNotificationSize());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* GattSubscribedClient_get_Session(py::wrapper::Windows::Devices::Bluetooth::GenericAttributeProfile::GattSubscribedClient* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Bluetooth.GenericAttributeProfile.GattSubscribedClient", L"Session"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Session());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* GattSubscribedClient_add_MaxNotificationSizeChanged(py::wrapper::Windows::Devices::Bluetooth::GenericAttributeProfile::GattSubscribedClient* self, PyObject* arg) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Devices.Bluetooth.GenericAttributeProfile.GattSubscribedClient", L"MaxNotificationSizeChanged"))
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Devices::Bluetooth::GenericAttributeProfile::GattSubscribedClient, winrt::Windows::Foundation::IInspectable>>(arg);

            return py::convert(self->obj.MaxNotificationSizeChanged(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* GattSubscribedClient_remove_MaxNotificationSizeChanged(py::wrapper::Windows::Devices::Bluetooth::GenericAttributeProfile::GattSubscribedClient* self, PyObject* arg) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Devices.Bluetooth.GenericAttributeProfile.GattSubscribedClient", L"MaxNotificationSizeChanged"))
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.MaxNotificationSizeChanged(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_GattSubscribedClient(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Devices::Bluetooth::GenericAttributeProfile::GattSubscribedClient>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_GattSubscribedClient(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Devices::Bluetooth::GenericAttributeProfile::GattSubscribedClient>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_GattSubscribedClient[] = {
        { "add_max_notification_size_changed", reinterpret_cast<PyCFunction>(GattSubscribedClient_add_MaxNotificationSizeChanged), METH_O, nullptr },
        { "remove_max_notification_size_changed", reinterpret_cast<PyCFunction>(GattSubscribedClient_remove_MaxNotificationSizeChanged), METH_O, nullptr },
        { "_assign_array_", _assign_array_GattSubscribedClient, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_GattSubscribedClient), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_GattSubscribedClient[] = {
        { "max_notification_size", reinterpret_cast<getter>(GattSubscribedClient_get_MaxNotificationSize), nullptr, nullptr, nullptr },
        { "session", reinterpret_cast<getter>(GattSubscribedClient_get_Session), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_GattSubscribedClient[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_GattSubscribedClient) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_GattSubscribedClient) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_GattSubscribedClient) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_GattSubscribedClient) },
        { },
    };

    static PyType_Spec type_spec_GattSubscribedClient =
    {
        "winrt._winrt_windows_devices_bluetooth_genericattributeprofile.GattSubscribedClient",
        sizeof(py::wrapper::Windows::Devices::Bluetooth::GenericAttributeProfile::GattSubscribedClient),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_GattSubscribedClient
    };

    // ----- GattValueChangedEventArgs class --------------------

    static PyObject* _new_GattValueChangedEventArgs(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Devices::Bluetooth::GenericAttributeProfile::GattValueChangedEventArgs>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Devices::Bluetooth::GenericAttributeProfile::GattValueChangedEventArgs>::type_name);
        return nullptr;
    }

    static void _dealloc_GattValueChangedEventArgs(py::wrapper::Windows::Devices::Bluetooth::GenericAttributeProfile::GattValueChangedEventArgs* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* GattValueChangedEventArgs_get_CharacteristicValue(py::wrapper::Windows::Devices::Bluetooth::GenericAttributeProfile::GattValueChangedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Bluetooth.GenericAttributeProfile.GattValueChangedEventArgs", L"CharacteristicValue"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.CharacteristicValue());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* GattValueChangedEventArgs_get_Timestamp(py::wrapper::Windows::Devices::Bluetooth::GenericAttributeProfile::GattValueChangedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Bluetooth.GenericAttributeProfile.GattValueChangedEventArgs", L"Timestamp"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Timestamp());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_GattValueChangedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Devices::Bluetooth::GenericAttributeProfile::GattValueChangedEventArgs>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_GattValueChangedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Devices::Bluetooth::GenericAttributeProfile::GattValueChangedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_GattValueChangedEventArgs[] = {
        { "_assign_array_", _assign_array_GattValueChangedEventArgs, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_GattValueChangedEventArgs), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_GattValueChangedEventArgs[] = {
        { "characteristic_value", reinterpret_cast<getter>(GattValueChangedEventArgs_get_CharacteristicValue), nullptr, nullptr, nullptr },
        { "timestamp", reinterpret_cast<getter>(GattValueChangedEventArgs_get_Timestamp), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_GattValueChangedEventArgs[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_GattValueChangedEventArgs) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_GattValueChangedEventArgs) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_GattValueChangedEventArgs) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_GattValueChangedEventArgs) },
        { },
    };

    static PyType_Spec type_spec_GattValueChangedEventArgs =
    {
        "winrt._winrt_windows_devices_bluetooth_genericattributeprofile.GattValueChangedEventArgs",
        sizeof(py::wrapper::Windows::Devices::Bluetooth::GenericAttributeProfile::GattValueChangedEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_GattValueChangedEventArgs
    };

    // ----- GattWriteRequest class --------------------

    static PyObject* _new_GattWriteRequest(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Devices::Bluetooth::GenericAttributeProfile::GattWriteRequest>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Devices::Bluetooth::GenericAttributeProfile::GattWriteRequest>::type_name);
        return nullptr;
    }

    static void _dealloc_GattWriteRequest(py::wrapper::Windows::Devices::Bluetooth::GenericAttributeProfile::GattWriteRequest* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* GattWriteRequest_Respond(py::wrapper::Windows::Devices::Bluetooth::GenericAttributeProfile::GattWriteRequest* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.Bluetooth.GenericAttributeProfile.GattWriteRequest", L"Respond", 0))
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                self->obj.Respond();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* GattWriteRequest_RespondWithProtocolError(py::wrapper::Windows::Devices::Bluetooth::GenericAttributeProfile::GattWriteRequest* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.Bluetooth.GenericAttributeProfile.GattWriteRequest", L"RespondWithProtocolError", 1))
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<uint8_t>(args, 0);

                self->obj.RespondWithProtocolError(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* GattWriteRequest_get_Offset(py::wrapper::Windows::Devices::Bluetooth::GenericAttributeProfile::GattWriteRequest* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Bluetooth.GenericAttributeProfile.GattWriteRequest", L"Offset"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Offset());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* GattWriteRequest_get_Option(py::wrapper::Windows::Devices::Bluetooth::GenericAttributeProfile::GattWriteRequest* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Bluetooth.GenericAttributeProfile.GattWriteRequest", L"Option"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Option());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* GattWriteRequest_get_State(py::wrapper::Windows::Devices::Bluetooth::GenericAttributeProfile::GattWriteRequest* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Bluetooth.GenericAttributeProfile.GattWriteRequest", L"State"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.State());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* GattWriteRequest_get_Value(py::wrapper::Windows::Devices::Bluetooth::GenericAttributeProfile::GattWriteRequest* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Bluetooth.GenericAttributeProfile.GattWriteRequest", L"Value"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Value());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* GattWriteRequest_add_StateChanged(py::wrapper::Windows::Devices::Bluetooth::GenericAttributeProfile::GattWriteRequest* self, PyObject* arg) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Devices.Bluetooth.GenericAttributeProfile.GattWriteRequest", L"StateChanged"))
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Devices::Bluetooth::GenericAttributeProfile::GattWriteRequest, winrt::Windows::Devices::Bluetooth::GenericAttributeProfile::GattRequestStateChangedEventArgs>>(arg);

            return py::convert(self->obj.StateChanged(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* GattWriteRequest_remove_StateChanged(py::wrapper::Windows::Devices::Bluetooth::GenericAttributeProfile::GattWriteRequest* self, PyObject* arg) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Devices.Bluetooth.GenericAttributeProfile.GattWriteRequest", L"StateChanged"))
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.StateChanged(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_GattWriteRequest(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Devices::Bluetooth::GenericAttributeProfile::GattWriteRequest>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_GattWriteRequest(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Devices::Bluetooth::GenericAttributeProfile::GattWriteRequest>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_GattWriteRequest[] = {
        { "respond", reinterpret_cast<PyCFunction>(GattWriteRequest_Respond), METH_VARARGS, nullptr },
        { "respond_with_protocol_error", reinterpret_cast<PyCFunction>(GattWriteRequest_RespondWithProtocolError), METH_VARARGS, nullptr },
        { "add_state_changed", reinterpret_cast<PyCFunction>(GattWriteRequest_add_StateChanged), METH_O, nullptr },
        { "remove_state_changed", reinterpret_cast<PyCFunction>(GattWriteRequest_remove_StateChanged), METH_O, nullptr },
        { "_assign_array_", _assign_array_GattWriteRequest, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_GattWriteRequest), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_GattWriteRequest[] = {
        { "offset", reinterpret_cast<getter>(GattWriteRequest_get_Offset), nullptr, nullptr, nullptr },
        { "option", reinterpret_cast<getter>(GattWriteRequest_get_Option), nullptr, nullptr, nullptr },
        { "state", reinterpret_cast<getter>(GattWriteRequest_get_State), nullptr, nullptr, nullptr },
        { "value", reinterpret_cast<getter>(GattWriteRequest_get_Value), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_GattWriteRequest[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_GattWriteRequest) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_GattWriteRequest) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_GattWriteRequest) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_GattWriteRequest) },
        { },
    };

    static PyType_Spec type_spec_GattWriteRequest =
    {
        "winrt._winrt_windows_devices_bluetooth_genericattributeprofile.GattWriteRequest",
        sizeof(py::wrapper::Windows::Devices::Bluetooth::GenericAttributeProfile::GattWriteRequest),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_GattWriteRequest
    };

    // ----- GattWriteRequestedEventArgs class --------------------

    static PyObject* _new_GattWriteRequestedEventArgs(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Devices::Bluetooth::GenericAttributeProfile::GattWriteRequestedEventArgs>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Devices::Bluetooth::GenericAttributeProfile::GattWriteRequestedEventArgs>::type_name);
        return nullptr;
    }

    static void _dealloc_GattWriteRequestedEventArgs(py::wrapper::Windows::Devices::Bluetooth::GenericAttributeProfile::GattWriteRequestedEventArgs* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* GattWriteRequestedEventArgs_GetDeferral(py::wrapper::Windows::Devices::Bluetooth::GenericAttributeProfile::GattWriteRequestedEventArgs* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.Bluetooth.GenericAttributeProfile.GattWriteRequestedEventArgs", L"GetDeferral", 0))
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert(self->obj.GetDeferral());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* GattWriteRequestedEventArgs_GetRequestAsync(py::wrapper::Windows::Devices::Bluetooth::GenericAttributeProfile::GattWriteRequestedEventArgs* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.Bluetooth.GenericAttributeProfile.GattWriteRequestedEventArgs", L"GetRequestAsync", 0))
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert(self->obj.GetRequestAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* GattWriteRequestedEventArgs_get_Session(py::wrapper::Windows::Devices::Bluetooth::GenericAttributeProfile::GattWriteRequestedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Bluetooth.GenericAttributeProfile.GattWriteRequestedEventArgs", L"Session"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Session());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_GattWriteRequestedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Devices::Bluetooth::GenericAttributeProfile::GattWriteRequestedEventArgs>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_GattWriteRequestedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Devices::Bluetooth::GenericAttributeProfile::GattWriteRequestedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_GattWriteRequestedEventArgs[] = {
        { "get_deferral", reinterpret_cast<PyCFunction>(GattWriteRequestedEventArgs_GetDeferral), METH_VARARGS, nullptr },
        { "get_request_async", reinterpret_cast<PyCFunction>(GattWriteRequestedEventArgs_GetRequestAsync), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_GattWriteRequestedEventArgs, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_GattWriteRequestedEventArgs), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_GattWriteRequestedEventArgs[] = {
        { "session", reinterpret_cast<getter>(GattWriteRequestedEventArgs_get_Session), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_GattWriteRequestedEventArgs[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_GattWriteRequestedEventArgs) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_GattWriteRequestedEventArgs) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_GattWriteRequestedEventArgs) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_GattWriteRequestedEventArgs) },
        { },
    };

    static PyType_Spec type_spec_GattWriteRequestedEventArgs =
    {
        "winrt._winrt_windows_devices_bluetooth_genericattributeprofile.GattWriteRequestedEventArgs",
        sizeof(py::wrapper::Windows::Devices::Bluetooth::GenericAttributeProfile::GattWriteRequestedEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_GattWriteRequestedEventArgs
    };

    // ----- GattWriteResult class --------------------

    static PyObject* _new_GattWriteResult(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Devices::Bluetooth::GenericAttributeProfile::GattWriteResult>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Devices::Bluetooth::GenericAttributeProfile::GattWriteResult>::type_name);
        return nullptr;
    }

    static void _dealloc_GattWriteResult(py::wrapper::Windows::Devices::Bluetooth::GenericAttributeProfile::GattWriteResult* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* GattWriteResult_get_ProtocolError(py::wrapper::Windows::Devices::Bluetooth::GenericAttributeProfile::GattWriteResult* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Bluetooth.GenericAttributeProfile.GattWriteResult", L"ProtocolError"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.ProtocolError());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* GattWriteResult_get_Status(py::wrapper::Windows::Devices::Bluetooth::GenericAttributeProfile::GattWriteResult* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Bluetooth.GenericAttributeProfile.GattWriteResult", L"Status"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Status());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_GattWriteResult(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Devices::Bluetooth::GenericAttributeProfile::GattWriteResult>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_GattWriteResult(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Devices::Bluetooth::GenericAttributeProfile::GattWriteResult>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_GattWriteResult[] = {
        { "_assign_array_", _assign_array_GattWriteResult, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_GattWriteResult), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_GattWriteResult[] = {
        { "protocol_error", reinterpret_cast<getter>(GattWriteResult_get_ProtocolError), nullptr, nullptr, nullptr },
        { "status", reinterpret_cast<getter>(GattWriteResult_get_Status), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_GattWriteResult[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_GattWriteResult) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_GattWriteResult) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_GattWriteResult) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_GattWriteResult) },
        { },
    };

    static PyType_Spec type_spec_GattWriteResult =
    {
        "winrt._winrt_windows_devices_bluetooth_genericattributeprofile.GattWriteResult",
        sizeof(py::wrapper::Windows::Devices::Bluetooth::GenericAttributeProfile::GattWriteResult),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_GattWriteResult
    };

    // ----- Windows.Devices.Bluetooth.GenericAttributeProfile Initialization --------------------

    PyDoc_STRVAR(module_doc, "Windows.Devices.Bluetooth.GenericAttributeProfile");

    static PyModuleDef module_def = {
        PyModuleDef_HEAD_INIT,
        "_winrt_windows_devices_bluetooth_genericattributeprofile",
        module_doc,
        0,
        nullptr,
        nullptr,
        nullptr,
        nullptr,
        nullptr};
} // py::cpp::Windows::Devices::Bluetooth::GenericAttributeProfile

PyMODINIT_FUNC PyInit__winrt_windows_devices_bluetooth_genericattributeprofile(void) noexcept
{
    using namespace py::cpp::Windows::Devices::Bluetooth::GenericAttributeProfile;

    if (py::import_winrt_runtime() == -1)
    {
        return nullptr;
    }

    py::pyobj_handle module{PyModule_Create(&module_def)};

    if (!module)
    {
        return nullptr;
    }

    auto object_type = py::get_object_type();
    if (!object_type)
    {
        return nullptr;
    }

    py::pyobj_handle object_bases{PyTuple_Pack(1, object_type)};

    if (!object_bases)
    {
        return nullptr;
    }

    py::pyobj_handle type_GattCharacteristic_Static{PyType_FromSpec(&type_spec_GattCharacteristic_Static)};
    if (!type_GattCharacteristic_Static)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_GattCharacteristic, object_bases.get(), reinterpret_cast<PyTypeObject*>(type_GattCharacteristic_Static.get())) == -1)
    {
        return nullptr;
    }

    py::pyobj_handle type_GattCharacteristicUuids_Static{PyType_FromSpec(&type_spec_GattCharacteristicUuids_Static)};
    if (!type_GattCharacteristicUuids_Static)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_GattCharacteristicUuids, object_bases.get(), reinterpret_cast<PyTypeObject*>(type_GattCharacteristicUuids_Static.get())) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_GattCharacteristicsResult, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_GattClientNotificationResult, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    py::pyobj_handle type_GattDescriptor_Static{PyType_FromSpec(&type_spec_GattDescriptor_Static)};
    if (!type_GattDescriptor_Static)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_GattDescriptor, object_bases.get(), reinterpret_cast<PyTypeObject*>(type_GattDescriptor_Static.get())) == -1)
    {
        return nullptr;
    }

    py::pyobj_handle type_GattDescriptorUuids_Static{PyType_FromSpec(&type_spec_GattDescriptorUuids_Static)};
    if (!type_GattDescriptorUuids_Static)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_GattDescriptorUuids, object_bases.get(), reinterpret_cast<PyTypeObject*>(type_GattDescriptorUuids_Static.get())) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_GattDescriptorsResult, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    py::pyobj_handle type_GattDeviceService_Static{PyType_FromSpec(&type_spec_GattDeviceService_Static)};
    if (!type_GattDeviceService_Static)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_GattDeviceService, object_bases.get(), reinterpret_cast<PyTypeObject*>(type_GattDeviceService_Static.get())) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_GattDeviceServicesResult, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_GattLocalCharacteristic, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_GattLocalCharacteristicParameters, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_GattLocalCharacteristicResult, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_GattLocalDescriptor, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_GattLocalDescriptorParameters, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_GattLocalDescriptorResult, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_GattLocalService, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    py::pyobj_handle type_GattPresentationFormat_Static{PyType_FromSpec(&type_spec_GattPresentationFormat_Static)};
    if (!type_GattPresentationFormat_Static)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_GattPresentationFormat, object_bases.get(), reinterpret_cast<PyTypeObject*>(type_GattPresentationFormat_Static.get())) == -1)
    {
        return nullptr;
    }

    py::pyobj_handle type_GattPresentationFormatTypes_Static{PyType_FromSpec(&type_spec_GattPresentationFormatTypes_Static)};
    if (!type_GattPresentationFormatTypes_Static)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_GattPresentationFormatTypes, object_bases.get(), reinterpret_cast<PyTypeObject*>(type_GattPresentationFormatTypes_Static.get())) == -1)
    {
        return nullptr;
    }

    py::pyobj_handle type_GattProtocolError_Static{PyType_FromSpec(&type_spec_GattProtocolError_Static)};
    if (!type_GattProtocolError_Static)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_GattProtocolError, object_bases.get(), reinterpret_cast<PyTypeObject*>(type_GattProtocolError_Static.get())) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_GattReadClientCharacteristicConfigurationDescriptorResult, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_GattReadRequest, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_GattReadRequestedEventArgs, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_GattReadResult, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_GattReliableWriteTransaction, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_GattRequestStateChangedEventArgs, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    py::pyobj_handle type_GattServiceProvider_Static{PyType_FromSpec(&type_spec_GattServiceProvider_Static)};
    if (!type_GattServiceProvider_Static)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_GattServiceProvider, object_bases.get(), reinterpret_cast<PyTypeObject*>(type_GattServiceProvider_Static.get())) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_GattServiceProviderAdvertisementStatusChangedEventArgs, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_GattServiceProviderAdvertisingParameters, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_GattServiceProviderResult, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    py::pyobj_handle type_GattServiceUuids_Static{PyType_FromSpec(&type_spec_GattServiceUuids_Static)};
    if (!type_GattServiceUuids_Static)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_GattServiceUuids, object_bases.get(), reinterpret_cast<PyTypeObject*>(type_GattServiceUuids_Static.get())) == -1)
    {
        return nullptr;
    }

    py::pyobj_handle type_GattSession_Static{PyType_FromSpec(&type_spec_GattSession_Static)};
    if (!type_GattSession_Static)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_GattSession, object_bases.get(), reinterpret_cast<PyTypeObject*>(type_GattSession_Static.get())) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_GattSessionStatusChangedEventArgs, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_GattSubscribedClient, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_GattValueChangedEventArgs, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_GattWriteRequest, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_GattWriteRequestedEventArgs, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_GattWriteResult, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }


    return module.detach();
}
