// WARNING: Please don't edit this file. It was generated by Python/WinRT v0.0.0

#include "py.Windows.Foundation.Diagnostics.h"

namespace py::cpp::Windows::Foundation::Diagnostics
{
    // ----- AsyncCausalityTracer class --------------------

    static PyObject* _new_AsyncCausalityTracer(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Foundation::Diagnostics::AsyncCausalityTracer>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Foundation::Diagnostics::AsyncCausalityTracer>::type_name);
        return nullptr;
    }

    static PyObject* AsyncCausalityTracer_TraceOperationCompletion(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 5)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Foundation.Diagnostics.AsyncCausalityTracer", L"TraceOperationCompletion", 5);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(5);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Foundation::Diagnostics::CausalityTraceLevel>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Foundation::Diagnostics::CausalitySource>(args, 1);
                auto param2 = py::convert_to<winrt::guid>(args, 2);
                auto param3 = py::convert_to<uint64_t>(args, 3);
                auto param4 = py::convert_to<winrt::Windows::Foundation::AsyncStatus>(args, 4);

                {
                    auto _gil = release_gil();
                    winrt::Windows::Foundation::Diagnostics::AsyncCausalityTracer::TraceOperationCompletion(param0, param1, param2, param3, param4);
                }

                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AsyncCausalityTracer_TraceOperationCreation(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 6)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Foundation.Diagnostics.AsyncCausalityTracer", L"TraceOperationCreation", 6);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(6);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Foundation::Diagnostics::CausalityTraceLevel>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Foundation::Diagnostics::CausalitySource>(args, 1);
                auto param2 = py::convert_to<winrt::guid>(args, 2);
                auto param3 = py::convert_to<uint64_t>(args, 3);
                auto param4 = py::convert_to<winrt::hstring>(args, 4);
                auto param5 = py::convert_to<uint64_t>(args, 5);

                {
                    auto _gil = release_gil();
                    winrt::Windows::Foundation::Diagnostics::AsyncCausalityTracer::TraceOperationCreation(param0, param1, param2, param3, param4, param5);
                }

                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AsyncCausalityTracer_TraceOperationRelation(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 5)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Foundation.Diagnostics.AsyncCausalityTracer", L"TraceOperationRelation", 5);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(5);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Foundation::Diagnostics::CausalityTraceLevel>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Foundation::Diagnostics::CausalitySource>(args, 1);
                auto param2 = py::convert_to<winrt::guid>(args, 2);
                auto param3 = py::convert_to<uint64_t>(args, 3);
                auto param4 = py::convert_to<winrt::Windows::Foundation::Diagnostics::CausalityRelation>(args, 4);

                {
                    auto _gil = release_gil();
                    winrt::Windows::Foundation::Diagnostics::AsyncCausalityTracer::TraceOperationRelation(param0, param1, param2, param3, param4);
                }

                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AsyncCausalityTracer_TraceSynchronousWorkCompletion(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 3)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Foundation.Diagnostics.AsyncCausalityTracer", L"TraceSynchronousWorkCompletion", 3);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(3);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Foundation::Diagnostics::CausalityTraceLevel>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Foundation::Diagnostics::CausalitySource>(args, 1);
                auto param2 = py::convert_to<winrt::Windows::Foundation::Diagnostics::CausalitySynchronousWork>(args, 2);

                {
                    auto _gil = release_gil();
                    winrt::Windows::Foundation::Diagnostics::AsyncCausalityTracer::TraceSynchronousWorkCompletion(param0, param1, param2);
                }

                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AsyncCausalityTracer_TraceSynchronousWorkStart(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 5)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Foundation.Diagnostics.AsyncCausalityTracer", L"TraceSynchronousWorkStart", 5);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(5);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Foundation::Diagnostics::CausalityTraceLevel>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Foundation::Diagnostics::CausalitySource>(args, 1);
                auto param2 = py::convert_to<winrt::guid>(args, 2);
                auto param3 = py::convert_to<uint64_t>(args, 3);
                auto param4 = py::convert_to<winrt::Windows::Foundation::Diagnostics::CausalitySynchronousWork>(args, 4);

                {
                    auto _gil = release_gil();
                    winrt::Windows::Foundation::Diagnostics::AsyncCausalityTracer::TraceSynchronousWorkStart(param0, param1, param2, param3, param4);
                }

                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AsyncCausalityTracer_add_TracingStatusChanged(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            static std::optional<bool> is_event_present{};

            if (!is_event_present.has_value())
            {
                is_event_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Foundation.Diagnostics.AsyncCausalityTracer", L"TracingStatusChanged");
            }

            if (!is_event_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::EventHandler<winrt::Windows::Foundation::Diagnostics::TracingStatusChangedEventArgs>>(arg);

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return winrt::Windows::Foundation::Diagnostics::AsyncCausalityTracer::TracingStatusChanged(param0);
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AsyncCausalityTracer_remove_TracingStatusChanged(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            static std::optional<bool> is_event_present{};

            if (!is_event_present.has_value())
            {
                is_event_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Foundation.Diagnostics.AsyncCausalityTracer", L"TracingStatusChanged");
            }

            if (!is_event_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::event_token>(arg);

            {
                auto _gil = release_gil();
                winrt::Windows::Foundation::Diagnostics::AsyncCausalityTracer::TracingStatusChanged(param0);
            }

            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_AsyncCausalityTracer[] = {
        { }
    };

    static PyGetSetDef _getset_AsyncCausalityTracer[] = {
        { }
    };

    static PyType_Slot _type_slots_AsyncCausalityTracer[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_AsyncCausalityTracer) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_AsyncCausalityTracer) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_AsyncCausalityTracer) },
        { }
    };

    static PyType_Spec type_spec_AsyncCausalityTracer = {
        "winrt._winrt_windows_foundation_diagnostics.AsyncCausalityTracer",
        0,
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_AsyncCausalityTracer};

    static PyGetSetDef getset_AsyncCausalityTracer_Static[] = {
        { }
    };

    static PyMethodDef methods_AsyncCausalityTracer_Static[] = {
        { "trace_operation_completion", reinterpret_cast<PyCFunction>(AsyncCausalityTracer_TraceOperationCompletion), METH_VARARGS, nullptr },
        { "trace_operation_creation", reinterpret_cast<PyCFunction>(AsyncCausalityTracer_TraceOperationCreation), METH_VARARGS, nullptr },
        { "trace_operation_relation", reinterpret_cast<PyCFunction>(AsyncCausalityTracer_TraceOperationRelation), METH_VARARGS, nullptr },
        { "trace_synchronous_work_completion", reinterpret_cast<PyCFunction>(AsyncCausalityTracer_TraceSynchronousWorkCompletion), METH_VARARGS, nullptr },
        { "trace_synchronous_work_start", reinterpret_cast<PyCFunction>(AsyncCausalityTracer_TraceSynchronousWorkStart), METH_VARARGS, nullptr },
        { "add_tracing_status_changed", reinterpret_cast<PyCFunction>(AsyncCausalityTracer_add_TracingStatusChanged), METH_O, nullptr },
        { "remove_tracing_status_changed", reinterpret_cast<PyCFunction>(AsyncCausalityTracer_remove_TracingStatusChanged), METH_O, nullptr },
        { }
    };

    static PyType_Slot type_slots_AsyncCausalityTracer_Static[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_AsyncCausalityTracer_Static) },
        { Py_tp_methods, reinterpret_cast<void*>(methods_AsyncCausalityTracer_Static) },
        { }
    };

    static PyType_Spec type_spec_AsyncCausalityTracer_Static =
    {
        "winrt._winrt_windows_foundation_diagnostics.AsyncCausalityTracer_Static",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT,
        type_slots_AsyncCausalityTracer_Static
    };

    // ----- ErrorDetails class --------------------

    static PyObject* _new_ErrorDetails(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Foundation::Diagnostics::ErrorDetails>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Foundation::Diagnostics::ErrorDetails>::type_name);
        return nullptr;
    }

    static void _dealloc_ErrorDetails(py::wrapper::Windows::Foundation::Diagnostics::ErrorDetails* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* ErrorDetails_CreateFromHResultAsync(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Foundation.Diagnostics.ErrorDetails", L"CreateFromHResultAsync", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<int32_t>(args, 0);

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return winrt::Windows::Foundation::Diagnostics::ErrorDetails::CreateFromHResultAsync(param0);
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ErrorDetails_get_Description(py::wrapper::Windows::Foundation::Diagnostics::ErrorDetails* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Foundation.Diagnostics.ErrorDetails", L"Description");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Description();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ErrorDetails_get_HelpUri(py::wrapper::Windows::Foundation::Diagnostics::ErrorDetails* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Foundation.Diagnostics.ErrorDetails", L"HelpUri");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.HelpUri();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ErrorDetails_get_LongDescription(py::wrapper::Windows::Foundation::Diagnostics::ErrorDetails* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Foundation.Diagnostics.ErrorDetails", L"LongDescription");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.LongDescription();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_ErrorDetails(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Foundation::Diagnostics::ErrorDetails>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_ErrorDetails(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Foundation::Diagnostics::ErrorDetails>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_ErrorDetails[] = {
        { "_assign_array_", _assign_array_ErrorDetails, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_ErrorDetails), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_ErrorDetails[] = {
        { "description", reinterpret_cast<getter>(ErrorDetails_get_Description), nullptr, nullptr, nullptr },
        { "help_uri", reinterpret_cast<getter>(ErrorDetails_get_HelpUri), nullptr, nullptr, nullptr },
        { "long_description", reinterpret_cast<getter>(ErrorDetails_get_LongDescription), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_ErrorDetails[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_ErrorDetails) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_ErrorDetails) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_ErrorDetails) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_ErrorDetails) },
        { }
    };

    static PyType_Spec type_spec_ErrorDetails = {
        "winrt._winrt_windows_foundation_diagnostics.ErrorDetails",
        sizeof(py::wrapper::Windows::Foundation::Diagnostics::ErrorDetails),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_ErrorDetails};

    static PyGetSetDef getset_ErrorDetails_Static[] = {
        { }
    };

    static PyMethodDef methods_ErrorDetails_Static[] = {
        { "create_from_h_result_async", reinterpret_cast<PyCFunction>(ErrorDetails_CreateFromHResultAsync), METH_VARARGS, nullptr },
        { }
    };

    static PyType_Slot type_slots_ErrorDetails_Static[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_ErrorDetails_Static) },
        { Py_tp_methods, reinterpret_cast<void*>(methods_ErrorDetails_Static) },
        { }
    };

    static PyType_Spec type_spec_ErrorDetails_Static =
    {
        "winrt._winrt_windows_foundation_diagnostics.ErrorDetails_Static",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT,
        type_slots_ErrorDetails_Static
    };

    // ----- FileLoggingSession class --------------------

    static PyObject* _new_FileLoggingSession(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                winrt::Windows::Foundation::Diagnostics::FileLoggingSession instance{param0};
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_FileLoggingSession(py::wrapper::Windows::Foundation::Diagnostics::FileLoggingSession* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* FileLoggingSession_AddLoggingChannel(py::wrapper::Windows::Foundation::Diagnostics::FileLoggingSession* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Foundation.Diagnostics.FileLoggingSession", L"AddLoggingChannel", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Foundation::Diagnostics::ILoggingChannel>(args, 0);

                {
                    auto _gil = release_gil();
                    self->obj.AddLoggingChannel(param0);
                }

                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* FileLoggingSession_AddLoggingChannelWithLevel(py::wrapper::Windows::Foundation::Diagnostics::FileLoggingSession* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Foundation.Diagnostics.FileLoggingSession", L"AddLoggingChannel", 2);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(2);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Foundation::Diagnostics::ILoggingChannel>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Foundation::Diagnostics::LoggingLevel>(args, 1);

                {
                    auto _gil = release_gil();
                    self->obj.AddLoggingChannel(param0, param1);
                }

                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* FileLoggingSession_Close(py::wrapper::Windows::Foundation::Diagnostics::FileLoggingSession* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Foundation.Diagnostics.FileLoggingSession", L"Close", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                {
                    auto _gil = release_gil();
                    self->obj.Close();
                }

                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* FileLoggingSession_CloseAndSaveToFileAsync(py::wrapper::Windows::Foundation::Diagnostics::FileLoggingSession* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Foundation.Diagnostics.FileLoggingSession", L"CloseAndSaveToFileAsync", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return self->obj.CloseAndSaveToFileAsync();
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* FileLoggingSession_RemoveLoggingChannel(py::wrapper::Windows::Foundation::Diagnostics::FileLoggingSession* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Foundation.Diagnostics.FileLoggingSession", L"RemoveLoggingChannel", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Foundation::Diagnostics::ILoggingChannel>(args, 0);

                {
                    auto _gil = release_gil();
                    self->obj.RemoveLoggingChannel(param0);
                }

                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* FileLoggingSession_get_Name(py::wrapper::Windows::Foundation::Diagnostics::FileLoggingSession* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Foundation.Diagnostics.FileLoggingSession", L"Name");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Name();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* FileLoggingSession_add_LogFileGenerated(py::wrapper::Windows::Foundation::Diagnostics::FileLoggingSession* self, PyObject* arg) noexcept
    {
        try
        {
            static std::optional<bool> is_event_present{};

            if (!is_event_present.has_value())
            {
                is_event_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Foundation.Diagnostics.FileLoggingSession", L"LogFileGenerated");
            }

            if (!is_event_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Foundation::Diagnostics::IFileLoggingSession, winrt::Windows::Foundation::Diagnostics::LogFileGeneratedEventArgs>>(arg);

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.LogFileGenerated(param0);
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* FileLoggingSession_remove_LogFileGenerated(py::wrapper::Windows::Foundation::Diagnostics::FileLoggingSession* self, PyObject* arg) noexcept
    {
        try
        {
            static std::optional<bool> is_event_present{};

            if (!is_event_present.has_value())
            {
                is_event_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Foundation.Diagnostics.FileLoggingSession", L"LogFileGenerated");
            }

            if (!is_event_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::event_token>(arg);

            {
                auto _gil = release_gil();
                self->obj.LogFileGenerated(param0);
            }

            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_FileLoggingSession(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Foundation::Diagnostics::FileLoggingSession>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_FileLoggingSession(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Foundation::Diagnostics::FileLoggingSession>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _enter_FileLoggingSession(py::wrapper::Windows::Foundation::Diagnostics::FileLoggingSession* self, PyObject* /*unused*/) noexcept
    {
        return Py_NewRef(self);
    }

    static PyObject* _exit_FileLoggingSession(py::wrapper::Windows::Foundation::Diagnostics::FileLoggingSession* self, PyObject* /*unused*/) noexcept
    {
        try
        {
            {
                auto _gil = py::release_gil();
                self->obj.Close();
            }

            Py_RETURN_FALSE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_FileLoggingSession[] = {
        { "add_logging_channel", reinterpret_cast<PyCFunction>(FileLoggingSession_AddLoggingChannel), METH_VARARGS, nullptr },
        { "add_logging_channel_with_level", reinterpret_cast<PyCFunction>(FileLoggingSession_AddLoggingChannelWithLevel), METH_VARARGS, nullptr },
        { "close", reinterpret_cast<PyCFunction>(FileLoggingSession_Close), METH_VARARGS, nullptr },
        { "close_and_save_to_file_async", reinterpret_cast<PyCFunction>(FileLoggingSession_CloseAndSaveToFileAsync), METH_VARARGS, nullptr },
        { "remove_logging_channel", reinterpret_cast<PyCFunction>(FileLoggingSession_RemoveLoggingChannel), METH_VARARGS, nullptr },
        { "add_log_file_generated", reinterpret_cast<PyCFunction>(FileLoggingSession_add_LogFileGenerated), METH_O, nullptr },
        { "remove_log_file_generated", reinterpret_cast<PyCFunction>(FileLoggingSession_remove_LogFileGenerated), METH_O, nullptr },
        { "_assign_array_", _assign_array_FileLoggingSession, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_FileLoggingSession), METH_O | METH_STATIC, nullptr },
        { "__enter__", reinterpret_cast<PyCFunction>(_enter_FileLoggingSession), METH_NOARGS, nullptr },
        { "__exit__", reinterpret_cast<PyCFunction>(_exit_FileLoggingSession), METH_VARARGS, nullptr },
        { }
    };

    static PyGetSetDef _getset_FileLoggingSession[] = {
        { "name", reinterpret_cast<getter>(FileLoggingSession_get_Name), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_FileLoggingSession[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_FileLoggingSession) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_FileLoggingSession) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_FileLoggingSession) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_FileLoggingSession) },
        { }
    };

    static PyType_Spec type_spec_FileLoggingSession = {
        "winrt._winrt_windows_foundation_diagnostics.FileLoggingSession",
        sizeof(py::wrapper::Windows::Foundation::Diagnostics::FileLoggingSession),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_FileLoggingSession};

    // ----- LogFileGeneratedEventArgs class --------------------

    static PyObject* _new_LogFileGeneratedEventArgs(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Foundation::Diagnostics::LogFileGeneratedEventArgs>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Foundation::Diagnostics::LogFileGeneratedEventArgs>::type_name);
        return nullptr;
    }

    static void _dealloc_LogFileGeneratedEventArgs(py::wrapper::Windows::Foundation::Diagnostics::LogFileGeneratedEventArgs* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* LogFileGeneratedEventArgs_get_File(py::wrapper::Windows::Foundation::Diagnostics::LogFileGeneratedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Foundation.Diagnostics.LogFileGeneratedEventArgs", L"File");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.File();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_LogFileGeneratedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Foundation::Diagnostics::LogFileGeneratedEventArgs>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_LogFileGeneratedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Foundation::Diagnostics::LogFileGeneratedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_LogFileGeneratedEventArgs[] = {
        { "_assign_array_", _assign_array_LogFileGeneratedEventArgs, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_LogFileGeneratedEventArgs), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_LogFileGeneratedEventArgs[] = {
        { "file", reinterpret_cast<getter>(LogFileGeneratedEventArgs_get_File), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_LogFileGeneratedEventArgs[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_LogFileGeneratedEventArgs) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_LogFileGeneratedEventArgs) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_LogFileGeneratedEventArgs) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_LogFileGeneratedEventArgs) },
        { }
    };

    static PyType_Spec type_spec_LogFileGeneratedEventArgs = {
        "winrt._winrt_windows_foundation_diagnostics.LogFileGeneratedEventArgs",
        sizeof(py::wrapper::Windows::Foundation::Diagnostics::LogFileGeneratedEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_LogFileGeneratedEventArgs};

    // ----- LoggingActivity class --------------------

    static PyObject* _new_LoggingActivity(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Foundation::Diagnostics::ILoggingChannel>(args, 1);

                winrt::Windows::Foundation::Diagnostics::LoggingActivity instance{param0, param1};
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 3)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Foundation::Diagnostics::ILoggingChannel>(args, 1);
                auto param2 = py::convert_to<winrt::Windows::Foundation::Diagnostics::LoggingLevel>(args, 2);

                winrt::Windows::Foundation::Diagnostics::LoggingActivity instance{param0, param1, param2};
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_LoggingActivity(py::wrapper::Windows::Foundation::Diagnostics::LoggingActivity* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* LoggingActivity_Close(py::wrapper::Windows::Foundation::Diagnostics::LoggingActivity* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Foundation.Diagnostics.LoggingActivity", L"Close", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                {
                    auto _gil = release_gil();
                    self->obj.Close();
                }

                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* LoggingActivity_IsEnabled(py::wrapper::Windows::Foundation::Diagnostics::LoggingActivity* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Foundation.Diagnostics.LoggingActivity", L"IsEnabled", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return self->obj.IsEnabled();
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* LoggingActivity_IsEnabledWithLevel(py::wrapper::Windows::Foundation::Diagnostics::LoggingActivity* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Foundation.Diagnostics.LoggingActivity", L"IsEnabled", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Foundation::Diagnostics::LoggingLevel>(args, 0);

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return self->obj.IsEnabled(param0);
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* LoggingActivity_IsEnabledWithLevelAndKeywords(py::wrapper::Windows::Foundation::Diagnostics::LoggingActivity* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Foundation.Diagnostics.LoggingActivity", L"IsEnabled", 2);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(2);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Foundation::Diagnostics::LoggingLevel>(args, 0);
                auto param1 = py::convert_to<int64_t>(args, 1);

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return self->obj.IsEnabled(param0, param1);
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* LoggingActivity_LogEvent(py::wrapper::Windows::Foundation::Diagnostics::LoggingActivity* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Foundation.Diagnostics.LoggingActivity", L"LogEvent", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                {
                    auto _gil = release_gil();
                    self->obj.LogEvent(param0);
                }

                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* LoggingActivity_LogEventWithFields(py::wrapper::Windows::Foundation::Diagnostics::LoggingActivity* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Foundation.Diagnostics.LoggingActivity", L"LogEvent", 2);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(2);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Foundation::Diagnostics::LoggingFields>(args, 1);

                {
                    auto _gil = release_gil();
                    self->obj.LogEvent(param0, param1);
                }

                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* LoggingActivity_LogEventWithFieldsAndLevel(py::wrapper::Windows::Foundation::Diagnostics::LoggingActivity* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 3)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Foundation.Diagnostics.LoggingActivity", L"LogEvent", 3);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(3);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Foundation::Diagnostics::LoggingFields>(args, 1);
                auto param2 = py::convert_to<winrt::Windows::Foundation::Diagnostics::LoggingLevel>(args, 2);

                {
                    auto _gil = release_gil();
                    self->obj.LogEvent(param0, param1, param2);
                }

                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* LoggingActivity_LogEventWithFieldsAndOptions(py::wrapper::Windows::Foundation::Diagnostics::LoggingActivity* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 4)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Foundation.Diagnostics.LoggingActivity", L"LogEvent", 4);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(4);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Foundation::Diagnostics::LoggingFields>(args, 1);
                auto param2 = py::convert_to<winrt::Windows::Foundation::Diagnostics::LoggingLevel>(args, 2);
                auto param3 = py::convert_to<winrt::Windows::Foundation::Diagnostics::LoggingOptions>(args, 3);

                {
                    auto _gil = release_gil();
                    self->obj.LogEvent(param0, param1, param2, param3);
                }

                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* LoggingActivity_StartActivity(py::wrapper::Windows::Foundation::Diagnostics::LoggingActivity* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Foundation.Diagnostics.LoggingActivity", L"StartActivity", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return self->obj.StartActivity(param0);
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* LoggingActivity_StartActivityWithFields(py::wrapper::Windows::Foundation::Diagnostics::LoggingActivity* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Foundation.Diagnostics.LoggingActivity", L"StartActivity", 2);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(2);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Foundation::Diagnostics::LoggingFields>(args, 1);

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return self->obj.StartActivity(param0, param1);
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* LoggingActivity_StartActivityWithFieldsAndLevel(py::wrapper::Windows::Foundation::Diagnostics::LoggingActivity* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 3)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Foundation.Diagnostics.LoggingActivity", L"StartActivity", 3);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(3);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Foundation::Diagnostics::LoggingFields>(args, 1);
                auto param2 = py::convert_to<winrt::Windows::Foundation::Diagnostics::LoggingLevel>(args, 2);

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return self->obj.StartActivity(param0, param1, param2);
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* LoggingActivity_StartActivityWithFieldsAndOptions(py::wrapper::Windows::Foundation::Diagnostics::LoggingActivity* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 4)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Foundation.Diagnostics.LoggingActivity", L"StartActivity", 4);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(4);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Foundation::Diagnostics::LoggingFields>(args, 1);
                auto param2 = py::convert_to<winrt::Windows::Foundation::Diagnostics::LoggingLevel>(args, 2);
                auto param3 = py::convert_to<winrt::Windows::Foundation::Diagnostics::LoggingOptions>(args, 3);

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return self->obj.StartActivity(param0, param1, param2, param3);
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* LoggingActivity_StopActivity(py::wrapper::Windows::Foundation::Diagnostics::LoggingActivity* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Foundation.Diagnostics.LoggingActivity", L"StopActivity", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                {
                    auto _gil = release_gil();
                    self->obj.StopActivity(param0);
                }

                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* LoggingActivity_StopActivityWithFields(py::wrapper::Windows::Foundation::Diagnostics::LoggingActivity* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Foundation.Diagnostics.LoggingActivity", L"StopActivity", 2);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(2);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Foundation::Diagnostics::LoggingFields>(args, 1);

                {
                    auto _gil = release_gil();
                    self->obj.StopActivity(param0, param1);
                }

                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* LoggingActivity_StopActivityWithFieldsAndOptions(py::wrapper::Windows::Foundation::Diagnostics::LoggingActivity* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 3)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Foundation.Diagnostics.LoggingActivity", L"StopActivity", 3);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(3);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Foundation::Diagnostics::LoggingFields>(args, 1);
                auto param2 = py::convert_to<winrt::Windows::Foundation::Diagnostics::LoggingOptions>(args, 2);

                {
                    auto _gil = release_gil();
                    self->obj.StopActivity(param0, param1, param2);
                }

                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* LoggingActivity_get_Id(py::wrapper::Windows::Foundation::Diagnostics::LoggingActivity* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Foundation.Diagnostics.LoggingActivity", L"Id");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Id();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* LoggingActivity_get_Name(py::wrapper::Windows::Foundation::Diagnostics::LoggingActivity* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Foundation.Diagnostics.LoggingActivity", L"Name");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Name();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* LoggingActivity_get_Channel(py::wrapper::Windows::Foundation::Diagnostics::LoggingActivity* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Foundation.Diagnostics.LoggingActivity", L"Channel");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Channel();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_LoggingActivity(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Foundation::Diagnostics::LoggingActivity>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_LoggingActivity(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Foundation::Diagnostics::LoggingActivity>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _enter_LoggingActivity(py::wrapper::Windows::Foundation::Diagnostics::LoggingActivity* self, PyObject* /*unused*/) noexcept
    {
        return Py_NewRef(self);
    }

    static PyObject* _exit_LoggingActivity(py::wrapper::Windows::Foundation::Diagnostics::LoggingActivity* self, PyObject* /*unused*/) noexcept
    {
        try
        {
            {
                auto _gil = py::release_gil();
                self->obj.Close();
            }

            Py_RETURN_FALSE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_LoggingActivity[] = {
        { "close", reinterpret_cast<PyCFunction>(LoggingActivity_Close), METH_VARARGS, nullptr },
        { "is_enabled", reinterpret_cast<PyCFunction>(LoggingActivity_IsEnabled), METH_VARARGS, nullptr },
        { "is_enabled_with_level", reinterpret_cast<PyCFunction>(LoggingActivity_IsEnabledWithLevel), METH_VARARGS, nullptr },
        { "is_enabled_with_level_and_keywords", reinterpret_cast<PyCFunction>(LoggingActivity_IsEnabledWithLevelAndKeywords), METH_VARARGS, nullptr },
        { "log_event", reinterpret_cast<PyCFunction>(LoggingActivity_LogEvent), METH_VARARGS, nullptr },
        { "log_event_with_fields", reinterpret_cast<PyCFunction>(LoggingActivity_LogEventWithFields), METH_VARARGS, nullptr },
        { "log_event_with_fields_and_level", reinterpret_cast<PyCFunction>(LoggingActivity_LogEventWithFieldsAndLevel), METH_VARARGS, nullptr },
        { "log_event_with_fields_and_options", reinterpret_cast<PyCFunction>(LoggingActivity_LogEventWithFieldsAndOptions), METH_VARARGS, nullptr },
        { "start_activity", reinterpret_cast<PyCFunction>(LoggingActivity_StartActivity), METH_VARARGS, nullptr },
        { "start_activity_with_fields", reinterpret_cast<PyCFunction>(LoggingActivity_StartActivityWithFields), METH_VARARGS, nullptr },
        { "start_activity_with_fields_and_level", reinterpret_cast<PyCFunction>(LoggingActivity_StartActivityWithFieldsAndLevel), METH_VARARGS, nullptr },
        { "start_activity_with_fields_and_options", reinterpret_cast<PyCFunction>(LoggingActivity_StartActivityWithFieldsAndOptions), METH_VARARGS, nullptr },
        { "stop_activity", reinterpret_cast<PyCFunction>(LoggingActivity_StopActivity), METH_VARARGS, nullptr },
        { "stop_activity_with_fields", reinterpret_cast<PyCFunction>(LoggingActivity_StopActivityWithFields), METH_VARARGS, nullptr },
        { "stop_activity_with_fields_and_options", reinterpret_cast<PyCFunction>(LoggingActivity_StopActivityWithFieldsAndOptions), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_LoggingActivity, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_LoggingActivity), METH_O | METH_STATIC, nullptr },
        { "__enter__", reinterpret_cast<PyCFunction>(_enter_LoggingActivity), METH_NOARGS, nullptr },
        { "__exit__", reinterpret_cast<PyCFunction>(_exit_LoggingActivity), METH_VARARGS, nullptr },
        { }
    };

    static PyGetSetDef _getset_LoggingActivity[] = {
        { "id", reinterpret_cast<getter>(LoggingActivity_get_Id), nullptr, nullptr, nullptr },
        { "name", reinterpret_cast<getter>(LoggingActivity_get_Name), nullptr, nullptr, nullptr },
        { "channel", reinterpret_cast<getter>(LoggingActivity_get_Channel), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_LoggingActivity[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_LoggingActivity) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_LoggingActivity) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_LoggingActivity) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_LoggingActivity) },
        { }
    };

    static PyType_Spec type_spec_LoggingActivity = {
        "winrt._winrt_windows_foundation_diagnostics.LoggingActivity",
        sizeof(py::wrapper::Windows::Foundation::Diagnostics::LoggingActivity),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_LoggingActivity};

    // ----- LoggingChannel class --------------------

    static PyObject* _new_LoggingChannel(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Foundation::Diagnostics::LoggingChannelOptions>(args, 1);

                winrt::Windows::Foundation::Diagnostics::LoggingChannel instance{param0, param1};
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 3)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Foundation::Diagnostics::LoggingChannelOptions>(args, 1);
                auto param2 = py::convert_to<winrt::guid>(args, 2);

                winrt::Windows::Foundation::Diagnostics::LoggingChannel instance{param0, param1, param2};
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                winrt::Windows::Foundation::Diagnostics::LoggingChannel instance{param0};
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_LoggingChannel(py::wrapper::Windows::Foundation::Diagnostics::LoggingChannel* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* LoggingChannel_Close(py::wrapper::Windows::Foundation::Diagnostics::LoggingChannel* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Foundation.Diagnostics.LoggingChannel", L"Close", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                {
                    auto _gil = release_gil();
                    self->obj.Close();
                }

                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* LoggingChannel_IsEnabled(py::wrapper::Windows::Foundation::Diagnostics::LoggingChannel* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Foundation.Diagnostics.LoggingChannel", L"IsEnabled", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return self->obj.IsEnabled();
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* LoggingChannel_IsEnabledWithLevel(py::wrapper::Windows::Foundation::Diagnostics::LoggingChannel* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Foundation.Diagnostics.LoggingChannel", L"IsEnabled", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Foundation::Diagnostics::LoggingLevel>(args, 0);

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return self->obj.IsEnabled(param0);
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* LoggingChannel_IsEnabledWithLevelAndKeywords(py::wrapper::Windows::Foundation::Diagnostics::LoggingChannel* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Foundation.Diagnostics.LoggingChannel", L"IsEnabled", 2);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(2);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Foundation::Diagnostics::LoggingLevel>(args, 0);
                auto param1 = py::convert_to<int64_t>(args, 1);

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return self->obj.IsEnabled(param0, param1);
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* LoggingChannel_LogEvent(py::wrapper::Windows::Foundation::Diagnostics::LoggingChannel* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Foundation.Diagnostics.LoggingChannel", L"LogEvent", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                {
                    auto _gil = release_gil();
                    self->obj.LogEvent(param0);
                }

                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* LoggingChannel_LogEventWithFields(py::wrapper::Windows::Foundation::Diagnostics::LoggingChannel* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Foundation.Diagnostics.LoggingChannel", L"LogEvent", 2);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(2);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Foundation::Diagnostics::LoggingFields>(args, 1);

                {
                    auto _gil = release_gil();
                    self->obj.LogEvent(param0, param1);
                }

                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* LoggingChannel_LogEventWithFieldsAndLevel(py::wrapper::Windows::Foundation::Diagnostics::LoggingChannel* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 3)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Foundation.Diagnostics.LoggingChannel", L"LogEvent", 3);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(3);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Foundation::Diagnostics::LoggingFields>(args, 1);
                auto param2 = py::convert_to<winrt::Windows::Foundation::Diagnostics::LoggingLevel>(args, 2);

                {
                    auto _gil = release_gil();
                    self->obj.LogEvent(param0, param1, param2);
                }

                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* LoggingChannel_LogEventWithFieldsAndOptions(py::wrapper::Windows::Foundation::Diagnostics::LoggingChannel* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 4)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Foundation.Diagnostics.LoggingChannel", L"LogEvent", 4);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(4);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Foundation::Diagnostics::LoggingFields>(args, 1);
                auto param2 = py::convert_to<winrt::Windows::Foundation::Diagnostics::LoggingLevel>(args, 2);
                auto param3 = py::convert_to<winrt::Windows::Foundation::Diagnostics::LoggingOptions>(args, 3);

                {
                    auto _gil = release_gil();
                    self->obj.LogEvent(param0, param1, param2, param3);
                }

                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* LoggingChannel_LogMessage(py::wrapper::Windows::Foundation::Diagnostics::LoggingChannel* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Foundation.Diagnostics.LoggingChannel", L"LogMessage", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                {
                    auto _gil = release_gil();
                    self->obj.LogMessage(param0);
                }

                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* LoggingChannel_LogMessageWithLevel(py::wrapper::Windows::Foundation::Diagnostics::LoggingChannel* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Foundation.Diagnostics.LoggingChannel", L"LogMessage", 2);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(2);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Foundation::Diagnostics::LoggingLevel>(args, 1);

                {
                    auto _gil = release_gil();
                    self->obj.LogMessage(param0, param1);
                }

                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* LoggingChannel_LogValuePair(py::wrapper::Windows::Foundation::Diagnostics::LoggingChannel* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Foundation.Diagnostics.LoggingChannel", L"LogValuePair", 2);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(2);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<int32_t>(args, 1);

                {
                    auto _gil = release_gil();
                    self->obj.LogValuePair(param0, param1);
                }

                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* LoggingChannel_LogValuePairWithLevel(py::wrapper::Windows::Foundation::Diagnostics::LoggingChannel* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 3)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Foundation.Diagnostics.LoggingChannel", L"LogValuePair", 3);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(3);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<int32_t>(args, 1);
                auto param2 = py::convert_to<winrt::Windows::Foundation::Diagnostics::LoggingLevel>(args, 2);

                {
                    auto _gil = release_gil();
                    self->obj.LogValuePair(param0, param1, param2);
                }

                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* LoggingChannel_StartActivity(py::wrapper::Windows::Foundation::Diagnostics::LoggingChannel* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Foundation.Diagnostics.LoggingChannel", L"StartActivity", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return self->obj.StartActivity(param0);
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* LoggingChannel_StartActivityWithFields(py::wrapper::Windows::Foundation::Diagnostics::LoggingChannel* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Foundation.Diagnostics.LoggingChannel", L"StartActivity", 2);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(2);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Foundation::Diagnostics::LoggingFields>(args, 1);

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return self->obj.StartActivity(param0, param1);
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* LoggingChannel_StartActivityWithFieldsAndLevel(py::wrapper::Windows::Foundation::Diagnostics::LoggingChannel* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 3)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Foundation.Diagnostics.LoggingChannel", L"StartActivity", 3);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(3);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Foundation::Diagnostics::LoggingFields>(args, 1);
                auto param2 = py::convert_to<winrt::Windows::Foundation::Diagnostics::LoggingLevel>(args, 2);

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return self->obj.StartActivity(param0, param1, param2);
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* LoggingChannel_StartActivityWithFieldsAndOptions(py::wrapper::Windows::Foundation::Diagnostics::LoggingChannel* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 4)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Foundation.Diagnostics.LoggingChannel", L"StartActivity", 4);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(4);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Foundation::Diagnostics::LoggingFields>(args, 1);
                auto param2 = py::convert_to<winrt::Windows::Foundation::Diagnostics::LoggingLevel>(args, 2);
                auto param3 = py::convert_to<winrt::Windows::Foundation::Diagnostics::LoggingOptions>(args, 3);

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return self->obj.StartActivity(param0, param1, param2, param3);
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* LoggingChannel_get_Enabled(py::wrapper::Windows::Foundation::Diagnostics::LoggingChannel* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Foundation.Diagnostics.LoggingChannel", L"Enabled");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Enabled();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* LoggingChannel_get_Level(py::wrapper::Windows::Foundation::Diagnostics::LoggingChannel* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Foundation.Diagnostics.LoggingChannel", L"Level");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Level();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* LoggingChannel_get_Name(py::wrapper::Windows::Foundation::Diagnostics::LoggingChannel* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Foundation.Diagnostics.LoggingChannel", L"Name");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Name();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* LoggingChannel_get_Id(py::wrapper::Windows::Foundation::Diagnostics::LoggingChannel* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Foundation.Diagnostics.LoggingChannel", L"Id");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Id();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* LoggingChannel_add_LoggingEnabled(py::wrapper::Windows::Foundation::Diagnostics::LoggingChannel* self, PyObject* arg) noexcept
    {
        try
        {
            static std::optional<bool> is_event_present{};

            if (!is_event_present.has_value())
            {
                is_event_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Foundation.Diagnostics.LoggingChannel", L"LoggingEnabled");
            }

            if (!is_event_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Foundation::Diagnostics::ILoggingChannel, winrt::Windows::Foundation::IInspectable>>(arg);

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.LoggingEnabled(param0);
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* LoggingChannel_remove_LoggingEnabled(py::wrapper::Windows::Foundation::Diagnostics::LoggingChannel* self, PyObject* arg) noexcept
    {
        try
        {
            static std::optional<bool> is_event_present{};

            if (!is_event_present.has_value())
            {
                is_event_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Foundation.Diagnostics.LoggingChannel", L"LoggingEnabled");
            }

            if (!is_event_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::event_token>(arg);

            {
                auto _gil = release_gil();
                self->obj.LoggingEnabled(param0);
            }

            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_LoggingChannel(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Foundation::Diagnostics::LoggingChannel>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_LoggingChannel(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Foundation::Diagnostics::LoggingChannel>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _enter_LoggingChannel(py::wrapper::Windows::Foundation::Diagnostics::LoggingChannel* self, PyObject* /*unused*/) noexcept
    {
        return Py_NewRef(self);
    }

    static PyObject* _exit_LoggingChannel(py::wrapper::Windows::Foundation::Diagnostics::LoggingChannel* self, PyObject* /*unused*/) noexcept
    {
        try
        {
            {
                auto _gil = py::release_gil();
                self->obj.Close();
            }

            Py_RETURN_FALSE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_LoggingChannel[] = {
        { "close", reinterpret_cast<PyCFunction>(LoggingChannel_Close), METH_VARARGS, nullptr },
        { "is_enabled", reinterpret_cast<PyCFunction>(LoggingChannel_IsEnabled), METH_VARARGS, nullptr },
        { "is_enabled_with_level", reinterpret_cast<PyCFunction>(LoggingChannel_IsEnabledWithLevel), METH_VARARGS, nullptr },
        { "is_enabled_with_level_and_keywords", reinterpret_cast<PyCFunction>(LoggingChannel_IsEnabledWithLevelAndKeywords), METH_VARARGS, nullptr },
        { "log_event", reinterpret_cast<PyCFunction>(LoggingChannel_LogEvent), METH_VARARGS, nullptr },
        { "log_event_with_fields", reinterpret_cast<PyCFunction>(LoggingChannel_LogEventWithFields), METH_VARARGS, nullptr },
        { "log_event_with_fields_and_level", reinterpret_cast<PyCFunction>(LoggingChannel_LogEventWithFieldsAndLevel), METH_VARARGS, nullptr },
        { "log_event_with_fields_and_options", reinterpret_cast<PyCFunction>(LoggingChannel_LogEventWithFieldsAndOptions), METH_VARARGS, nullptr },
        { "log_message", reinterpret_cast<PyCFunction>(LoggingChannel_LogMessage), METH_VARARGS, nullptr },
        { "log_message_with_level", reinterpret_cast<PyCFunction>(LoggingChannel_LogMessageWithLevel), METH_VARARGS, nullptr },
        { "log_value_pair", reinterpret_cast<PyCFunction>(LoggingChannel_LogValuePair), METH_VARARGS, nullptr },
        { "log_value_pair_with_level", reinterpret_cast<PyCFunction>(LoggingChannel_LogValuePairWithLevel), METH_VARARGS, nullptr },
        { "start_activity", reinterpret_cast<PyCFunction>(LoggingChannel_StartActivity), METH_VARARGS, nullptr },
        { "start_activity_with_fields", reinterpret_cast<PyCFunction>(LoggingChannel_StartActivityWithFields), METH_VARARGS, nullptr },
        { "start_activity_with_fields_and_level", reinterpret_cast<PyCFunction>(LoggingChannel_StartActivityWithFieldsAndLevel), METH_VARARGS, nullptr },
        { "start_activity_with_fields_and_options", reinterpret_cast<PyCFunction>(LoggingChannel_StartActivityWithFieldsAndOptions), METH_VARARGS, nullptr },
        { "add_logging_enabled", reinterpret_cast<PyCFunction>(LoggingChannel_add_LoggingEnabled), METH_O, nullptr },
        { "remove_logging_enabled", reinterpret_cast<PyCFunction>(LoggingChannel_remove_LoggingEnabled), METH_O, nullptr },
        { "_assign_array_", _assign_array_LoggingChannel, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_LoggingChannel), METH_O | METH_STATIC, nullptr },
        { "__enter__", reinterpret_cast<PyCFunction>(_enter_LoggingChannel), METH_NOARGS, nullptr },
        { "__exit__", reinterpret_cast<PyCFunction>(_exit_LoggingChannel), METH_VARARGS, nullptr },
        { }
    };

    static PyGetSetDef _getset_LoggingChannel[] = {
        { "enabled", reinterpret_cast<getter>(LoggingChannel_get_Enabled), nullptr, nullptr, nullptr },
        { "level", reinterpret_cast<getter>(LoggingChannel_get_Level), nullptr, nullptr, nullptr },
        { "name", reinterpret_cast<getter>(LoggingChannel_get_Name), nullptr, nullptr, nullptr },
        { "id", reinterpret_cast<getter>(LoggingChannel_get_Id), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_LoggingChannel[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_LoggingChannel) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_LoggingChannel) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_LoggingChannel) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_LoggingChannel) },
        { }
    };

    static PyType_Spec type_spec_LoggingChannel = {
        "winrt._winrt_windows_foundation_diagnostics.LoggingChannel",
        sizeof(py::wrapper::Windows::Foundation::Diagnostics::LoggingChannel),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_LoggingChannel};

    // ----- LoggingChannelOptions class --------------------

    static PyObject* _new_LoggingChannelOptions(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 0)
        {
            try
            {
                winrt::Windows::Foundation::Diagnostics::LoggingChannelOptions instance{};
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::guid>(args, 0);

                winrt::Windows::Foundation::Diagnostics::LoggingChannelOptions instance{param0};
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_LoggingChannelOptions(py::wrapper::Windows::Foundation::Diagnostics::LoggingChannelOptions* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* LoggingChannelOptions_get_Group(py::wrapper::Windows::Foundation::Diagnostics::LoggingChannelOptions* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Foundation.Diagnostics.LoggingChannelOptions", L"Group");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Group();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int LoggingChannelOptions_put_Group(py::wrapper::Windows::Foundation::Diagnostics::LoggingChannelOptions* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Foundation.Diagnostics.LoggingChannelOptions", L"Group");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::guid>(arg);

            {
                auto _gil = release_gil();
                self->obj.Group(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* _assign_array_LoggingChannelOptions(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Foundation::Diagnostics::LoggingChannelOptions>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_LoggingChannelOptions(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Foundation::Diagnostics::LoggingChannelOptions>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_LoggingChannelOptions[] = {
        { "_assign_array_", _assign_array_LoggingChannelOptions, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_LoggingChannelOptions), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_LoggingChannelOptions[] = {
        { "group", reinterpret_cast<getter>(LoggingChannelOptions_get_Group), reinterpret_cast<setter>(LoggingChannelOptions_put_Group), nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_LoggingChannelOptions[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_LoggingChannelOptions) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_LoggingChannelOptions) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_LoggingChannelOptions) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_LoggingChannelOptions) },
        { }
    };

    static PyType_Spec type_spec_LoggingChannelOptions = {
        "winrt._winrt_windows_foundation_diagnostics.LoggingChannelOptions",
        sizeof(py::wrapper::Windows::Foundation::Diagnostics::LoggingChannelOptions),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_LoggingChannelOptions};

    // ----- LoggingFields class --------------------

    static PyObject* _new_LoggingFields(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 0)
        {
            try
            {
                winrt::Windows::Foundation::Diagnostics::LoggingFields instance{};
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_LoggingFields(py::wrapper::Windows::Foundation::Diagnostics::LoggingFields* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* LoggingFields_AddBoolean(py::wrapper::Windows::Foundation::Diagnostics::LoggingFields* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Foundation.Diagnostics.LoggingFields", L"AddBoolean", 2);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(2);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<bool>(args, 1);

                {
                    auto _gil = release_gil();
                    self->obj.AddBoolean(param0, param1);
                }

                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* LoggingFields_AddBooleanArray(py::wrapper::Windows::Foundation::Diagnostics::LoggingFields* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Foundation.Diagnostics.LoggingFields", L"AddBooleanArray", 2);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(2);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<py::pybuf_view<bool, false>>(args, 1);

                {
                    auto _gil = release_gil();
                    self->obj.AddBooleanArray(param0, param1);
                }

                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* LoggingFields_AddBooleanArrayWithFormat(py::wrapper::Windows::Foundation::Diagnostics::LoggingFields* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 3)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Foundation.Diagnostics.LoggingFields", L"AddBooleanArray", 3);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(3);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<py::pybuf_view<bool, false>>(args, 1);
                auto param2 = py::convert_to<winrt::Windows::Foundation::Diagnostics::LoggingFieldFormat>(args, 2);

                {
                    auto _gil = release_gil();
                    self->obj.AddBooleanArray(param0, param1, param2);
                }

                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* LoggingFields_AddBooleanArrayWithFormatAndTags(py::wrapper::Windows::Foundation::Diagnostics::LoggingFields* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 4)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Foundation.Diagnostics.LoggingFields", L"AddBooleanArray", 4);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(4);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<py::pybuf_view<bool, false>>(args, 1);
                auto param2 = py::convert_to<winrt::Windows::Foundation::Diagnostics::LoggingFieldFormat>(args, 2);
                auto param3 = py::convert_to<int32_t>(args, 3);

                {
                    auto _gil = release_gil();
                    self->obj.AddBooleanArray(param0, param1, param2, param3);
                }

                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* LoggingFields_AddBooleanWithFormat(py::wrapper::Windows::Foundation::Diagnostics::LoggingFields* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 3)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Foundation.Diagnostics.LoggingFields", L"AddBoolean", 3);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(3);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<bool>(args, 1);
                auto param2 = py::convert_to<winrt::Windows::Foundation::Diagnostics::LoggingFieldFormat>(args, 2);

                {
                    auto _gil = release_gil();
                    self->obj.AddBoolean(param0, param1, param2);
                }

                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* LoggingFields_AddBooleanWithFormatAndTags(py::wrapper::Windows::Foundation::Diagnostics::LoggingFields* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 4)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Foundation.Diagnostics.LoggingFields", L"AddBoolean", 4);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(4);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<bool>(args, 1);
                auto param2 = py::convert_to<winrt::Windows::Foundation::Diagnostics::LoggingFieldFormat>(args, 2);
                auto param3 = py::convert_to<int32_t>(args, 3);

                {
                    auto _gil = release_gil();
                    self->obj.AddBoolean(param0, param1, param2, param3);
                }

                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* LoggingFields_AddChar16(py::wrapper::Windows::Foundation::Diagnostics::LoggingFields* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Foundation.Diagnostics.LoggingFields", L"AddChar16", 2);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(2);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<char16_t>(args, 1);

                {
                    auto _gil = release_gil();
                    self->obj.AddChar16(param0, param1);
                }

                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* LoggingFields_AddChar16Array(py::wrapper::Windows::Foundation::Diagnostics::LoggingFields* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Foundation.Diagnostics.LoggingFields", L"AddChar16Array", 2);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(2);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<py::pybuf_view<char16_t, false>>(args, 1);

                {
                    auto _gil = release_gil();
                    self->obj.AddChar16Array(param0, param1);
                }

                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* LoggingFields_AddChar16ArrayWithFormat(py::wrapper::Windows::Foundation::Diagnostics::LoggingFields* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 3)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Foundation.Diagnostics.LoggingFields", L"AddChar16Array", 3);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(3);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<py::pybuf_view<char16_t, false>>(args, 1);
                auto param2 = py::convert_to<winrt::Windows::Foundation::Diagnostics::LoggingFieldFormat>(args, 2);

                {
                    auto _gil = release_gil();
                    self->obj.AddChar16Array(param0, param1, param2);
                }

                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* LoggingFields_AddChar16ArrayWithFormatAndTags(py::wrapper::Windows::Foundation::Diagnostics::LoggingFields* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 4)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Foundation.Diagnostics.LoggingFields", L"AddChar16Array", 4);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(4);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<py::pybuf_view<char16_t, false>>(args, 1);
                auto param2 = py::convert_to<winrt::Windows::Foundation::Diagnostics::LoggingFieldFormat>(args, 2);
                auto param3 = py::convert_to<int32_t>(args, 3);

                {
                    auto _gil = release_gil();
                    self->obj.AddChar16Array(param0, param1, param2, param3);
                }

                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* LoggingFields_AddChar16WithFormat(py::wrapper::Windows::Foundation::Diagnostics::LoggingFields* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 3)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Foundation.Diagnostics.LoggingFields", L"AddChar16", 3);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(3);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<char16_t>(args, 1);
                auto param2 = py::convert_to<winrt::Windows::Foundation::Diagnostics::LoggingFieldFormat>(args, 2);

                {
                    auto _gil = release_gil();
                    self->obj.AddChar16(param0, param1, param2);
                }

                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* LoggingFields_AddChar16WithFormatAndTags(py::wrapper::Windows::Foundation::Diagnostics::LoggingFields* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 4)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Foundation.Diagnostics.LoggingFields", L"AddChar16", 4);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(4);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<char16_t>(args, 1);
                auto param2 = py::convert_to<winrt::Windows::Foundation::Diagnostics::LoggingFieldFormat>(args, 2);
                auto param3 = py::convert_to<int32_t>(args, 3);

                {
                    auto _gil = release_gil();
                    self->obj.AddChar16(param0, param1, param2, param3);
                }

                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* LoggingFields_AddDateTime(py::wrapper::Windows::Foundation::Diagnostics::LoggingFields* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Foundation.Diagnostics.LoggingFields", L"AddDateTime", 2);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(2);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Foundation::DateTime>(args, 1);

                {
                    auto _gil = release_gil();
                    self->obj.AddDateTime(param0, param1);
                }

                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* LoggingFields_AddDateTimeArray(py::wrapper::Windows::Foundation::Diagnostics::LoggingFields* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Foundation.Diagnostics.LoggingFields", L"AddDateTimeArray", 2);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(2);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<py::pybuf_view<winrt::Windows::Foundation::DateTime, false>>(args, 1);

                {
                    auto _gil = release_gil();
                    self->obj.AddDateTimeArray(param0, param1);
                }

                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* LoggingFields_AddDateTimeArrayWithFormat(py::wrapper::Windows::Foundation::Diagnostics::LoggingFields* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 3)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Foundation.Diagnostics.LoggingFields", L"AddDateTimeArray", 3);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(3);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<py::pybuf_view<winrt::Windows::Foundation::DateTime, false>>(args, 1);
                auto param2 = py::convert_to<winrt::Windows::Foundation::Diagnostics::LoggingFieldFormat>(args, 2);

                {
                    auto _gil = release_gil();
                    self->obj.AddDateTimeArray(param0, param1, param2);
                }

                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* LoggingFields_AddDateTimeArrayWithFormatAndTags(py::wrapper::Windows::Foundation::Diagnostics::LoggingFields* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 4)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Foundation.Diagnostics.LoggingFields", L"AddDateTimeArray", 4);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(4);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<py::pybuf_view<winrt::Windows::Foundation::DateTime, false>>(args, 1);
                auto param2 = py::convert_to<winrt::Windows::Foundation::Diagnostics::LoggingFieldFormat>(args, 2);
                auto param3 = py::convert_to<int32_t>(args, 3);

                {
                    auto _gil = release_gil();
                    self->obj.AddDateTimeArray(param0, param1, param2, param3);
                }

                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* LoggingFields_AddDateTimeWithFormat(py::wrapper::Windows::Foundation::Diagnostics::LoggingFields* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 3)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Foundation.Diagnostics.LoggingFields", L"AddDateTime", 3);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(3);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Foundation::DateTime>(args, 1);
                auto param2 = py::convert_to<winrt::Windows::Foundation::Diagnostics::LoggingFieldFormat>(args, 2);

                {
                    auto _gil = release_gil();
                    self->obj.AddDateTime(param0, param1, param2);
                }

                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* LoggingFields_AddDateTimeWithFormatAndTags(py::wrapper::Windows::Foundation::Diagnostics::LoggingFields* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 4)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Foundation.Diagnostics.LoggingFields", L"AddDateTime", 4);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(4);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Foundation::DateTime>(args, 1);
                auto param2 = py::convert_to<winrt::Windows::Foundation::Diagnostics::LoggingFieldFormat>(args, 2);
                auto param3 = py::convert_to<int32_t>(args, 3);

                {
                    auto _gil = release_gil();
                    self->obj.AddDateTime(param0, param1, param2, param3);
                }

                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* LoggingFields_AddDouble(py::wrapper::Windows::Foundation::Diagnostics::LoggingFields* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Foundation.Diagnostics.LoggingFields", L"AddDouble", 2);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(2);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<double>(args, 1);

                {
                    auto _gil = release_gil();
                    self->obj.AddDouble(param0, param1);
                }

                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* LoggingFields_AddDoubleArray(py::wrapper::Windows::Foundation::Diagnostics::LoggingFields* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Foundation.Diagnostics.LoggingFields", L"AddDoubleArray", 2);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(2);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<py::pybuf_view<double, false>>(args, 1);

                {
                    auto _gil = release_gil();
                    self->obj.AddDoubleArray(param0, param1);
                }

                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* LoggingFields_AddDoubleArrayWithFormat(py::wrapper::Windows::Foundation::Diagnostics::LoggingFields* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 3)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Foundation.Diagnostics.LoggingFields", L"AddDoubleArray", 3);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(3);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<py::pybuf_view<double, false>>(args, 1);
                auto param2 = py::convert_to<winrt::Windows::Foundation::Diagnostics::LoggingFieldFormat>(args, 2);

                {
                    auto _gil = release_gil();
                    self->obj.AddDoubleArray(param0, param1, param2);
                }

                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* LoggingFields_AddDoubleArrayWithFormatAndTags(py::wrapper::Windows::Foundation::Diagnostics::LoggingFields* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 4)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Foundation.Diagnostics.LoggingFields", L"AddDoubleArray", 4);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(4);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<py::pybuf_view<double, false>>(args, 1);
                auto param2 = py::convert_to<winrt::Windows::Foundation::Diagnostics::LoggingFieldFormat>(args, 2);
                auto param3 = py::convert_to<int32_t>(args, 3);

                {
                    auto _gil = release_gil();
                    self->obj.AddDoubleArray(param0, param1, param2, param3);
                }

                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* LoggingFields_AddDoubleWithFormat(py::wrapper::Windows::Foundation::Diagnostics::LoggingFields* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 3)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Foundation.Diagnostics.LoggingFields", L"AddDouble", 3);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(3);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<double>(args, 1);
                auto param2 = py::convert_to<winrt::Windows::Foundation::Diagnostics::LoggingFieldFormat>(args, 2);

                {
                    auto _gil = release_gil();
                    self->obj.AddDouble(param0, param1, param2);
                }

                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* LoggingFields_AddDoubleWithFormatAndTags(py::wrapper::Windows::Foundation::Diagnostics::LoggingFields* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 4)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Foundation.Diagnostics.LoggingFields", L"AddDouble", 4);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(4);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<double>(args, 1);
                auto param2 = py::convert_to<winrt::Windows::Foundation::Diagnostics::LoggingFieldFormat>(args, 2);
                auto param3 = py::convert_to<int32_t>(args, 3);

                {
                    auto _gil = release_gil();
                    self->obj.AddDouble(param0, param1, param2, param3);
                }

                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* LoggingFields_AddEmpty(py::wrapper::Windows::Foundation::Diagnostics::LoggingFields* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Foundation.Diagnostics.LoggingFields", L"AddEmpty", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                {
                    auto _gil = release_gil();
                    self->obj.AddEmpty(param0);
                }

                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* LoggingFields_AddEmptyWithFormat(py::wrapper::Windows::Foundation::Diagnostics::LoggingFields* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Foundation.Diagnostics.LoggingFields", L"AddEmpty", 2);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(2);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Foundation::Diagnostics::LoggingFieldFormat>(args, 1);

                {
                    auto _gil = release_gil();
                    self->obj.AddEmpty(param0, param1);
                }

                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* LoggingFields_AddEmptyWithFormatAndTags(py::wrapper::Windows::Foundation::Diagnostics::LoggingFields* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 3)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Foundation.Diagnostics.LoggingFields", L"AddEmpty", 3);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(3);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Foundation::Diagnostics::LoggingFieldFormat>(args, 1);
                auto param2 = py::convert_to<int32_t>(args, 2);

                {
                    auto _gil = release_gil();
                    self->obj.AddEmpty(param0, param1, param2);
                }

                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* LoggingFields_AddGuid(py::wrapper::Windows::Foundation::Diagnostics::LoggingFields* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Foundation.Diagnostics.LoggingFields", L"AddGuid", 2);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(2);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::guid>(args, 1);

                {
                    auto _gil = release_gil();
                    self->obj.AddGuid(param0, param1);
                }

                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* LoggingFields_AddGuidArray(py::wrapper::Windows::Foundation::Diagnostics::LoggingFields* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Foundation.Diagnostics.LoggingFields", L"AddGuidArray", 2);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(2);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<py::pybuf_view<winrt::guid, false>>(args, 1);

                {
                    auto _gil = release_gil();
                    self->obj.AddGuidArray(param0, param1);
                }

                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* LoggingFields_AddGuidArrayWithFormat(py::wrapper::Windows::Foundation::Diagnostics::LoggingFields* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 3)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Foundation.Diagnostics.LoggingFields", L"AddGuidArray", 3);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(3);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<py::pybuf_view<winrt::guid, false>>(args, 1);
                auto param2 = py::convert_to<winrt::Windows::Foundation::Diagnostics::LoggingFieldFormat>(args, 2);

                {
                    auto _gil = release_gil();
                    self->obj.AddGuidArray(param0, param1, param2);
                }

                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* LoggingFields_AddGuidArrayWithFormatAndTags(py::wrapper::Windows::Foundation::Diagnostics::LoggingFields* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 4)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Foundation.Diagnostics.LoggingFields", L"AddGuidArray", 4);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(4);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<py::pybuf_view<winrt::guid, false>>(args, 1);
                auto param2 = py::convert_to<winrt::Windows::Foundation::Diagnostics::LoggingFieldFormat>(args, 2);
                auto param3 = py::convert_to<int32_t>(args, 3);

                {
                    auto _gil = release_gil();
                    self->obj.AddGuidArray(param0, param1, param2, param3);
                }

                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* LoggingFields_AddGuidWithFormat(py::wrapper::Windows::Foundation::Diagnostics::LoggingFields* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 3)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Foundation.Diagnostics.LoggingFields", L"AddGuid", 3);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(3);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::guid>(args, 1);
                auto param2 = py::convert_to<winrt::Windows::Foundation::Diagnostics::LoggingFieldFormat>(args, 2);

                {
                    auto _gil = release_gil();
                    self->obj.AddGuid(param0, param1, param2);
                }

                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* LoggingFields_AddGuidWithFormatAndTags(py::wrapper::Windows::Foundation::Diagnostics::LoggingFields* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 4)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Foundation.Diagnostics.LoggingFields", L"AddGuid", 4);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(4);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::guid>(args, 1);
                auto param2 = py::convert_to<winrt::Windows::Foundation::Diagnostics::LoggingFieldFormat>(args, 2);
                auto param3 = py::convert_to<int32_t>(args, 3);

                {
                    auto _gil = release_gil();
                    self->obj.AddGuid(param0, param1, param2, param3);
                }

                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* LoggingFields_AddInt16(py::wrapper::Windows::Foundation::Diagnostics::LoggingFields* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Foundation.Diagnostics.LoggingFields", L"AddInt16", 2);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(2);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<int16_t>(args, 1);

                {
                    auto _gil = release_gil();
                    self->obj.AddInt16(param0, param1);
                }

                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* LoggingFields_AddInt16Array(py::wrapper::Windows::Foundation::Diagnostics::LoggingFields* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Foundation.Diagnostics.LoggingFields", L"AddInt16Array", 2);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(2);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<py::pybuf_view<int16_t, false>>(args, 1);

                {
                    auto _gil = release_gil();
                    self->obj.AddInt16Array(param0, param1);
                }

                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* LoggingFields_AddInt16ArrayWithFormat(py::wrapper::Windows::Foundation::Diagnostics::LoggingFields* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 3)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Foundation.Diagnostics.LoggingFields", L"AddInt16Array", 3);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(3);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<py::pybuf_view<int16_t, false>>(args, 1);
                auto param2 = py::convert_to<winrt::Windows::Foundation::Diagnostics::LoggingFieldFormat>(args, 2);

                {
                    auto _gil = release_gil();
                    self->obj.AddInt16Array(param0, param1, param2);
                }

                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* LoggingFields_AddInt16ArrayWithFormatAndTags(py::wrapper::Windows::Foundation::Diagnostics::LoggingFields* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 4)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Foundation.Diagnostics.LoggingFields", L"AddInt16Array", 4);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(4);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<py::pybuf_view<int16_t, false>>(args, 1);
                auto param2 = py::convert_to<winrt::Windows::Foundation::Diagnostics::LoggingFieldFormat>(args, 2);
                auto param3 = py::convert_to<int32_t>(args, 3);

                {
                    auto _gil = release_gil();
                    self->obj.AddInt16Array(param0, param1, param2, param3);
                }

                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* LoggingFields_AddInt16WithFormat(py::wrapper::Windows::Foundation::Diagnostics::LoggingFields* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 3)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Foundation.Diagnostics.LoggingFields", L"AddInt16", 3);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(3);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<int16_t>(args, 1);
                auto param2 = py::convert_to<winrt::Windows::Foundation::Diagnostics::LoggingFieldFormat>(args, 2);

                {
                    auto _gil = release_gil();
                    self->obj.AddInt16(param0, param1, param2);
                }

                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* LoggingFields_AddInt16WithFormatAndTags(py::wrapper::Windows::Foundation::Diagnostics::LoggingFields* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 4)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Foundation.Diagnostics.LoggingFields", L"AddInt16", 4);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(4);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<int16_t>(args, 1);
                auto param2 = py::convert_to<winrt::Windows::Foundation::Diagnostics::LoggingFieldFormat>(args, 2);
                auto param3 = py::convert_to<int32_t>(args, 3);

                {
                    auto _gil = release_gil();
                    self->obj.AddInt16(param0, param1, param2, param3);
                }

                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* LoggingFields_AddInt32(py::wrapper::Windows::Foundation::Diagnostics::LoggingFields* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Foundation.Diagnostics.LoggingFields", L"AddInt32", 2);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(2);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<int32_t>(args, 1);

                {
                    auto _gil = release_gil();
                    self->obj.AddInt32(param0, param1);
                }

                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* LoggingFields_AddInt32Array(py::wrapper::Windows::Foundation::Diagnostics::LoggingFields* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Foundation.Diagnostics.LoggingFields", L"AddInt32Array", 2);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(2);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<py::pybuf_view<int32_t, false>>(args, 1);

                {
                    auto _gil = release_gil();
                    self->obj.AddInt32Array(param0, param1);
                }

                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* LoggingFields_AddInt32ArrayWithFormat(py::wrapper::Windows::Foundation::Diagnostics::LoggingFields* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 3)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Foundation.Diagnostics.LoggingFields", L"AddInt32Array", 3);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(3);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<py::pybuf_view<int32_t, false>>(args, 1);
                auto param2 = py::convert_to<winrt::Windows::Foundation::Diagnostics::LoggingFieldFormat>(args, 2);

                {
                    auto _gil = release_gil();
                    self->obj.AddInt32Array(param0, param1, param2);
                }

                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* LoggingFields_AddInt32ArrayWithFormatAndTags(py::wrapper::Windows::Foundation::Diagnostics::LoggingFields* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 4)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Foundation.Diagnostics.LoggingFields", L"AddInt32Array", 4);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(4);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<py::pybuf_view<int32_t, false>>(args, 1);
                auto param2 = py::convert_to<winrt::Windows::Foundation::Diagnostics::LoggingFieldFormat>(args, 2);
                auto param3 = py::convert_to<int32_t>(args, 3);

                {
                    auto _gil = release_gil();
                    self->obj.AddInt32Array(param0, param1, param2, param3);
                }

                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* LoggingFields_AddInt32WithFormat(py::wrapper::Windows::Foundation::Diagnostics::LoggingFields* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 3)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Foundation.Diagnostics.LoggingFields", L"AddInt32", 3);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(3);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<int32_t>(args, 1);
                auto param2 = py::convert_to<winrt::Windows::Foundation::Diagnostics::LoggingFieldFormat>(args, 2);

                {
                    auto _gil = release_gil();
                    self->obj.AddInt32(param0, param1, param2);
                }

                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* LoggingFields_AddInt32WithFormatAndTags(py::wrapper::Windows::Foundation::Diagnostics::LoggingFields* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 4)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Foundation.Diagnostics.LoggingFields", L"AddInt32", 4);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(4);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<int32_t>(args, 1);
                auto param2 = py::convert_to<winrt::Windows::Foundation::Diagnostics::LoggingFieldFormat>(args, 2);
                auto param3 = py::convert_to<int32_t>(args, 3);

                {
                    auto _gil = release_gil();
                    self->obj.AddInt32(param0, param1, param2, param3);
                }

                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* LoggingFields_AddInt64(py::wrapper::Windows::Foundation::Diagnostics::LoggingFields* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Foundation.Diagnostics.LoggingFields", L"AddInt64", 2);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(2);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<int64_t>(args, 1);

                {
                    auto _gil = release_gil();
                    self->obj.AddInt64(param0, param1);
                }

                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* LoggingFields_AddInt64Array(py::wrapper::Windows::Foundation::Diagnostics::LoggingFields* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Foundation.Diagnostics.LoggingFields", L"AddInt64Array", 2);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(2);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<py::pybuf_view<int64_t, false>>(args, 1);

                {
                    auto _gil = release_gil();
                    self->obj.AddInt64Array(param0, param1);
                }

                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* LoggingFields_AddInt64ArrayWithFormat(py::wrapper::Windows::Foundation::Diagnostics::LoggingFields* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 3)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Foundation.Diagnostics.LoggingFields", L"AddInt64Array", 3);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(3);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<py::pybuf_view<int64_t, false>>(args, 1);
                auto param2 = py::convert_to<winrt::Windows::Foundation::Diagnostics::LoggingFieldFormat>(args, 2);

                {
                    auto _gil = release_gil();
                    self->obj.AddInt64Array(param0, param1, param2);
                }

                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* LoggingFields_AddInt64ArrayWithFormatAndTags(py::wrapper::Windows::Foundation::Diagnostics::LoggingFields* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 4)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Foundation.Diagnostics.LoggingFields", L"AddInt64Array", 4);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(4);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<py::pybuf_view<int64_t, false>>(args, 1);
                auto param2 = py::convert_to<winrt::Windows::Foundation::Diagnostics::LoggingFieldFormat>(args, 2);
                auto param3 = py::convert_to<int32_t>(args, 3);

                {
                    auto _gil = release_gil();
                    self->obj.AddInt64Array(param0, param1, param2, param3);
                }

                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* LoggingFields_AddInt64WithFormat(py::wrapper::Windows::Foundation::Diagnostics::LoggingFields* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 3)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Foundation.Diagnostics.LoggingFields", L"AddInt64", 3);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(3);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<int64_t>(args, 1);
                auto param2 = py::convert_to<winrt::Windows::Foundation::Diagnostics::LoggingFieldFormat>(args, 2);

                {
                    auto _gil = release_gil();
                    self->obj.AddInt64(param0, param1, param2);
                }

                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* LoggingFields_AddInt64WithFormatAndTags(py::wrapper::Windows::Foundation::Diagnostics::LoggingFields* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 4)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Foundation.Diagnostics.LoggingFields", L"AddInt64", 4);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(4);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<int64_t>(args, 1);
                auto param2 = py::convert_to<winrt::Windows::Foundation::Diagnostics::LoggingFieldFormat>(args, 2);
                auto param3 = py::convert_to<int32_t>(args, 3);

                {
                    auto _gil = release_gil();
                    self->obj.AddInt64(param0, param1, param2, param3);
                }

                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* LoggingFields_AddPoint(py::wrapper::Windows::Foundation::Diagnostics::LoggingFields* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Foundation.Diagnostics.LoggingFields", L"AddPoint", 2);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(2);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Foundation::Point>(args, 1);

                {
                    auto _gil = release_gil();
                    self->obj.AddPoint(param0, param1);
                }

                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* LoggingFields_AddPointArray(py::wrapper::Windows::Foundation::Diagnostics::LoggingFields* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Foundation.Diagnostics.LoggingFields", L"AddPointArray", 2);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(2);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<py::pybuf_view<winrt::Windows::Foundation::Point, false>>(args, 1);

                {
                    auto _gil = release_gil();
                    self->obj.AddPointArray(param0, param1);
                }

                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* LoggingFields_AddPointArrayWithFormat(py::wrapper::Windows::Foundation::Diagnostics::LoggingFields* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 3)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Foundation.Diagnostics.LoggingFields", L"AddPointArray", 3);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(3);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<py::pybuf_view<winrt::Windows::Foundation::Point, false>>(args, 1);
                auto param2 = py::convert_to<winrt::Windows::Foundation::Diagnostics::LoggingFieldFormat>(args, 2);

                {
                    auto _gil = release_gil();
                    self->obj.AddPointArray(param0, param1, param2);
                }

                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* LoggingFields_AddPointArrayWithFormatAndTags(py::wrapper::Windows::Foundation::Diagnostics::LoggingFields* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 4)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Foundation.Diagnostics.LoggingFields", L"AddPointArray", 4);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(4);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<py::pybuf_view<winrt::Windows::Foundation::Point, false>>(args, 1);
                auto param2 = py::convert_to<winrt::Windows::Foundation::Diagnostics::LoggingFieldFormat>(args, 2);
                auto param3 = py::convert_to<int32_t>(args, 3);

                {
                    auto _gil = release_gil();
                    self->obj.AddPointArray(param0, param1, param2, param3);
                }

                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* LoggingFields_AddPointWithFormat(py::wrapper::Windows::Foundation::Diagnostics::LoggingFields* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 3)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Foundation.Diagnostics.LoggingFields", L"AddPoint", 3);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(3);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Foundation::Point>(args, 1);
                auto param2 = py::convert_to<winrt::Windows::Foundation::Diagnostics::LoggingFieldFormat>(args, 2);

                {
                    auto _gil = release_gil();
                    self->obj.AddPoint(param0, param1, param2);
                }

                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* LoggingFields_AddPointWithFormatAndTags(py::wrapper::Windows::Foundation::Diagnostics::LoggingFields* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 4)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Foundation.Diagnostics.LoggingFields", L"AddPoint", 4);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(4);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Foundation::Point>(args, 1);
                auto param2 = py::convert_to<winrt::Windows::Foundation::Diagnostics::LoggingFieldFormat>(args, 2);
                auto param3 = py::convert_to<int32_t>(args, 3);

                {
                    auto _gil = release_gil();
                    self->obj.AddPoint(param0, param1, param2, param3);
                }

                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* LoggingFields_AddRect(py::wrapper::Windows::Foundation::Diagnostics::LoggingFields* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Foundation.Diagnostics.LoggingFields", L"AddRect", 2);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(2);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Foundation::Rect>(args, 1);

                {
                    auto _gil = release_gil();
                    self->obj.AddRect(param0, param1);
                }

                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* LoggingFields_AddRectArray(py::wrapper::Windows::Foundation::Diagnostics::LoggingFields* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Foundation.Diagnostics.LoggingFields", L"AddRectArray", 2);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(2);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<py::pybuf_view<winrt::Windows::Foundation::Rect, false>>(args, 1);

                {
                    auto _gil = release_gil();
                    self->obj.AddRectArray(param0, param1);
                }

                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* LoggingFields_AddRectArrayWithFormat(py::wrapper::Windows::Foundation::Diagnostics::LoggingFields* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 3)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Foundation.Diagnostics.LoggingFields", L"AddRectArray", 3);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(3);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<py::pybuf_view<winrt::Windows::Foundation::Rect, false>>(args, 1);
                auto param2 = py::convert_to<winrt::Windows::Foundation::Diagnostics::LoggingFieldFormat>(args, 2);

                {
                    auto _gil = release_gil();
                    self->obj.AddRectArray(param0, param1, param2);
                }

                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* LoggingFields_AddRectArrayWithFormatAndTags(py::wrapper::Windows::Foundation::Diagnostics::LoggingFields* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 4)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Foundation.Diagnostics.LoggingFields", L"AddRectArray", 4);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(4);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<py::pybuf_view<winrt::Windows::Foundation::Rect, false>>(args, 1);
                auto param2 = py::convert_to<winrt::Windows::Foundation::Diagnostics::LoggingFieldFormat>(args, 2);
                auto param3 = py::convert_to<int32_t>(args, 3);

                {
                    auto _gil = release_gil();
                    self->obj.AddRectArray(param0, param1, param2, param3);
                }

                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* LoggingFields_AddRectWithFormat(py::wrapper::Windows::Foundation::Diagnostics::LoggingFields* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 3)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Foundation.Diagnostics.LoggingFields", L"AddRect", 3);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(3);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Foundation::Rect>(args, 1);
                auto param2 = py::convert_to<winrt::Windows::Foundation::Diagnostics::LoggingFieldFormat>(args, 2);

                {
                    auto _gil = release_gil();
                    self->obj.AddRect(param0, param1, param2);
                }

                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* LoggingFields_AddRectWithFormatAndTags(py::wrapper::Windows::Foundation::Diagnostics::LoggingFields* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 4)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Foundation.Diagnostics.LoggingFields", L"AddRect", 4);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(4);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Foundation::Rect>(args, 1);
                auto param2 = py::convert_to<winrt::Windows::Foundation::Diagnostics::LoggingFieldFormat>(args, 2);
                auto param3 = py::convert_to<int32_t>(args, 3);

                {
                    auto _gil = release_gil();
                    self->obj.AddRect(param0, param1, param2, param3);
                }

                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* LoggingFields_AddSingle(py::wrapper::Windows::Foundation::Diagnostics::LoggingFields* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Foundation.Diagnostics.LoggingFields", L"AddSingle", 2);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(2);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<float>(args, 1);

                {
                    auto _gil = release_gil();
                    self->obj.AddSingle(param0, param1);
                }

                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* LoggingFields_AddSingleArray(py::wrapper::Windows::Foundation::Diagnostics::LoggingFields* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Foundation.Diagnostics.LoggingFields", L"AddSingleArray", 2);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(2);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<py::pybuf_view<float, false>>(args, 1);

                {
                    auto _gil = release_gil();
                    self->obj.AddSingleArray(param0, param1);
                }

                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* LoggingFields_AddSingleArrayWithFormat(py::wrapper::Windows::Foundation::Diagnostics::LoggingFields* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 3)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Foundation.Diagnostics.LoggingFields", L"AddSingleArray", 3);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(3);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<py::pybuf_view<float, false>>(args, 1);
                auto param2 = py::convert_to<winrt::Windows::Foundation::Diagnostics::LoggingFieldFormat>(args, 2);

                {
                    auto _gil = release_gil();
                    self->obj.AddSingleArray(param0, param1, param2);
                }

                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* LoggingFields_AddSingleArrayWithFormatAndTags(py::wrapper::Windows::Foundation::Diagnostics::LoggingFields* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 4)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Foundation.Diagnostics.LoggingFields", L"AddSingleArray", 4);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(4);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<py::pybuf_view<float, false>>(args, 1);
                auto param2 = py::convert_to<winrt::Windows::Foundation::Diagnostics::LoggingFieldFormat>(args, 2);
                auto param3 = py::convert_to<int32_t>(args, 3);

                {
                    auto _gil = release_gil();
                    self->obj.AddSingleArray(param0, param1, param2, param3);
                }

                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* LoggingFields_AddSingleWithFormat(py::wrapper::Windows::Foundation::Diagnostics::LoggingFields* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 3)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Foundation.Diagnostics.LoggingFields", L"AddSingle", 3);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(3);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<float>(args, 1);
                auto param2 = py::convert_to<winrt::Windows::Foundation::Diagnostics::LoggingFieldFormat>(args, 2);

                {
                    auto _gil = release_gil();
                    self->obj.AddSingle(param0, param1, param2);
                }

                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* LoggingFields_AddSingleWithFormatAndTags(py::wrapper::Windows::Foundation::Diagnostics::LoggingFields* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 4)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Foundation.Diagnostics.LoggingFields", L"AddSingle", 4);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(4);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<float>(args, 1);
                auto param2 = py::convert_to<winrt::Windows::Foundation::Diagnostics::LoggingFieldFormat>(args, 2);
                auto param3 = py::convert_to<int32_t>(args, 3);

                {
                    auto _gil = release_gil();
                    self->obj.AddSingle(param0, param1, param2, param3);
                }

                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* LoggingFields_AddSize(py::wrapper::Windows::Foundation::Diagnostics::LoggingFields* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Foundation.Diagnostics.LoggingFields", L"AddSize", 2);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(2);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Foundation::Size>(args, 1);

                {
                    auto _gil = release_gil();
                    self->obj.AddSize(param0, param1);
                }

                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* LoggingFields_AddSizeArray(py::wrapper::Windows::Foundation::Diagnostics::LoggingFields* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Foundation.Diagnostics.LoggingFields", L"AddSizeArray", 2);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(2);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<py::pybuf_view<winrt::Windows::Foundation::Size, false>>(args, 1);

                {
                    auto _gil = release_gil();
                    self->obj.AddSizeArray(param0, param1);
                }

                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* LoggingFields_AddSizeArrayWithFormat(py::wrapper::Windows::Foundation::Diagnostics::LoggingFields* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 3)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Foundation.Diagnostics.LoggingFields", L"AddSizeArray", 3);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(3);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<py::pybuf_view<winrt::Windows::Foundation::Size, false>>(args, 1);
                auto param2 = py::convert_to<winrt::Windows::Foundation::Diagnostics::LoggingFieldFormat>(args, 2);

                {
                    auto _gil = release_gil();
                    self->obj.AddSizeArray(param0, param1, param2);
                }

                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* LoggingFields_AddSizeArrayWithFormatAndTags(py::wrapper::Windows::Foundation::Diagnostics::LoggingFields* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 4)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Foundation.Diagnostics.LoggingFields", L"AddSizeArray", 4);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(4);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<py::pybuf_view<winrt::Windows::Foundation::Size, false>>(args, 1);
                auto param2 = py::convert_to<winrt::Windows::Foundation::Diagnostics::LoggingFieldFormat>(args, 2);
                auto param3 = py::convert_to<int32_t>(args, 3);

                {
                    auto _gil = release_gil();
                    self->obj.AddSizeArray(param0, param1, param2, param3);
                }

                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* LoggingFields_AddSizeWithFormat(py::wrapper::Windows::Foundation::Diagnostics::LoggingFields* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 3)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Foundation.Diagnostics.LoggingFields", L"AddSize", 3);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(3);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Foundation::Size>(args, 1);
                auto param2 = py::convert_to<winrt::Windows::Foundation::Diagnostics::LoggingFieldFormat>(args, 2);

                {
                    auto _gil = release_gil();
                    self->obj.AddSize(param0, param1, param2);
                }

                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* LoggingFields_AddSizeWithFormatAndTags(py::wrapper::Windows::Foundation::Diagnostics::LoggingFields* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 4)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Foundation.Diagnostics.LoggingFields", L"AddSize", 4);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(4);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Foundation::Size>(args, 1);
                auto param2 = py::convert_to<winrt::Windows::Foundation::Diagnostics::LoggingFieldFormat>(args, 2);
                auto param3 = py::convert_to<int32_t>(args, 3);

                {
                    auto _gil = release_gil();
                    self->obj.AddSize(param0, param1, param2, param3);
                }

                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* LoggingFields_AddString(py::wrapper::Windows::Foundation::Diagnostics::LoggingFields* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Foundation.Diagnostics.LoggingFields", L"AddString", 2);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(2);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::hstring>(args, 1);

                {
                    auto _gil = release_gil();
                    self->obj.AddString(param0, param1);
                }

                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* LoggingFields_AddStringArray(py::wrapper::Windows::Foundation::Diagnostics::LoggingFields* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Foundation.Diagnostics.LoggingFields", L"AddStringArray", 2);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(2);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<py::pybuf_view<winrt::hstring, false>>(args, 1);

                {
                    auto _gil = release_gil();
                    self->obj.AddStringArray(param0, param1);
                }

                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* LoggingFields_AddStringArrayWithFormat(py::wrapper::Windows::Foundation::Diagnostics::LoggingFields* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 3)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Foundation.Diagnostics.LoggingFields", L"AddStringArray", 3);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(3);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<py::pybuf_view<winrt::hstring, false>>(args, 1);
                auto param2 = py::convert_to<winrt::Windows::Foundation::Diagnostics::LoggingFieldFormat>(args, 2);

                {
                    auto _gil = release_gil();
                    self->obj.AddStringArray(param0, param1, param2);
                }

                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* LoggingFields_AddStringArrayWithFormatAndTags(py::wrapper::Windows::Foundation::Diagnostics::LoggingFields* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 4)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Foundation.Diagnostics.LoggingFields", L"AddStringArray", 4);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(4);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<py::pybuf_view<winrt::hstring, false>>(args, 1);
                auto param2 = py::convert_to<winrt::Windows::Foundation::Diagnostics::LoggingFieldFormat>(args, 2);
                auto param3 = py::convert_to<int32_t>(args, 3);

                {
                    auto _gil = release_gil();
                    self->obj.AddStringArray(param0, param1, param2, param3);
                }

                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* LoggingFields_AddStringWithFormat(py::wrapper::Windows::Foundation::Diagnostics::LoggingFields* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 3)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Foundation.Diagnostics.LoggingFields", L"AddString", 3);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(3);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::hstring>(args, 1);
                auto param2 = py::convert_to<winrt::Windows::Foundation::Diagnostics::LoggingFieldFormat>(args, 2);

                {
                    auto _gil = release_gil();
                    self->obj.AddString(param0, param1, param2);
                }

                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* LoggingFields_AddStringWithFormatAndTags(py::wrapper::Windows::Foundation::Diagnostics::LoggingFields* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 4)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Foundation.Diagnostics.LoggingFields", L"AddString", 4);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(4);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::hstring>(args, 1);
                auto param2 = py::convert_to<winrt::Windows::Foundation::Diagnostics::LoggingFieldFormat>(args, 2);
                auto param3 = py::convert_to<int32_t>(args, 3);

                {
                    auto _gil = release_gil();
                    self->obj.AddString(param0, param1, param2, param3);
                }

                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* LoggingFields_AddTimeSpan(py::wrapper::Windows::Foundation::Diagnostics::LoggingFields* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Foundation.Diagnostics.LoggingFields", L"AddTimeSpan", 2);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(2);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Foundation::TimeSpan>(args, 1);

                {
                    auto _gil = release_gil();
                    self->obj.AddTimeSpan(param0, param1);
                }

                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* LoggingFields_AddTimeSpanArray(py::wrapper::Windows::Foundation::Diagnostics::LoggingFields* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Foundation.Diagnostics.LoggingFields", L"AddTimeSpanArray", 2);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(2);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<py::pybuf_view<winrt::Windows::Foundation::TimeSpan, false>>(args, 1);

                {
                    auto _gil = release_gil();
                    self->obj.AddTimeSpanArray(param0, param1);
                }

                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* LoggingFields_AddTimeSpanArrayWithFormat(py::wrapper::Windows::Foundation::Diagnostics::LoggingFields* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 3)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Foundation.Diagnostics.LoggingFields", L"AddTimeSpanArray", 3);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(3);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<py::pybuf_view<winrt::Windows::Foundation::TimeSpan, false>>(args, 1);
                auto param2 = py::convert_to<winrt::Windows::Foundation::Diagnostics::LoggingFieldFormat>(args, 2);

                {
                    auto _gil = release_gil();
                    self->obj.AddTimeSpanArray(param0, param1, param2);
                }

                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* LoggingFields_AddTimeSpanArrayWithFormatAndTags(py::wrapper::Windows::Foundation::Diagnostics::LoggingFields* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 4)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Foundation.Diagnostics.LoggingFields", L"AddTimeSpanArray", 4);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(4);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<py::pybuf_view<winrt::Windows::Foundation::TimeSpan, false>>(args, 1);
                auto param2 = py::convert_to<winrt::Windows::Foundation::Diagnostics::LoggingFieldFormat>(args, 2);
                auto param3 = py::convert_to<int32_t>(args, 3);

                {
                    auto _gil = release_gil();
                    self->obj.AddTimeSpanArray(param0, param1, param2, param3);
                }

                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* LoggingFields_AddTimeSpanWithFormat(py::wrapper::Windows::Foundation::Diagnostics::LoggingFields* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 3)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Foundation.Diagnostics.LoggingFields", L"AddTimeSpan", 3);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(3);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Foundation::TimeSpan>(args, 1);
                auto param2 = py::convert_to<winrt::Windows::Foundation::Diagnostics::LoggingFieldFormat>(args, 2);

                {
                    auto _gil = release_gil();
                    self->obj.AddTimeSpan(param0, param1, param2);
                }

                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* LoggingFields_AddTimeSpanWithFormatAndTags(py::wrapper::Windows::Foundation::Diagnostics::LoggingFields* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 4)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Foundation.Diagnostics.LoggingFields", L"AddTimeSpan", 4);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(4);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Foundation::TimeSpan>(args, 1);
                auto param2 = py::convert_to<winrt::Windows::Foundation::Diagnostics::LoggingFieldFormat>(args, 2);
                auto param3 = py::convert_to<int32_t>(args, 3);

                {
                    auto _gil = release_gil();
                    self->obj.AddTimeSpan(param0, param1, param2, param3);
                }

                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* LoggingFields_AddUInt16(py::wrapper::Windows::Foundation::Diagnostics::LoggingFields* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Foundation.Diagnostics.LoggingFields", L"AddUInt16", 2);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(2);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<uint16_t>(args, 1);

                {
                    auto _gil = release_gil();
                    self->obj.AddUInt16(param0, param1);
                }

                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* LoggingFields_AddUInt16Array(py::wrapper::Windows::Foundation::Diagnostics::LoggingFields* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Foundation.Diagnostics.LoggingFields", L"AddUInt16Array", 2);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(2);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<py::pybuf_view<uint16_t, false>>(args, 1);

                {
                    auto _gil = release_gil();
                    self->obj.AddUInt16Array(param0, param1);
                }

                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* LoggingFields_AddUInt16ArrayWithFormat(py::wrapper::Windows::Foundation::Diagnostics::LoggingFields* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 3)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Foundation.Diagnostics.LoggingFields", L"AddUInt16Array", 3);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(3);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<py::pybuf_view<uint16_t, false>>(args, 1);
                auto param2 = py::convert_to<winrt::Windows::Foundation::Diagnostics::LoggingFieldFormat>(args, 2);

                {
                    auto _gil = release_gil();
                    self->obj.AddUInt16Array(param0, param1, param2);
                }

                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* LoggingFields_AddUInt16ArrayWithFormatAndTags(py::wrapper::Windows::Foundation::Diagnostics::LoggingFields* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 4)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Foundation.Diagnostics.LoggingFields", L"AddUInt16Array", 4);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(4);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<py::pybuf_view<uint16_t, false>>(args, 1);
                auto param2 = py::convert_to<winrt::Windows::Foundation::Diagnostics::LoggingFieldFormat>(args, 2);
                auto param3 = py::convert_to<int32_t>(args, 3);

                {
                    auto _gil = release_gil();
                    self->obj.AddUInt16Array(param0, param1, param2, param3);
                }

                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* LoggingFields_AddUInt16WithFormat(py::wrapper::Windows::Foundation::Diagnostics::LoggingFields* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 3)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Foundation.Diagnostics.LoggingFields", L"AddUInt16", 3);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(3);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<uint16_t>(args, 1);
                auto param2 = py::convert_to<winrt::Windows::Foundation::Diagnostics::LoggingFieldFormat>(args, 2);

                {
                    auto _gil = release_gil();
                    self->obj.AddUInt16(param0, param1, param2);
                }

                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* LoggingFields_AddUInt16WithFormatAndTags(py::wrapper::Windows::Foundation::Diagnostics::LoggingFields* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 4)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Foundation.Diagnostics.LoggingFields", L"AddUInt16", 4);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(4);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<uint16_t>(args, 1);
                auto param2 = py::convert_to<winrt::Windows::Foundation::Diagnostics::LoggingFieldFormat>(args, 2);
                auto param3 = py::convert_to<int32_t>(args, 3);

                {
                    auto _gil = release_gil();
                    self->obj.AddUInt16(param0, param1, param2, param3);
                }

                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* LoggingFields_AddUInt32(py::wrapper::Windows::Foundation::Diagnostics::LoggingFields* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Foundation.Diagnostics.LoggingFields", L"AddUInt32", 2);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(2);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<uint32_t>(args, 1);

                {
                    auto _gil = release_gil();
                    self->obj.AddUInt32(param0, param1);
                }

                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* LoggingFields_AddUInt32Array(py::wrapper::Windows::Foundation::Diagnostics::LoggingFields* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Foundation.Diagnostics.LoggingFields", L"AddUInt32Array", 2);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(2);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<py::pybuf_view<uint32_t, false>>(args, 1);

                {
                    auto _gil = release_gil();
                    self->obj.AddUInt32Array(param0, param1);
                }

                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* LoggingFields_AddUInt32ArrayWithFormat(py::wrapper::Windows::Foundation::Diagnostics::LoggingFields* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 3)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Foundation.Diagnostics.LoggingFields", L"AddUInt32Array", 3);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(3);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<py::pybuf_view<uint32_t, false>>(args, 1);
                auto param2 = py::convert_to<winrt::Windows::Foundation::Diagnostics::LoggingFieldFormat>(args, 2);

                {
                    auto _gil = release_gil();
                    self->obj.AddUInt32Array(param0, param1, param2);
                }

                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* LoggingFields_AddUInt32ArrayWithFormatAndTags(py::wrapper::Windows::Foundation::Diagnostics::LoggingFields* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 4)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Foundation.Diagnostics.LoggingFields", L"AddUInt32Array", 4);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(4);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<py::pybuf_view<uint32_t, false>>(args, 1);
                auto param2 = py::convert_to<winrt::Windows::Foundation::Diagnostics::LoggingFieldFormat>(args, 2);
                auto param3 = py::convert_to<int32_t>(args, 3);

                {
                    auto _gil = release_gil();
                    self->obj.AddUInt32Array(param0, param1, param2, param3);
                }

                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* LoggingFields_AddUInt32WithFormat(py::wrapper::Windows::Foundation::Diagnostics::LoggingFields* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 3)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Foundation.Diagnostics.LoggingFields", L"AddUInt32", 3);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(3);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<uint32_t>(args, 1);
                auto param2 = py::convert_to<winrt::Windows::Foundation::Diagnostics::LoggingFieldFormat>(args, 2);

                {
                    auto _gil = release_gil();
                    self->obj.AddUInt32(param0, param1, param2);
                }

                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* LoggingFields_AddUInt32WithFormatAndTags(py::wrapper::Windows::Foundation::Diagnostics::LoggingFields* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 4)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Foundation.Diagnostics.LoggingFields", L"AddUInt32", 4);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(4);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<uint32_t>(args, 1);
                auto param2 = py::convert_to<winrt::Windows::Foundation::Diagnostics::LoggingFieldFormat>(args, 2);
                auto param3 = py::convert_to<int32_t>(args, 3);

                {
                    auto _gil = release_gil();
                    self->obj.AddUInt32(param0, param1, param2, param3);
                }

                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* LoggingFields_AddUInt64(py::wrapper::Windows::Foundation::Diagnostics::LoggingFields* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Foundation.Diagnostics.LoggingFields", L"AddUInt64", 2);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(2);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<uint64_t>(args, 1);

                {
                    auto _gil = release_gil();
                    self->obj.AddUInt64(param0, param1);
                }

                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* LoggingFields_AddUInt64Array(py::wrapper::Windows::Foundation::Diagnostics::LoggingFields* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Foundation.Diagnostics.LoggingFields", L"AddUInt64Array", 2);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(2);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<py::pybuf_view<uint64_t, false>>(args, 1);

                {
                    auto _gil = release_gil();
                    self->obj.AddUInt64Array(param0, param1);
                }

                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* LoggingFields_AddUInt64ArrayWithFormat(py::wrapper::Windows::Foundation::Diagnostics::LoggingFields* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 3)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Foundation.Diagnostics.LoggingFields", L"AddUInt64Array", 3);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(3);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<py::pybuf_view<uint64_t, false>>(args, 1);
                auto param2 = py::convert_to<winrt::Windows::Foundation::Diagnostics::LoggingFieldFormat>(args, 2);

                {
                    auto _gil = release_gil();
                    self->obj.AddUInt64Array(param0, param1, param2);
                }

                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* LoggingFields_AddUInt64ArrayWithFormatAndTags(py::wrapper::Windows::Foundation::Diagnostics::LoggingFields* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 4)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Foundation.Diagnostics.LoggingFields", L"AddUInt64Array", 4);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(4);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<py::pybuf_view<uint64_t, false>>(args, 1);
                auto param2 = py::convert_to<winrt::Windows::Foundation::Diagnostics::LoggingFieldFormat>(args, 2);
                auto param3 = py::convert_to<int32_t>(args, 3);

                {
                    auto _gil = release_gil();
                    self->obj.AddUInt64Array(param0, param1, param2, param3);
                }

                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* LoggingFields_AddUInt64WithFormat(py::wrapper::Windows::Foundation::Diagnostics::LoggingFields* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 3)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Foundation.Diagnostics.LoggingFields", L"AddUInt64", 3);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(3);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<uint64_t>(args, 1);
                auto param2 = py::convert_to<winrt::Windows::Foundation::Diagnostics::LoggingFieldFormat>(args, 2);

                {
                    auto _gil = release_gil();
                    self->obj.AddUInt64(param0, param1, param2);
                }

                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* LoggingFields_AddUInt64WithFormatAndTags(py::wrapper::Windows::Foundation::Diagnostics::LoggingFields* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 4)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Foundation.Diagnostics.LoggingFields", L"AddUInt64", 4);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(4);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<uint64_t>(args, 1);
                auto param2 = py::convert_to<winrt::Windows::Foundation::Diagnostics::LoggingFieldFormat>(args, 2);
                auto param3 = py::convert_to<int32_t>(args, 3);

                {
                    auto _gil = release_gil();
                    self->obj.AddUInt64(param0, param1, param2, param3);
                }

                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* LoggingFields_AddUInt8(py::wrapper::Windows::Foundation::Diagnostics::LoggingFields* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Foundation.Diagnostics.LoggingFields", L"AddUInt8", 2);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(2);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<uint8_t>(args, 1);

                {
                    auto _gil = release_gil();
                    self->obj.AddUInt8(param0, param1);
                }

                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* LoggingFields_AddUInt8Array(py::wrapper::Windows::Foundation::Diagnostics::LoggingFields* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Foundation.Diagnostics.LoggingFields", L"AddUInt8Array", 2);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(2);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<py::pybuf_view<uint8_t, false>>(args, 1);

                {
                    auto _gil = release_gil();
                    self->obj.AddUInt8Array(param0, param1);
                }

                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* LoggingFields_AddUInt8ArrayWithFormat(py::wrapper::Windows::Foundation::Diagnostics::LoggingFields* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 3)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Foundation.Diagnostics.LoggingFields", L"AddUInt8Array", 3);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(3);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<py::pybuf_view<uint8_t, false>>(args, 1);
                auto param2 = py::convert_to<winrt::Windows::Foundation::Diagnostics::LoggingFieldFormat>(args, 2);

                {
                    auto _gil = release_gil();
                    self->obj.AddUInt8Array(param0, param1, param2);
                }

                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* LoggingFields_AddUInt8ArrayWithFormatAndTags(py::wrapper::Windows::Foundation::Diagnostics::LoggingFields* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 4)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Foundation.Diagnostics.LoggingFields", L"AddUInt8Array", 4);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(4);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<py::pybuf_view<uint8_t, false>>(args, 1);
                auto param2 = py::convert_to<winrt::Windows::Foundation::Diagnostics::LoggingFieldFormat>(args, 2);
                auto param3 = py::convert_to<int32_t>(args, 3);

                {
                    auto _gil = release_gil();
                    self->obj.AddUInt8Array(param0, param1, param2, param3);
                }

                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* LoggingFields_AddUInt8WithFormat(py::wrapper::Windows::Foundation::Diagnostics::LoggingFields* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 3)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Foundation.Diagnostics.LoggingFields", L"AddUInt8", 3);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(3);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<uint8_t>(args, 1);
                auto param2 = py::convert_to<winrt::Windows::Foundation::Diagnostics::LoggingFieldFormat>(args, 2);

                {
                    auto _gil = release_gil();
                    self->obj.AddUInt8(param0, param1, param2);
                }

                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* LoggingFields_AddUInt8WithFormatAndTags(py::wrapper::Windows::Foundation::Diagnostics::LoggingFields* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 4)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Foundation.Diagnostics.LoggingFields", L"AddUInt8", 4);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(4);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<uint8_t>(args, 1);
                auto param2 = py::convert_to<winrt::Windows::Foundation::Diagnostics::LoggingFieldFormat>(args, 2);
                auto param3 = py::convert_to<int32_t>(args, 3);

                {
                    auto _gil = release_gil();
                    self->obj.AddUInt8(param0, param1, param2, param3);
                }

                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* LoggingFields_BeginStruct(py::wrapper::Windows::Foundation::Diagnostics::LoggingFields* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Foundation.Diagnostics.LoggingFields", L"BeginStruct", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                {
                    auto _gil = release_gil();
                    self->obj.BeginStruct(param0);
                }

                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* LoggingFields_BeginStructWithTags(py::wrapper::Windows::Foundation::Diagnostics::LoggingFields* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Foundation.Diagnostics.LoggingFields", L"BeginStruct", 2);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(2);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<int32_t>(args, 1);

                {
                    auto _gil = release_gil();
                    self->obj.BeginStruct(param0, param1);
                }

                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* LoggingFields_Clear(py::wrapper::Windows::Foundation::Diagnostics::LoggingFields* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Foundation.Diagnostics.LoggingFields", L"Clear", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                {
                    auto _gil = release_gil();
                    self->obj.Clear();
                }

                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* LoggingFields_EndStruct(py::wrapper::Windows::Foundation::Diagnostics::LoggingFields* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Foundation.Diagnostics.LoggingFields", L"EndStruct", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                {
                    auto _gil = release_gil();
                    self->obj.EndStruct();
                }

                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* _assign_array_LoggingFields(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Foundation::Diagnostics::LoggingFields>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_LoggingFields(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Foundation::Diagnostics::LoggingFields>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_LoggingFields[] = {
        { "add_boolean", reinterpret_cast<PyCFunction>(LoggingFields_AddBoolean), METH_VARARGS, nullptr },
        { "add_boolean_array", reinterpret_cast<PyCFunction>(LoggingFields_AddBooleanArray), METH_VARARGS, nullptr },
        { "add_boolean_array_with_format", reinterpret_cast<PyCFunction>(LoggingFields_AddBooleanArrayWithFormat), METH_VARARGS, nullptr },
        { "add_boolean_array_with_format_and_tags", reinterpret_cast<PyCFunction>(LoggingFields_AddBooleanArrayWithFormatAndTags), METH_VARARGS, nullptr },
        { "add_boolean_with_format", reinterpret_cast<PyCFunction>(LoggingFields_AddBooleanWithFormat), METH_VARARGS, nullptr },
        { "add_boolean_with_format_and_tags", reinterpret_cast<PyCFunction>(LoggingFields_AddBooleanWithFormatAndTags), METH_VARARGS, nullptr },
        { "add_char16", reinterpret_cast<PyCFunction>(LoggingFields_AddChar16), METH_VARARGS, nullptr },
        { "add_char16_array", reinterpret_cast<PyCFunction>(LoggingFields_AddChar16Array), METH_VARARGS, nullptr },
        { "add_char16_array_with_format", reinterpret_cast<PyCFunction>(LoggingFields_AddChar16ArrayWithFormat), METH_VARARGS, nullptr },
        { "add_char16_array_with_format_and_tags", reinterpret_cast<PyCFunction>(LoggingFields_AddChar16ArrayWithFormatAndTags), METH_VARARGS, nullptr },
        { "add_char16_with_format", reinterpret_cast<PyCFunction>(LoggingFields_AddChar16WithFormat), METH_VARARGS, nullptr },
        { "add_char16_with_format_and_tags", reinterpret_cast<PyCFunction>(LoggingFields_AddChar16WithFormatAndTags), METH_VARARGS, nullptr },
        { "add_date_time", reinterpret_cast<PyCFunction>(LoggingFields_AddDateTime), METH_VARARGS, nullptr },
        { "add_date_time_array", reinterpret_cast<PyCFunction>(LoggingFields_AddDateTimeArray), METH_VARARGS, nullptr },
        { "add_date_time_array_with_format", reinterpret_cast<PyCFunction>(LoggingFields_AddDateTimeArrayWithFormat), METH_VARARGS, nullptr },
        { "add_date_time_array_with_format_and_tags", reinterpret_cast<PyCFunction>(LoggingFields_AddDateTimeArrayWithFormatAndTags), METH_VARARGS, nullptr },
        { "add_date_time_with_format", reinterpret_cast<PyCFunction>(LoggingFields_AddDateTimeWithFormat), METH_VARARGS, nullptr },
        { "add_date_time_with_format_and_tags", reinterpret_cast<PyCFunction>(LoggingFields_AddDateTimeWithFormatAndTags), METH_VARARGS, nullptr },
        { "add_double", reinterpret_cast<PyCFunction>(LoggingFields_AddDouble), METH_VARARGS, nullptr },
        { "add_double_array", reinterpret_cast<PyCFunction>(LoggingFields_AddDoubleArray), METH_VARARGS, nullptr },
        { "add_double_array_with_format", reinterpret_cast<PyCFunction>(LoggingFields_AddDoubleArrayWithFormat), METH_VARARGS, nullptr },
        { "add_double_array_with_format_and_tags", reinterpret_cast<PyCFunction>(LoggingFields_AddDoubleArrayWithFormatAndTags), METH_VARARGS, nullptr },
        { "add_double_with_format", reinterpret_cast<PyCFunction>(LoggingFields_AddDoubleWithFormat), METH_VARARGS, nullptr },
        { "add_double_with_format_and_tags", reinterpret_cast<PyCFunction>(LoggingFields_AddDoubleWithFormatAndTags), METH_VARARGS, nullptr },
        { "add_empty", reinterpret_cast<PyCFunction>(LoggingFields_AddEmpty), METH_VARARGS, nullptr },
        { "add_empty_with_format", reinterpret_cast<PyCFunction>(LoggingFields_AddEmptyWithFormat), METH_VARARGS, nullptr },
        { "add_empty_with_format_and_tags", reinterpret_cast<PyCFunction>(LoggingFields_AddEmptyWithFormatAndTags), METH_VARARGS, nullptr },
        { "add_guid", reinterpret_cast<PyCFunction>(LoggingFields_AddGuid), METH_VARARGS, nullptr },
        { "add_guid_array", reinterpret_cast<PyCFunction>(LoggingFields_AddGuidArray), METH_VARARGS, nullptr },
        { "add_guid_array_with_format", reinterpret_cast<PyCFunction>(LoggingFields_AddGuidArrayWithFormat), METH_VARARGS, nullptr },
        { "add_guid_array_with_format_and_tags", reinterpret_cast<PyCFunction>(LoggingFields_AddGuidArrayWithFormatAndTags), METH_VARARGS, nullptr },
        { "add_guid_with_format", reinterpret_cast<PyCFunction>(LoggingFields_AddGuidWithFormat), METH_VARARGS, nullptr },
        { "add_guid_with_format_and_tags", reinterpret_cast<PyCFunction>(LoggingFields_AddGuidWithFormatAndTags), METH_VARARGS, nullptr },
        { "add_int16", reinterpret_cast<PyCFunction>(LoggingFields_AddInt16), METH_VARARGS, nullptr },
        { "add_int16_array", reinterpret_cast<PyCFunction>(LoggingFields_AddInt16Array), METH_VARARGS, nullptr },
        { "add_int16_array_with_format", reinterpret_cast<PyCFunction>(LoggingFields_AddInt16ArrayWithFormat), METH_VARARGS, nullptr },
        { "add_int16_array_with_format_and_tags", reinterpret_cast<PyCFunction>(LoggingFields_AddInt16ArrayWithFormatAndTags), METH_VARARGS, nullptr },
        { "add_int16_with_format", reinterpret_cast<PyCFunction>(LoggingFields_AddInt16WithFormat), METH_VARARGS, nullptr },
        { "add_int16_with_format_and_tags", reinterpret_cast<PyCFunction>(LoggingFields_AddInt16WithFormatAndTags), METH_VARARGS, nullptr },
        { "add_int32", reinterpret_cast<PyCFunction>(LoggingFields_AddInt32), METH_VARARGS, nullptr },
        { "add_int32_array", reinterpret_cast<PyCFunction>(LoggingFields_AddInt32Array), METH_VARARGS, nullptr },
        { "add_int32_array_with_format", reinterpret_cast<PyCFunction>(LoggingFields_AddInt32ArrayWithFormat), METH_VARARGS, nullptr },
        { "add_int32_array_with_format_and_tags", reinterpret_cast<PyCFunction>(LoggingFields_AddInt32ArrayWithFormatAndTags), METH_VARARGS, nullptr },
        { "add_int32_with_format", reinterpret_cast<PyCFunction>(LoggingFields_AddInt32WithFormat), METH_VARARGS, nullptr },
        { "add_int32_with_format_and_tags", reinterpret_cast<PyCFunction>(LoggingFields_AddInt32WithFormatAndTags), METH_VARARGS, nullptr },
        { "add_int64", reinterpret_cast<PyCFunction>(LoggingFields_AddInt64), METH_VARARGS, nullptr },
        { "add_int64_array", reinterpret_cast<PyCFunction>(LoggingFields_AddInt64Array), METH_VARARGS, nullptr },
        { "add_int64_array_with_format", reinterpret_cast<PyCFunction>(LoggingFields_AddInt64ArrayWithFormat), METH_VARARGS, nullptr },
        { "add_int64_array_with_format_and_tags", reinterpret_cast<PyCFunction>(LoggingFields_AddInt64ArrayWithFormatAndTags), METH_VARARGS, nullptr },
        { "add_int64_with_format", reinterpret_cast<PyCFunction>(LoggingFields_AddInt64WithFormat), METH_VARARGS, nullptr },
        { "add_int64_with_format_and_tags", reinterpret_cast<PyCFunction>(LoggingFields_AddInt64WithFormatAndTags), METH_VARARGS, nullptr },
        { "add_point", reinterpret_cast<PyCFunction>(LoggingFields_AddPoint), METH_VARARGS, nullptr },
        { "add_point_array", reinterpret_cast<PyCFunction>(LoggingFields_AddPointArray), METH_VARARGS, nullptr },
        { "add_point_array_with_format", reinterpret_cast<PyCFunction>(LoggingFields_AddPointArrayWithFormat), METH_VARARGS, nullptr },
        { "add_point_array_with_format_and_tags", reinterpret_cast<PyCFunction>(LoggingFields_AddPointArrayWithFormatAndTags), METH_VARARGS, nullptr },
        { "add_point_with_format", reinterpret_cast<PyCFunction>(LoggingFields_AddPointWithFormat), METH_VARARGS, nullptr },
        { "add_point_with_format_and_tags", reinterpret_cast<PyCFunction>(LoggingFields_AddPointWithFormatAndTags), METH_VARARGS, nullptr },
        { "add_rect", reinterpret_cast<PyCFunction>(LoggingFields_AddRect), METH_VARARGS, nullptr },
        { "add_rect_array", reinterpret_cast<PyCFunction>(LoggingFields_AddRectArray), METH_VARARGS, nullptr },
        { "add_rect_array_with_format", reinterpret_cast<PyCFunction>(LoggingFields_AddRectArrayWithFormat), METH_VARARGS, nullptr },
        { "add_rect_array_with_format_and_tags", reinterpret_cast<PyCFunction>(LoggingFields_AddRectArrayWithFormatAndTags), METH_VARARGS, nullptr },
        { "add_rect_with_format", reinterpret_cast<PyCFunction>(LoggingFields_AddRectWithFormat), METH_VARARGS, nullptr },
        { "add_rect_with_format_and_tags", reinterpret_cast<PyCFunction>(LoggingFields_AddRectWithFormatAndTags), METH_VARARGS, nullptr },
        { "add_single", reinterpret_cast<PyCFunction>(LoggingFields_AddSingle), METH_VARARGS, nullptr },
        { "add_single_array", reinterpret_cast<PyCFunction>(LoggingFields_AddSingleArray), METH_VARARGS, nullptr },
        { "add_single_array_with_format", reinterpret_cast<PyCFunction>(LoggingFields_AddSingleArrayWithFormat), METH_VARARGS, nullptr },
        { "add_single_array_with_format_and_tags", reinterpret_cast<PyCFunction>(LoggingFields_AddSingleArrayWithFormatAndTags), METH_VARARGS, nullptr },
        { "add_single_with_format", reinterpret_cast<PyCFunction>(LoggingFields_AddSingleWithFormat), METH_VARARGS, nullptr },
        { "add_single_with_format_and_tags", reinterpret_cast<PyCFunction>(LoggingFields_AddSingleWithFormatAndTags), METH_VARARGS, nullptr },
        { "add_size", reinterpret_cast<PyCFunction>(LoggingFields_AddSize), METH_VARARGS, nullptr },
        { "add_size_array", reinterpret_cast<PyCFunction>(LoggingFields_AddSizeArray), METH_VARARGS, nullptr },
        { "add_size_array_with_format", reinterpret_cast<PyCFunction>(LoggingFields_AddSizeArrayWithFormat), METH_VARARGS, nullptr },
        { "add_size_array_with_format_and_tags", reinterpret_cast<PyCFunction>(LoggingFields_AddSizeArrayWithFormatAndTags), METH_VARARGS, nullptr },
        { "add_size_with_format", reinterpret_cast<PyCFunction>(LoggingFields_AddSizeWithFormat), METH_VARARGS, nullptr },
        { "add_size_with_format_and_tags", reinterpret_cast<PyCFunction>(LoggingFields_AddSizeWithFormatAndTags), METH_VARARGS, nullptr },
        { "add_string", reinterpret_cast<PyCFunction>(LoggingFields_AddString), METH_VARARGS, nullptr },
        { "add_string_array", reinterpret_cast<PyCFunction>(LoggingFields_AddStringArray), METH_VARARGS, nullptr },
        { "add_string_array_with_format", reinterpret_cast<PyCFunction>(LoggingFields_AddStringArrayWithFormat), METH_VARARGS, nullptr },
        { "add_string_array_with_format_and_tags", reinterpret_cast<PyCFunction>(LoggingFields_AddStringArrayWithFormatAndTags), METH_VARARGS, nullptr },
        { "add_string_with_format", reinterpret_cast<PyCFunction>(LoggingFields_AddStringWithFormat), METH_VARARGS, nullptr },
        { "add_string_with_format_and_tags", reinterpret_cast<PyCFunction>(LoggingFields_AddStringWithFormatAndTags), METH_VARARGS, nullptr },
        { "add_time_span", reinterpret_cast<PyCFunction>(LoggingFields_AddTimeSpan), METH_VARARGS, nullptr },
        { "add_time_span_array", reinterpret_cast<PyCFunction>(LoggingFields_AddTimeSpanArray), METH_VARARGS, nullptr },
        { "add_time_span_array_with_format", reinterpret_cast<PyCFunction>(LoggingFields_AddTimeSpanArrayWithFormat), METH_VARARGS, nullptr },
        { "add_time_span_array_with_format_and_tags", reinterpret_cast<PyCFunction>(LoggingFields_AddTimeSpanArrayWithFormatAndTags), METH_VARARGS, nullptr },
        { "add_time_span_with_format", reinterpret_cast<PyCFunction>(LoggingFields_AddTimeSpanWithFormat), METH_VARARGS, nullptr },
        { "add_time_span_with_format_and_tags", reinterpret_cast<PyCFunction>(LoggingFields_AddTimeSpanWithFormatAndTags), METH_VARARGS, nullptr },
        { "add_uint16", reinterpret_cast<PyCFunction>(LoggingFields_AddUInt16), METH_VARARGS, nullptr },
        { "add_uint16_array", reinterpret_cast<PyCFunction>(LoggingFields_AddUInt16Array), METH_VARARGS, nullptr },
        { "add_uint16_array_with_format", reinterpret_cast<PyCFunction>(LoggingFields_AddUInt16ArrayWithFormat), METH_VARARGS, nullptr },
        { "add_uint16_array_with_format_and_tags", reinterpret_cast<PyCFunction>(LoggingFields_AddUInt16ArrayWithFormatAndTags), METH_VARARGS, nullptr },
        { "add_uint16_with_format", reinterpret_cast<PyCFunction>(LoggingFields_AddUInt16WithFormat), METH_VARARGS, nullptr },
        { "add_uint16_with_format_and_tags", reinterpret_cast<PyCFunction>(LoggingFields_AddUInt16WithFormatAndTags), METH_VARARGS, nullptr },
        { "add_uint32", reinterpret_cast<PyCFunction>(LoggingFields_AddUInt32), METH_VARARGS, nullptr },
        { "add_uint32_array", reinterpret_cast<PyCFunction>(LoggingFields_AddUInt32Array), METH_VARARGS, nullptr },
        { "add_uint32_array_with_format", reinterpret_cast<PyCFunction>(LoggingFields_AddUInt32ArrayWithFormat), METH_VARARGS, nullptr },
        { "add_uint32_array_with_format_and_tags", reinterpret_cast<PyCFunction>(LoggingFields_AddUInt32ArrayWithFormatAndTags), METH_VARARGS, nullptr },
        { "add_uint32_with_format", reinterpret_cast<PyCFunction>(LoggingFields_AddUInt32WithFormat), METH_VARARGS, nullptr },
        { "add_uint32_with_format_and_tags", reinterpret_cast<PyCFunction>(LoggingFields_AddUInt32WithFormatAndTags), METH_VARARGS, nullptr },
        { "add_uint64", reinterpret_cast<PyCFunction>(LoggingFields_AddUInt64), METH_VARARGS, nullptr },
        { "add_uint64_array", reinterpret_cast<PyCFunction>(LoggingFields_AddUInt64Array), METH_VARARGS, nullptr },
        { "add_uint64_array_with_format", reinterpret_cast<PyCFunction>(LoggingFields_AddUInt64ArrayWithFormat), METH_VARARGS, nullptr },
        { "add_uint64_array_with_format_and_tags", reinterpret_cast<PyCFunction>(LoggingFields_AddUInt64ArrayWithFormatAndTags), METH_VARARGS, nullptr },
        { "add_uint64_with_format", reinterpret_cast<PyCFunction>(LoggingFields_AddUInt64WithFormat), METH_VARARGS, nullptr },
        { "add_uint64_with_format_and_tags", reinterpret_cast<PyCFunction>(LoggingFields_AddUInt64WithFormatAndTags), METH_VARARGS, nullptr },
        { "add_uint8", reinterpret_cast<PyCFunction>(LoggingFields_AddUInt8), METH_VARARGS, nullptr },
        { "add_uint8_array", reinterpret_cast<PyCFunction>(LoggingFields_AddUInt8Array), METH_VARARGS, nullptr },
        { "add_uint8_array_with_format", reinterpret_cast<PyCFunction>(LoggingFields_AddUInt8ArrayWithFormat), METH_VARARGS, nullptr },
        { "add_uint8_array_with_format_and_tags", reinterpret_cast<PyCFunction>(LoggingFields_AddUInt8ArrayWithFormatAndTags), METH_VARARGS, nullptr },
        { "add_uint8_with_format", reinterpret_cast<PyCFunction>(LoggingFields_AddUInt8WithFormat), METH_VARARGS, nullptr },
        { "add_uint8_with_format_and_tags", reinterpret_cast<PyCFunction>(LoggingFields_AddUInt8WithFormatAndTags), METH_VARARGS, nullptr },
        { "begin_struct", reinterpret_cast<PyCFunction>(LoggingFields_BeginStruct), METH_VARARGS, nullptr },
        { "begin_struct_with_tags", reinterpret_cast<PyCFunction>(LoggingFields_BeginStructWithTags), METH_VARARGS, nullptr },
        { "clear", reinterpret_cast<PyCFunction>(LoggingFields_Clear), METH_VARARGS, nullptr },
        { "end_struct", reinterpret_cast<PyCFunction>(LoggingFields_EndStruct), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_LoggingFields, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_LoggingFields), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_LoggingFields[] = {
        { }
    };

    static PyType_Slot _type_slots_LoggingFields[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_LoggingFields) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_LoggingFields) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_LoggingFields) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_LoggingFields) },
        { }
    };

    static PyType_Spec type_spec_LoggingFields = {
        "winrt._winrt_windows_foundation_diagnostics.LoggingFields",
        sizeof(py::wrapper::Windows::Foundation::Diagnostics::LoggingFields),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_LoggingFields};

    // ----- LoggingOptions class --------------------

    static PyObject* _new_LoggingOptions(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 0)
        {
            try
            {
                winrt::Windows::Foundation::Diagnostics::LoggingOptions instance{};
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<int64_t>(args, 0);

                winrt::Windows::Foundation::Diagnostics::LoggingOptions instance{param0};
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_LoggingOptions(py::wrapper::Windows::Foundation::Diagnostics::LoggingOptions* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* LoggingOptions_get_Task(py::wrapper::Windows::Foundation::Diagnostics::LoggingOptions* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Foundation.Diagnostics.LoggingOptions", L"Task");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Task();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int LoggingOptions_put_Task(py::wrapper::Windows::Foundation::Diagnostics::LoggingOptions* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Foundation.Diagnostics.LoggingOptions", L"Task");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<int16_t>(arg);

            {
                auto _gil = release_gil();
                self->obj.Task(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* LoggingOptions_get_Tags(py::wrapper::Windows::Foundation::Diagnostics::LoggingOptions* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Foundation.Diagnostics.LoggingOptions", L"Tags");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Tags();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int LoggingOptions_put_Tags(py::wrapper::Windows::Foundation::Diagnostics::LoggingOptions* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Foundation.Diagnostics.LoggingOptions", L"Tags");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<int32_t>(arg);

            {
                auto _gil = release_gil();
                self->obj.Tags(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* LoggingOptions_get_RelatedActivityId(py::wrapper::Windows::Foundation::Diagnostics::LoggingOptions* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Foundation.Diagnostics.LoggingOptions", L"RelatedActivityId");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.RelatedActivityId();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int LoggingOptions_put_RelatedActivityId(py::wrapper::Windows::Foundation::Diagnostics::LoggingOptions* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Foundation.Diagnostics.LoggingOptions", L"RelatedActivityId");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::guid>(arg);

            {
                auto _gil = release_gil();
                self->obj.RelatedActivityId(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* LoggingOptions_get_Opcode(py::wrapper::Windows::Foundation::Diagnostics::LoggingOptions* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Foundation.Diagnostics.LoggingOptions", L"Opcode");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Opcode();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int LoggingOptions_put_Opcode(py::wrapper::Windows::Foundation::Diagnostics::LoggingOptions* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Foundation.Diagnostics.LoggingOptions", L"Opcode");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::Diagnostics::LoggingOpcode>(arg);

            {
                auto _gil = release_gil();
                self->obj.Opcode(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* LoggingOptions_get_Keywords(py::wrapper::Windows::Foundation::Diagnostics::LoggingOptions* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Foundation.Diagnostics.LoggingOptions", L"Keywords");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Keywords();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int LoggingOptions_put_Keywords(py::wrapper::Windows::Foundation::Diagnostics::LoggingOptions* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Foundation.Diagnostics.LoggingOptions", L"Keywords");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<int64_t>(arg);

            {
                auto _gil = release_gil();
                self->obj.Keywords(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* LoggingOptions_get_ActivityId(py::wrapper::Windows::Foundation::Diagnostics::LoggingOptions* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Foundation.Diagnostics.LoggingOptions", L"ActivityId");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.ActivityId();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int LoggingOptions_put_ActivityId(py::wrapper::Windows::Foundation::Diagnostics::LoggingOptions* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Foundation.Diagnostics.LoggingOptions", L"ActivityId");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::guid>(arg);

            {
                auto _gil = release_gil();
                self->obj.ActivityId(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* _assign_array_LoggingOptions(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Foundation::Diagnostics::LoggingOptions>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_LoggingOptions(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Foundation::Diagnostics::LoggingOptions>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_LoggingOptions[] = {
        { "_assign_array_", _assign_array_LoggingOptions, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_LoggingOptions), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_LoggingOptions[] = {
        { "task", reinterpret_cast<getter>(LoggingOptions_get_Task), reinterpret_cast<setter>(LoggingOptions_put_Task), nullptr, nullptr },
        { "tags", reinterpret_cast<getter>(LoggingOptions_get_Tags), reinterpret_cast<setter>(LoggingOptions_put_Tags), nullptr, nullptr },
        { "related_activity_id", reinterpret_cast<getter>(LoggingOptions_get_RelatedActivityId), reinterpret_cast<setter>(LoggingOptions_put_RelatedActivityId), nullptr, nullptr },
        { "opcode", reinterpret_cast<getter>(LoggingOptions_get_Opcode), reinterpret_cast<setter>(LoggingOptions_put_Opcode), nullptr, nullptr },
        { "keywords", reinterpret_cast<getter>(LoggingOptions_get_Keywords), reinterpret_cast<setter>(LoggingOptions_put_Keywords), nullptr, nullptr },
        { "activity_id", reinterpret_cast<getter>(LoggingOptions_get_ActivityId), reinterpret_cast<setter>(LoggingOptions_put_ActivityId), nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_LoggingOptions[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_LoggingOptions) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_LoggingOptions) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_LoggingOptions) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_LoggingOptions) },
        { }
    };

    static PyType_Spec type_spec_LoggingOptions = {
        "winrt._winrt_windows_foundation_diagnostics.LoggingOptions",
        sizeof(py::wrapper::Windows::Foundation::Diagnostics::LoggingOptions),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_LoggingOptions};

    // ----- LoggingSession class --------------------

    static PyObject* _new_LoggingSession(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                winrt::Windows::Foundation::Diagnostics::LoggingSession instance{param0};
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_LoggingSession(py::wrapper::Windows::Foundation::Diagnostics::LoggingSession* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* LoggingSession_AddLoggingChannel(py::wrapper::Windows::Foundation::Diagnostics::LoggingSession* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Foundation.Diagnostics.LoggingSession", L"AddLoggingChannel", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Foundation::Diagnostics::ILoggingChannel>(args, 0);

                {
                    auto _gil = release_gil();
                    self->obj.AddLoggingChannel(param0);
                }

                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* LoggingSession_AddLoggingChannelWithLevel(py::wrapper::Windows::Foundation::Diagnostics::LoggingSession* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Foundation.Diagnostics.LoggingSession", L"AddLoggingChannel", 2);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(2);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Foundation::Diagnostics::ILoggingChannel>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Foundation::Diagnostics::LoggingLevel>(args, 1);

                {
                    auto _gil = release_gil();
                    self->obj.AddLoggingChannel(param0, param1);
                }

                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* LoggingSession_Close(py::wrapper::Windows::Foundation::Diagnostics::LoggingSession* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Foundation.Diagnostics.LoggingSession", L"Close", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                {
                    auto _gil = release_gil();
                    self->obj.Close();
                }

                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* LoggingSession_RemoveLoggingChannel(py::wrapper::Windows::Foundation::Diagnostics::LoggingSession* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Foundation.Diagnostics.LoggingSession", L"RemoveLoggingChannel", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Foundation::Diagnostics::ILoggingChannel>(args, 0);

                {
                    auto _gil = release_gil();
                    self->obj.RemoveLoggingChannel(param0);
                }

                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* LoggingSession_SaveToFileAsync(py::wrapper::Windows::Foundation::Diagnostics::LoggingSession* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Foundation.Diagnostics.LoggingSession", L"SaveToFileAsync", 2);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(2);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Storage::IStorageFolder>(args, 0);
                auto param1 = py::convert_to<winrt::hstring>(args, 1);

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return self->obj.SaveToFileAsync(param0, param1);
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* LoggingSession_get_Name(py::wrapper::Windows::Foundation::Diagnostics::LoggingSession* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Foundation.Diagnostics.LoggingSession", L"Name");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Name();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_LoggingSession(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Foundation::Diagnostics::LoggingSession>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_LoggingSession(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Foundation::Diagnostics::LoggingSession>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _enter_LoggingSession(py::wrapper::Windows::Foundation::Diagnostics::LoggingSession* self, PyObject* /*unused*/) noexcept
    {
        return Py_NewRef(self);
    }

    static PyObject* _exit_LoggingSession(py::wrapper::Windows::Foundation::Diagnostics::LoggingSession* self, PyObject* /*unused*/) noexcept
    {
        try
        {
            {
                auto _gil = py::release_gil();
                self->obj.Close();
            }

            Py_RETURN_FALSE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_LoggingSession[] = {
        { "add_logging_channel", reinterpret_cast<PyCFunction>(LoggingSession_AddLoggingChannel), METH_VARARGS, nullptr },
        { "add_logging_channel_with_level", reinterpret_cast<PyCFunction>(LoggingSession_AddLoggingChannelWithLevel), METH_VARARGS, nullptr },
        { "close", reinterpret_cast<PyCFunction>(LoggingSession_Close), METH_VARARGS, nullptr },
        { "remove_logging_channel", reinterpret_cast<PyCFunction>(LoggingSession_RemoveLoggingChannel), METH_VARARGS, nullptr },
        { "save_to_file_async", reinterpret_cast<PyCFunction>(LoggingSession_SaveToFileAsync), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_LoggingSession, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_LoggingSession), METH_O | METH_STATIC, nullptr },
        { "__enter__", reinterpret_cast<PyCFunction>(_enter_LoggingSession), METH_NOARGS, nullptr },
        { "__exit__", reinterpret_cast<PyCFunction>(_exit_LoggingSession), METH_VARARGS, nullptr },
        { }
    };

    static PyGetSetDef _getset_LoggingSession[] = {
        { "name", reinterpret_cast<getter>(LoggingSession_get_Name), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_LoggingSession[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_LoggingSession) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_LoggingSession) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_LoggingSession) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_LoggingSession) },
        { }
    };

    static PyType_Spec type_spec_LoggingSession = {
        "winrt._winrt_windows_foundation_diagnostics.LoggingSession",
        sizeof(py::wrapper::Windows::Foundation::Diagnostics::LoggingSession),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_LoggingSession};

    // ----- RuntimeBrokerErrorSettings class --------------------

    static PyObject* _new_RuntimeBrokerErrorSettings(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 0)
        {
            try
            {
                winrt::Windows::Foundation::Diagnostics::RuntimeBrokerErrorSettings instance{};
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_RuntimeBrokerErrorSettings(py::wrapper::Windows::Foundation::Diagnostics::RuntimeBrokerErrorSettings* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* RuntimeBrokerErrorSettings_GetErrorOptions(py::wrapper::Windows::Foundation::Diagnostics::RuntimeBrokerErrorSettings* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Foundation.Diagnostics.RuntimeBrokerErrorSettings", L"GetErrorOptions", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return self->obj.GetErrorOptions();
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* RuntimeBrokerErrorSettings_SetErrorOptions(py::wrapper::Windows::Foundation::Diagnostics::RuntimeBrokerErrorSettings* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Foundation.Diagnostics.RuntimeBrokerErrorSettings", L"SetErrorOptions", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Foundation::Diagnostics::ErrorOptions>(args, 0);

                {
                    auto _gil = release_gil();
                    self->obj.SetErrorOptions(param0);
                }

                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* _assign_array_RuntimeBrokerErrorSettings(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Foundation::Diagnostics::RuntimeBrokerErrorSettings>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_RuntimeBrokerErrorSettings(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Foundation::Diagnostics::RuntimeBrokerErrorSettings>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_RuntimeBrokerErrorSettings[] = {
        { "get_error_options", reinterpret_cast<PyCFunction>(RuntimeBrokerErrorSettings_GetErrorOptions), METH_VARARGS, nullptr },
        { "set_error_options", reinterpret_cast<PyCFunction>(RuntimeBrokerErrorSettings_SetErrorOptions), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_RuntimeBrokerErrorSettings, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_RuntimeBrokerErrorSettings), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_RuntimeBrokerErrorSettings[] = {
        { }
    };

    static PyType_Slot _type_slots_RuntimeBrokerErrorSettings[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_RuntimeBrokerErrorSettings) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_RuntimeBrokerErrorSettings) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_RuntimeBrokerErrorSettings) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_RuntimeBrokerErrorSettings) },
        { }
    };

    static PyType_Spec type_spec_RuntimeBrokerErrorSettings = {
        "winrt._winrt_windows_foundation_diagnostics.RuntimeBrokerErrorSettings",
        sizeof(py::wrapper::Windows::Foundation::Diagnostics::RuntimeBrokerErrorSettings),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_RuntimeBrokerErrorSettings};

    // ----- TracingStatusChangedEventArgs class --------------------

    static PyObject* _new_TracingStatusChangedEventArgs(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Foundation::Diagnostics::TracingStatusChangedEventArgs>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Foundation::Diagnostics::TracingStatusChangedEventArgs>::type_name);
        return nullptr;
    }

    static void _dealloc_TracingStatusChangedEventArgs(py::wrapper::Windows::Foundation::Diagnostics::TracingStatusChangedEventArgs* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* TracingStatusChangedEventArgs_get_Enabled(py::wrapper::Windows::Foundation::Diagnostics::TracingStatusChangedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Foundation.Diagnostics.TracingStatusChangedEventArgs", L"Enabled");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Enabled();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* TracingStatusChangedEventArgs_get_TraceLevel(py::wrapper::Windows::Foundation::Diagnostics::TracingStatusChangedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Foundation.Diagnostics.TracingStatusChangedEventArgs", L"TraceLevel");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.TraceLevel();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_TracingStatusChangedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Foundation::Diagnostics::TracingStatusChangedEventArgs>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_TracingStatusChangedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Foundation::Diagnostics::TracingStatusChangedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_TracingStatusChangedEventArgs[] = {
        { "_assign_array_", _assign_array_TracingStatusChangedEventArgs, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_TracingStatusChangedEventArgs), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_TracingStatusChangedEventArgs[] = {
        { "enabled", reinterpret_cast<getter>(TracingStatusChangedEventArgs_get_Enabled), nullptr, nullptr, nullptr },
        { "trace_level", reinterpret_cast<getter>(TracingStatusChangedEventArgs_get_TraceLevel), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_TracingStatusChangedEventArgs[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_TracingStatusChangedEventArgs) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_TracingStatusChangedEventArgs) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_TracingStatusChangedEventArgs) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_TracingStatusChangedEventArgs) },
        { }
    };

    static PyType_Spec type_spec_TracingStatusChangedEventArgs = {
        "winrt._winrt_windows_foundation_diagnostics.TracingStatusChangedEventArgs",
        sizeof(py::wrapper::Windows::Foundation::Diagnostics::TracingStatusChangedEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_TracingStatusChangedEventArgs};

    // ----- IErrorReportingSettings interface --------------------

    static PyObject* _new_IErrorReportingSettings(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Foundation::Diagnostics::IErrorReportingSettings>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Foundation::Diagnostics::IErrorReportingSettings>::type_name);
        return nullptr;
    }

    static void _dealloc_IErrorReportingSettings(py::wrapper::Windows::Foundation::Diagnostics::IErrorReportingSettings* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* IErrorReportingSettings_GetErrorOptions(py::wrapper::Windows::Foundation::Diagnostics::IErrorReportingSettings* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Foundation.Diagnostics.IErrorReportingSettings", L"GetErrorOptions", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return self->obj.GetErrorOptions();
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* IErrorReportingSettings_SetErrorOptions(py::wrapper::Windows::Foundation::Diagnostics::IErrorReportingSettings* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Foundation.Diagnostics.IErrorReportingSettings", L"SetErrorOptions", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Foundation::Diagnostics::ErrorOptions>(args, 0);

                {
                    auto _gil = release_gil();
                    self->obj.SetErrorOptions(param0);
                }

                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* _assign_array_IErrorReportingSettings(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Foundation::Diagnostics::IErrorReportingSettings>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_IErrorReportingSettings(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Foundation::Diagnostics::IErrorReportingSettings>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_IErrorReportingSettings[] = {
        { "get_error_options", reinterpret_cast<PyCFunction>(IErrorReportingSettings_GetErrorOptions), METH_VARARGS, nullptr },
        { "set_error_options", reinterpret_cast<PyCFunction>(IErrorReportingSettings_SetErrorOptions), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_IErrorReportingSettings, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_IErrorReportingSettings), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_IErrorReportingSettings[] = {
        { }
    };

    static PyType_Slot _type_slots_IErrorReportingSettings[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_IErrorReportingSettings) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_IErrorReportingSettings) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_IErrorReportingSettings) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_IErrorReportingSettings) },
        { }
    };

    static PyType_Spec type_spec_IErrorReportingSettings = {
        "winrt._winrt_windows_foundation_diagnostics.IErrorReportingSettings",
        sizeof(py::wrapper::Windows::Foundation::Diagnostics::IErrorReportingSettings),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_IErrorReportingSettings};

    struct ImplementsIErrorReportingSettings : py::ImplementsInterfaceT<ImplementsIErrorReportingSettings, winrt::Windows::Foundation::Diagnostics::IErrorReportingSettings>
    {
        ImplementsIErrorReportingSettings() = delete;
        ImplementsIErrorReportingSettings(PyObject* py_obj, winrt::impl::inspectable_abi* runtime_class) : py::ImplementsInterfaceT<ImplementsIErrorReportingSettings, winrt::Windows::Foundation::Diagnostics::IErrorReportingSettings>(py_obj, runtime_class)
        {
        }

        auto GetErrorOptions()
        {
            try
            {
                py::pyobj_handle self{this->get_py_obj()};

                py::pyobj_handle method{PyObject_GetAttrString(self.get(), "get_error_options")};
                if (!method)
                {
                    throw python_exception();
                }

                py::pyobj_handle return_value{PyObject_CallNoArgs(method.get())};
                if (!return_value)
                {
                    throw python_exception();
                }

                return py::convert_to<winrt::Windows::Foundation::Diagnostics::ErrorOptions>(return_value.get());
            }
            catch (python_exception)
            {
                py::write_unraisable_and_throw();
            }
        }

        auto SetErrorOptions(winrt::Windows::Foundation::Diagnostics::ErrorOptions param0)
        {
            try
            {
                py::pyobj_handle self{this->get_py_obj()};

                py::pyobj_handle method{PyObject_GetAttrString(self.get(), "set_error_options")};
                if (!method)
                {
                    throw python_exception();
                }

                py::pyobj_handle py_param0{py::convert(param0)};
                if (!py_param0)
                {
                    throw python_exception();
                }

                py::pyobj_handle return_value{PyObject_CallOneArg(method.get(), py_param0.get())};
                if (!return_value)
                {
                    throw python_exception();
                }
            }
            catch (python_exception)
            {
                py::write_unraisable_and_throw();
            }
        }
    };

    static PyObject* _guid_ImplementsIErrorReportingSettings(PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::guid_of<winrt::Windows::Foundation::Diagnostics::IErrorReportingSettings>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _make_ImplementsIErrorReportingSettings(PyObject* /*unused*/, PyObject* args) noexcept
    {
        try
        {
            PyObject* py_obj;
            winrt::impl::inspectable_abi* runtime_class;

            if (!PyArg_ParseTuple(args, "On", &py_obj, &runtime_class))
            {
                return nullptr;
            }

            auto iface{std::make_unique<ImplementsIErrorReportingSettings>(py_obj, runtime_class)};

            return PyLong_FromVoidPtr(iface.release());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef methods_ImplementsIErrorReportingSettings[] = {
        { "_guid_", reinterpret_cast<PyCFunction>(_guid_ImplementsIErrorReportingSettings), METH_NOARGS | METH_STATIC, nullptr },
        { "_make_", reinterpret_cast<PyCFunction>(_make_ImplementsIErrorReportingSettings), METH_VARARGS | METH_STATIC, nullptr },
        { }
    };

    static PyType_Slot type_slots_ImplementsIErrorReportingSettings[] = {
        { Py_tp_methods, reinterpret_cast<void*>(methods_ImplementsIErrorReportingSettings) },
        { }
    };

    static PyType_Spec type_spec_ImplementsIErrorReportingSettings = {
        "winrt._winrt_windows_foundation_diagnostics.ImplementsIErrorReportingSettings",
        0,
        0,
        Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,
        type_slots_ImplementsIErrorReportingSettings};

    // ----- IFileLoggingSession interface --------------------

    static PyObject* _new_IFileLoggingSession(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Foundation::Diagnostics::IFileLoggingSession>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Foundation::Diagnostics::IFileLoggingSession>::type_name);
        return nullptr;
    }

    static void _dealloc_IFileLoggingSession(py::wrapper::Windows::Foundation::Diagnostics::IFileLoggingSession* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* IFileLoggingSession_AddLoggingChannel(py::wrapper::Windows::Foundation::Diagnostics::IFileLoggingSession* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Foundation.Diagnostics.IFileLoggingSession", L"AddLoggingChannel", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Foundation::Diagnostics::ILoggingChannel>(args, 0);

                {
                    auto _gil = release_gil();
                    self->obj.AddLoggingChannel(param0);
                }

                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* IFileLoggingSession_AddLoggingChannelWithLevel(py::wrapper::Windows::Foundation::Diagnostics::IFileLoggingSession* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Foundation.Diagnostics.IFileLoggingSession", L"AddLoggingChannel", 2);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(2);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Foundation::Diagnostics::ILoggingChannel>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Foundation::Diagnostics::LoggingLevel>(args, 1);

                {
                    auto _gil = release_gil();
                    self->obj.AddLoggingChannel(param0, param1);
                }

                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* IFileLoggingSession_Close(py::wrapper::Windows::Foundation::Diagnostics::IFileLoggingSession* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Foundation.IClosable", L"Close", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                {
                    auto _gil = release_gil();
                    self->obj.Close();
                }

                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* IFileLoggingSession_CloseAndSaveToFileAsync(py::wrapper::Windows::Foundation::Diagnostics::IFileLoggingSession* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Foundation.Diagnostics.IFileLoggingSession", L"CloseAndSaveToFileAsync", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return self->obj.CloseAndSaveToFileAsync();
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* IFileLoggingSession_RemoveLoggingChannel(py::wrapper::Windows::Foundation::Diagnostics::IFileLoggingSession* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Foundation.Diagnostics.IFileLoggingSession", L"RemoveLoggingChannel", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Foundation::Diagnostics::ILoggingChannel>(args, 0);

                {
                    auto _gil = release_gil();
                    self->obj.RemoveLoggingChannel(param0);
                }

                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* IFileLoggingSession_get_Name(py::wrapper::Windows::Foundation::Diagnostics::IFileLoggingSession* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Foundation.Diagnostics.IFileLoggingSession", L"Name");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Name();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IFileLoggingSession_add_LogFileGenerated(py::wrapper::Windows::Foundation::Diagnostics::IFileLoggingSession* self, PyObject* arg) noexcept
    {
        try
        {
            static std::optional<bool> is_event_present{};

            if (!is_event_present.has_value())
            {
                is_event_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Foundation.Diagnostics.IFileLoggingSession", L"LogFileGenerated");
            }

            if (!is_event_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Foundation::Diagnostics::IFileLoggingSession, winrt::Windows::Foundation::Diagnostics::LogFileGeneratedEventArgs>>(arg);

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.LogFileGenerated(param0);
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IFileLoggingSession_remove_LogFileGenerated(py::wrapper::Windows::Foundation::Diagnostics::IFileLoggingSession* self, PyObject* arg) noexcept
    {
        try
        {
            static std::optional<bool> is_event_present{};

            if (!is_event_present.has_value())
            {
                is_event_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Foundation.Diagnostics.IFileLoggingSession", L"LogFileGenerated");
            }

            if (!is_event_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::event_token>(arg);

            {
                auto _gil = release_gil();
                self->obj.LogFileGenerated(param0);
            }

            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_IFileLoggingSession(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Foundation::Diagnostics::IFileLoggingSession>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_IFileLoggingSession(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Foundation::Diagnostics::IFileLoggingSession>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _enter_IFileLoggingSession(py::wrapper::Windows::Foundation::Diagnostics::IFileLoggingSession* self, PyObject* /*unused*/) noexcept
    {
        return Py_NewRef(self);
    }

    static PyObject* _exit_IFileLoggingSession(py::wrapper::Windows::Foundation::Diagnostics::IFileLoggingSession* self, PyObject* /*unused*/) noexcept
    {
        try
        {
            {
                auto _gil = py::release_gil();
                self->obj.Close();
            }

            Py_RETURN_FALSE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_IFileLoggingSession[] = {
        { "add_logging_channel", reinterpret_cast<PyCFunction>(IFileLoggingSession_AddLoggingChannel), METH_VARARGS, nullptr },
        { "add_logging_channel_with_level", reinterpret_cast<PyCFunction>(IFileLoggingSession_AddLoggingChannelWithLevel), METH_VARARGS, nullptr },
        { "close", reinterpret_cast<PyCFunction>(IFileLoggingSession_Close), METH_VARARGS, nullptr },
        { "close_and_save_to_file_async", reinterpret_cast<PyCFunction>(IFileLoggingSession_CloseAndSaveToFileAsync), METH_VARARGS, nullptr },
        { "remove_logging_channel", reinterpret_cast<PyCFunction>(IFileLoggingSession_RemoveLoggingChannel), METH_VARARGS, nullptr },
        { "add_log_file_generated", reinterpret_cast<PyCFunction>(IFileLoggingSession_add_LogFileGenerated), METH_O, nullptr },
        { "remove_log_file_generated", reinterpret_cast<PyCFunction>(IFileLoggingSession_remove_LogFileGenerated), METH_O, nullptr },
        { "_assign_array_", _assign_array_IFileLoggingSession, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_IFileLoggingSession), METH_O | METH_STATIC, nullptr },
        { "__enter__", reinterpret_cast<PyCFunction>(_enter_IFileLoggingSession), METH_NOARGS, nullptr },
        { "__exit__", reinterpret_cast<PyCFunction>(_exit_IFileLoggingSession), METH_VARARGS, nullptr },
        { }
    };

    static PyGetSetDef _getset_IFileLoggingSession[] = {
        { "name", reinterpret_cast<getter>(IFileLoggingSession_get_Name), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_IFileLoggingSession[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_IFileLoggingSession) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_IFileLoggingSession) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_IFileLoggingSession) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_IFileLoggingSession) },
        { }
    };

    static PyType_Spec type_spec_IFileLoggingSession = {
        "winrt._winrt_windows_foundation_diagnostics.IFileLoggingSession",
        sizeof(py::wrapper::Windows::Foundation::Diagnostics::IFileLoggingSession),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_IFileLoggingSession};

    struct ImplementsIFileLoggingSession : py::ImplementsInterfaceT<ImplementsIFileLoggingSession, winrt::Windows::Foundation::Diagnostics::IFileLoggingSession>
    {
        ImplementsIFileLoggingSession() = delete;
        ImplementsIFileLoggingSession(PyObject* py_obj, winrt::impl::inspectable_abi* runtime_class) : py::ImplementsInterfaceT<ImplementsIFileLoggingSession, winrt::Windows::Foundation::Diagnostics::IFileLoggingSession>(py_obj, runtime_class)
        {
        }

        auto AddLoggingChannel(winrt::Windows::Foundation::Diagnostics::ILoggingChannel const& param0)
        {
            try
            {
                py::pyobj_handle self{this->get_py_obj()};

                py::pyobj_handle method{PyObject_GetAttrString(self.get(), "add_logging_channel")};
                if (!method)
                {
                    throw python_exception();
                }

                py::pyobj_handle py_param0{py::convert(param0)};
                if (!py_param0)
                {
                    throw python_exception();
                }

                py::pyobj_handle return_value{PyObject_CallOneArg(method.get(), py_param0.get())};
                if (!return_value)
                {
                    throw python_exception();
                }
            }
            catch (python_exception)
            {
                py::write_unraisable_and_throw();
            }
        }

        auto AddLoggingChannel(winrt::Windows::Foundation::Diagnostics::ILoggingChannel const& param0, winrt::Windows::Foundation::Diagnostics::LoggingLevel param1)
        {
            try
            {
                py::pyobj_handle self{this->get_py_obj()};

                py::pyobj_handle method{PyObject_GetAttrString(self.get(), "add_logging_channel_with_level")};
                if (!method)
                {
                    throw python_exception();
                }

                py::pyobj_handle py_param0{py::convert(param0)};
                if (!py_param0)
                {
                    throw python_exception();
                }

                py::pyobj_handle py_param1{py::convert(param1)};
                if (!py_param1)
                {
                    throw python_exception();
                }

                py::pyobj_handle args{PyTuple_Pack(2, py_param0.get(), py_param1.get())};
                if (!args)
                {
                    throw python_exception();
                }

                py::pyobj_handle return_value{PyObject_CallObject(method.get(), args.get())};
                if (!return_value)
                {
                    throw python_exception();
                }
            }
            catch (python_exception)
            {
                py::write_unraisable_and_throw();
            }
        }

        auto Close()
        {
            try
            {
                py::pyobj_handle self{this->get_py_obj()};

                py::pyobj_handle method{PyObject_GetAttrString(self.get(), "close")};
                if (!method)
                {
                    throw python_exception();
                }

                py::pyobj_handle return_value{PyObject_CallNoArgs(method.get())};
                if (!return_value)
                {
                    throw python_exception();
                }
            }
            catch (python_exception)
            {
                py::write_unraisable_and_throw();
            }
        }

        auto CloseAndSaveToFileAsync()
        {
            try
            {
                py::pyobj_handle self{this->get_py_obj()};

                py::pyobj_handle method{PyObject_GetAttrString(self.get(), "close_and_save_to_file_async")};
                if (!method)
                {
                    throw python_exception();
                }

                py::pyobj_handle return_value{PyObject_CallNoArgs(method.get())};
                if (!return_value)
                {
                    throw python_exception();
                }

                return py::convert_to<winrt::Windows::Foundation::IAsyncOperation<winrt::Windows::Storage::StorageFile>>(return_value.get());
            }
            catch (python_exception)
            {
                py::write_unraisable_and_throw();
            }
        }

        auto RemoveLoggingChannel(winrt::Windows::Foundation::Diagnostics::ILoggingChannel const& param0)
        {
            try
            {
                py::pyobj_handle self{this->get_py_obj()};

                py::pyobj_handle method{PyObject_GetAttrString(self.get(), "remove_logging_channel")};
                if (!method)
                {
                    throw python_exception();
                }

                py::pyobj_handle py_param0{py::convert(param0)};
                if (!py_param0)
                {
                    throw python_exception();
                }

                py::pyobj_handle return_value{PyObject_CallOneArg(method.get(), py_param0.get())};
                if (!return_value)
                {
                    throw python_exception();
                }
            }
            catch (python_exception)
            {
                py::write_unraisable_and_throw();
            }
        }

        auto Name()
        {
            try
            {
                py::pyobj_handle self{this->get_py_obj()};

                py::pyobj_handle value{PyObject_GetAttrString(self.get(), "name")};
                if (!value)
                {
                    throw python_exception();
                }

                return py::convert_to<winrt::hstring>(value.get());
            }
            catch (python_exception)
            {
                py::write_unraisable_and_throw();
            }
        }

        auto LogFileGenerated(winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Foundation::Diagnostics::IFileLoggingSession, winrt::Windows::Foundation::Diagnostics::LogFileGeneratedEventArgs> const& param0)
        {
            try
            {
                py::pyobj_handle self{this->get_py_obj()};

                py::pyobj_handle method{PyObject_GetAttrString(self.get(), "add_log_file_generated")};
                if (!method)
                {
                    throw python_exception();
                }

                py::pyobj_handle py_param0{py::convert(param0)};
                if (!py_param0)
                {
                    throw python_exception();
                }

                py::pyobj_handle return_value{PyObject_CallOneArg(method.get(), py_param0.get())};
                if (!return_value)
                {
                    throw python_exception();
                }

                return py::convert_to<winrt::event_token>(return_value.get());
            }
            catch (python_exception)
            {
                py::write_unraisable_and_throw();
            }
        }

        auto LogFileGenerated(winrt::event_token param0)
        {
            try
            {
                py::pyobj_handle self{this->get_py_obj()};

                py::pyobj_handle method{PyObject_GetAttrString(self.get(), "remove_log_file_generated")};
                if (!method)
                {
                    throw python_exception();
                }

                py::pyobj_handle py_param0{py::convert(param0)};
                if (!py_param0)
                {
                    throw python_exception();
                }

                py::pyobj_handle return_value{PyObject_CallOneArg(method.get(), py_param0.get())};
                if (!return_value)
                {
                    throw python_exception();
                }
            }
            catch (python_exception)
            {
                py::write_unraisable_and_throw();
            }
        }
    };

    static PyObject* _guid_ImplementsIFileLoggingSession(PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::guid_of<winrt::Windows::Foundation::Diagnostics::IFileLoggingSession>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _make_ImplementsIFileLoggingSession(PyObject* /*unused*/, PyObject* args) noexcept
    {
        try
        {
            PyObject* py_obj;
            winrt::impl::inspectable_abi* runtime_class;

            if (!PyArg_ParseTuple(args, "On", &py_obj, &runtime_class))
            {
                return nullptr;
            }

            auto iface{std::make_unique<ImplementsIFileLoggingSession>(py_obj, runtime_class)};

            return PyLong_FromVoidPtr(iface.release());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef methods_ImplementsIFileLoggingSession[] = {
        { "_guid_", reinterpret_cast<PyCFunction>(_guid_ImplementsIFileLoggingSession), METH_NOARGS | METH_STATIC, nullptr },
        { "_make_", reinterpret_cast<PyCFunction>(_make_ImplementsIFileLoggingSession), METH_VARARGS | METH_STATIC, nullptr },
        { }
    };

    static PyType_Slot type_slots_ImplementsIFileLoggingSession[] = {
        { Py_tp_methods, reinterpret_cast<void*>(methods_ImplementsIFileLoggingSession) },
        { }
    };

    static PyType_Spec type_spec_ImplementsIFileLoggingSession = {
        "winrt._winrt_windows_foundation_diagnostics.ImplementsIFileLoggingSession",
        0,
        0,
        Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,
        type_slots_ImplementsIFileLoggingSession};

    // ----- ILoggingChannel interface --------------------

    static PyObject* _new_ILoggingChannel(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Foundation::Diagnostics::ILoggingChannel>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Foundation::Diagnostics::ILoggingChannel>::type_name);
        return nullptr;
    }

    static void _dealloc_ILoggingChannel(py::wrapper::Windows::Foundation::Diagnostics::ILoggingChannel* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* ILoggingChannel_Close(py::wrapper::Windows::Foundation::Diagnostics::ILoggingChannel* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Foundation.IClosable", L"Close", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                {
                    auto _gil = release_gil();
                    self->obj.Close();
                }

                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ILoggingChannel_LogMessage(py::wrapper::Windows::Foundation::Diagnostics::ILoggingChannel* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Foundation.Diagnostics.ILoggingChannel", L"LogMessage", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                {
                    auto _gil = release_gil();
                    self->obj.LogMessage(param0);
                }

                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ILoggingChannel_LogMessageWithLevel(py::wrapper::Windows::Foundation::Diagnostics::ILoggingChannel* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Foundation.Diagnostics.ILoggingChannel", L"LogMessage", 2);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(2);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Foundation::Diagnostics::LoggingLevel>(args, 1);

                {
                    auto _gil = release_gil();
                    self->obj.LogMessage(param0, param1);
                }

                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ILoggingChannel_LogValuePair(py::wrapper::Windows::Foundation::Diagnostics::ILoggingChannel* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Foundation.Diagnostics.ILoggingChannel", L"LogValuePair", 2);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(2);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<int32_t>(args, 1);

                {
                    auto _gil = release_gil();
                    self->obj.LogValuePair(param0, param1);
                }

                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ILoggingChannel_LogValuePairWithLevel(py::wrapper::Windows::Foundation::Diagnostics::ILoggingChannel* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 3)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Foundation.Diagnostics.ILoggingChannel", L"LogValuePair", 3);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(3);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<int32_t>(args, 1);
                auto param2 = py::convert_to<winrt::Windows::Foundation::Diagnostics::LoggingLevel>(args, 2);

                {
                    auto _gil = release_gil();
                    self->obj.LogValuePair(param0, param1, param2);
                }

                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ILoggingChannel_get_Enabled(py::wrapper::Windows::Foundation::Diagnostics::ILoggingChannel* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Foundation.Diagnostics.ILoggingChannel", L"Enabled");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Enabled();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ILoggingChannel_get_Level(py::wrapper::Windows::Foundation::Diagnostics::ILoggingChannel* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Foundation.Diagnostics.ILoggingChannel", L"Level");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Level();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ILoggingChannel_get_Name(py::wrapper::Windows::Foundation::Diagnostics::ILoggingChannel* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Foundation.Diagnostics.ILoggingChannel", L"Name");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Name();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ILoggingChannel_add_LoggingEnabled(py::wrapper::Windows::Foundation::Diagnostics::ILoggingChannel* self, PyObject* arg) noexcept
    {
        try
        {
            static std::optional<bool> is_event_present{};

            if (!is_event_present.has_value())
            {
                is_event_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Foundation.Diagnostics.ILoggingChannel", L"LoggingEnabled");
            }

            if (!is_event_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Foundation::Diagnostics::ILoggingChannel, winrt::Windows::Foundation::IInspectable>>(arg);

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.LoggingEnabled(param0);
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ILoggingChannel_remove_LoggingEnabled(py::wrapper::Windows::Foundation::Diagnostics::ILoggingChannel* self, PyObject* arg) noexcept
    {
        try
        {
            static std::optional<bool> is_event_present{};

            if (!is_event_present.has_value())
            {
                is_event_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Foundation.Diagnostics.ILoggingChannel", L"LoggingEnabled");
            }

            if (!is_event_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::event_token>(arg);

            {
                auto _gil = release_gil();
                self->obj.LoggingEnabled(param0);
            }

            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_ILoggingChannel(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Foundation::Diagnostics::ILoggingChannel>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_ILoggingChannel(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Foundation::Diagnostics::ILoggingChannel>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _enter_ILoggingChannel(py::wrapper::Windows::Foundation::Diagnostics::ILoggingChannel* self, PyObject* /*unused*/) noexcept
    {
        return Py_NewRef(self);
    }

    static PyObject* _exit_ILoggingChannel(py::wrapper::Windows::Foundation::Diagnostics::ILoggingChannel* self, PyObject* /*unused*/) noexcept
    {
        try
        {
            {
                auto _gil = py::release_gil();
                self->obj.Close();
            }

            Py_RETURN_FALSE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_ILoggingChannel[] = {
        { "close", reinterpret_cast<PyCFunction>(ILoggingChannel_Close), METH_VARARGS, nullptr },
        { "log_message", reinterpret_cast<PyCFunction>(ILoggingChannel_LogMessage), METH_VARARGS, nullptr },
        { "log_message_with_level", reinterpret_cast<PyCFunction>(ILoggingChannel_LogMessageWithLevel), METH_VARARGS, nullptr },
        { "log_value_pair", reinterpret_cast<PyCFunction>(ILoggingChannel_LogValuePair), METH_VARARGS, nullptr },
        { "log_value_pair_with_level", reinterpret_cast<PyCFunction>(ILoggingChannel_LogValuePairWithLevel), METH_VARARGS, nullptr },
        { "add_logging_enabled", reinterpret_cast<PyCFunction>(ILoggingChannel_add_LoggingEnabled), METH_O, nullptr },
        { "remove_logging_enabled", reinterpret_cast<PyCFunction>(ILoggingChannel_remove_LoggingEnabled), METH_O, nullptr },
        { "_assign_array_", _assign_array_ILoggingChannel, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_ILoggingChannel), METH_O | METH_STATIC, nullptr },
        { "__enter__", reinterpret_cast<PyCFunction>(_enter_ILoggingChannel), METH_NOARGS, nullptr },
        { "__exit__", reinterpret_cast<PyCFunction>(_exit_ILoggingChannel), METH_VARARGS, nullptr },
        { }
    };

    static PyGetSetDef _getset_ILoggingChannel[] = {
        { "enabled", reinterpret_cast<getter>(ILoggingChannel_get_Enabled), nullptr, nullptr, nullptr },
        { "level", reinterpret_cast<getter>(ILoggingChannel_get_Level), nullptr, nullptr, nullptr },
        { "name", reinterpret_cast<getter>(ILoggingChannel_get_Name), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_ILoggingChannel[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_ILoggingChannel) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_ILoggingChannel) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_ILoggingChannel) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_ILoggingChannel) },
        { }
    };

    static PyType_Spec type_spec_ILoggingChannel = {
        "winrt._winrt_windows_foundation_diagnostics.ILoggingChannel",
        sizeof(py::wrapper::Windows::Foundation::Diagnostics::ILoggingChannel),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_ILoggingChannel};

    struct ImplementsILoggingChannel : py::ImplementsInterfaceT<ImplementsILoggingChannel, winrt::Windows::Foundation::Diagnostics::ILoggingChannel>
    {
        ImplementsILoggingChannel() = delete;
        ImplementsILoggingChannel(PyObject* py_obj, winrt::impl::inspectable_abi* runtime_class) : py::ImplementsInterfaceT<ImplementsILoggingChannel, winrt::Windows::Foundation::Diagnostics::ILoggingChannel>(py_obj, runtime_class)
        {
        }

        auto Close()
        {
            try
            {
                py::pyobj_handle self{this->get_py_obj()};

                py::pyobj_handle method{PyObject_GetAttrString(self.get(), "close")};
                if (!method)
                {
                    throw python_exception();
                }

                py::pyobj_handle return_value{PyObject_CallNoArgs(method.get())};
                if (!return_value)
                {
                    throw python_exception();
                }
            }
            catch (python_exception)
            {
                py::write_unraisable_and_throw();
            }
        }

        auto LogMessage(winrt::hstring const& param0)
        {
            try
            {
                py::pyobj_handle self{this->get_py_obj()};

                py::pyobj_handle method{PyObject_GetAttrString(self.get(), "log_message")};
                if (!method)
                {
                    throw python_exception();
                }

                py::pyobj_handle py_param0{py::convert(param0)};
                if (!py_param0)
                {
                    throw python_exception();
                }

                py::pyobj_handle return_value{PyObject_CallOneArg(method.get(), py_param0.get())};
                if (!return_value)
                {
                    throw python_exception();
                }
            }
            catch (python_exception)
            {
                py::write_unraisable_and_throw();
            }
        }

        auto LogMessage(winrt::hstring const& param0, winrt::Windows::Foundation::Diagnostics::LoggingLevel param1)
        {
            try
            {
                py::pyobj_handle self{this->get_py_obj()};

                py::pyobj_handle method{PyObject_GetAttrString(self.get(), "log_message_with_level")};
                if (!method)
                {
                    throw python_exception();
                }

                py::pyobj_handle py_param0{py::convert(param0)};
                if (!py_param0)
                {
                    throw python_exception();
                }

                py::pyobj_handle py_param1{py::convert(param1)};
                if (!py_param1)
                {
                    throw python_exception();
                }

                py::pyobj_handle args{PyTuple_Pack(2, py_param0.get(), py_param1.get())};
                if (!args)
                {
                    throw python_exception();
                }

                py::pyobj_handle return_value{PyObject_CallObject(method.get(), args.get())};
                if (!return_value)
                {
                    throw python_exception();
                }
            }
            catch (python_exception)
            {
                py::write_unraisable_and_throw();
            }
        }

        auto LogValuePair(winrt::hstring const& param0, int32_t param1)
        {
            try
            {
                py::pyobj_handle self{this->get_py_obj()};

                py::pyobj_handle method{PyObject_GetAttrString(self.get(), "log_value_pair")};
                if (!method)
                {
                    throw python_exception();
                }

                py::pyobj_handle py_param0{py::convert(param0)};
                if (!py_param0)
                {
                    throw python_exception();
                }

                py::pyobj_handle py_param1{py::convert(param1)};
                if (!py_param1)
                {
                    throw python_exception();
                }

                py::pyobj_handle args{PyTuple_Pack(2, py_param0.get(), py_param1.get())};
                if (!args)
                {
                    throw python_exception();
                }

                py::pyobj_handle return_value{PyObject_CallObject(method.get(), args.get())};
                if (!return_value)
                {
                    throw python_exception();
                }
            }
            catch (python_exception)
            {
                py::write_unraisable_and_throw();
            }
        }

        auto LogValuePair(winrt::hstring const& param0, int32_t param1, winrt::Windows::Foundation::Diagnostics::LoggingLevel param2)
        {
            try
            {
                py::pyobj_handle self{this->get_py_obj()};

                py::pyobj_handle method{PyObject_GetAttrString(self.get(), "log_value_pair_with_level")};
                if (!method)
                {
                    throw python_exception();
                }

                py::pyobj_handle py_param0{py::convert(param0)};
                if (!py_param0)
                {
                    throw python_exception();
                }

                py::pyobj_handle py_param1{py::convert(param1)};
                if (!py_param1)
                {
                    throw python_exception();
                }

                py::pyobj_handle py_param2{py::convert(param2)};
                if (!py_param2)
                {
                    throw python_exception();
                }

                py::pyobj_handle args{PyTuple_Pack(3, py_param0.get(), py_param1.get(), py_param2.get())};
                if (!args)
                {
                    throw python_exception();
                }

                py::pyobj_handle return_value{PyObject_CallObject(method.get(), args.get())};
                if (!return_value)
                {
                    throw python_exception();
                }
            }
            catch (python_exception)
            {
                py::write_unraisable_and_throw();
            }
        }

        auto Enabled()
        {
            try
            {
                py::pyobj_handle self{this->get_py_obj()};

                py::pyobj_handle value{PyObject_GetAttrString(self.get(), "enabled")};
                if (!value)
                {
                    throw python_exception();
                }

                return py::convert_to<bool>(value.get());
            }
            catch (python_exception)
            {
                py::write_unraisable_and_throw();
            }
        }

        auto Level()
        {
            try
            {
                py::pyobj_handle self{this->get_py_obj()};

                py::pyobj_handle value{PyObject_GetAttrString(self.get(), "level")};
                if (!value)
                {
                    throw python_exception();
                }

                return py::convert_to<winrt::Windows::Foundation::Diagnostics::LoggingLevel>(value.get());
            }
            catch (python_exception)
            {
                py::write_unraisable_and_throw();
            }
        }

        auto Name()
        {
            try
            {
                py::pyobj_handle self{this->get_py_obj()};

                py::pyobj_handle value{PyObject_GetAttrString(self.get(), "name")};
                if (!value)
                {
                    throw python_exception();
                }

                return py::convert_to<winrt::hstring>(value.get());
            }
            catch (python_exception)
            {
                py::write_unraisable_and_throw();
            }
        }

        auto LoggingEnabled(winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Foundation::Diagnostics::ILoggingChannel, winrt::Windows::Foundation::IInspectable> const& param0)
        {
            try
            {
                py::pyobj_handle self{this->get_py_obj()};

                py::pyobj_handle method{PyObject_GetAttrString(self.get(), "add_logging_enabled")};
                if (!method)
                {
                    throw python_exception();
                }

                py::pyobj_handle py_param0{py::convert(param0)};
                if (!py_param0)
                {
                    throw python_exception();
                }

                py::pyobj_handle return_value{PyObject_CallOneArg(method.get(), py_param0.get())};
                if (!return_value)
                {
                    throw python_exception();
                }

                return py::convert_to<winrt::event_token>(return_value.get());
            }
            catch (python_exception)
            {
                py::write_unraisable_and_throw();
            }
        }

        auto LoggingEnabled(winrt::event_token param0)
        {
            try
            {
                py::pyobj_handle self{this->get_py_obj()};

                py::pyobj_handle method{PyObject_GetAttrString(self.get(), "remove_logging_enabled")};
                if (!method)
                {
                    throw python_exception();
                }

                py::pyobj_handle py_param0{py::convert(param0)};
                if (!py_param0)
                {
                    throw python_exception();
                }

                py::pyobj_handle return_value{PyObject_CallOneArg(method.get(), py_param0.get())};
                if (!return_value)
                {
                    throw python_exception();
                }
            }
            catch (python_exception)
            {
                py::write_unraisable_and_throw();
            }
        }
    };

    static PyObject* _guid_ImplementsILoggingChannel(PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::guid_of<winrt::Windows::Foundation::Diagnostics::ILoggingChannel>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _make_ImplementsILoggingChannel(PyObject* /*unused*/, PyObject* args) noexcept
    {
        try
        {
            PyObject* py_obj;
            winrt::impl::inspectable_abi* runtime_class;

            if (!PyArg_ParseTuple(args, "On", &py_obj, &runtime_class))
            {
                return nullptr;
            }

            auto iface{std::make_unique<ImplementsILoggingChannel>(py_obj, runtime_class)};

            return PyLong_FromVoidPtr(iface.release());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef methods_ImplementsILoggingChannel[] = {
        { "_guid_", reinterpret_cast<PyCFunction>(_guid_ImplementsILoggingChannel), METH_NOARGS | METH_STATIC, nullptr },
        { "_make_", reinterpret_cast<PyCFunction>(_make_ImplementsILoggingChannel), METH_VARARGS | METH_STATIC, nullptr },
        { }
    };

    static PyType_Slot type_slots_ImplementsILoggingChannel[] = {
        { Py_tp_methods, reinterpret_cast<void*>(methods_ImplementsILoggingChannel) },
        { }
    };

    static PyType_Spec type_spec_ImplementsILoggingChannel = {
        "winrt._winrt_windows_foundation_diagnostics.ImplementsILoggingChannel",
        0,
        0,
        Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,
        type_slots_ImplementsILoggingChannel};

    // ----- ILoggingSession interface --------------------

    static PyObject* _new_ILoggingSession(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Foundation::Diagnostics::ILoggingSession>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Foundation::Diagnostics::ILoggingSession>::type_name);
        return nullptr;
    }

    static void _dealloc_ILoggingSession(py::wrapper::Windows::Foundation::Diagnostics::ILoggingSession* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* ILoggingSession_AddLoggingChannel(py::wrapper::Windows::Foundation::Diagnostics::ILoggingSession* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Foundation.Diagnostics.ILoggingSession", L"AddLoggingChannel", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Foundation::Diagnostics::ILoggingChannel>(args, 0);

                {
                    auto _gil = release_gil();
                    self->obj.AddLoggingChannel(param0);
                }

                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ILoggingSession_AddLoggingChannelWithLevel(py::wrapper::Windows::Foundation::Diagnostics::ILoggingSession* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Foundation.Diagnostics.ILoggingSession", L"AddLoggingChannel", 2);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(2);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Foundation::Diagnostics::ILoggingChannel>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Foundation::Diagnostics::LoggingLevel>(args, 1);

                {
                    auto _gil = release_gil();
                    self->obj.AddLoggingChannel(param0, param1);
                }

                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ILoggingSession_Close(py::wrapper::Windows::Foundation::Diagnostics::ILoggingSession* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Foundation.IClosable", L"Close", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                {
                    auto _gil = release_gil();
                    self->obj.Close();
                }

                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ILoggingSession_RemoveLoggingChannel(py::wrapper::Windows::Foundation::Diagnostics::ILoggingSession* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Foundation.Diagnostics.ILoggingSession", L"RemoveLoggingChannel", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Foundation::Diagnostics::ILoggingChannel>(args, 0);

                {
                    auto _gil = release_gil();
                    self->obj.RemoveLoggingChannel(param0);
                }

                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ILoggingSession_SaveToFileAsync(py::wrapper::Windows::Foundation::Diagnostics::ILoggingSession* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Foundation.Diagnostics.ILoggingSession", L"SaveToFileAsync", 2);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(2);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Storage::IStorageFolder>(args, 0);
                auto param1 = py::convert_to<winrt::hstring>(args, 1);

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return self->obj.SaveToFileAsync(param0, param1);
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ILoggingSession_get_Name(py::wrapper::Windows::Foundation::Diagnostics::ILoggingSession* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Foundation.Diagnostics.ILoggingSession", L"Name");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Name();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_ILoggingSession(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Foundation::Diagnostics::ILoggingSession>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_ILoggingSession(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Foundation::Diagnostics::ILoggingSession>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _enter_ILoggingSession(py::wrapper::Windows::Foundation::Diagnostics::ILoggingSession* self, PyObject* /*unused*/) noexcept
    {
        return Py_NewRef(self);
    }

    static PyObject* _exit_ILoggingSession(py::wrapper::Windows::Foundation::Diagnostics::ILoggingSession* self, PyObject* /*unused*/) noexcept
    {
        try
        {
            {
                auto _gil = py::release_gil();
                self->obj.Close();
            }

            Py_RETURN_FALSE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_ILoggingSession[] = {
        { "add_logging_channel", reinterpret_cast<PyCFunction>(ILoggingSession_AddLoggingChannel), METH_VARARGS, nullptr },
        { "add_logging_channel_with_level", reinterpret_cast<PyCFunction>(ILoggingSession_AddLoggingChannelWithLevel), METH_VARARGS, nullptr },
        { "close", reinterpret_cast<PyCFunction>(ILoggingSession_Close), METH_VARARGS, nullptr },
        { "remove_logging_channel", reinterpret_cast<PyCFunction>(ILoggingSession_RemoveLoggingChannel), METH_VARARGS, nullptr },
        { "save_to_file_async", reinterpret_cast<PyCFunction>(ILoggingSession_SaveToFileAsync), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_ILoggingSession, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_ILoggingSession), METH_O | METH_STATIC, nullptr },
        { "__enter__", reinterpret_cast<PyCFunction>(_enter_ILoggingSession), METH_NOARGS, nullptr },
        { "__exit__", reinterpret_cast<PyCFunction>(_exit_ILoggingSession), METH_VARARGS, nullptr },
        { }
    };

    static PyGetSetDef _getset_ILoggingSession[] = {
        { "name", reinterpret_cast<getter>(ILoggingSession_get_Name), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_ILoggingSession[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_ILoggingSession) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_ILoggingSession) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_ILoggingSession) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_ILoggingSession) },
        { }
    };

    static PyType_Spec type_spec_ILoggingSession = {
        "winrt._winrt_windows_foundation_diagnostics.ILoggingSession",
        sizeof(py::wrapper::Windows::Foundation::Diagnostics::ILoggingSession),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_ILoggingSession};

    struct ImplementsILoggingSession : py::ImplementsInterfaceT<ImplementsILoggingSession, winrt::Windows::Foundation::Diagnostics::ILoggingSession>
    {
        ImplementsILoggingSession() = delete;
        ImplementsILoggingSession(PyObject* py_obj, winrt::impl::inspectable_abi* runtime_class) : py::ImplementsInterfaceT<ImplementsILoggingSession, winrt::Windows::Foundation::Diagnostics::ILoggingSession>(py_obj, runtime_class)
        {
        }

        auto AddLoggingChannel(winrt::Windows::Foundation::Diagnostics::ILoggingChannel const& param0)
        {
            try
            {
                py::pyobj_handle self{this->get_py_obj()};

                py::pyobj_handle method{PyObject_GetAttrString(self.get(), "add_logging_channel")};
                if (!method)
                {
                    throw python_exception();
                }

                py::pyobj_handle py_param0{py::convert(param0)};
                if (!py_param0)
                {
                    throw python_exception();
                }

                py::pyobj_handle return_value{PyObject_CallOneArg(method.get(), py_param0.get())};
                if (!return_value)
                {
                    throw python_exception();
                }
            }
            catch (python_exception)
            {
                py::write_unraisable_and_throw();
            }
        }

        auto AddLoggingChannel(winrt::Windows::Foundation::Diagnostics::ILoggingChannel const& param0, winrt::Windows::Foundation::Diagnostics::LoggingLevel param1)
        {
            try
            {
                py::pyobj_handle self{this->get_py_obj()};

                py::pyobj_handle method{PyObject_GetAttrString(self.get(), "add_logging_channel_with_level")};
                if (!method)
                {
                    throw python_exception();
                }

                py::pyobj_handle py_param0{py::convert(param0)};
                if (!py_param0)
                {
                    throw python_exception();
                }

                py::pyobj_handle py_param1{py::convert(param1)};
                if (!py_param1)
                {
                    throw python_exception();
                }

                py::pyobj_handle args{PyTuple_Pack(2, py_param0.get(), py_param1.get())};
                if (!args)
                {
                    throw python_exception();
                }

                py::pyobj_handle return_value{PyObject_CallObject(method.get(), args.get())};
                if (!return_value)
                {
                    throw python_exception();
                }
            }
            catch (python_exception)
            {
                py::write_unraisable_and_throw();
            }
        }

        auto Close()
        {
            try
            {
                py::pyobj_handle self{this->get_py_obj()};

                py::pyobj_handle method{PyObject_GetAttrString(self.get(), "close")};
                if (!method)
                {
                    throw python_exception();
                }

                py::pyobj_handle return_value{PyObject_CallNoArgs(method.get())};
                if (!return_value)
                {
                    throw python_exception();
                }
            }
            catch (python_exception)
            {
                py::write_unraisable_and_throw();
            }
        }

        auto RemoveLoggingChannel(winrt::Windows::Foundation::Diagnostics::ILoggingChannel const& param0)
        {
            try
            {
                py::pyobj_handle self{this->get_py_obj()};

                py::pyobj_handle method{PyObject_GetAttrString(self.get(), "remove_logging_channel")};
                if (!method)
                {
                    throw python_exception();
                }

                py::pyobj_handle py_param0{py::convert(param0)};
                if (!py_param0)
                {
                    throw python_exception();
                }

                py::pyobj_handle return_value{PyObject_CallOneArg(method.get(), py_param0.get())};
                if (!return_value)
                {
                    throw python_exception();
                }
            }
            catch (python_exception)
            {
                py::write_unraisable_and_throw();
            }
        }

        auto SaveToFileAsync(winrt::Windows::Storage::IStorageFolder const& param0, winrt::hstring const& param1)
        {
            try
            {
                py::pyobj_handle self{this->get_py_obj()};

                py::pyobj_handle method{PyObject_GetAttrString(self.get(), "save_to_file_async")};
                if (!method)
                {
                    throw python_exception();
                }

                py::pyobj_handle py_param0{py::convert(param0)};
                if (!py_param0)
                {
                    throw python_exception();
                }

                py::pyobj_handle py_param1{py::convert(param1)};
                if (!py_param1)
                {
                    throw python_exception();
                }

                py::pyobj_handle args{PyTuple_Pack(2, py_param0.get(), py_param1.get())};
                if (!args)
                {
                    throw python_exception();
                }

                py::pyobj_handle return_value{PyObject_CallObject(method.get(), args.get())};
                if (!return_value)
                {
                    throw python_exception();
                }

                return py::convert_to<winrt::Windows::Foundation::IAsyncOperation<winrt::Windows::Storage::StorageFile>>(return_value.get());
            }
            catch (python_exception)
            {
                py::write_unraisable_and_throw();
            }
        }

        auto Name()
        {
            try
            {
                py::pyobj_handle self{this->get_py_obj()};

                py::pyobj_handle value{PyObject_GetAttrString(self.get(), "name")};
                if (!value)
                {
                    throw python_exception();
                }

                return py::convert_to<winrt::hstring>(value.get());
            }
            catch (python_exception)
            {
                py::write_unraisable_and_throw();
            }
        }
    };

    static PyObject* _guid_ImplementsILoggingSession(PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::guid_of<winrt::Windows::Foundation::Diagnostics::ILoggingSession>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _make_ImplementsILoggingSession(PyObject* /*unused*/, PyObject* args) noexcept
    {
        try
        {
            PyObject* py_obj;
            winrt::impl::inspectable_abi* runtime_class;

            if (!PyArg_ParseTuple(args, "On", &py_obj, &runtime_class))
            {
                return nullptr;
            }

            auto iface{std::make_unique<ImplementsILoggingSession>(py_obj, runtime_class)};

            return PyLong_FromVoidPtr(iface.release());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef methods_ImplementsILoggingSession[] = {
        { "_guid_", reinterpret_cast<PyCFunction>(_guid_ImplementsILoggingSession), METH_NOARGS | METH_STATIC, nullptr },
        { "_make_", reinterpret_cast<PyCFunction>(_make_ImplementsILoggingSession), METH_VARARGS | METH_STATIC, nullptr },
        { }
    };

    static PyType_Slot type_slots_ImplementsILoggingSession[] = {
        { Py_tp_methods, reinterpret_cast<void*>(methods_ImplementsILoggingSession) },
        { }
    };

    static PyType_Spec type_spec_ImplementsILoggingSession = {
        "winrt._winrt_windows_foundation_diagnostics.ImplementsILoggingSession",
        0,
        0,
        Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,
        type_slots_ImplementsILoggingSession};

    // ----- ILoggingTarget interface --------------------

    static PyObject* _new_ILoggingTarget(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Foundation::Diagnostics::ILoggingTarget>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Foundation::Diagnostics::ILoggingTarget>::type_name);
        return nullptr;
    }

    static void _dealloc_ILoggingTarget(py::wrapper::Windows::Foundation::Diagnostics::ILoggingTarget* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* ILoggingTarget_IsEnabled(py::wrapper::Windows::Foundation::Diagnostics::ILoggingTarget* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Foundation.Diagnostics.ILoggingTarget", L"IsEnabled", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return self->obj.IsEnabled();
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ILoggingTarget_IsEnabledWithLevel(py::wrapper::Windows::Foundation::Diagnostics::ILoggingTarget* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Foundation.Diagnostics.ILoggingTarget", L"IsEnabled", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Foundation::Diagnostics::LoggingLevel>(args, 0);

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return self->obj.IsEnabled(param0);
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ILoggingTarget_IsEnabledWithLevelAndKeywords(py::wrapper::Windows::Foundation::Diagnostics::ILoggingTarget* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Foundation.Diagnostics.ILoggingTarget", L"IsEnabled", 2);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(2);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Foundation::Diagnostics::LoggingLevel>(args, 0);
                auto param1 = py::convert_to<int64_t>(args, 1);

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return self->obj.IsEnabled(param0, param1);
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ILoggingTarget_LogEvent(py::wrapper::Windows::Foundation::Diagnostics::ILoggingTarget* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Foundation.Diagnostics.ILoggingTarget", L"LogEvent", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                {
                    auto _gil = release_gil();
                    self->obj.LogEvent(param0);
                }

                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ILoggingTarget_LogEventWithFields(py::wrapper::Windows::Foundation::Diagnostics::ILoggingTarget* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Foundation.Diagnostics.ILoggingTarget", L"LogEvent", 2);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(2);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Foundation::Diagnostics::LoggingFields>(args, 1);

                {
                    auto _gil = release_gil();
                    self->obj.LogEvent(param0, param1);
                }

                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ILoggingTarget_LogEventWithFieldsAndLevel(py::wrapper::Windows::Foundation::Diagnostics::ILoggingTarget* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 3)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Foundation.Diagnostics.ILoggingTarget", L"LogEvent", 3);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(3);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Foundation::Diagnostics::LoggingFields>(args, 1);
                auto param2 = py::convert_to<winrt::Windows::Foundation::Diagnostics::LoggingLevel>(args, 2);

                {
                    auto _gil = release_gil();
                    self->obj.LogEvent(param0, param1, param2);
                }

                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ILoggingTarget_LogEventWithFieldsAndOptions(py::wrapper::Windows::Foundation::Diagnostics::ILoggingTarget* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 4)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Foundation.Diagnostics.ILoggingTarget", L"LogEvent", 4);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(4);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Foundation::Diagnostics::LoggingFields>(args, 1);
                auto param2 = py::convert_to<winrt::Windows::Foundation::Diagnostics::LoggingLevel>(args, 2);
                auto param3 = py::convert_to<winrt::Windows::Foundation::Diagnostics::LoggingOptions>(args, 3);

                {
                    auto _gil = release_gil();
                    self->obj.LogEvent(param0, param1, param2, param3);
                }

                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ILoggingTarget_StartActivity(py::wrapper::Windows::Foundation::Diagnostics::ILoggingTarget* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Foundation.Diagnostics.ILoggingTarget", L"StartActivity", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return self->obj.StartActivity(param0);
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ILoggingTarget_StartActivityWithFields(py::wrapper::Windows::Foundation::Diagnostics::ILoggingTarget* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Foundation.Diagnostics.ILoggingTarget", L"StartActivity", 2);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(2);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Foundation::Diagnostics::LoggingFields>(args, 1);

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return self->obj.StartActivity(param0, param1);
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ILoggingTarget_StartActivityWithFieldsAndLevel(py::wrapper::Windows::Foundation::Diagnostics::ILoggingTarget* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 3)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Foundation.Diagnostics.ILoggingTarget", L"StartActivity", 3);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(3);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Foundation::Diagnostics::LoggingFields>(args, 1);
                auto param2 = py::convert_to<winrt::Windows::Foundation::Diagnostics::LoggingLevel>(args, 2);

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return self->obj.StartActivity(param0, param1, param2);
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ILoggingTarget_StartActivityWithFieldsAndOptions(py::wrapper::Windows::Foundation::Diagnostics::ILoggingTarget* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 4)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Foundation.Diagnostics.ILoggingTarget", L"StartActivity", 4);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(4);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Foundation::Diagnostics::LoggingFields>(args, 1);
                auto param2 = py::convert_to<winrt::Windows::Foundation::Diagnostics::LoggingLevel>(args, 2);
                auto param3 = py::convert_to<winrt::Windows::Foundation::Diagnostics::LoggingOptions>(args, 3);

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return self->obj.StartActivity(param0, param1, param2, param3);
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* _assign_array_ILoggingTarget(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Foundation::Diagnostics::ILoggingTarget>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_ILoggingTarget(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Foundation::Diagnostics::ILoggingTarget>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_ILoggingTarget[] = {
        { "is_enabled", reinterpret_cast<PyCFunction>(ILoggingTarget_IsEnabled), METH_VARARGS, nullptr },
        { "is_enabled_with_level", reinterpret_cast<PyCFunction>(ILoggingTarget_IsEnabledWithLevel), METH_VARARGS, nullptr },
        { "is_enabled_with_level_and_keywords", reinterpret_cast<PyCFunction>(ILoggingTarget_IsEnabledWithLevelAndKeywords), METH_VARARGS, nullptr },
        { "log_event", reinterpret_cast<PyCFunction>(ILoggingTarget_LogEvent), METH_VARARGS, nullptr },
        { "log_event_with_fields", reinterpret_cast<PyCFunction>(ILoggingTarget_LogEventWithFields), METH_VARARGS, nullptr },
        { "log_event_with_fields_and_level", reinterpret_cast<PyCFunction>(ILoggingTarget_LogEventWithFieldsAndLevel), METH_VARARGS, nullptr },
        { "log_event_with_fields_and_options", reinterpret_cast<PyCFunction>(ILoggingTarget_LogEventWithFieldsAndOptions), METH_VARARGS, nullptr },
        { "start_activity", reinterpret_cast<PyCFunction>(ILoggingTarget_StartActivity), METH_VARARGS, nullptr },
        { "start_activity_with_fields", reinterpret_cast<PyCFunction>(ILoggingTarget_StartActivityWithFields), METH_VARARGS, nullptr },
        { "start_activity_with_fields_and_level", reinterpret_cast<PyCFunction>(ILoggingTarget_StartActivityWithFieldsAndLevel), METH_VARARGS, nullptr },
        { "start_activity_with_fields_and_options", reinterpret_cast<PyCFunction>(ILoggingTarget_StartActivityWithFieldsAndOptions), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_ILoggingTarget, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_ILoggingTarget), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_ILoggingTarget[] = {
        { }
    };

    static PyType_Slot _type_slots_ILoggingTarget[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_ILoggingTarget) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_ILoggingTarget) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_ILoggingTarget) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_ILoggingTarget) },
        { }
    };

    static PyType_Spec type_spec_ILoggingTarget = {
        "winrt._winrt_windows_foundation_diagnostics.ILoggingTarget",
        sizeof(py::wrapper::Windows::Foundation::Diagnostics::ILoggingTarget),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_ILoggingTarget};

    struct ImplementsILoggingTarget : py::ImplementsInterfaceT<ImplementsILoggingTarget, winrt::Windows::Foundation::Diagnostics::ILoggingTarget>
    {
        ImplementsILoggingTarget() = delete;
        ImplementsILoggingTarget(PyObject* py_obj, winrt::impl::inspectable_abi* runtime_class) : py::ImplementsInterfaceT<ImplementsILoggingTarget, winrt::Windows::Foundation::Diagnostics::ILoggingTarget>(py_obj, runtime_class)
        {
        }

        auto IsEnabled()
        {
            try
            {
                py::pyobj_handle self{this->get_py_obj()};

                py::pyobj_handle method{PyObject_GetAttrString(self.get(), "is_enabled")};
                if (!method)
                {
                    throw python_exception();
                }

                py::pyobj_handle return_value{PyObject_CallNoArgs(method.get())};
                if (!return_value)
                {
                    throw python_exception();
                }

                return py::convert_to<bool>(return_value.get());
            }
            catch (python_exception)
            {
                py::write_unraisable_and_throw();
            }
        }

        auto IsEnabled(winrt::Windows::Foundation::Diagnostics::LoggingLevel param0)
        {
            try
            {
                py::pyobj_handle self{this->get_py_obj()};

                py::pyobj_handle method{PyObject_GetAttrString(self.get(), "is_enabled_with_level")};
                if (!method)
                {
                    throw python_exception();
                }

                py::pyobj_handle py_param0{py::convert(param0)};
                if (!py_param0)
                {
                    throw python_exception();
                }

                py::pyobj_handle return_value{PyObject_CallOneArg(method.get(), py_param0.get())};
                if (!return_value)
                {
                    throw python_exception();
                }

                return py::convert_to<bool>(return_value.get());
            }
            catch (python_exception)
            {
                py::write_unraisable_and_throw();
            }
        }

        auto IsEnabled(winrt::Windows::Foundation::Diagnostics::LoggingLevel param0, int64_t param1)
        {
            try
            {
                py::pyobj_handle self{this->get_py_obj()};

                py::pyobj_handle method{PyObject_GetAttrString(self.get(), "is_enabled_with_level_and_keywords")};
                if (!method)
                {
                    throw python_exception();
                }

                py::pyobj_handle py_param0{py::convert(param0)};
                if (!py_param0)
                {
                    throw python_exception();
                }

                py::pyobj_handle py_param1{py::convert(param1)};
                if (!py_param1)
                {
                    throw python_exception();
                }

                py::pyobj_handle args{PyTuple_Pack(2, py_param0.get(), py_param1.get())};
                if (!args)
                {
                    throw python_exception();
                }

                py::pyobj_handle return_value{PyObject_CallObject(method.get(), args.get())};
                if (!return_value)
                {
                    throw python_exception();
                }

                return py::convert_to<bool>(return_value.get());
            }
            catch (python_exception)
            {
                py::write_unraisable_and_throw();
            }
        }

        auto LogEvent(winrt::hstring const& param0)
        {
            try
            {
                py::pyobj_handle self{this->get_py_obj()};

                py::pyobj_handle method{PyObject_GetAttrString(self.get(), "log_event")};
                if (!method)
                {
                    throw python_exception();
                }

                py::pyobj_handle py_param0{py::convert(param0)};
                if (!py_param0)
                {
                    throw python_exception();
                }

                py::pyobj_handle return_value{PyObject_CallOneArg(method.get(), py_param0.get())};
                if (!return_value)
                {
                    throw python_exception();
                }
            }
            catch (python_exception)
            {
                py::write_unraisable_and_throw();
            }
        }

        auto LogEvent(winrt::hstring const& param0, winrt::Windows::Foundation::Diagnostics::LoggingFields const& param1)
        {
            try
            {
                py::pyobj_handle self{this->get_py_obj()};

                py::pyobj_handle method{PyObject_GetAttrString(self.get(), "log_event_with_fields")};
                if (!method)
                {
                    throw python_exception();
                }

                py::pyobj_handle py_param0{py::convert(param0)};
                if (!py_param0)
                {
                    throw python_exception();
                }

                py::pyobj_handle py_param1{py::convert(param1)};
                if (!py_param1)
                {
                    throw python_exception();
                }

                py::pyobj_handle args{PyTuple_Pack(2, py_param0.get(), py_param1.get())};
                if (!args)
                {
                    throw python_exception();
                }

                py::pyobj_handle return_value{PyObject_CallObject(method.get(), args.get())};
                if (!return_value)
                {
                    throw python_exception();
                }
            }
            catch (python_exception)
            {
                py::write_unraisable_and_throw();
            }
        }

        auto LogEvent(winrt::hstring const& param0, winrt::Windows::Foundation::Diagnostics::LoggingFields const& param1, winrt::Windows::Foundation::Diagnostics::LoggingLevel param2)
        {
            try
            {
                py::pyobj_handle self{this->get_py_obj()};

                py::pyobj_handle method{PyObject_GetAttrString(self.get(), "log_event_with_fields_and_level")};
                if (!method)
                {
                    throw python_exception();
                }

                py::pyobj_handle py_param0{py::convert(param0)};
                if (!py_param0)
                {
                    throw python_exception();
                }

                py::pyobj_handle py_param1{py::convert(param1)};
                if (!py_param1)
                {
                    throw python_exception();
                }

                py::pyobj_handle py_param2{py::convert(param2)};
                if (!py_param2)
                {
                    throw python_exception();
                }

                py::pyobj_handle args{PyTuple_Pack(3, py_param0.get(), py_param1.get(), py_param2.get())};
                if (!args)
                {
                    throw python_exception();
                }

                py::pyobj_handle return_value{PyObject_CallObject(method.get(), args.get())};
                if (!return_value)
                {
                    throw python_exception();
                }
            }
            catch (python_exception)
            {
                py::write_unraisable_and_throw();
            }
        }

        auto LogEvent(winrt::hstring const& param0, winrt::Windows::Foundation::Diagnostics::LoggingFields const& param1, winrt::Windows::Foundation::Diagnostics::LoggingLevel param2, winrt::Windows::Foundation::Diagnostics::LoggingOptions const& param3)
        {
            try
            {
                py::pyobj_handle self{this->get_py_obj()};

                py::pyobj_handle method{PyObject_GetAttrString(self.get(), "log_event_with_fields_and_options")};
                if (!method)
                {
                    throw python_exception();
                }

                py::pyobj_handle py_param0{py::convert(param0)};
                if (!py_param0)
                {
                    throw python_exception();
                }

                py::pyobj_handle py_param1{py::convert(param1)};
                if (!py_param1)
                {
                    throw python_exception();
                }

                py::pyobj_handle py_param2{py::convert(param2)};
                if (!py_param2)
                {
                    throw python_exception();
                }

                py::pyobj_handle py_param3{py::convert(param3)};
                if (!py_param3)
                {
                    throw python_exception();
                }

                py::pyobj_handle args{PyTuple_Pack(4, py_param0.get(), py_param1.get(), py_param2.get(), py_param3.get())};
                if (!args)
                {
                    throw python_exception();
                }

                py::pyobj_handle return_value{PyObject_CallObject(method.get(), args.get())};
                if (!return_value)
                {
                    throw python_exception();
                }
            }
            catch (python_exception)
            {
                py::write_unraisable_and_throw();
            }
        }

        auto StartActivity(winrt::hstring const& param0)
        {
            try
            {
                py::pyobj_handle self{this->get_py_obj()};

                py::pyobj_handle method{PyObject_GetAttrString(self.get(), "start_activity")};
                if (!method)
                {
                    throw python_exception();
                }

                py::pyobj_handle py_param0{py::convert(param0)};
                if (!py_param0)
                {
                    throw python_exception();
                }

                py::pyobj_handle return_value{PyObject_CallOneArg(method.get(), py_param0.get())};
                if (!return_value)
                {
                    throw python_exception();
                }

                return py::convert_to<winrt::Windows::Foundation::Diagnostics::LoggingActivity>(return_value.get());
            }
            catch (python_exception)
            {
                py::write_unraisable_and_throw();
            }
        }

        auto StartActivity(winrt::hstring const& param0, winrt::Windows::Foundation::Diagnostics::LoggingFields const& param1)
        {
            try
            {
                py::pyobj_handle self{this->get_py_obj()};

                py::pyobj_handle method{PyObject_GetAttrString(self.get(), "start_activity_with_fields")};
                if (!method)
                {
                    throw python_exception();
                }

                py::pyobj_handle py_param0{py::convert(param0)};
                if (!py_param0)
                {
                    throw python_exception();
                }

                py::pyobj_handle py_param1{py::convert(param1)};
                if (!py_param1)
                {
                    throw python_exception();
                }

                py::pyobj_handle args{PyTuple_Pack(2, py_param0.get(), py_param1.get())};
                if (!args)
                {
                    throw python_exception();
                }

                py::pyobj_handle return_value{PyObject_CallObject(method.get(), args.get())};
                if (!return_value)
                {
                    throw python_exception();
                }

                return py::convert_to<winrt::Windows::Foundation::Diagnostics::LoggingActivity>(return_value.get());
            }
            catch (python_exception)
            {
                py::write_unraisable_and_throw();
            }
        }

        auto StartActivity(winrt::hstring const& param0, winrt::Windows::Foundation::Diagnostics::LoggingFields const& param1, winrt::Windows::Foundation::Diagnostics::LoggingLevel param2)
        {
            try
            {
                py::pyobj_handle self{this->get_py_obj()};

                py::pyobj_handle method{PyObject_GetAttrString(self.get(), "start_activity_with_fields_and_level")};
                if (!method)
                {
                    throw python_exception();
                }

                py::pyobj_handle py_param0{py::convert(param0)};
                if (!py_param0)
                {
                    throw python_exception();
                }

                py::pyobj_handle py_param1{py::convert(param1)};
                if (!py_param1)
                {
                    throw python_exception();
                }

                py::pyobj_handle py_param2{py::convert(param2)};
                if (!py_param2)
                {
                    throw python_exception();
                }

                py::pyobj_handle args{PyTuple_Pack(3, py_param0.get(), py_param1.get(), py_param2.get())};
                if (!args)
                {
                    throw python_exception();
                }

                py::pyobj_handle return_value{PyObject_CallObject(method.get(), args.get())};
                if (!return_value)
                {
                    throw python_exception();
                }

                return py::convert_to<winrt::Windows::Foundation::Diagnostics::LoggingActivity>(return_value.get());
            }
            catch (python_exception)
            {
                py::write_unraisable_and_throw();
            }
        }

        auto StartActivity(winrt::hstring const& param0, winrt::Windows::Foundation::Diagnostics::LoggingFields const& param1, winrt::Windows::Foundation::Diagnostics::LoggingLevel param2, winrt::Windows::Foundation::Diagnostics::LoggingOptions const& param3)
        {
            try
            {
                py::pyobj_handle self{this->get_py_obj()};

                py::pyobj_handle method{PyObject_GetAttrString(self.get(), "start_activity_with_fields_and_options")};
                if (!method)
                {
                    throw python_exception();
                }

                py::pyobj_handle py_param0{py::convert(param0)};
                if (!py_param0)
                {
                    throw python_exception();
                }

                py::pyobj_handle py_param1{py::convert(param1)};
                if (!py_param1)
                {
                    throw python_exception();
                }

                py::pyobj_handle py_param2{py::convert(param2)};
                if (!py_param2)
                {
                    throw python_exception();
                }

                py::pyobj_handle py_param3{py::convert(param3)};
                if (!py_param3)
                {
                    throw python_exception();
                }

                py::pyobj_handle args{PyTuple_Pack(4, py_param0.get(), py_param1.get(), py_param2.get(), py_param3.get())};
                if (!args)
                {
                    throw python_exception();
                }

                py::pyobj_handle return_value{PyObject_CallObject(method.get(), args.get())};
                if (!return_value)
                {
                    throw python_exception();
                }

                return py::convert_to<winrt::Windows::Foundation::Diagnostics::LoggingActivity>(return_value.get());
            }
            catch (python_exception)
            {
                py::write_unraisable_and_throw();
            }
        }
    };

    static PyObject* _guid_ImplementsILoggingTarget(PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::guid_of<winrt::Windows::Foundation::Diagnostics::ILoggingTarget>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _make_ImplementsILoggingTarget(PyObject* /*unused*/, PyObject* args) noexcept
    {
        try
        {
            PyObject* py_obj;
            winrt::impl::inspectable_abi* runtime_class;

            if (!PyArg_ParseTuple(args, "On", &py_obj, &runtime_class))
            {
                return nullptr;
            }

            auto iface{std::make_unique<ImplementsILoggingTarget>(py_obj, runtime_class)};

            return PyLong_FromVoidPtr(iface.release());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef methods_ImplementsILoggingTarget[] = {
        { "_guid_", reinterpret_cast<PyCFunction>(_guid_ImplementsILoggingTarget), METH_NOARGS | METH_STATIC, nullptr },
        { "_make_", reinterpret_cast<PyCFunction>(_make_ImplementsILoggingTarget), METH_VARARGS | METH_STATIC, nullptr },
        { }
    };

    static PyType_Slot type_slots_ImplementsILoggingTarget[] = {
        { Py_tp_methods, reinterpret_cast<void*>(methods_ImplementsILoggingTarget) },
        { }
    };

    static PyType_Spec type_spec_ImplementsILoggingTarget = {
        "winrt._winrt_windows_foundation_diagnostics.ImplementsILoggingTarget",
        0,
        0,
        Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,
        type_slots_ImplementsILoggingTarget};

    // ----- Windows.Foundation.Diagnostics Initialization --------------------

    PyDoc_STRVAR(module_doc, "Windows.Foundation.Diagnostics");

    static PyModuleDef module_def = {
        PyModuleDef_HEAD_INIT,
        "_winrt_windows_foundation_diagnostics",
        module_doc,
        0,
        nullptr,
        nullptr,
        nullptr,
        nullptr,
        nullptr};
} // py::cpp::Windows::Foundation::Diagnostics

PyMODINIT_FUNC PyInit__winrt_windows_foundation_diagnostics(void) noexcept
{
    using namespace py::cpp::Windows::Foundation::Diagnostics;

    if (py::import_winrt_runtime() == -1)
    {
        return nullptr;
    }

    py::pyobj_handle module{PyModule_Create(&module_def)};

    if (!module)
    {
        return nullptr;
    }

    auto object_type = py::get_object_type();
    if (!object_type)
    {
        return nullptr;
    }

    py::pyobj_handle object_bases{PyTuple_Pack(1, object_type)};

    if (!object_bases)
    {
        return nullptr;
    }

    py::pyobj_handle type_AsyncCausalityTracer_Static{PyType_FromSpec(&type_spec_AsyncCausalityTracer_Static)};
    if (!type_AsyncCausalityTracer_Static)
    {
        return nullptr;
    }

    py::pytype_handle AsyncCausalityTracer_type{py::register_python_type(module.get(), &type_spec_AsyncCausalityTracer, object_bases.get(), reinterpret_cast<PyTypeObject*>(type_AsyncCausalityTracer_Static.get()))};
    if (!AsyncCausalityTracer_type)
    {
        return nullptr;
    }

    py::pyobj_handle type_ErrorDetails_Static{PyType_FromSpec(&type_spec_ErrorDetails_Static)};
    if (!type_ErrorDetails_Static)
    {
        return nullptr;
    }

    py::pytype_handle ErrorDetails_type{py::register_python_type(module.get(), &type_spec_ErrorDetails, object_bases.get(), reinterpret_cast<PyTypeObject*>(type_ErrorDetails_Static.get()))};
    if (!ErrorDetails_type)
    {
        return nullptr;
    }

    py::pytype_handle FileLoggingSession_type{py::register_python_type(module.get(), &type_spec_FileLoggingSession, object_bases.get(), nullptr)};
    if (!FileLoggingSession_type)
    {
        return nullptr;
    }

    py::pytype_handle LogFileGeneratedEventArgs_type{py::register_python_type(module.get(), &type_spec_LogFileGeneratedEventArgs, object_bases.get(), nullptr)};
    if (!LogFileGeneratedEventArgs_type)
    {
        return nullptr;
    }

    py::pytype_handle LoggingActivity_type{py::register_python_type(module.get(), &type_spec_LoggingActivity, object_bases.get(), nullptr)};
    if (!LoggingActivity_type)
    {
        return nullptr;
    }

    py::pytype_handle LoggingChannel_type{py::register_python_type(module.get(), &type_spec_LoggingChannel, object_bases.get(), nullptr)};
    if (!LoggingChannel_type)
    {
        return nullptr;
    }

    py::pytype_handle LoggingChannelOptions_type{py::register_python_type(module.get(), &type_spec_LoggingChannelOptions, object_bases.get(), nullptr)};
    if (!LoggingChannelOptions_type)
    {
        return nullptr;
    }

    py::pytype_handle LoggingFields_type{py::register_python_type(module.get(), &type_spec_LoggingFields, object_bases.get(), nullptr)};
    if (!LoggingFields_type)
    {
        return nullptr;
    }

    py::pytype_handle LoggingOptions_type{py::register_python_type(module.get(), &type_spec_LoggingOptions, object_bases.get(), nullptr)};
    if (!LoggingOptions_type)
    {
        return nullptr;
    }

    py::pytype_handle LoggingSession_type{py::register_python_type(module.get(), &type_spec_LoggingSession, object_bases.get(), nullptr)};
    if (!LoggingSession_type)
    {
        return nullptr;
    }

    py::pytype_handle RuntimeBrokerErrorSettings_type{py::register_python_type(module.get(), &type_spec_RuntimeBrokerErrorSettings, object_bases.get(), nullptr)};
    if (!RuntimeBrokerErrorSettings_type)
    {
        return nullptr;
    }

    py::pytype_handle TracingStatusChangedEventArgs_type{py::register_python_type(module.get(), &type_spec_TracingStatusChangedEventArgs, object_bases.get(), nullptr)};
    if (!TracingStatusChangedEventArgs_type)
    {
        return nullptr;
    }

    py::pytype_handle IErrorReportingSettings_type{py::register_python_type(module.get(), &type_spec_IErrorReportingSettings, object_bases.get(), nullptr)};
    if (!IErrorReportingSettings_type)
    {
        return nullptr;
    }

    py::pytype_handle ImplementsIErrorReportingSettings_type{reinterpret_cast<PyTypeObject*>(PyType_FromModuleAndSpec(module.get(), &type_spec_ImplementsIErrorReportingSettings, nullptr))};
    if (!ImplementsIErrorReportingSettings_type)
    {
        return nullptr;
    }

    if (PyModule_AddType(module.get(), ImplementsIErrorReportingSettings_type.get()) == -1)
    {
        return nullptr;
    }

    py::pytype_handle IFileLoggingSession_type{py::register_python_type(module.get(), &type_spec_IFileLoggingSession, object_bases.get(), nullptr)};
    if (!IFileLoggingSession_type)
    {
        return nullptr;
    }

    py::pytype_handle ImplementsIFileLoggingSession_type{reinterpret_cast<PyTypeObject*>(PyType_FromModuleAndSpec(module.get(), &type_spec_ImplementsIFileLoggingSession, nullptr))};
    if (!ImplementsIFileLoggingSession_type)
    {
        return nullptr;
    }

    if (PyModule_AddType(module.get(), ImplementsIFileLoggingSession_type.get()) == -1)
    {
        return nullptr;
    }

    py::pytype_handle ILoggingChannel_type{py::register_python_type(module.get(), &type_spec_ILoggingChannel, object_bases.get(), nullptr)};
    if (!ILoggingChannel_type)
    {
        return nullptr;
    }

    py::pytype_handle ImplementsILoggingChannel_type{reinterpret_cast<PyTypeObject*>(PyType_FromModuleAndSpec(module.get(), &type_spec_ImplementsILoggingChannel, nullptr))};
    if (!ImplementsILoggingChannel_type)
    {
        return nullptr;
    }

    if (PyModule_AddType(module.get(), ImplementsILoggingChannel_type.get()) == -1)
    {
        return nullptr;
    }

    py::pytype_handle ILoggingSession_type{py::register_python_type(module.get(), &type_spec_ILoggingSession, object_bases.get(), nullptr)};
    if (!ILoggingSession_type)
    {
        return nullptr;
    }

    py::pytype_handle ImplementsILoggingSession_type{reinterpret_cast<PyTypeObject*>(PyType_FromModuleAndSpec(module.get(), &type_spec_ImplementsILoggingSession, nullptr))};
    if (!ImplementsILoggingSession_type)
    {
        return nullptr;
    }

    if (PyModule_AddType(module.get(), ImplementsILoggingSession_type.get()) == -1)
    {
        return nullptr;
    }

    py::pytype_handle ILoggingTarget_type{py::register_python_type(module.get(), &type_spec_ILoggingTarget, object_bases.get(), nullptr)};
    if (!ILoggingTarget_type)
    {
        return nullptr;
    }

    py::pytype_handle ImplementsILoggingTarget_type{reinterpret_cast<PyTypeObject*>(PyType_FromModuleAndSpec(module.get(), &type_spec_ImplementsILoggingTarget, nullptr))};
    if (!ImplementsILoggingTarget_type)
    {
        return nullptr;
    }

    if (PyModule_AddType(module.get(), ImplementsILoggingTarget_type.get()) == -1)
    {
        return nullptr;
    }


    return module.detach();
}
