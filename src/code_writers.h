#pragma once

namespace pywinrt
{
    template<typename F>
    void write_snake_case(writer& w, std::string_view const& name, F case_func)
    {
        assert(name.size() > 0);

        for (std::string_view::size_type i = 0; i < name.size(); i++)
        {
            if (isupper(name[i]) && i > 0)
            {
                static const std::set<std::string_view> casing_exceptions
                    = {"UInt", "IPAddress"};

                auto sub = name.substr(i - 1);
                if (sub[0] != '_'
                    && std::none_of(
                        casing_exceptions.begin(),
                        casing_exceptions.end(),
                        [&sub](std::string_view v)
                        {
                            return sub.substr(0, v.length()) == v;
                        }))
                {
                    w.write('_');
                }
            }

            w.write(case_func(name[i]));
        }
    }

    void write_upper_snake_case(writer& w, std::string_view const& name)
    {
        write_snake_case(
            w,
            name,
            [](char c)
            {
                return static_cast<char>(::toupper(c));
            });
    }

    void write_lower_snake_case(writer& w, std::string_view const& name)
    {
        write_snake_case(
            w,
            name,
            [](char c)
            {
                return static_cast<char>(::tolower(c));
            });
    }

    /**
     * Writes a string as lower case.
     */
    void write_lower_case(writer& w, std::string_view const& ns)
    {
        for (auto c : ns)
        {
            w.write(static_cast<char>(::tolower(c)));
        }
    }

    /**
     * Writes a Python identifier name, avoiding Python keywords.
     *
     * If @p name is a Python keyword, a trailing underscore is added.
     *
     * https://docs.python.org/3/reference/lexical_analysis.html#keywords
     */
    void write_python_identifier(writer& w, std::string_view const& name)
    {
        auto identifier = w.write_temp("%", bind<write_lower_case>(name));

        w.write(identifier);

        std::vector<std::string> keywords{
            "and",      "as",       "assert", "async", "await",  "break",  "class",
            "continue", "def",      "del",    "elif",  "else",   "except", "finally",
            "for",      "from",     "global", "if",    "import", "in",     "is",
            "lambda",   "nonlocal", "not",    "or",    "pass",   "raise",  "return",
            "try",      "while",    "with",   "yield",
        };

        // add trailing underscore to avoid keyword clashes
        if (std::find(keywords.begin(), keywords.end(), identifier) != keywords.end())
        {
            w.write("_");
        }
    }

    /**
     * Converts @p name to lower_snake_case and adds a trailing underscore if
     * @p name is a Python keyword.
     */
    void write_lower_snake_case_python_identifier(
        writer& w, std::string_view const& name)
    {
        auto identifier = w.write_temp("%", bind<write_lower_snake_case>(name));

        w.write("%", bind<write_python_identifier>(identifier));
    }

    /**
     * Writes a namespace as a Python dotted package name.
     *
     * If any package name is a Python keyword, a trailing underscore is added.
     */
    void write_python_subpackage(writer& w, std::string_view const& ns)
    {
        auto segments = get_dotted_name_segments(ns);
        w.write("%", bind_list<write_python_identifier>(".", segments));
    }

    void write_license(writer& w, std::string_view comment_marker = "//")
    {
        w.write(
            "% WARNING: Please don't edit this file. It was generated by Python/WinRT v%\n\n",
            comment_marker,
            PYWINRT_VERSION_STRING);
    }

    /**
     * Writes a type name (without generic specifier).
     */
    void write_type_name(writer& w, TypeDef const& type)
    {
        w.write("@", type.TypeName());
    }

    /**
     * Writes a type name for inclusion in the list of `__all__` module members.
     *
     * Skips types that are not projected to Python.
     */
    void write_dunder_all_type_name_entry(writer& w, TypeDef const& type)
    {
        if (is_exclusive_to(type))
        {
            return;
        }

        if (is_customized_struct(type))
        {
            return;
        }

        w.write("\"@\",\n", type.TypeName());
    }

    /**
     * Writes the binary extension module name for the given namespace.
     *
     * Example: "Windows.Foundation" becomes "_winrt_windows_foundation".
     */
    void write_ns_module_name(writer& w, std::string_view const& ns)
    {
        auto segments = get_dotted_name_segments(ns);
        w.write("_winrt_%", bind_list<write_python_identifier>("_", segments));
    }

    void write_python_import_type(writer& w, TypeDef const& type)
    {
        if (is_exclusive_to(type))
        {
            return;
        }

        if (is_customized_struct(type))
        {
            return;
        }

        w.write(
            "@ = %.@\n",
            type.TypeName(),
            bind<write_ns_module_name>(type.TypeNamespace()),
            type.TypeName());

        if (implements_imap(type))
        {
            w.write("winrt.system._mixin_mutable_mapping(@)\n", type.TypeName());
        }
        else if (implements_imapview(type))
        {
            w.write("winrt.system._mixin_mapping(@)\n", type.TypeName());
        }
        else if (implements_ivector(type))
        {
            w.write("winrt.system._mixin_mutable_sequence(@)\n", type.TypeName());
        }
        else if (implements_ivectorview(type))
        {
            w.write("winrt.system._mixin_sequence(@)\n", type.TypeName());
        }
    }

    /**
     * Writes a Python import statement.
     */
    void write_python_import_namespace(writer& w, std::string_view const& ns)
    {
        w.write("import winrt.%\n", bind<write_python_subpackage>(ns));
    }

    void write_python_enum(writer& w, TypeDef const& type)
    {
        w.write(
            "\nclass %(enum.%):\n",
            type.TypeName(),
            is_flags_enum(type) ? "IntFlag" : "IntEnum");
        {
            writer::indent_guard g{w};

            for (auto&& field : type.FieldList())
            {
                if (auto constant = field.Constant())
                {
                    w.write(
                        "% = %\n",
                        bind<write_upper_snake_case>(field.Name()),
                        *constant);
                }
            }
        }
    }

    /**
     * Writes a CppWinRT include statement for a namespace.
     */
    void write_winrt_include(writer& w, std::string_view const& ns)
    {
        w.write("#include <winrt/%.h>\n", ns);
    }

    /**
     * Writes a Python include statement for a namespace.
     */
    void write_py_include(writer& w, std::string_view const& ns)
    {
        if (w.current_namespace != ns)
        {
            auto format = R"(
#if __has_include("py.%.h")
#include "py.%.h"
#endif
)";
            w.write(format, ns, ns);
        }
        else
        {
            w.write("#include \"py.%.h\"\n", ns);
        }
    }

    // All generated try/catch blocks go thru this function in order to have a single
    // place to change as we test the binary size of different approaches
    void write_try_catch(
        writer& w,
        std::function<void(writer&)> tryfunc,
        std::string_view exception_return_value = "nullptr")
    {
        w.write("try\n{\n");
        {
            writer::indent_guard g{w};
            tryfunc(w);
        }
        w.write(
            R"(}
catch (...)
{
    py::to_PyErr();
    return %;
}
)",
            exception_return_value);
    }

    void write_setter_try_catch(writer& w, std::function<void(writer&)> tryfunc)
    {
        w.write(R"(if (arg == nullptr)
{
    PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
    return -1;
}

)");
        write_try_catch(
            w,
            [&](writer& w)
            {
                tryfunc(w);
            },
            "-1");
    }

    void write_template_arg_name(writer& w, GenericParam const& param)
    {
        w.write(param.Name());
    }

    void write_template_arg(writer& w, GenericParam const& param)
    {
        w.write("typename %", bind<write_template_arg_name>(param));
    }

    void write_type_namespace(writer& w, TypeDef const& type)
    {
        auto segments = get_dotted_name_segments(type.TypeNamespace());
        w.write("%", bind_list("::", segments));
    }

    void write_pywrapper_type(writer& w, TypeDef const& type)
    {
        w.write("py::wrapper::%::@", bind<write_type_namespace>(type), type.TypeName());
    }

    void write_pyproj_type(writer& w, TypeDef const& type)
    {
        w.write("py::proj::%::@", bind<write_type_namespace>(type), type.TypeName());
    }

    void write_pyimpl_type(writer& w, TypeDef const& type)
    {
        w.write("py::impl::%::@", bind<write_type_namespace>(type), type.TypeName());
    }

    void write_python_wrapper_template_type(writer& w, TypeDef const& type)
    {
        if (is_ptype(type))
        {
            write_pyproj_type(w, type);
        }
        else
        {
            w.write("%", type);
        }
    }

    /**
     * Writes the type specialization for the py_type struct.
     */
    void write_py_type_specialization_struct(writer& w, TypeDef const& type)
    {
        if (is_exclusive_to(type))
        {
            return;
        }

        auto format = R"(
template<>
struct py_type<%>
{
    static constexpr const char* module_name = "winrt.%";
    static constexpr const char* type_name = "@";
};
)";
        w.write(
            format,
            bind<write_python_wrapper_template_type>(type),
            bind<write_python_subpackage>(type.TypeNamespace()),
            type.TypeName());
    }

    void write_python_wrapper_type(writer& w, TypeDef const& type)
    {
        switch (get_category(type))
        {
        case category::class_type:
            w.write("winrt_wrapper");
            break;
        case category::interface_type:
            if (is_ptype(type))
                w.write("winrt_pinterface_wrapper");
            else
                w.write("winrt_wrapper");
            break;
        case category::struct_type:
            w.write("winrt_struct_wrapper");
            break;
        }
    }

    void write_python_wrapper_alias(writer& w, TypeDef const& type)
    {
        if (is_exclusive_to(type))
        {
            return;
        }

        if (is_customized_struct(type))
        {
            return;
        }

        w.write(
            "using @ = py::%<%>;\n",
            type.TypeName(),
            bind<write_python_wrapper_type>(type),
            bind<write_python_wrapper_template_type>(type));
    }

    void write_type_base(writer& w, TypeDef const& type)
    {
        auto category = get_category(type);

        if (category == category::interface_type || category == category::class_type)
        {
            w.write("object_bases.get()");
        }
        else
        {
            w.write("nullptr");
        }
    }

    /**
     * Writes the type initialization for a binary extension Python type inside
     * the module init function.
     */
    void write_ns_module_init_python_type(writer& w, TypeDef const& type)
    {
        if (is_exclusive_to(type))
        {
            return;
        }

        if (is_customized_struct(type))
        {
            return;
        }

        std::string metaclass{"nullptr"};

        if (requires_metaclass(type))
        {
            w.write(
                "py::pyobj_handle type_%_Static{PyType_FromSpec(&type_spec_@_Static)};\n",
                type.TypeName(),
                type.TypeName());

            w.write("if (!type_%_Static)\n{\n", type.TypeName());
            {
                writer::indent_guard g{w};
                w.write("return nullptr;\n");
            }
            w.write("}\n\n");

            metaclass = w.write_temp(
                "reinterpret_cast<PyTypeObject*>(type_%_Static.get())",
                type.TypeName());
        }

        w.write(
            "if (py::register_python_type(module.get(), &type_spec_@, %, %) == -1)\n",
            type.TypeName(),
            bind<write_type_base>(type),
            metaclass);

        w.write("{\n");
        {
            writer::indent_guard g{w};

            w.write("return nullptr;\n");
        }
        w.write("}\n\n");
    }

    /**
     * Writes a struct field to hold a pointer to a pure Python type.
     */
    void write_ns_module_py_type_member(writer& w, TypeDef const& type)
    {
        if (is_exclusive_to(type))
        {
            return;
        }

        w.write("PyObject* type_@;\n", type.TypeName());
    }

    /**
     * Writes a struct field to hold a pointer to a binary extension Python type.
     */
    void write_ns_module_python_type_member(writer& w, TypeDef const& type)
    {
        if (is_exclusive_to(type))
        {
            return;
        }

        if (is_customized_struct(type))
        {
            return;
        }

        w.write("PyTypeObject* type_@;\n", type.TypeName());
    }

    /**
     * Writes the namespace module doc string definition.
     */
    void write_ns_module_doc_string(writer& w, std::string_view const& ns)
    {
        w.write("PyDoc_STRVAR(module_doc, \"@\");\n\n", ns);
    }

    /**
     * Writes the namespace module definition structure.
     */
    void write_ns_module_def_struct(writer& w, std::string_view const& ns)
    {
        auto format = R"(
static PyModuleDef module_def
    = {PyModuleDef_HEAD_INIT,
       "%",
       module_doc,
       0,
       nullptr,
       nullptr,
       nullptr,
       nullptr,
       nullptr};

)";

        w.write(format, bind<write_ns_module_name>(ns));
    }

    /**
     * Writes all namespace initialization members except for the public init function.
     */
    void write_namespace_initialization(
        writer& w, std::string_view const& ns, cache::namespace_members const& members)
    {
        w.write("\n// ----- % Initialization --------------------\n", ns);

        write_ns_module_doc_string(w, ns);
        write_ns_module_def_struct(w, ns);
    }

    /**
     * Writes the namespace module PyMODINIT_FUNC function delecaration.
     */
    void write_namespace_module_init_function(
        writer& w, std::string_view const& ns, cache::namespace_members const& members)
    {
        w.write(
            "\nPyMODINIT_FUNC PyInit_%(void) noexcept\n{\n",
            bind<write_ns_module_name>(ns));
        {
            writer::indent_guard g{w};

            auto segments = get_dotted_name_segments(ns);
            w.write("using namespace py::cpp::%;\n\n", bind_list("::", segments));

            w.write("if (py::import_winrt_runtime() == -1)\n{\n");
            {
                writer::indent_guard gg{w};

                w.write("return nullptr;\n");
            }
            w.write("}\n\n");

            w.write("py::pyobj_handle module{PyModule_Create(&module_def)};\n\n");

            w.write("if (!module)\n{\n");
            {
                writer::indent_guard gg{w};

                w.write("return nullptr;\n");
            }
            w.write("}\n\n");

            w.write("auto object_type = py::get_object_type();\n");
            w.write("if (!object_type)\n{\n");
            {
                writer::indent_guard gg{w};

                w.write("return nullptr;\n");
            }
            w.write("}\n\n");

            w.write("py::pyobj_handle object_bases{PyTuple_Pack(1, object_type)};\n\n");

            w.write("if (!object_bases)\n{\n");
            {
                writer::indent_guard gg{w};

                w.write("return nullptr;\n");
            }
            w.write("}\n\n");

            settings.filter.bind_each<write_ns_module_init_python_type>(
                members.classes)(w);
            settings.filter.bind_each<write_ns_module_init_python_type>(
                members.interfaces)(w);
            settings.filter.bind_each<write_ns_module_init_python_type>(
                members.structs)(w);
            w.write("\nreturn module.detach();\n");
        }
        w.write("}\n");
    }

    void write_dealloc_function(writer& w, TypeDef const& type)
    {
        auto category = get_category(type);
        if (category == category::class_type && is_static_class(type))
        {
            return;
        }

        w.write(
            "\nstatic void _dealloc_@(%* self) noexcept\n{\n",
            type.TypeName(),
            bind<write_pywrapper_type>(type));

        {
            writer::indent_guard g{w};

            w.write("auto tp = Py_TYPE(self);\n");
            w.write("std::destroy_at(&self->obj);\n");

            if (is_ptype(type))
            {
                w.write("std::destroy_at(&self->impl);\n");
            }

            w.write("tp->tp_free(self);\n");
            w.write("Py_DECREF(tp);\n");
        }
        w.write("}\n");
    }

    void write_method_self_param(writer& w, TypeDef const& type, bool is_static)
    {
        if (is_static)
        {
            w.write("PyObject* /*unused*/");
        }
        else
        {
            w.write("%* self", bind<write_pywrapper_type>(type));
        }
    }

    void write_param_name(writer& w, method_signature::param_t param)
    {
        w.register_type_namespace(param.second->Type());
        w.write("param%", param.first.Sequence() - 1);
    }

    void write_out_param_init(writer& w, method_signature::param_t const& param)
    {
        call(
            get_type_semantics(param.second->Type()),
            [&](TypeDef const& type)
            {
                switch (get_category(type))
                {
                case category::class_type:
                case category::interface_type:
                case category::delegate_type:
                    w.write("nullptr");
                    break;
                }
            },
            [&](generic_type_instance const&)
            {
                w.write("nullptr");
            },
            [](auto)
            {
            });
    }

    void write_convert_to_params(writer& w, MethodDef const& method, int sequence)
    {
        switch (get_argument_convention(method))
        {
        case argument_convention::single_arg:
            w.write("arg");
            break;
        case argument_convention::variable_args:
            w.write("args, %", sequence);
            break;
        default:
            throw_invalid("write_convert_to_params");
        }
    }

    void write_method_param_definition(
        writer& w, MethodDef const& method, method_signature::param_t const& param)
    {
        auto sequence = param.first.Sequence() - 1;
        auto category = get_param_category(param);

        switch (category)
        {
        case param_category::in:
            w.write(
                "auto % = py::convert_to<%>(%);\n",
                bind<write_param_name>(param),
                param.second->Type(),
                bind<write_convert_to_params>(method, sequence));
            break;
        case param_category::out:
            w.write(
                "% % { % };\n",
                param.second->Type(),
                bind<write_param_name>(param),
                bind<write_out_param_init>(param));
            break;
        case param_category::pass_array:
        case param_category::fill_array:
            w.write(
                "auto % = py::convert_to<py::pybuf_view<%, %>>(%);\n",
                bind<write_param_name>(param),
                param.second->Type(),
                category == param_category::fill_array ? "true" : "false",
                bind<write_convert_to_params>(method, sequence));
            break;
        case param_category::receive_array:
            w.write(
                "winrt::com_array<%> % { };\n",
                param.second->Type(),
                bind<write_param_name>(param));
            break;
        default:
            throw_invalid("invalid param_category");
        }
    }

    void write_method_invoke_context(
        writer& w, TypeDef const& type, MethodDef const& method)
    {
        if (is_ptype(type))
        {
            w.write("_obj.");
        }
        else if (method && (is_static(method) || is_constructor(method)))
        {
            w.write("%::", type);
        }
        else
        {
            // HACK: work around https://github.com/microsoft/cppwinrt/issues/1287
            // so far, this is the only case in the entire Windows SDK where
            // a property is entirely replaced with one of the same name
            if (type.TypeNamespace() == "Windows.UI.Xaml.Controls.Maps"
                && type.TypeName() == "MapControl" && method.Name() == "get_Style")
            {
                w.write(
                    "static_cast<winrt::Windows::UI::Xaml::Controls::Maps::IMapControl>(self->obj).");
            }
            else
            {
                w.write("self->obj.");
            }
        }
    }

    void write_method_cpp_name(writer& w, MethodDef const& method)
    {
        auto name = method.Name();

        if (method.SpecialName())
        {
            w.write(name.substr(name.find('_') + 1));
        }
        else
        {
            w.write(name);
        }
    }

    void write_get_param(writer& w, std::string const& paramName)
    {
        w.write("%.get()", paramName);
    }

    void write_detach_param(writer& w, std::string const& paramName)
    {
        w.write("%.detach()", paramName);
    }

    void write_py_tuple_pack(writer& w, std::vector<std::string> const& params)
    {
        w.write(
            "PyTuple_Pack(%, %)",
            static_cast<int>(params.size()),
            bind_list<write_get_param>(", ", params));
    }

    void write_method_body_contents(
        writer& w,
        TypeDef const& type,
        MethodDef const& method,
        bool put_property_method = false)
    {
        assert(!is_constructor(method));

        auto write_void_return
            = [](writer& w, MethodDef const& method, bool set_property_method)
        {
            // instance property set methods are projected as Python setters,
            // thus return 0 to indicate success
            if (set_property_method)
            {
                w.write("return 0;\n");
            }
            else
            {
                w.write("Py_RETURN_NONE;\n");
            }
        };

        method_signature signature{method};

        // convert in params from Python -> C++
        for (auto&& param : signature.params())
        {
            write_method_param_definition(w, method, param);
        }
        if (signature.params().size() > 0)
        {
            w.write("\n");
        }

        // Invoke member - simplified code path for methods w/ no out params
        if (count_py_out_param(signature.params()) == 0)
        {
            if (signature.return_signature())
            {
                w.register_type_namespace(signature.return_signature().Type());

                w.write(
                    "return py::convert(%%(%));\n",
                    bind<write_method_invoke_context>(type, method),
                    bind<write_method_cpp_name>(method),
                    bind_list<write_param_name>(", ", signature.params()));
            }
            else
            {
                w.write(
                    "%%(%);\n",
                    bind<write_method_invoke_context>(type, method),
                    bind<write_method_cpp_name>(method),
                    bind_list<write_param_name>(", ", signature.params()));

                write_void_return(w, method, put_property_method);
            }

            return;
        }

        // Invoke member - code path for methods w/ out params
        if (signature.return_signature())
        {
            w.register_type_namespace(signature.return_signature().Type());
            w.write("auto return_value = ");
        }
        w.write(
            "%%(%);\n",
            bind<write_method_invoke_context>(type, method),
            bind<write_method_cpp_name>(method),
            bind_list<write_param_name>(", ", signature.params()));

        w.write("\n");

        // Convert return values and out parameters from C++ -> Python
        std::vector<std::string> return_values{};
        if (signature.return_signature() || is_constructor(method))
        {
            auto format
                = R"(py::pyobj_handle out_return_value{ py::convert(return_value) };
if (!out_return_value)
{
    return nullptr;
}
)";
            w.write(format);
            return_values.push_back("out_return_value");
        }

        for (auto&& param : signature.params())
        {
            if (!is_py_out_param(param))
            {
                continue;
            }

            auto sequence = param.first.Sequence() - 1;
            auto out_param = w.write_temp("out%", sequence);

            auto format = R"(py::pyobj_handle %{ py::convert(param%) };
if (!%)
{
    return nullptr;
}
)";
            w.write(format, out_param, sequence, out_param);
            return_values.push_back(out_param);
        }

        // Return Python projected return/out params
        if (return_values.size() == 0)
        {
            write_void_return(w, method, put_property_method);
        }
        else if (return_values.size() == 1)
        {
            w.write("return %;\n", bind<write_detach_param>(return_values[0]));
        }
        else
        {
            w.write("return %;\n", bind<write_py_tuple_pack>(return_values));
        }
    }

    void write_class_new_function(writer& w, TypeDef const& type)
    {
        auto constructors = get_public_constructors(type);

        if (is_static_class(type) || constructors.size() == 0)
        {
            w.write(
                "\nstatic PyObject* _new_%(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept\n{\n",
                type.TypeName());
        }
        else
        {
            w.write(
                "\nstatic PyObject* _new_%(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept\n{\n",
                type.TypeName());
        }

        {
            writer::indent_guard g{w};

            if (is_static_class(type) || constructors.size() == 0)
            {
                w.write(
                    "static_assert(py::py_type<%>::type_name);\n",
                    bind<write_python_wrapper_template_type>(type));
                w.write(
                    "py::set_invalid_activation_error(py::py_type<%>::type_name);\n",
                    bind<write_python_wrapper_template_type>(type));
                w.write("return nullptr;\n");
            }
            else
            {
                w.write(R"(if (kwds != nullptr)
{
    py::set_invalid_kwd_args_error();
    return nullptr;
}

auto arg_count = PyTuple_Size(args);
)");

                separator s{w, "else "};
                for (auto&& ctor : constructors)
                {
                    method_signature signature{ctor};

                    s();
                    w.write(
                        "if (arg_count == %)\n{\n",
                        count_py_in_param(signature.params()));
                    {
                        writer::indent_guard g2{w};
                        write_try_catch(
                            w,
                            [&](writer& w)
                            {
                                for (auto&& param : signature.params())
                                {
                                    write_method_param_definition(w, ctor, param);
                                }

                                if (signature.params().size() > 0)
                                {
                                    w.write("\n");
                                }

                                w.write(
                                    "% instance{ % };\nreturn py::wrap(instance, type);\n",
                                    type,
                                    bind_list<write_param_name>(
                                        ", ", signature.params()));
                            });
                    }
                    w.write("}\n");
                }

                w.write(R"(else
{
    py::set_invalid_arg_count_error(arg_count);
    return nullptr;
}
)");
            }
        }
        w.write("}\n");
    }

    void write_new_function(writer& w, TypeDef const& type)
    {
        auto category = get_category(type);

        if (category == category::interface_type)
        {
            auto format = R"(
static PyObject* _new_@(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
{
    static_assert(py::py_type<%>::type_name);
    py::set_invalid_activation_error(py::py_type<%>::type_name);
    return nullptr;
}
)";
            w.write(
                format,
                type.TypeName(),
                bind<write_python_wrapper_template_type>(type),
                bind<write_python_wrapper_template_type>(type));
        }
        else if (category == category::class_type)
        {
            write_class_new_function(w, type);
        }
    }

    void write_method_overloads(
        writer& w, TypeDef const& type, std::string_view method_name)
    {
        w.write("auto arg_count = PyTuple_Size(args);\n\n");
        separator s{w, "else "};

        enumerate_methods(
            w,
            type,
            [&](auto const& method)
            {
                if (method.Name() == method_name)
                {
                    method_signature signature{method};

                    s();
                    w.write(
                        "if (arg_count == %)\n{\n",
                        count_py_in_param(signature.params()));
                    {
                        writer::indent_guard g{w};

                        w.write(
                            "if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L\"%.%\", L\"%\", %))\n{\n",
                            method.Parent().TypeNamespace(),
                            method.Parent().TypeName(),
                            method.Name(),
                            count_in_param(signature.params()));
                        {
                            writer::indent_guard gg{w};
                            w.write(
                                "py::set_arg_count_version_error(%);\n",
                                count_in_param(signature.params()));
                            w.write("return nullptr;\n");
                        }
                        w.write("}\n\n");

                        write_try_catch(
                            w,
                            [&](writer& w)
                            {
                                write_method_body_contents(w, type, method);
                            });
                    }
                    w.write("}\n");
                }
            });

        w.write(R"(else
{
    py::set_invalid_arg_count_error(arg_count);
    return nullptr;
}
)");
    }

    /**
     * Writes the Python descriptor (PyGetSetDef) getter implementation for a winrt
     * property getter.
     * @param w The writer.
     * @param t The type that contains the property.
     * @param method The getter method metadata.
     * @param prop_name The name of the winrt property.
     */
    void write_get_property_function(
        writer& w,
        TypeDef const& type,
        MethodDef const& method,
        std::string_view const& prop_name)
    {
        w.write(
            "\nstatic PyObject* @_%(%, void* /*unused*/) noexcept\n{\n",
            type.TypeName(),
            method.Name(),
            bind<write_method_self_param>(type, is_static(method)));
        {
            writer::indent_guard g{w};

            w.write(
                "if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L\"%.%\", L\"%\"))\n{\n",
                method.Parent().TypeNamespace(),
                method.Parent().TypeName(),
                prop_name);
            {
                writer::indent_guard gg{w};
                w.write(
                    "PyErr_SetString(PyExc_AttributeError, \"property is not available in this version of Windows\");\n");
                w.write("return nullptr;\n");
            }
            w.write("}\n\n");

            if (is_ptype(type))
            {
                w.write("return self->impl->%();\n", method.Name());
            }
            else
            {
                write_try_catch(
                    w,
                    [&](writer& w)
                    {
                        write_method_body_contents(w, type, method);
                    });
            }
        }
        w.write("}\n");
    }

    /**
     * Writes the Python descriptor (PyGetSetDef) setter implementation for a winrt
     * property setter.
     * @param w The writer.
     * @param t The type that contains the property.
     * @param method The setter method metadata.
     * @param prop_name The name of the winrt property.
     */
    void write_put_property_function(
        writer& w,
        TypeDef const& type,
        MethodDef const& method,
        std::string_view const& prop_name)
    {
        if (!method)
            return;

        w.write(
            "\nstatic int @_%(%, PyObject* arg, void* /*unused*/) noexcept\n{\n",
            type.TypeName(),
            method.Name(),
            bind<write_method_self_param>(type, is_static(method)));
        {
            writer::indent_guard g{w};

            w.write(
                "if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L\"%.%\", L\"%\"))\n{\n",
                method.Parent().TypeNamespace(),
                method.Parent().TypeName(),
                prop_name);
            {
                writer::indent_guard gg{w};
                w.write(
                    "PyErr_SetString(PyExc_AttributeError, \"property is not available in this version of Windows\");\n");

                w.write("return -1;\n");
            }
            w.write("}\n\n");

            if (is_ptype(type))
            {
                w.write("return self->impl->%(arg);\n", method.Name());
            }
            else
            {
                write_setter_try_catch(
                    w,
                    [&](writer& w)
                    {
                        write_method_body_contents(w, type, method, true);
                    });
            }
        }
        w.write("}\n");
    }

    /**
     * Writes the Python add/remove method implementation for a winrt event.
     * @param w The writer.
     * @param t The type that contains the event.
     * @param method The add or remove method metadata.
     * @param prop_name The name of the winrt event.
     */
    void write_event_function(
        writer& w,
        TypeDef const& type,
        MethodDef const& method,
        std::string_view const& event_name)
    {
        w.write(
            "\nstatic PyObject* @_%(%, PyObject* arg) noexcept\n{\n",
            type.TypeName(),
            method.Name(),
            bind<write_method_self_param>(type, is_static(method)));
        {
            writer::indent_guard g{w};

            w.write(
                "if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L\"%.%\", L\"%\"))\n{\n",
                method.Parent().TypeNamespace(),
                method.Parent().TypeName(),
                event_name);
            {
                writer::indent_guard gg{w};
                w.write(
                    "PyErr_SetString(PyExc_AttributeError, \"event is not available in this version of Windows\");\n");
                w.write("return nullptr;\n");
            }
            w.write("}\n\n");

            if (is_ptype(type))
            {
                w.write("return self->impl->%(arg);\n", method.Name());
            }
            else
            {
                write_try_catch(
                    w,
                    [&](writer& w)
                    {
                        write_method_body_contents(w, type, method);
                    });
            }
        }
        w.write("}\n");
    }

    void write_assign_array_method(writer& w, TypeDef const& type)
    {

        w.write(
            "\nstatic PyObject* _assign_array_@(PyObject* /*unused*/, PyObject* arg) noexcept\n{\n",
            type.TypeName());
        {
            writer::indent_guard g{w};
            w.write("auto array = std::make_unique<py::ComArray<%>>();\n", type);
            w.write("if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))\n{\n");
            {
                writer::indent_guard gg{w};
                w.write("return nullptr;\n");
            }
            w.write("}\n");
            w.write("Py_RETURN_NONE;\n");
        }
        w.write("}\n");
    }

    /**
     * Writes the body of the tp_iter slot for the __iter__ special method.
     */
    void write_dunder_iter_body(writer& w, TypeDef const& type)
    {
        if (implements_mapping(type))
        {
            // Mappings are a special case since WinRT iterates `KeyValuePair`s
            // while Python iterates only keys. So we have to wrap the iterator
            // in a helper class to get only the keys.
            write_try_catch(
                w,
                [&](writer& w)
                {
                    w.write(
                        "py::pyobj_handle iter{py::convert(%First())};\n",
                        bind<write_method_invoke_context>(type, MethodDef{}));

                    w.write("\nif (!iter)\n{\n");
                    {
                        writer::indent_guard g{w};
                        w.write("return nullptr;\n");
                    }
                    w.write("}\n\n");

                    w.write("return py::wrap_mapping_iter(iter.get());\n");
                });
        }
        else if (implements_iiterable(type))
        {
            write_try_catch(
                w,
                [&](writer& w)
                {
                    w.write(
                        "return py::convert(%First());\n",
                        bind<write_method_invoke_context>(type, MethodDef{}));
                });
        }
        else if (implements_iiterator(type))
        {
            w.write(
                "return reinterpret_cast<PyObject*>(%);\n",
                is_ptype(type) ? "this" : "self");
        }
        else
        {
            assert(false);
        }
    }

    void write_dunder_iter_next_body(writer& w, TypeDef const& type)
    {
        write_try_catch(
            w,
            [&](writer& w)
            {
                auto format = R"(if (%HasCurrent())
{
    auto cur = %Current();
    %MoveNext();
    return py::convert(cur);
}
else
{
    return nullptr;
})";
                w.write(
                    format,
                    bind<write_method_invoke_context>(type, MethodDef{}),
                    bind<write_method_invoke_context>(type, MethodDef{}),
                    bind<write_method_invoke_context>(type, MethodDef{}));
            },
            "nullptr");
    }

    void write_seq_length_body(writer& w, TypeDef const& type)
    {
        write_try_catch(
            w,
            [&](writer& w)
            {
                w.write(
                    "return static_cast<Py_ssize_t>(%Size());\n",
                    bind<write_method_invoke_context>(type, MethodDef{}));
            },
            "-1");
    }

    void write_seq_item_body(writer& w, TypeDef const& type)
    {
        write_try_catch(
            w,
            [&](writer& w)
            {
                w.write(
                    "return py::convert(%GetAt(static_cast<uint32_t>(i)));\n",
                    bind<write_method_invoke_context>(type, MethodDef{}));
            });
    }

    void write_seq_subscript_body(writer& w, TypeDef const& type)
    {
        std::string collection_type{};
        enumerate_methods(
            w,
            type,
            [&](MethodDef const& method)
            {
                if (method.Name() == "GetAt")
                {
                    collection_type
                        = w.write_temp("%", method.Signature().ReturnType().Type());
                }
            });

        auto seq_item_invoke
            = is_ptype(type) ? "seq_item(i)"
                             : w.write_temp("_seq_item_@(self, i)", type.TypeName());

        auto format = R"(if (PyIndex_Check(slice))
{
    pyobj_handle index{PyNumber_Index(slice)};

    if (!index)
    {
        return nullptr;
    }

    auto i = PyNumber_AsSsize_t(index.get(), PyExc_IndexError);

    if (i == -1 && PyErr_Occurred())
    {
        return nullptr;
    }

    return %;
}

if (!PySlice_Check(slice))
{
    PyErr_Format(
        PyExc_TypeError,
        "indicies must be integers, not '^%s'",
        Py_TYPE(slice)->tp_name);
}

Py_ssize_t start, stop, step, length;

if (PySlice_GetIndicesEx(
        slice, %Size(), &start, &stop, &step, &length)
    < 0)
{
    return nullptr;
}

if (step != 1)
{
    PyErr_SetString(
        PyExc_NotImplementedError,
        "slices with step other than 1 are not implemented");
    return nullptr;
}

winrt::com_array<%> items(static_cast<uint32_t>(length), empty_instance<%>::get());

auto count = %GetMany(static_cast<uint32_t>(start), items);

if (count != static_cast<uint32_t>(length))
{
    PyErr_Format(
        PyExc_RuntimeError,
        "returned count ^%d did not match requested length ^%zd",
        count,
        length);
    return nullptr;
}

return convert(items);)";

        write_try_catch(
            w,
            [&](writer& w)
            {
                w.write(
                    format,
                    seq_item_invoke,
                    bind<write_method_invoke_context>(type, MethodDef{}),
                    collection_type,
                    collection_type,
                    bind<write_method_invoke_context>(type, MethodDef{}));
            });
    }

    void write_seq_assign_body(writer& w, TypeDef const& type)
    {
        std::string collection_type{};
        enumerate_methods(
            w,
            type,
            [&](MethodDef const& method)
            {
                if (method.Name() == "GetAt")
                {
                    collection_type
                        = w.write_temp("%", method.Signature().ReturnType().Type());
                }
            });

        write_try_catch(
            w,
            [&](writer& w)
            {
                w.write(
                    R"(if (value == nullptr) { %RemoveAt(static_cast<uint32_t>(i)); }
else { %SetAt(static_cast<uint32_t>(i), py::convert_to<%>(value)); }
return 0;
)",
                    bind<write_method_invoke_context>(type, MethodDef{}),
                    bind<write_method_invoke_context>(type, MethodDef{}),
                    collection_type);
            },
            "-1");
    }

    void write_map_contains_body(writer& w, TypeDef const& type)
    {
        std::string key_type{};
        enumerate_methods(
            w,
            type,
            [&](MethodDef const& method)
            {
                if (method.Name() == "HasKey")
                {
                    method_signature signature{method};
                    key_type
                        = w.write_temp("%", signature.params().at(0).second->Type());
                }
            });

        write_try_catch(
            w,
            [&](writer& w)
            {
                w.write(
                    "return static_cast<int>(%HasKey(py::convert_to<%>(key)));\n",
                    bind<write_method_invoke_context>(type, MethodDef{}),
                    key_type);
            },
            "-1");
    }

    void write_map_length_body(writer& w, TypeDef const& type)
    {
        write_try_catch(
            w,
            [&](writer& w)
            {
                w.write(
                    "return static_cast<Py_ssize_t>(%Size());\n",
                    bind<write_method_invoke_context>(type, MethodDef{}));
            },
            "-1");
    }

    /**
     * Writes the body of the mp_subscript slot for the __getitem__ special method.
     */
    void write_map_subscript_body(writer& w, TypeDef const& type)
    {
        std::string key_type{};
        enumerate_methods(
            w,
            type,
            [&](MethodDef const& method)
            {
                if (method.Name() == "Lookup")
                {
                    method_signature signature{method};
                    key_type
                        = w.write_temp("%", signature.params().at(0).second->Type());
                }
            });

        write_try_catch(
            w,
            [&](writer& w)
            {
                // we use the CppWinRT extension TryLookup so we can raise
                // KeyError on failure.
                w.write(
                    "auto value = %TryLookup(py::convert_to<%>(key));\n",
                    bind<write_method_invoke_context>(type, MethodDef{}),
                    key_type);

                w.write("\nif (!value) {\n");
                {
                    writer::indent_guard g{w};

                    w.write("PyErr_SetObject(PyExc_KeyError, key);\n");
                    w.write("return nullptr;\n");
                }
                w.write("}\n\n");

                w.write("return py::convert(value);\n");
            });
    }

    /**
     * Writes the body of the mp_ass_subscript slot for the __setitem__ and __delitem__
     * special methods.
     */
    void write_map_assign_body(writer& w, TypeDef const& type)
    {
        std::string key_type, value_type{};
        enumerate_methods(
            w,
            type,
            [&](MethodDef const& method)
            {
                if (method.Name() == "Lookup")
                {
                    method_signature signature{method};
                    key_type
                        = w.write_temp("%", signature.params().at(0).second->Type());
                    value_type = w.write_temp("%", signature.return_signature().Type());
                }
            });

        write_try_catch(
            w,
            [&](writer& w)
            {
                w.write("auto _key = py::convert_to<%>(key);\n", key_type);

                // null value indicates this is del rather than assign
                w.write("\nif (value == nullptr) {\n");
                {
                    writer::indent_guard g{w};

                    // we use the CppWinRT extension TryRemove so we can raise
                    // KeyError on failure.
                    w.write(
                        "if (!%TryRemove(_key)) {\n",
                        bind<write_method_invoke_context>(type, MethodDef{}));
                    {
                        writer::indent_guard gg{w};

                        w.write("PyErr_SetObject(PyExc_KeyError, key);\n");
                        w.write("return -1;\n");
                    }
                    w.write("}\n\n");
                    w.write("return 0;\n");
                }
                w.write("}\n\n");

                w.write(
                    "%Insert(_key, py::convert_to<%>(value));\n",
                    bind<write_method_invoke_context>(type, MethodDef{}),
                    value_type);

                w.write("\nreturn 0;\n");
            },
            "-1");
    }

    void write_method_functions(writer& w, TypeDef const& type)
    {
        // create a map of methods to determine overloads + ensure all overloads match
        // instance/static
        std::map<std::string_view, bool> method_map{};
        enumerate_methods(
            w,
            type,
            [&](auto const& method)
            {
                assert(
                    contains(method_map, method.Name())
                        ? method_map[method.Name()] == is_static(method)
                        : true);
                method_map[method.Name()] = is_static(method);
            });

        for (auto&& [method_name, method_is_static] : method_map)
        {
            w.write(
                "\nstatic PyObject* @_%(%, PyObject* args) noexcept\n{\n",
                type.TypeName(),
                method_name,
                bind<write_method_self_param>(type, method_is_static));
            {
                writer::indent_guard g{w};

                if (is_ptype(type))
                {
                    w.write("return self->impl->%(args);\n", method_name);
                }
                else
                {
                    write_method_overloads(w, type, method_name);
                }
            }
            w.write("}\n");
        }

        enumerate_properties(
            w,
            type,
            [&](auto const& prop)
            {
                auto&& [get_method, put_method] = get_property_methods(prop);
                write_get_property_function(w, type, get_method, prop.Name());
                write_put_property_function(w, type, put_method, prop.Name());
            });

        enumerate_events(
            w,
            type,
            [&](auto const& evt)
            {
                auto&& [add_method, remove_method] = get_event_methods(evt);
                write_event_function(w, type, add_method, evt.Name());
                write_event_function(w, type, remove_method, evt.Name());
            });

        if (!(is_ptype(type) || is_static_class(type)))
        {
            write_assign_array_method(w, type);
        }

        if (is_iunknown(type) && !(is_ptype(type) || is_static_class(type)))
        {
            w.write(
                "\nstatic PyObject* _from_@(PyObject* /*unused*/, PyObject* arg) noexcept\n{\n",
                type.TypeName());
            {
                writer::indent_guard g{w};
                write_try_catch(
                    w,
                    [&](writer& w)
                    {
                        auto format
                            = "auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);\nreturn "
                              "py::convert(return_value.as<%>());\n";
                        w.write(format, type);
                    });
            }
            w.write("}\n");
        }

        if (implements_iclosable(type))
        {
            w.write(
                "\nstatic PyObject* _enter_@(%* self, PyObject* /*unused*/) noexcept\n",
                type.TypeName(),
                bind<write_pywrapper_type>(type));
            w.write("{\n");
            {
                writer::indent_guard g{w};
                w.write("return Py_NewRef(self);\n");
            }
            w.write("}\n");

            w.write(
                "\nstatic PyObject* _exit_@(%* self, PyObject* /*unused*/) noexcept\n",
                type.TypeName(),
                bind<write_pywrapper_type>(type));
            w.write("{\n");
            {
                writer::indent_guard g{w};
                write_try_catch(
                    w,
                    [](auto& w)
                    {
                        w.write("self->obj.Close();\n");
                        w.write("Py_RETURN_FALSE;\n");
                    });
            }
            w.write("}\n");
        }

        if (implements_ibuffer(type) || implements_imemorybufferreference(type))
        {
            w.write(
                "\nstatic int _get_buffer_@(%* self, Py_buffer* view, int flags) noexcept\n{\n",
                type.TypeName(),
                bind<write_pywrapper_type>(type));
            {
                writer::indent_guard g{w};
                w.write("try\n");
                w.write("{\n");
                {
                    writer::indent_guard gg{w};
                    w.write(
                        "return PyBuffer_FillInfo(view, reinterpret_cast<PyObject*>(self), "
                        "reinterpret_cast<void*>(self->obj.data()), static_cast<Py_ssize_t>(self->obj.@()), 0, flags);\n",
                        implements_ibuffer(type) ? "Length" : "Capacity");
                }
                w.write("}\n");
                w.write("catch (...)\n");
                w.write("{\n");
                {
                    writer::indent_guard gg{w};
                    w.write("view->obj = nullptr;\n");
                    // TODO: attach C++ exception info to Python exception
                    w.write("PyErr_SetNone(PyExc_BufferError);\n");
                    w.write("return -1;\n");
                }
                w.write("}\n");
            }
            w.write("}\n");
        }

        if (implements_istringable(type))
        {
            w.write(
                "\nstatic PyObject* _str_@(%* self) noexcept\n{\n",
                type.TypeName(),
                bind<write_pywrapper_type>(type));
            {
                writer::indent_guard g{w};
                write_try_catch(
                    w,
                    [](auto& w)
                    {
                        w.write("return py::convert(self->obj.ToString());\n");
                    });
            }
            w.write("}\n");
        }

        auto write_ptype_body = [&](std::string_view ptype_func_call,
                                    std::function<void(writer&)> ctype_func)
        {
            writer::indent_guard g{w};

            if (is_ptype(type))
            {
                w.write("return self->impl->%;\n", ptype_func_call);
            }
            else
            {
                ctype_func(w);
            }
        };

        if (implements_iasync(type))
        {
            w.write(
                "\nstatic PyObject* _await_@(%* self) noexcept\n{\n",
                type.TypeName(),
                bind<write_pywrapper_type>(type));
            {
                write_ptype_body(
                    "dunder_await()",
                    [&](auto& w)
                    {
                        w.write("return py::dunder_await(self->obj);\n");
                    });
            }
            w.write("}\n");
        }

        if (implements_iiterable(type) || implements_iiterator(type))
        {
            w.write(
                "\nstatic PyObject* _iterator_@(%* self) noexcept\n{\n",
                type.TypeName(),
                bind<write_pywrapper_type>(type));
            {
                write_ptype_body(
                    "dunder_iter()",
                    [&](auto& w)
                    {
                        write_dunder_iter_body(w, type);
                    });
            }
            w.write("}\n");
        }

        if (implements_iiterator(type))
        {
            w.write(
                "\nstatic PyObject* _iterator_next_@(%* self) noexcept\n{\n",
                type.TypeName(),
                bind<write_pywrapper_type>(type));
            {
                write_ptype_body(
                    "dunder_iternext()",
                    [&](auto& w)
                    {
                        write_dunder_iter_next_body(w, type);
                    });
            }
            w.write("}\n");
        }

        if (implements_sequence(type))
        {
            w.write(
                "\nstatic Py_ssize_t _seq_length_@(%* self) noexcept\n{\n",
                type.TypeName(),
                bind<write_pywrapper_type>(type));
            {
                write_ptype_body(
                    "seq_length()",
                    [&](auto& w)
                    {
                        write_seq_length_body(w, type);
                    });
            }
            w.write("}\n");

            w.write(
                "\nstatic PyObject* _seq_item_@(%* self, Py_ssize_t i) noexcept\n{\n",
                type.TypeName(),
                bind<write_pywrapper_type>(type));
            {
                write_ptype_body(
                    "seq_item(i)",
                    [&](auto& w)
                    {
                        write_seq_item_body(w, type);
                    });
            }
            w.write("}\n");

            w.write(
                "\nstatic PyObject* _seq_subscript_@(%* self, PyObject* slice) noexcept\n{\n",
                type.TypeName(),
                bind<write_pywrapper_type>(type));
            {
                write_ptype_body(
                    "seq_subscript(slice)",
                    [&](auto& w)
                    {
                        write_seq_subscript_body(w, type);
                    });
            }
            w.write("}\n");

            if (implements_ivector(type))
            {
                w.write(
                    "\nstatic int _seq_assign_@(%* self, Py_ssize_t i, PyObject* value) noexcept\n{\n",
                    type.TypeName(),
                    bind<write_pywrapper_type>(type));
                {
                    write_ptype_body(
                        "seq_assign(i, value)",
                        [&](auto& w)
                        {
                            write_seq_assign_body(w, type);
                        });
                }
                w.write("}\n");
            }
        }

        if (implements_mapping(type))
        {
            w.write(
                "\nstatic int _map_contains_@(%* self, PyObject* key) noexcept\n{\n",
                type.TypeName(),
                bind<write_pywrapper_type>(type));
            {
                write_ptype_body(
                    "map_contains(key)",
                    [&](auto& w)
                    {
                        write_map_contains_body(w, type);
                    });
            }
            w.write("}\n");

            w.write(
                "\nstatic Py_ssize_t _map_length_@(%* self) noexcept\n{\n",
                type.TypeName(),
                bind<write_pywrapper_type>(type));
            {
                write_ptype_body(
                    "map_length()",
                    [&](auto& w)
                    {
                        write_map_length_body(w, type);
                    });
            }
            w.write("}\n");

            w.write(
                "\nstatic PyObject* _map_subscript_@(%* self, PyObject* key) noexcept\n{\n",
                type.TypeName(),
                bind<write_pywrapper_type>(type));
            {
                write_ptype_body(
                    "map_subscript(key)",
                    [&](auto& w)
                    {
                        write_map_subscript_body(w, type);
                    });
            }
            w.write("}\n");

            if (implements_imap(type))
            {
                w.write(
                    "\nstatic int _map_assign_@(%* self, PyObject* key, PyObject* value) noexcept\n{\n",
                    type.TypeName(),
                    bind<write_pywrapper_type>(type));
                {
                    write_ptype_body(
                        "map_assign(key, value)",
                        [&](auto& w)
                        {
                            write_map_assign_body(w, type);
                        });
                }
                w.write("}\n");
            }
        }
    }

    void write_method_table(writer& w, TypeDef const& type)
    {
        auto get_argument_convention_flag = [](MethodDef const& method)
        {
            switch (get_argument_convention(method))
            {
            case argument_convention::no_args:
                return "METH_NOARGS";
            case argument_convention::single_arg:
                return "METH_O";
            case argument_convention::variable_args:
                return "METH_VARARGS";
            }

            throw_invalid("invalid argument_convention");
        };

        auto write_row = [&](MethodDef const& method)
        {
            auto argument_convention_flag = get_argument_convention_flag(method);
            auto static_flag
                = is_static(method) || is_constructor(method) ? " | METH_STATIC" : "";

            w.write(
                "{ \"%\", reinterpret_cast<PyCFunction>(@_%), %%, nullptr },\n",
                bind<write_lower_snake_case_python_identifier>(method.Name()),
                type.TypeName(),
                method.Name(),
                argument_convention_flag,
                static_flag);
        };

        w.write("\nstatic PyMethodDef _methods_@[] = {\n", type.TypeName());
        {
            writer::indent_guard g{w};

            std::set<std::string_view> method_names{};
            enumerate_methods(
                w,
                type,
                [&](auto const& method)
                {
                    if (is_static(method))
                    {
                        return;
                    }

                    if (!contains(method_names, method.Name()))
                    {
                        write_row(method);
                    }

                    method_names.insert(method.Name());
                });

            enumerate_events(
                w,
                type,
                [&](auto const& evt)
                {
                    auto [add_method, remove_method] = get_event_methods(evt);
                    write_row(add_method);
                    write_row(remove_method);
                });

            if (!(is_ptype(type) || is_static_class(type)))
            {
                w.write(
                    "{ \"_assign_array_\", _assign_array_@, METH_O | METH_STATIC, nullptr },\n",
                    type.TypeName());
            }

            // TODO: support _from for ptypes
            if (is_iunknown(type) && !(is_ptype(type) || is_static_class(type)))
            {
                w.write(
                    "{ \"_from\", reinterpret_cast<PyCFunction>(_from_@), METH_O | METH_STATIC, nullptr },\n",
                    type.TypeName());
            }

            if (implements_iclosable(type))
            {
                w.write(
                    "{ \"__enter__\", reinterpret_cast<PyCFunction>(_enter_@), METH_NOARGS, nullptr },\n",
                    type.TypeName());
                w.write(
                    "{ \"__exit__\",  reinterpret_cast<PyCFunction>(_exit_@), METH_VARARGS, nullptr },\n",
                    type.TypeName());
            }

            if (is_ptype(type))
            {
                w.write(
                    "{ \"__class_getitem__\", Py_GenericAlias, METH_O | METH_CLASS, PyDoc_STR(\"See PEP 585\") },\n");
            }

            w.write("{ }\n");
        }

        w.write("};\n");
    }

    void write_getset_table(writer& w, TypeDef const& type)
    {
        auto write_row = [&](std::string_view field_name,
                             std::string_view getter_name,
                             std::string_view setter_name)
        {
            auto setter = setter_name.empty() ? "nullptr"
                                              : w.write_temp(
                                                  "reinterpret_cast<setter>(@_%)",
                                                  type.TypeName(),
                                                  setter_name);

            w.write(
                "{ \"%\", reinterpret_cast<getter>(@_%), %, nullptr, nullptr },\n",
                bind<write_lower_snake_case_python_identifier>(field_name),
                type.TypeName(),
                getter_name,
                setter);
        };

        w.write("\nstatic PyGetSetDef _getset_@[] = {\n", type.TypeName());
        {
            writer::indent_guard g{w};

            auto category = get_category(type);
            if (category == category::struct_type)
            {
                for (auto&& field : type.FieldList())
                {
                    write_row(
                        field.Name(),
                        w.write_temp("get_%", field.Name()),
                        w.write_temp("set_%", field.Name()));
                }
            }
            else if (
                category == category::class_type
                || category == category::interface_type)
            {
                enumerate_properties(
                    w,
                    type,
                    [&](Property prop)
                    {
                        auto [getter, setter] = get_property_methods(prop);

                        // static properties are implemented in the metaclass
                        if (!is_static(getter))
                        {
                            write_row(
                                prop.Name(),
                                getter.Name(),
                                setter ? setter.Name() : "");
                        }
                    });
            }

            w.write("{ }\n");
        }
        w.write("};\n");
    }

    void write_type_slot_table(writer& w, TypeDef const& type)
    {
        auto category = get_category(type);
        auto name = type.TypeName();

        w.write("\nstatic PyType_Slot _type_slots_@[] = \n{\n", name);

        {
            writer::indent_guard g{w};

            w.write("{ Py_tp_new, reinterpret_cast<void*>(_new_@) },\n", name);
            if (category == category::struct_type)
            {
                w.write("{ Py_tp_init, reinterpret_cast<void*>(_init_@) },\n", name);
            }
            if (!is_static_class(type))
            {
                w.write(
                    "{ Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_@) },\n", name);
            }

            w.write("{ Py_tp_methods, reinterpret_cast<void*>(_methods_@) },\n", name);
            w.write("{ Py_tp_getset, reinterpret_cast<void*>(_getset_@) },\n", name);

            if (implements_ibuffer(type) || implements_imemorybufferreference(type))
            {
                w.write(
                    "{ Py_bf_getbuffer, reinterpret_cast<void*>(_get_buffer_@) },\n",
                    name);
            }

            if (implements_istringable(type))
            {
                w.write("{ Py_tp_str, reinterpret_cast<void*>(_str_@) },\n", name);
            }
            if (implements_iasync(type))
            {
                w.write("{ Py_am_await, reinterpret_cast<void*>(_await_@) },\n", name);
            }
            if (implements_iiterable(type) || implements_iiterator(type))
            {
                w.write(
                    "{ Py_tp_iter, reinterpret_cast<void*>(_iterator_@) },\n", name);
            }
            if (implements_iiterator(type))
            {
                w.write(
                    "{ Py_tp_iternext, reinterpret_cast<void*>(_iterator_next_@) },\n",
                    name);
            }
            if (implements_sequence(type))
            {
                w.write(
                    "{ Py_sq_length, reinterpret_cast<void*>(_seq_length_@) },\n",
                    name);
                w.write(
                    "{ Py_sq_item, reinterpret_cast<void*>(_seq_item_@) },\n", name);
                w.write(
                    "{ Py_mp_subscript, reinterpret_cast<void*>(_seq_subscript_@) },\n",
                    name);

                if (implements_ivector(type))
                {
                    w.write(
                        "{ Py_sq_ass_item, reinterpret_cast<void*>(_seq_assign_@) },\n",
                        name);
                }
            }
            if (implements_mapping(type))
            {
                w.write(
                    "{ Py_sq_contains, reinterpret_cast<void*>(_map_contains_@) },\n",
                    name);
                w.write(
                    "{ Py_mp_length, reinterpret_cast<void*>(_map_length_@) },\n",
                    name);
                w.write(
                    "{ Py_mp_subscript, reinterpret_cast<void*>(_map_subscript_@) },\n",
                    name);

                if (implements_imap(type))
                {
                    w.write(
                        "{ Py_mp_ass_subscript, reinterpret_cast<void*>(_map_assign_@) },\n",
                        name);
                }
            }
            w.write("{ },\n");
        }
        w.write("};\n");
    }

    void write_type_spec(writer& w, TypeDef const& type)
    {
        auto type_size
            = is_static_class(type)
                  ? "0"
                  : w.write_temp("sizeof(%)", bind<write_pywrapper_type>(type));

        auto format = R"(
static PyType_Spec type_spec_@ =
{
    "winrt.%.@",
    %,
    0,
    Py_TPFLAGS_DEFAULT,
    _type_slots_@
};
)";
        auto type_name = type.TypeName();
        w.write(
            format,
            type_name,
            bind<write_ns_module_name>(type.TypeNamespace()),
            type_name,
            type_size,
            type_name);
    }

    static void write_metaclass_property_getset_table(writer& w, TypeDef const& type)
    {
        auto write_row = [&](std::string_view field_name,
                             std::string_view getter_name,
                             std::string_view setter_name)
        {
            auto setter = setter_name.empty() ? "nullptr"
                                              : w.write_temp(
                                                  "reinterpret_cast<setter>(@_%)",
                                                  type.TypeName(),
                                                  setter_name);

            w.write(
                "{ \"%\", reinterpret_cast<getter>(@_%), %, nullptr, nullptr },\n",
                bind<write_lower_snake_case_python_identifier>(field_name),
                type.TypeName(),
                getter_name,
                setter);
        };

        w.write("\nstatic PyGetSetDef getset_@_Static[] = {\n", type.TypeName());
        {
            writer::indent_guard g{w};

            enumerate_properties(
                w,
                type,
                [&](Property prop)
                {
                    auto [getter, setter] = get_property_methods(prop);

                    if (is_static(getter))
                    {
                        write_row(
                            prop.Name(), getter.Name(), setter ? setter.Name() : "");
                    }
                });

            w.write("{ }\n");
        }
        w.write("};\n");
    }

    static void write_metaclass_method_table(writer& w, TypeDef const& type)
    {
        auto get_argument_convention_flag = [](MethodDef const& method)
        {
            switch (get_argument_convention(method))
            {
            case argument_convention::no_args:
                return "METH_NOARGS";
            case argument_convention::single_arg:
                return "METH_O";
            case argument_convention::variable_args:
                return "METH_VARARGS";
            }

            throw_invalid("invalid argument_convention");
        };

        auto write_row = [&](MethodDef const& method)
        {
            w.write(
                "{ \"%\", reinterpret_cast<PyCFunction>(@_%), %, nullptr },\n",
                bind<write_lower_snake_case_python_identifier>(method.Name()),
                type.TypeName(),
                method.Name(),
                get_argument_convention_flag(method));
        };

        w.write("\nstatic PyMethodDef methods_@_Static[] = {\n", type.TypeName());
        {
            writer::indent_guard g{w};

            std::set<std::string_view> method_names{};
            enumerate_methods(
                w,
                type,
                [&](auto const& method)
                {
                    if (!contains(method_names, method.Name()))
                    {
                        if (is_static(method))
                        {
                            write_row(method);
                        }
                    }

                    method_names.insert(method.Name());
                });

            w.write("{ }\n");
        }
        w.write("};\n");
    }

    void write_metaclass(writer& w, TypeDef const& type)
    {
        if (!requires_metaclass(type))
        {
            return;
        }

        write_metaclass_property_getset_table(w, type);
        write_metaclass_method_table(w, type);

        w.write("\nstatic PyType_Slot type_slots_@_Static[] = \n{\n", type.TypeName());

        {
            writer::indent_guard g{w};
            w.write("{ Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },\n");
            w.write(
                "{ Py_tp_getset, reinterpret_cast<void*>(getset_@_Static) },\n",
                type.TypeName());
            w.write(
                "{ Py_tp_methods, reinterpret_cast<void*>(methods_@_Static) },\n",
                type.TypeName());
            w.write("{ }\n");
        }

        w.write("};\n");

        auto format = R"(
static PyType_Spec type_spec_@_Static =
{
    "winrt.%.@_Static",
    static_cast<int>(PyType_Type.tp_basicsize),
    static_cast<int>(PyType_Type.tp_itemsize),
    Py_TPFLAGS_DEFAULT,
    type_slots_@_Static
};
)";

        w.write(
            format,
            type.TypeName(),
            bind<write_ns_module_name>(type.TypeNamespace()),
            type.TypeName(),
            type.TypeName());
    }

    void write_category(writer& w, TypeDef const& type)
    {
        switch (get_category(type))
        {
        case category::class_type:
            w.write("class");
            break;
        case category::delegate_type:
            w.write("delegate");
            break;
        case category::enum_type:
            w.write("enum");
            break;
        case category::interface_type:
            w.write("interface");
            break;
        case category::struct_type:
            w.write("struct");
            break;
        }
    }

    void write_inspectable_type(writer& w, TypeDef const& type)
    {
        if (is_exclusive_to(type))
            return;

        auto guard{w.push_generic_params(type.GenericParam())};

        w.write(
            "\n// ----- @ % --------------------\n",
            type.TypeName(),
            bind<write_category>(type));
        write_new_function(w, type);
        write_dealloc_function(w, type);
        write_method_functions(w, type);
        write_method_table(w, type);
        write_getset_table(w, type);
        write_type_slot_table(w, type);
        write_type_spec(w, type);
        write_metaclass(w, type);
    }

#pragma region pinterface functions
    void write_pinterface_type_mapper(writer& w, TypeDef const& type)
    {
        if (!is_ptype(type))
            return;

        auto format = R"(template <%>
struct pinterface_python_type<%<%>>
{
    using abstract = %;
    using concrete = %<%>;
};

)";
        w.write(
            format,
            bind_list<write_template_arg>(", ", type.GenericParam()),
            type,
            bind_list<write_template_arg_name>(", ", type.GenericParam()),
            bind<write_pyproj_type>(type),
            bind<write_pyimpl_type>(type),
            bind_list<write_template_arg_name>(", ", type.GenericParam()));
    }

    void write_pinterface_decl(writer& w, TypeDef const& type)
    {
        if (!is_ptype(type))
            return;

        auto guard{w.push_generic_params(type.GenericParam())};

        w.write("\nstruct @\n{\n", type.TypeName());
        {
            writer::indent_guard g{w};

            w.write("virtual ~@() {};\n", type.TypeName());

            std::set<std::string_view> method_names{};
            enumerate_methods(
                w,
                type,
                [&](auto const& method)
                {
                    if (!contains(method_names, method.Name()))
                    {
                        w.write(
                            "virtual PyObject* %(PyObject*) noexcept = 0;\n",
                            method.Name());
                    }

                    method_names.insert(method.Name());
                });

            enumerate_properties(
                w,
                type,
                [&](auto const& prop)
                {
                    auto [get_method, put_method] = get_property_methods(prop);
                    w.write("virtual PyObject* %() noexcept = 0;\n", get_method.Name());
                    if (put_method)
                    {
                        w.write(
                            "virtual int %(PyObject*) noexcept = 0;\n",
                            put_method.Name());
                    }
                });

            enumerate_events(
                w,
                type,
                [&](auto const& evt)
                {
                    auto [add_method, remove_method] = get_event_methods(evt);
                    w.write(
                        "virtual PyObject* %(PyObject*) noexcept = 0;\n",
                        add_method.Name());
                    w.write(
                        "virtual PyObject* %(PyObject*) noexcept = 0;\n",
                        remove_method.Name());
                });

            if (implements_iasync(type))
            {
                w.write("virtual PyObject* dunder_await() noexcept = 0;\n");
            }

            if (implements_iiterable(type) || implements_iiterator(type))
            {
                w.write("virtual PyObject* dunder_iter() noexcept = 0;\n");
            }

            if (implements_iiterator(type))
            {
                w.write("virtual PyObject* dunder_iternext() noexcept = 0;\n");
            }

            if (implements_sequence(type))
            {
                w.write("virtual Py_ssize_t seq_length() noexcept = 0;\n");
                w.write("virtual PyObject* seq_item(Py_ssize_t i) noexcept = 0;\n");
                w.write(
                    "virtual PyObject* seq_subscript(PyObject* slice) noexcept = 0;\n");

                if (implements_ivector(type))
                {
                    w.write(
                        "virtual int seq_assign(Py_ssize_t i, PyObject* value) noexcept = 0;\n");
                }
            }

            if (implements_mapping(type))
            {
                w.write("virtual int map_contains(PyObject* key) noexcept = 0;\n");
                w.write("virtual Py_ssize_t map_length() noexcept = 0;\n");
                w.write(
                    "virtual PyObject* map_subscript(PyObject* key) noexcept = 0;\n");

                if (implements_imap(type))
                {
                    w.write(
                        "virtual int map_assign(PyObject* key, PyObject* value) noexcept = 0;\n");
                }
            }
        }
        w.write("};\n");
    }

    void write_pinterface_impl(writer& w, TypeDef const& type)
    {
        if (!is_ptype(type))
            return;

        auto guard{w.push_generic_params(type.GenericParam())};

        w.write(
            "\ntemplate<%>\nstruct @ : public py::proj::%::@\n{\n",
            bind_list<write_template_arg>(", ", type.GenericParam()),
            type.TypeName(),
            bind<write_type_namespace>(type),
            type.TypeName());

        {
            writer::indent_guard g{w};

            w.write(
                "@(%<%> o) : _obj(o) {}\n",
                type.TypeName(),
                type,
                bind_list<write_template_arg_name>(", ", type.GenericParam()));

            std::set<std::string_view> method_names{};
            enumerate_methods(
                w,
                type,
                [&](auto const& method)
                {
                    method_names.insert(method.Name());
                });

            for (auto&& method_name : method_names)
            {
                w.write(
                    "PyObject* %(PyObject* args) noexcept override\n{\n", method_name);
                {
                    writer::indent_guard gg{w};
                    write_method_overloads(w, type, method_name);
                }
                w.write("}\n");
            }

            enumerate_properties(
                w,
                type,
                [&](auto const& prop)
                {
                    auto methods = get_property_methods(prop);
                    auto get_method = std::get<0>(methods);
                    auto put_method = std::get<1>(methods);

                    w.write("PyObject* %() noexcept override\n{\n", get_method.Name());
                    {
                        writer::indent_guard gg{w};
                        write_try_catch(
                            w,
                            [&](writer& w)
                            {
                                write_method_body_contents(w, type, get_method);
                            });
                    }
                    w.write("}\n");

                    if (put_method)
                    {
                        w.write(
                            "int %(PyObject* arg) noexcept override\n{\n",
                            put_method.Name());
                        {
                            writer::indent_guard gg{w};
                            write_setter_try_catch(
                                w,
                                [&](writer& w)
                                {
                                    write_method_body_contents(
                                        w, type, put_method, true);
                                });
                        }
                        w.write("}\n");
                    }
                });

            enumerate_events(
                w,
                type,
                [&](auto const& evt)
                {
                    auto methods = get_event_methods(evt);
                    auto add_method = std::get<0>(methods);
                    auto remove_method = std::get<1>(methods);

                    w.write(
                        "PyObject* %(PyObject* arg) noexcept override\n{\n",
                        add_method.Name());
                    {
                        writer::indent_guard gg{w};
                        write_try_catch(
                            w,
                            [&](writer& w)
                            {
                                write_method_body_contents(w, type, add_method);
                            });
                    }
                    w.write("}\n");

                    w.write(
                        "PyObject* %(PyObject* arg) noexcept override\n{\n",
                        remove_method.Name());
                    {
                        writer::indent_guard gg{w};
                        write_try_catch(
                            w,
                            [&](writer& w)
                            {
                                write_method_body_contents(w, type, remove_method);
                            });
                    }
                    w.write("}\n");
                });

            if (implements_iasync(type))
            {
                w.write(
                    "PyObject* dunder_await() noexcept override { return py::dunder_await(_obj); }\n");
            }

            if (implements_iiterable(type) || implements_iiterator(type))
            {
                w.write("PyObject* dunder_iter() noexcept override\n{\n");
                {
                    writer::indent_guard gg{w};
                    write_dunder_iter_body(w, type);
                }
                w.write("}\n");
            }

            if (implements_iiterator(type))
            {
                w.write("PyObject* dunder_iternext() noexcept override\n{\n");
                {
                    writer::indent_guard gg{w};
                    write_dunder_iter_next_body(w, type);
                }
                w.write("}\n");
            }

            if (implements_sequence(type))
            {
                w.write("Py_ssize_t seq_length() noexcept override\n{\n");
                {
                    writer::indent_guard gg{w};
                    write_seq_length_body(w, type);
                }
                w.write("}\n");

                w.write("PyObject* seq_item(Py_ssize_t i) noexcept override\n{\n");
                {
                    writer::indent_guard gg{w};
                    write_seq_item_body(w, type);
                }
                w.write("}\n");

                w.write(
                    "PyObject* seq_subscript(PyObject* slice) noexcept override\n{\n");
                {
                    writer::indent_guard gg{w};
                    write_seq_subscript_body(w, type);
                }
                w.write("}\n");

                if (implements_ivector(type))
                {
                    w.write(
                        "int seq_assign(Py_ssize_t i, PyObject* value) noexcept override\n{\n");
                    {
                        writer::indent_guard gg{w};
                        write_seq_assign_body(w, type);
                    }
                    w.write("}\n");
                }
            }

            if (implements_mapping(type))
            {
                w.write("int map_contains(PyObject* key) noexcept override\n{\n");
                {
                    writer::indent_guard gg{w};
                    write_map_contains_body(w, type);
                }
                w.write("}\n");

                w.write("Py_ssize_t map_length() noexcept override\n{\n");
                {
                    writer::indent_guard gg{w};
                    write_map_length_body(w, type);
                }
                w.write("}\n");

                w.write(
                    "PyObject* map_subscript(PyObject* key) noexcept override\n{\n");
                {
                    writer::indent_guard gg{w};
                    write_map_subscript_body(w, type);
                }
                w.write("}\n");

                if (implements_imap(type))
                {
                    w.write(
                        "int map_assign(PyObject* key, PyObject* value) noexcept override\n{\n");
                    {
                        writer::indent_guard gg{w};
                        write_map_assign_body(w, type);
                    }
                    w.write("}\n");
                }
            }

            w.write(
                "\n%<%> _obj{ nullptr };\n",
                type,
                bind_list<write_template_arg_name>(", ", type.GenericParam()));
        }
        w.write("};\n");
    }
#pragma endregion

#pragma region enum functions

    /**
     * Writes a const char* declaration for the PEP 3118 buffer format string
     * constant describing the underlying type of an enum.
     */
    void write_enum_buffer_format_decl(writer& w, TypeDef const& type)
    {
        w.write("template<>\n");
        w.write(
            "inline constexpr const char* buffer_format<%> = \"%\";\n\n",
            type,
            // flags are UInt32, regular enums are Int32
            is_flags_enum(type) ? "I" : "i");
    }

#pragma endregion

#pragma region struct functions

    static void write_struct_buffer_format_string(writer& w, TypeDef const& type);

    /**
     * Writes the PEP 3118 format string for the type of a field.
     */
    static void write_struct_buffer_format_type(writer& w, Field const& field)
    {
        call(
            get_struct_field_semantics(field, true),
            [&](fundamental_type type)
            {
                switch (type)
                {
                case fundamental_type::Boolean:
                    w.write("?");
                    break;
                case fundamental_type::Char:
                    w.write("u");
                    break;
                case fundamental_type::Int8:
                    w.write("b");
                    break;
                case fundamental_type::UInt8:
                    w.write("B");
                    break;
                case fundamental_type::Int16:
                    w.write("h");
                    break;
                case fundamental_type::UInt16:
                    w.write("H");
                    break;
                case fundamental_type::Int32:
                    w.write("i");
                    break;
                case fundamental_type::UInt32:
                    w.write("I");
                    break;
                case fundamental_type::Int64:
                    w.write("q");
                    break;
                case fundamental_type::UInt64:
                    w.write("Q");
                    break;
                case fundamental_type::Float:
                    w.write("f");
                    break;
                case fundamental_type::Double:
                    w.write("d");
                    break;
                case fundamental_type::String:
                    w.write("P");
                    break;
                default:
                    throw_invalid("invalid fundamental type");
                }
            },
            [&](guid_type type)
            {
                w.write("T{I2H8B}");
            },
            [&]([[maybe_unused]] TypeDef const& type)
            {
                assert(get_category(type) == category::struct_type);
                w.write("%", bind<write_struct_buffer_format_string>(type));
            },
            [](auto)
            {
                throw_invalid("invalid struct field type");
            });
    }

    /**
     * Writes the PEP 3118 format string for the type of a struct.
     */
    static void write_struct_buffer_format_string(writer& w, TypeDef const& type)
    {
        w.write("T{");

        for (auto&& field : type.FieldList())
        {
            w.write(
                "%:%:",
                bind<write_struct_buffer_format_type>(field),
                bind<write_lower_snake_case_python_identifier>(field.Name()));
        }

        w.write("}");
    }

    /**
     * Writes a const char* declaration for the PEP 3118 buffer format string
     * constant describing the layout of a struct.
     */
    void write_struct_buffer_format_decl(writer& w, TypeDef const& type)
    {
        if (is_customized_struct(type))
        {
            return;
        }

        w.write("template<>\n");
        w.write(
            "inline constexpr const char* buffer_format<%> = \"%\";\n\n",
            type,
            bind<write_struct_buffer_format_string>(type));
    }

    void write_struct_field_var_type(writer& w, Field const& field)
    {
        call(
            get_struct_field_semantics(field, true),
            [&](fundamental_type type)
            {
                switch (type)
                {
                case fundamental_type::Boolean:
                    w.write("bool");
                    break;
                case fundamental_type::Char:
                    w.write("char16_t");
                    break;
                case fundamental_type::Int8:
                    w.write("int8_t");
                    break;
                case fundamental_type::UInt8:
                    w.write("uint8_t");
                    break;
                case fundamental_type::Int16:
                    w.write("int16_t");
                    break;
                case fundamental_type::UInt16:
                    w.write("uint16_t");
                    break;
                case fundamental_type::Int32:
                    w.write("int32_t");
                    break;
                case fundamental_type::UInt32:
                    w.write("uint32_t");
                    break;
                case fundamental_type::Int64:
                    w.write("int64_t");
                    break;
                case fundamental_type::UInt64:
                    w.write("uint64_t");
                    break;
                case fundamental_type::Float:
                    w.write("float");
                    break;
                case fundamental_type::Double:
                    w.write("double");
                    break;
                case fundamental_type::String:
                    w.write("winrt::hstring");
                    break;
                default:
                    throw_invalid("invalid fundamental type");
                }
            },
            [&](guid_type type)
            {
                w.write("PyObject*");
            },
            [&]([[maybe_unused]] TypeDef const& type)
            {
                assert(get_category(type) == category::struct_type);
                w.write("PyObject*");
            },
            [](auto)
            {
                throw_invalid("invalid struct field type");
            });
    }

    /**
     * Writes the Python type name for a struct field.
     * @param [in]  w       The writer.
     * @param [in]  field   The field metadata.
     */
    void write_struct_field_python_type(writer& w, Field const& field)
    {
        call(
            get_struct_field_semantics(field, false),
            [&](fundamental_type type)
            {
                switch (type)
                {
                case fundamental_type::Boolean:
                    w.write("bool");
                    break;
                case fundamental_type::Char:
                    w.write("winrt.system.Char16");
                    break;
                case fundamental_type::Int8:
                    w.write("winrt.system.Int8");
                    break;
                case fundamental_type::UInt8:
                    w.write("winrt.system.UInt8");
                    break;
                case fundamental_type::Int16:
                    w.write("winrt.system.Int16");
                    break;
                case fundamental_type::UInt16:
                    w.write("winrt.system.UInt16");
                    break;
                case fundamental_type::Int32:
                    w.write("winrt.system.Int32");
                    break;
                case fundamental_type::UInt32:
                    w.write("winrt.system.UInt32");
                    break;
                case fundamental_type::Int64:
                    w.write("winrt.system.Int64");
                    break;
                case fundamental_type::UInt64:
                    w.write("winrt.system.UInt64");
                    break;
                case fundamental_type::Float:
                    w.write("winrt.system.Single");
                    break;
                case fundamental_type::Double:
                    w.write("winrt.system.Double");
                    break;
                case fundamental_type::String:
                    w.write("str");
                    break;
                default:
                    throw_invalid("invalid fundamental type");
                }
            },
            [&](guid_type type)
            {
                w.write("_uuid.UUID");
            },
            [&]([[maybe_unused]] TypeDef const& type)
            {
                w.write_python(type);
            },
            [](auto)
            {
                throw_invalid("invalid struct field type");
            });
    }

    void write_struct_field_keyword(writer& w, Field const& field)
    {
        w.write(
            "\"%\", ", bind<write_lower_snake_case_python_identifier>(field.Name()));
    }

    void write_struct_field_format(writer& w, Field const& field)
    {
        call(
            get_struct_field_semantics(field, true),
            [&](fundamental_type type)
            {
                switch (type)
                {
                case fundamental_type::Boolean:
                    w.write("p");
                    break;
                    // TODO: 'u' format string was deprecated in Python 3.3. Need to
                    // move to a supported construct
                case fundamental_type::Char:
                    w.write("u1");
                    break;
                case fundamental_type::Int8:
                    w.write("b");
                    break;
                case fundamental_type::UInt8:
                    w.write("B");
                    break;
                case fundamental_type::Int16:
                    w.write("h");
                    break;
                case fundamental_type::UInt16:
                    w.write("H");
                    break;
                case fundamental_type::Int32:
                    w.write("i");
                    break;
                case fundamental_type::UInt32:
                    w.write("I");
                    break;
                case fundamental_type::Int64:
                    w.write("L");
                    break;
                case fundamental_type::UInt64:
                    w.write("K");
                    break;
                case fundamental_type::Float:
                    w.write("f");
                    break;
                case fundamental_type::Double:
                    w.write("d");
                    break;
                    // TODO: 'u' format string was deprecated in Python 3.3. Need to
                    // move to a supported construct
                case fundamental_type::String:
                    w.write("u");
                    break;
                default:
                    throw_invalid("invalid fundamental type");
                }
            },
            [&](guid_type type)
            {
                w.write("O");
            },
            [&]([[maybe_unused]] type_definition const& type)
            {
                assert(get_category(type) == category::struct_type);
                w.write("O");
            },
            [](auto)
            {
                throw_invalid("invalid struct field type");
            });
    }

    void write_struct_field_parse_parameter(writer& w, Field const& field)
    {
        call(
            get_struct_field_semantics(field, true),
            [&](fundamental_type)
            {
                w.write(", &_%", field.Name());
            },
            [&](guid_type type)
            {
                w.write(", &_%", field.Name());
            },
            [&]([[maybe_unused]] type_definition const& type)
            {
                assert(get_category(type) == category::struct_type);
                w.write(", &_%", field.Name());
            },
            [](auto)
            {
                throw_invalid("invalid struct field type");
            });
    }

    void write_struct_field_initializer(writer& w, Field const& field)
    {
        call(
            get_struct_field_semantics(field, false),
            [&](fundamental_type)
            {
                w.write("_%", field.Name());
            },
            [&](guid_type type)
            {
                w.write("py::converter<winrt::guid>::convert_to(_%)", field.Name());
            },
            [&](type_definition const& type)
            {
                auto category = get_category(type);
                assert(
                    (category == category::struct_type)
                    || (category == category::enum_type));
                switch (category)
                {
                case category::enum_type:
                    w.write("static_cast<%>(_%)", type, field.Name());
                    break;
                case category::struct_type:
                    w.write("py::converter<%>::convert_to(_%)", type, field.Name());
                    break;
                }
            },
            [](auto)
            {
                throw_invalid("invalid struct field type");
            });
    }

    void write_struct_field_ref_capture(writer& w, Field const& field)
    {
        call(
            get_struct_field_semantics(field, true),
            [&](fundamental_type)
            {
            },
            [&](guid_type type)
            {
                w.write(", &_%", field.Name());
            },
            [&]([[maybe_unused]] TypeDef const& type)
            {
                assert(get_category(type) == category::struct_type);
                w.write(", &_%", field.Name());
            },
            [](auto)
            {
                throw_invalid("invalid struct field type");
            });
    }

    void write_struct_constructor(writer& w, TypeDef const& type)
    {
        w.write(
            "\nwinrt_struct_wrapper<%>* _new_@(PyTypeObject* subclass, PyObject* /*unused*/, PyObject* /*unused*/) noexcept\n{\n",
            type,
            type.TypeName());
        {
            writer::indent_guard g{w};
            w.write(
                "auto self = reinterpret_cast<winrt_struct_wrapper<%>*>(subclass->tp_alloc(subclass, 0));\n",
                type);

            w.write("\nif (!self)\n{\n");
            {
                writer::indent_guard gg{w};
                w.write("return nullptr;\n");
            }
            w.write("}\n\n");

            w.write("std::construct_at(&self->obj);\n");

            w.write("\nreturn self;\n");
        }
        w.write("}\n");

        w.write(
            "\nint _init_@(winrt_struct_wrapper<%>* self, PyObject* args, PyObject* kwds) noexcept\n{",
            type.TypeName(),
            type);
        {
            writer::indent_guard g{w};
            w.write(R"(
auto tuple_size = PyTuple_Size(args);

if ((tuple_size == 0) && (kwds == nullptr))
{
)");
            {
                writer::indent_guard gg{w};
                w.write("self->obj = {};\n");
                w.write("return 0;\n");
            }
            w.write("}\n\n");

            for (auto&& field : type.FieldList())
            {
                w.write(
                    "% _%{};\n",
                    bind<write_struct_field_var_type>(field),
                    field.Name());
            }

            auto format = R"(
static const char* kwlist[] = {%nullptr};
if (!PyArg_ParseTupleAndKeywords(args, kwds, "%", const_cast<char**>(kwlist)%))
{
    return -1;
}

)";
            w.write(
                format,
                bind_each<write_struct_field_keyword>(type.FieldList()),
                bind_each<write_struct_field_format>(type.FieldList()),
                bind_each<write_struct_field_parse_parameter>(type.FieldList()));

            write_try_catch(
                w,
                [&](writer& w)
                {
                    w.write(
                        "self->obj = {%};\n",
                        bind_list<write_struct_field_initializer>(
                            ", ", type.FieldList()));
                    w.write("return 0;\n");
                },
                "-1");
        }
        w.write("}\n");
    }

    void write_struct_field_name(writer& w, Field const& field)
    {
        static const std::set<std::string_view> custom_numerics
            = {"Matrix3x2",
               "Matrix4x4",
               "Plane",
               "Quaternion",
               "Vector2",
               "Vector3",
               "Vector4"};

        auto type = field.Parent();
        if ((type.TypeNamespace() == "Windows.Foundation.Numerics")
            && (custom_numerics.find(type.TypeName()) != custom_numerics.end()))
        {
            for (char c : field.Name())
            {
                w.write(static_cast<char>(::tolower(c)));
            }
        }
        else
        {
            w.write(field.Name());
        }
    }

    void write_struct_getset_function(
        writer& w, TypeDef const& type, Field const& field)
    {
        w.write(
            "\nstatic PyObject* @_get_%(%* self, void* /*unused*/) noexcept\n{\n",
            type.TypeName(),
            field.Name(),
            bind<write_pywrapper_type>(type));
        {
            writer::indent_guard g{w};

            if (has_custom_conversion(type))
            {
                write_try_catch(
                    w,
                    [](writer& w)
                    {
                        w.write("return py::convert(custom_get(self->obj));\n");
                    });
            }
            else
            {
                write_try_catch(
                    w,
                    [&](writer& w)
                    {
                        w.write(
                            "return py::convert(self->obj.%);\n",
                            bind<write_struct_field_name>(field));
                    });
            }
        }
        w.write("}\n");

        w.write(
            "\nstatic int @_set_%(%* self, PyObject* arg, void* /*unused*/) noexcept\n{\n",
            type.TypeName(),
            field.Name(),
            bind<write_pywrapper_type>(type));
        {
            writer::indent_guard g{w};

            if (has_custom_conversion(type))
            {
                write_setter_try_catch(
                    w,
                    [&](writer& w)
                    {
                        w.write(
                            "custom_set(self->obj, py::converter<%>::convert_to(arg));\nreturn 0;\n",
                            field.Signature().Type());
                    });
            }
            else
            {
                write_setter_try_catch(
                    w,
                    [&](writer& w)
                    {
                        w.write(
                            "self->obj.% = py::converter<%>::convert_to(arg);\nreturn 0;\n",
                            bind<write_struct_field_name>(field),
                            field.Signature().Type());
                    });
            }
        }
        w.write("}\n");
    }

    void write_struct_getset_functions(writer& w, TypeDef const& type)
    {
        for (auto&& field : type.FieldList())
        {
            write_struct_getset_function(w, type, field);
        }
    }

    void write_struct(writer& w, TypeDef const& type)
    {
        if (is_customized_struct(type))
        {
            return;
        }

        auto guard{w.push_generic_params(type.GenericParam())};

        w.write("\n// ----- % struct --------------------\n", type.TypeName());
        write_struct_constructor(w, type);
        write_dealloc_function(w, type);
        write_method_functions(w, type);
        write_method_table(w, type);
        write_struct_getset_functions(w, type);
        write_getset_table(w, type);
        write_type_slot_table(w, type);
        write_type_spec(w, type);
    }

#pragma endregion

#pragma region delegate functions
    void write_delegate_template_args(writer& w, TypeDef const& type)
    {
        if (is_ptype(type))
        {
            w.write(
                "<%>", bind_list<write_template_arg_name>(", ", type.GenericParam()));
        }
    }

    void write_delegate_type_mapper(writer& w, TypeDef const& type)
    {
        auto format = R"(template <%>
struct delegate_python_type<%%>
{
    using type = %%;
};

)";
        w.write(
            format,
            bind_list<write_template_arg>(", ", type.GenericParam()),
            type,
            bind<write_delegate_template_args>(type),
            bind<write_pyimpl_type>(type),
            bind<write_delegate_template_args>(type));
    }

    void write_delegate_param(writer& w, method_signature::param_t const& p)
    {
        auto [param, sig] = p;

        // compilers don't always infer the correct types if we use auto here
        // so we need to explicitly specify the type

        switch (get_param_category(p))
        {
        case param_category::in:
            // REVISIT: would be nice to have real type here instead of auto
            // but that means we would need to copy `consumes_type` writer
            // handling from cppwinrt
            // https://github.com/microsoft/cppwinrt/blob/9b453cfc518bdaa7e2ff590526c4883457fd6065/cppwinrt/code_writers.h#L896
            w.write("auto %", bind<write_param_name>(p));
            break;
        case param_category::out:
            w.write("%& %", sig->Type(), bind<write_param_name>(p));
            break;
        case param_category::pass_array:
            w.write(
                "winrt::array_view<% const> %", sig->Type(), bind<write_param_name>(p));
            break;
        case param_category::fill_array:
            w.write("winrt::array_view<%> %", sig->Type(), bind<write_param_name>(p));
            break;
        case param_category::receive_array:
            w.write("winrt::com_array<%>& %", sig->Type(), bind<write_param_name>(p));
            break;
        }
    }

    void write_delegate_callable_wrapper(writer& w, TypeDef const& type)
    {
        auto guard{w.push_generic_params(type.GenericParam())};

        auto invoke = get_delegate_invoke(type);
        method_signature signature{invoke};

        if (is_ptype(type))
        {
            w.write(
                "\ntemplate <%>",
                bind_list<write_template_arg>(", ", type.GenericParam()));
        }

        w.write("\nstruct @\n{\n", type.TypeName());
        {
            writer::indent_guard g{w};

            w.write(
                "static %% get(PyObject* callable)\n{\n",
                type,
                bind<write_delegate_template_args>(type));
            {
                writer::indent_guard gg{w};

                {
                    auto format = R"(py::delegate_callable _delegate{ callable };

return [delegate = std::move(_delegate)](%)
{
)";
                    w.write(
                        format,
                        bind_list<write_delegate_param>(", ", signature.params()));
                }
                {
                    writer::indent_guard ggg{w};

                    w.write("auto gil = py::ensure_gil();\n\n");

                    std::vector<std::string> tuple_params{};
                    for (auto&& p : filter_py_in_params(signature.params()))
                    {
                        auto param_name = w.write_temp("%", bind<write_param_name>(p));
                        auto py_param_name = "py_"s + param_name;

                        w.write(
                            "py::pyobj_handle %{ py::convert(%) };\n",
                            py_param_name,
                            param_name);

                        w.write("\nif (!%) {\n", py_param_name);
                        {
                            writer::indent_guard gggg{w};
                            w.write("PyErr_WriteUnraisable(delegate.callable());\n");
                            w.write(
                                "throw std::invalid_argument(\"%\");\n", param_name);
                        }
                        w.write("}\n\n");

                        tuple_params.push_back(py_param_name);
                    }

                    if (tuple_params.size() > 0)
                    {
                        w.write(
                            "py::pyobj_handle args{ % };\n",
                            bind<write_py_tuple_pack>(tuple_params));

                        w.write("\nif (!args) {\n");
                        {
                            writer::indent_guard gggg{w};
                            w.write("PyErr_WriteUnraisable(delegate.callable());\n");
                            w.write("throw winrt::hresult_error();\n");
                        }
                        w.write("}\n\n");
                    }
                    else
                    {
                        w.write("py::pyobj_handle args{ nullptr };\n");
                    }

                    w.write(
                        R"(py::pyobj_handle return_value{ PyObject_CallObject(delegate.callable(), args.get()) };

if (!return_value)
{
    PyErr_WriteUnraisable(delegate.callable());
    throw winrt::hresult_error();
}
)");
                    auto i = signature.return_signature() ? 1 : 0;
                    for (auto&& p : filter_py_out_params(signature.params()))
                    {
                        auto category = get_param_category(p);

                        switch (category)
                        {
                        case param_category::out:
                            w.write(
                                "\n% = py::convert_to<%>(return_value.get(), %);\n",
                                bind<write_param_name>(p),
                                p.second->Type(),
                                i++);
                            break;
                        case param_category::receive_array:
                            w.write(
                                "\nauto %_buf = py::convert_to<py::pybuf_view<%, false>>(return_value.get(), %);\n",
                                bind<write_param_name>(p),
                                p.second->Type(),
                                i++);
                            w.write(
                                "% = winrt::com_array<%>{%_buf.begin(), %_buf.end()};\n",
                                bind<write_param_name>(p),
                                p.second->Type(),
                                bind<write_param_name>(p),
                                bind<write_param_name>(p));
                            break;
                        default:
                            throw_invalid("invalid param_category for delegate");
                        }
                    }

                    if (signature.return_signature())
                    {
                        std::string index = "";

                        if (i > 1)
                        {
                            // delegate has out params and a return value so
                            // the return value is the first item in the tuple
                            index = ", 0";
                        }

                        if (signature.return_signature().Type().is_szarray())
                        {
                            w.write(
                                "\nauto return_buf = py::convert_to<py::pybuf_view<%, false>>(return_value.get()%);\n",
                                signature.return_signature().Type(),
                                index);
                            w.write(
                                "return winrt::com_array<%>{return_buf.begin(), return_buf.end()};\n",
                                signature.return_signature().Type());
                        }
                        else
                        {
                            w.write(
                                "\nreturn py::convert_to<%>(return_value.get()%);\n",
                                signature.return_signature().Type(),
                                index);
                        }
                    }
                }

                w.write("};\n");
            }
            w.write("};\n");
        }
        w.write("};\n");
    }
#pragma endregion

    /**
     * Writes the Python type.
     *
     * This does not wrap reference types in typing.Optional.
     *
     * @param w The writer.
     * @param type The type.
     */
    void write_python(writer& w, coded_index<TypeDefOrRef> const& type)
    {
        w.write_python(type);
    }

    /**
     * Writes the Python type signature for a parameter or return type.
     *
     * This will wrap reference types in typing.Optional.
     *
     * @param w The writer.
     * @param signature The type signature.
     */
    void write_nullable_python_type(writer& w, TypeSig const& signature)
    {
        // The type metadata doesn't have nullable annotations, so we have to
        // assume that every reference type is nullable (typing.Optional).
        // https://github.com/microsoft/xlang/issues/716

        call(
            signature.Type(),
            [&](ElementType t)
            {
                bool is_reference_type = t == ElementType::Object;

                if (is_reference_type)
                {
                    w.write("typing.Optional[");
                }

                w.write_python(t);

                if (is_reference_type)
                {
                    w.write("]");
                }
            },
            [&](GenericTypeIndex t)
            {
                w.write("typing.Optional[");
                w.write_python(t);
                w.write("]");
            },
            [&](GenericTypeInstSig t)
            {
                // type metadata does not contain nullability info, so we try
                // some heuristics to make our best guess
                auto is_nullable = !implements_iasync(get_typedef(t.GenericType()));

                if (is_nullable)
                {
                    w.write("typing.Optional[");
                }

                w.write_python(t);

                if (is_nullable)
                {
                    w.write("]");
                }
            },
            [&](GenericMethodTypeIndex)
            {
                throw_invalid("Generic methods not supported");
            },
            [&](coded_index<TypeDefOrRef> t)
            {
                auto is_reference_type = call(
                    get_type_semantics(t),
                    [&](type_definition type)
                    {
                        auto category = get_category(type);

                        return category == category::interface_type
                               || category == category::class_type
                               || category == category::delegate_type;
                    },
                    [](object_type)
                    {
                        return true;
                    },
                    [](auto&&)
                    {
                        return false;
                    });

                auto is_nullable
                    = is_reference_type && !implements_iasync(get_typedef(t));

                if (is_nullable)
                {
                    w.write("typing.Optional[");
                }

                w.write_python(t);

                if (is_nullable)
                {
                    w.write("]");
                }
            });
    }

    /**
     * Writes the Python type signature for a parameter or return type.
     *
     * @param w The writer.
     * @param signature The type signature.
     */
    void write_nonnullable_python_type(writer& w, TypeSig const& signature)
    {
        // The type metadata doesn't have nullable annotations, so we have to
        // assume that every reference type is nullable (typing.Optional).
        // https://github.com/microsoft/xlang/issues/716

        call(
            signature.Type(),
            [&](ElementType t)
            {
                w.write_python(t);
            },
            [&](GenericTypeIndex t)
            {
                w.write_python(t);
            },
            [&](GenericTypeInstSig t)
            {
                w.write_python(t);
            },
            [&](GenericMethodTypeIndex)
            {
                throw_invalid("Generic methods not supported");
            },
            [&](coded_index<TypeDefOrRef> t)
            {
                w.write_python(t);
            });
    }

    /**
     * Writes the name of the parameter in lower snake case.
     */
    void write_method_in_param_name(writer& w, method_signature::param_t const& param)
    {
        switch (get_param_category(param))
        {
        case param_category::in:
        case param_category::pass_array:
        case param_category::fill_array:
            w.write(
                "%",
                bind<write_lower_snake_case_python_identifier>(param.first.Name()));
            break;

        // this method only handles input parameters, receive arrays are output
        // parameters
        case param_category::out:
        case param_category::receive_array:
        default:
            throw_invalid("invalid in param category");
        }
    }

    /**
     * Writes the Python type of the parameter.
     */
    void write_method_in_param_typing(writer& w, method_signature::param_t const& param)
    {
        switch (get_param_category(param))
        {
        // regular parameters are just `name: type`
        case param_category::in:
            call(
                param.second->Type().Type(),
                [&](GenericTypeInstSig const& type)
                {
                    auto name = get_type_namespace_and_name(type.GenericType());

                    // Special case for w.f.IIterable since it accepts any Python
                    // iterable
                    if (name.first == "Windows.Foundation.Collections"
                        && name.second == "IIterable`1")
                    {
                        w.write(
                            "typing.Iterable[%]",
                            bind_list<write_nonnullable_python_type>(
                                ", ", type.GenericArgs()));
                    }
                    else
                    {
                        w.write_python(type);
                    }
                },
                [&](auto)
                {
                    w.write(
                        "%", bind<write_nullable_python_type>(param.second->Type()));
                });
            break;

        // array parameters accept any array-like (buffer protocol) object
        case param_category::pass_array:
        case param_category::fill_array:
            w.write(
                "winrt.system.Array[%]",
                bind<write_nonnullable_python_type>(param.second->Type()));
            break;

        // this method only handles input parameters, receive arrays are output
        // parameters
        case param_category::out:
        case param_category::receive_array:
        default:
            throw_invalid("invalid in param category");
        }
    }

    /**
     * Writes the Python `name: type` of the parameter.
     */
    void write_method_in_param_name_and_typing(
        writer& w, method_signature::param_t const& param)
    {
        w.write(
            "%: %",
            bind<write_method_in_param_name>(param),
            bind<write_method_in_param_typing>(param));
    }

    void write_method_out_param_typing(
        writer& w, method_signature::param_t const& param)
    {
        switch (get_param_category(param))
        {
        // regular parameters are just `type`
        case param_category::out:
            w.write("%", bind<write_nullable_python_type>(param.second->Type()));
            break;

        // array parameters return a System.Array
        case param_category::receive_array:
            w.write(
                "winrt.system.Array[%]",
                bind<write_nonnullable_python_type>(param.second->Type()));
            break;

        // this method only handles ouput parameters
        case param_category::in:
        case param_category::pass_array:
        case param_category::fill_array:
        default:
            throw_invalid("invalid in param category");
        }
    }

    /**
     * Writes the return Python typing.
     *
     * If a method has out parameters, the return type is a tuple that includes
     * those types in addition to the return type.
     */
    void write_return_typing(writer& w, method_signature& signature)
    {
        if (count_py_out_param(signature.params()) == 0)
        {
            if (signature.return_signature())
            {
                w.write(
                    "%",
                    bind<write_nullable_python_type>(
                        signature.return_signature().Type()));
            }
            else
            {
                w.write("None");
            }
        }
        else
        {
            if (signature.return_signature())
            {
                w.write(
                    "typing.Tuple[%, %]",
                    bind<write_nullable_python_type>(
                        signature.return_signature().Type()),
                    bind_list<write_method_out_param_typing>(
                        ", ", filter_py_out_params(signature.params())));
            }
            else
            {
                if (count_py_out_param(signature.params()) == 1)
                {
                    w.write(
                        "%",
                        bind<write_method_out_param_typing>(
                            filter_py_out_params(signature.params())[0]));
                }
                else
                {
                    w.write(
                        "typing.Tuple[%]",
                        bind_list<write_method_out_param_typing>(
                            ", ", filter_py_out_params(signature.params())));
                }
            }
        }
    }

    /**
     * Writes the list of Python base classes for a WinRT runtime class or
     * interface type declaration.
     */
    void write_python_base_classes(writer& w, TypeDef const& type)
    {
        w.write("winrt.system.Object");

        if (implements_mapping(type))
        {
            std::string type_args{};

            enumerate_methods(
                w,
                type,
                [&](MethodDef const& method)
                {
                    if (method.Name() == "Lookup")
                    {
                        auto key_type = method.Signature().Params().first->Type();
                        auto value_type = method.Signature().ReturnType().Type();

                        type_args = w.write_temp(
                            "[%, %]",
                            bind<write_nonnullable_python_type>(key_type),
                            bind<write_nonnullable_python_type>(value_type));
                    }
                });

            if (implements_imap(type))
            {
                w.write(", winrt._winrt.MutableMapping%", type_args);
            }
            else
            {
                w.write(", winrt._winrt.Mapping%", type_args);
            }
        }
        else if (implements_sequence(type))
        {
            std::string type_args{};

            enumerate_methods(
                w,
                type,
                [&](MethodDef const& method)
                {
                    if (method.Name() == "GetAt")
                    {
                        auto value_type = method.Signature().ReturnType().Type();

                        type_args = w.write_temp(
                            "[%]", bind<write_nonnullable_python_type>(value_type));
                    }
                });

            if (implements_ivector(type))
            {
                w.write(", winrt._winrt.MutableSequence%", type_args);
            }
            else
            {
                w.write(", winrt._winrt.Sequence%", type_args);
            }
        }

        if (is_ptype(type))
        {
            w.write(
                ", typing.Generic[%]",
                bind_list<write_template_arg_name>(", ", type.GenericParam()));
        }
    }

    /**
     * Writes de-duplicated Python TypeVars for generic type parameters.
     *
     * Note: only interfaces and delegates currently can be parameterized.
     *
     * @param w The writer
     * @param types The list of types to write type vars for.
     */
    void write_python_type_vars(writer& w, std::vector<TypeDef> const& types)
    {
        std::set<std::string> params;

        // filter function to add generic type params only if they are not
        // excluded, private or non-generic
        auto add_param = [&w, &params](TypeDef const& type)
        {
            if (!settings.filter.includes(type))
            {
                return;
            }

            if (is_exclusive_to(type))
            {
                return;
            }

            if (!is_ptype(type))
            {
                return;
            }

            for (auto& type_param : type.GenericParam())
            {
                params.insert(w.write_temp(type_param.Name()));
            }
        };

        for (auto&& type : types)
        {
            add_param(type);
        }

        for (auto& type_param : params)
        {
            w.write("@ = typing.TypeVar('@')\n", type_param, type_param);
        }
    }

    /**
     * Writes a Python attribute type hint for a field.
     * @param [in]  w       The writer.
     * @param [in]  field   The field metadata.
     */
    void write_struct_field_parameter_typing(writer& w, Field const& field)
    {
        w.write(
            "%: %",
            bind<write_lower_snake_case_python_identifier>(field.Name()),
            bind<write_struct_field_python_type>(field));
    }

    /**
     * Writes a Python class definition for a struct with type hints for a .pyi file.
     * @param [in]  w       The writer.
     * @param [in]  type    The type metadata.
     */
    void write_python_typing_for_struct(writer& w, TypeDef const& type)
    {
        if (is_customized_struct(type))
        {
            return;
        }

        w.write("@typing.final\n");
        w.write("class @:\n", type.TypeName());
        {
            writer::indent_guard g{w};

            for (auto&& f : type.FieldList())
            {
                w.write(
                    "%: %\n",
                    bind<write_lower_snake_case_python_identifier>(f.Name()),
                    bind<write_struct_field_python_type>(f));
            }

            w.write(
                "def __init__(self, %) -> None: ...\n",
                bind_list<write_struct_field_parameter_typing>(", ", type.FieldList()));
        }
        w.write("\n");
    }

    /**
     * Writes a Python class definition for a class or interface with type hints for a
     * .pyi file.
     * @param [in]  w       The writer.
     * @param [in]  type    The type metadata.
     */
    void write_python_typing_for_object(writer& w, TypeDef const& type)
    {
        if (is_exclusive_to(type))
        {
            return;
        }

        auto guard{w.push_generic_params(type.GenericParam())};

        auto ns = type.TypeNamespace();
        auto name = type.TypeName();

        if (requires_metaclass(type))
        {
            w.write("@typing.final\n");
            w.write("class @_Static(type):\n", type.TypeName());

            {
                writer::indent_guard g{w};

                // write regular methods

                auto method_writer = [&](MethodDef const& method)
                {
                    if (!is_static(method))
                    {
                        return;
                    }

                    method_signature signature{method};

                    if (is_method_overloaded(w, type, method.Name()))
                    {
                        w.write("@typing.overload\n");
                    }

                    // seperator between cls/self and the rest of the args
                    auto first_seperator
                        = count_py_in_param(signature.params()) > 0 ? ", " : "";

                    w.write(
                        "def %(cls%%%) -> %: ...\n",
                        bind<write_lower_snake_case_python_identifier>(method.Name()),
                        first_seperator,
                        bind_list<write_method_in_param_name_and_typing>(
                            ", ", filter_py_in_params(signature.params())),
                        filter_py_in_params(signature.params()).empty() ? "" : ", /",
                        bind<write_return_typing>(signature));
                };

                enumerate_methods(w, type, method_writer);

                enumerate_events(
                    w,
                    type,
                    [&](auto const& event)
                    {
                        auto&& [add_method, remove_method] = get_event_methods(event);
                        method_writer(add_method);
                        method_writer(remove_method);
                    });

                // write properties

                auto property_writer = [&](Property const& property)
                {
                    if (!is_static(property))
                    {
                        return;
                    }

                    auto [get_method, put_method] = get_property_methods(property);

                    auto type = w.write_temp(
                        "%", bind<write_nullable_python_type>(property.Type().Type()));

                    // NB: have to use "_property" because there can be
                    // properties named "property"
                    w.write("@_property\n");
                    w.write(
                        "def %(cls) -> %: ...\n",
                        bind<write_lower_snake_case_python_identifier>(property.Name()),
                        type);

                    if (put_method)
                    {
                        w.write(
                            "^@%.setter\n",
                            bind<write_lower_snake_case_python_identifier>(
                                property.Name()));
                        w.write(
                            "def %(cls, value: %) -> None: ...\n",
                            bind<write_lower_snake_case_python_identifier>(
                                property.Name()),
                            type);
                    }
                };

                enumerate_properties(w, type, property_writer);
            }

            w.write("\n");
        }

        std::string metaclass{};

        if (requires_metaclass(type))
        {
            metaclass = w.write_temp(", metaclass=@_Static", type.TypeName());
        }

        w.write("@typing.final\n");
        w.write(
            "class @(%%):\n",
            type.TypeName(),
            bind<write_python_base_classes>(type),
            metaclass);
        {
            writer::indent_guard g{w};

            // Write special methods.

            if (is_ptype(type))
            {
                w.write(
                    "def __class_getitem__(cls, key: typing.Any) -> types.GenericAlias: ...\n");
            }

            // TODO: this should use the implements_x helpers but we need to
            // figure out how to get the generic type args from each interface

            if (implements_iclosable(type))
            {
                w.write("def __enter__(self: Self) -> Self: ...\n");
                w.write("def __exit__(self, *args) -> None: ...\n");
            }

            if (implements_istringable(type))
            {
                w.write("def __str__(self) -> str: ...\n");
            }

            if (implements_ibuffer(type) || implements_imemorybufferreference(type))
            {
                w.write("def __buffer__(self, flags: int) -> memoryview: ...\n");
                w.write(
                    "def __release_buffer__(self, view: memoryview) -> None: ...\n");
            }

            if (implements_mapping(type))
            {
                w.write("def __len__(self) -> int: ...\n");

                enumerate_methods(
                    w,
                    type,
                    [&](MethodDef const& method)
                    {
                        if (method.Name() == "Lookup")
                        {
                            auto key_type = method.Signature().Params().first->Type();
                            auto value_type = method.Signature().ReturnType().Type();

                            w.write(
                                "def __getitem__(self, key: %) -> %: ...\n",
                                bind<write_nonnullable_python_type>(key_type),
                                bind<write_nonnullable_python_type>(value_type));
                        }
                        else if (method.Name() == "Insert")
                        {
                            auto key_type = method.Signature().Params().first->Type();
                            auto value_type
                                = (method.Signature().Params().first + 1)->Type();

                            w.write(
                                "def __setitem__(self, key: %, value: %) -> None: ...\n",
                                bind<write_nonnullable_python_type>(key_type),
                                bind<write_nonnullable_python_type>(value_type));
                        }
                        else if (method.Name() == "Remove")
                        {
                            auto key_type = method.Signature().Params().first->Type();

                            w.write(
                                "def __delitem__(self, key: %) -> None: ...\n",
                                bind<write_nonnullable_python_type>(key_type));
                        }
                        else if (method.Name() == "HasKey")
                        {
                            w.write(
                                "def __contains__(self, key: object) -> bool:...\n");
                        }
                        else if (method.Name() == "First")
                        {
                            auto return_type = w.write_temp(
                                "%",
                                bind<write_nonnullable_python_type>(
                                    method.Signature().ReturnType().Type()));

                            // try to scrape the key type out of the full
                            // IIterable[IKeyValuePair[K, V]] type

                            auto iter_type_args = return_type.substr(
                                return_type.find_first_of('[') + 1);

                            auto kvp_type_args = iter_type_args.substr(
                                iter_type_args.find_first_of('[') + 1);

                            // REVISIT: this won't work if the key is generic
                            auto key_type = kvp_type_args.substr(
                                0, kvp_type_args.find_first_of(','));

                            w.write(
                                "def __iter__(self) -> typing.Iterator[%]: ...\n",
                                key_type);
                        }
                    });
            }
            else if (implements_sequence(type))
            {
                w.write("def __len__(self) -> int: ...\n");

                enumerate_methods(
                    w,
                    type,
                    [&](MethodDef const& method)
                    {
                        if (method.Name() == "GetAt")
                        {
                            auto value_type = method.Signature().ReturnType().Type();

                            w.write("@typing.overload\n");
                            w.write(
                                "def __getitem__(self, index: typing.SupportsIndex) -> %: ...\n",
                                bind<write_nonnullable_python_type>(value_type));
                            w.write("@typing.overload\n");
                            w.write(
                                "def __getitem__(self, index: slice) -> winrt.system.Array[%]: ...\n",
                                bind<write_nonnullable_python_type>(value_type));
                        }
                        else if (method.Name() == "SetAt")
                        {
                            auto value_type
                                = (method.Signature().Params().first + 1)->Type();

                            w.write("@typing.overload\n");
                            w.write(
                                "def __setitem__(self, index: typing.SupportsIndex, value: %) -> None: ...\n",
                                bind<write_nonnullable_python_type>(value_type));
                            w.write("@typing.overload\n");
                            w.write(
                                "def __setitem__(self, index: slice, value: typing.Iterable[%]) -> None: ...\n",
                                bind<write_nonnullable_python_type>(value_type));
                        }
                        else if (method.Name() == "RemoveAt")
                        {
                            w.write("@typing.overload\n");
                            w.write(
                                "def __delitem__(self, index: typing.SupportsIndex) -> None: ...\n");
                            w.write("@typing.overload\n");
                            w.write(
                                "def __delitem__(self, index: slice) -> None: ...\n");
                        }
                        else if (method.Name() == "First")
                        {
                            auto return_type = method.Signature().ReturnType().Type();

                            w.write(
                                "def __iter__(self) -> %: ...\n",
                                bind<write_nonnullable_python_type>(return_type));
                        }
                    });
            }
            else if (implements_iiterable(type))
            {
                enumerate_methods(
                    w,
                    type,
                    [&](MethodDef const& method)
                    {
                        if (method.Name() == "First")
                        {
                            auto return_type = method.Signature().ReturnType().Type();

                            w.write(
                                "def __iter__(self) -> %: ...\n",
                                bind<write_nonnullable_python_type>(return_type));
                        }
                    });
            }
            else if (implements_iiterator(type))
            {
                enumerate_properties(
                    w,
                    type,
                    [&](Property const& prop)
                    {
                        if (prop.Name() == "Current")
                        {
                            w.write("def __iter__(self: Self) -> Self: ...\n");
                            w.write(
                                "def __next__(self) -> %: ...\n",
                                bind<write_nonnullable_python_type>(
                                    prop.Type().Type()));
                        }
                    });
            }

            if (implements_iasync(type))
            {
                std::string return_type = "None";

                if (type.TypeNamespace() == "Windows.Foundation"
                    && (type.TypeName() == "IAsyncOperation`1"
                        || type.TypeName() == "IAsyncOperationWithProgress`2"))
                {
                    return_type = type.GenericParam().first.Name();
                }
                else
                {
                    for (auto&& ii : type.InterfaceImpl())
                    {
                        // REVISIT: this is probably not as robust as it should
                        // be since it assumes that any class that implements
                        // IAsyncOperation* will refernce it this way. We may
                        // need to make this recusive and/or check TypeDef or TypeRef.

                        if (ii.Interface().type() != TypeDefOrRef::TypeSpec)
                        {
                            continue;
                        }

                        auto generic_inst
                            = ii.Interface().TypeSpec().Signature().GenericTypeInst();

                        auto generic_type = get_typedef(generic_inst.GenericType());

                        if (generic_type.TypeNamespace() != "Windows.Foundation"
                            || (generic_type.TypeName() != "IAsyncOperation`1"
                                && generic_type.TypeName()
                                       != "IAsyncOperationWithProgress`2"))
                        {
                            continue;
                        }

                        auto arg = *generic_inst.GenericArgs().first;

                        return_type
                            = w.write_temp("%", bind<write_nullable_python_type>(arg));

                        break;
                    }
                }

                w.write(
                    "def __await__(self) -> typing.Generator[typing.Any, None, %]: ...\n",
                    return_type);
            }

            if (!is_ptype(type) || is_static_class(type))
            {
                w.write("@staticmethod\n");
                w.write(
                    "def _from(obj: winrt.system.Object, /) -> @: ...\n",
                    type.TypeName());
            }

            // write regular methods

            auto method_writer = [&](MethodDef const& method)
            {
                if (is_static(method))
                {
                    return;
                }

                method_signature signature{method};

                if (is_method_overloaded(w, type, method.Name()))
                {
                    w.write("@typing.overload\n");
                }

                // seperator between cls/self and the rest of the args
                auto first_seperator
                    = count_py_in_param(signature.params()) > 0 ? ", " : "";

                if (is_constructor(method))
                {
                    w.write(
                        "def __new__(cls: typing.Type[%]%%) -> %:...\n",
                        type.TypeName(),
                        first_seperator,
                        bind_list<write_method_in_param_name_and_typing>(
                            ", ", filter_py_in_params(signature.params())),
                        type.TypeName());
                }
                else
                {
                    w.write(
                        "def %(self%%%) -> %: ...\n",
                        bind<write_lower_snake_case_python_identifier>(method.Name()),
                        first_seperator,
                        bind_list<write_method_in_param_name_and_typing>(
                            ", ", filter_py_in_params(signature.params())),
                        filter_py_in_params(signature.params()).empty() ? "" : ", /",
                        bind<write_return_typing>(signature));
                }
            };

            auto constructors = get_public_constructors(type);

            for (auto&& c : constructors)
            {
                method_writer(c);
            }

            enumerate_methods(w, type, method_writer);

            enumerate_events(
                w,
                type,
                [&](auto const& event)
                {
                    auto&& [add_method, remove_method] = get_event_methods(event);
                    method_writer(add_method);
                    method_writer(remove_method);
                });

            // write properties

            auto property_writer = [&](Property const& property)
            {
                if (is_static(property))
                {
                    return;
                }

                auto [get_method, put_method] = get_property_methods(property);

                auto type = w.write_temp(
                    "%", bind<write_nullable_python_type>(property.Type().Type()));

                // NB: have to use "_property" because there can be
                // properties named "property"
                w.write("@_property\n");
                w.write(
                    "def %(self) -> %: ...\n",
                    bind<write_lower_snake_case_python_identifier>(property.Name()),
                    type);

                if (put_method)
                {
                    w.write(
                        "^@%.setter\n",
                        bind<write_lower_snake_case_python_identifier>(
                            property.Name()));
                    w.write(
                        "def %(self, value: %) -> None: ...\n",
                        bind<write_lower_snake_case_python_identifier>(property.Name()),
                        type);
                }
            };

            enumerate_properties(w, type, property_writer);
        }

        w.write("\n");
    }

    /**
     * Writes a Python type alias for a delegate type.
     * @param [in]  w       The writer.
     * @param [in]  type    The type metadata.
     */
    void write_python_delegate_type_alias(writer& w, TypeDef const& type)
    {
        if (is_exclusive_to(type))
        {
            return;
        }

        auto guard{w.push_generic_params(type.GenericParam())};

        method_signature signature{get_delegate_invoke(type)};

        w.write(
            "@ = typing.Callable[[%], %]\n",
            type.TypeName(),
            bind_list<write_method_in_param_typing>(
                ", ", filter_py_in_params(signature.params())),
            bind<write_return_typing>(signature));
    }
} // namespace pywinrt
